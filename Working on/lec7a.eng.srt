1
00:00:15,314 --> 00:00:18,410
PROFESSOR: Well today we're going to learn about something quite amazing.

3
00:00:18,410 --> 00:00:26,800
We're going to understand what we mean by a program a little bit more profoundly than we have up till now.

5
00:00:26,800 --> 00:00:32,729
Up till now, we've been thinking of programs as describing machines.

7
00:00:32,729 --> 00:00:42,800
So for example, looking at this still store, we see here is a program for factorial.

9
00:00:42,800 --> 00:00:52,230
And what it is, is a character string description, if you will, of the wiring diagram of a potentially infinite machine.

12
00:00:52,230 --> 00:00:55,130
And we can look at that a little bit and just see the idea.

14
00:00:55,130 --> 00:01:00,170
That this is a sort of compact notation which says, if n is 0, the result is one.

16
00:01:00,170 --> 00:01:09,340
Well here comes n coming into this machine, and if it's 0, then I control this switch in such a way that the switch allows the output to be one.

19
00:01:09,340 --> 00:01:12,970
Otherwise, it's n times factorial of n minus one.

20
00:01:12,970 --> 00:01:21,900
Well, I'm computing factorial of n minus one and multiplying that by n, and, in the case that it's not 0, this switch makes the output come from there.

23
00:01:21,900 --> 00:01:31,070
Of course, this is a machine with a potentially infinite number of parts, because factorial occurs within factorial, so we don't know how deep it has to be.

26
00:01:31,070 --> 00:01:38,310
But that's basically what our notation for programs really means to us at this point.

28
00:01:38,310 --> 00:01:44,900
It's a character string description, if you will, of a wiring diagram that could also be drawn some other way.

30
00:01:44,900 --> 00:01:49,490
And, in fact, many people have proposed to me, programming languages look graphical like this.

32
00:01:49,490 --> 00:01:51,500
I'm not sure I believe there are many advantages.

33
00:01:51,500 --> 00:02:01,090
The major disadvantage, of course, is that it takes up more space on a page, and, therefore, it's harder to pack into a listing or to edit very well.

36
00:02:01,090 --> 00:02:10,450
But in any case, there's something very remarkable that can happen in the competition world which is that you can have something called a universal machine.

39
00:02:10,450 --> 00:02:21,260
If we look at the second slide, what we see is a special machine called eval.

41
00:02:21,260 --> 00:02:25,720
There is a machine called eval, and I'm going to show it to you today.

43
00:02:25,720 --> 00:02:27,780
It's very simple.

44
00:02:27,780 --> 00:02:30,490
What is remarkable is that it will fit on the blackboard.

46
00:02:33,350 --> 00:02:40,450
However, eval is a machine which takes as input a description of another machine.

48
00:02:40,450 --> 00:02:46,490
It could take the wiring diagram of a factorial machine as input.

50
00:02:46,490 --> 00:02:58,910
Having done so, it becomes a simulator for the factorial machine such that, if you put a six in, out comes a 720.

52
00:02:58,910 --> 00:03:02,130
That's a very remarkable sort of machine.

53
00:03:02,130 --> 00:03:05,590
And the most amazing part of it is that it fits on a blackboard.

55
00:03:05,590 --> 00:03:28,050
By contrast, one could imagine in the analog electronics world a very different machine, a machine which also was, in some sense, universal, where you gave a circuit diagram as one of the inputs, for example, of this little low-pass filter, one-pole low-pass filter.

60
00:03:28,050 --> 00:03:49,890
And you can imagine that you could, for example, scan this out-- the scan lines are the signal that's describing what this machine is to simulate-- then the analog of that which is made out of electrical circuits, should configure itself into a filter that has the frequency response specified by the circuit diagram.

68
00:03:49,890 --> 00:03:55,670
That's a very hard machine to make, and, surely, there's no chance that I could put it on a blackboard.

70
00:03:55,670 --> 00:03:58,430
So we're going to see an amazing thing today.

71
00:03:58,430 --> 00:04:02,790
We're going to see, on the blackboard, the universal machine.

73
00:04:02,790 --> 00:04:06,780
And we'll see that among other things, it's extremely simple.

74
00:04:06,780 --> 00:04:11,280
Now, we're getting very close to the real spirit in the computer at this point.

76
00:04:11,280 --> 00:04:20,470
So I have to show a certain amount of reverence and respect, so I'm going to wear a suit jacket for the only time that you'll ever see me wear a suit jacket here.

79
00:04:20,470 --> 00:04:26,980
And I think I'm also going to put on an appropriate hat for the occasion.

82
00:04:28,780 --> 00:04:40,370
Now, this is a lecturer which I have to warn you--  let's see, normally, people under 40 and who don't have several children are advised to be careful.

86
00:04:40,370 --> 00:04:51,820
If they're really worried, they should leave. Because there's a certain amount of mysticism that will appear here which may be disturbing and cause trouble in your minds.

90
00:04:51,820 --> 00:05:02,510
Well in any case, let's see, I wish to write for you the evaluator for Lisp.

92
00:05:02,510 --> 00:05:05,020
Now the evaluator isn't very complicated.

93
00:05:05,020 --> 00:05:08,240
It's very much like all the programs we've seen already.

94
00:05:08,240 --> 00:05:10,860
That's the amazing part of it.

95
00:05:10,860 --> 00:05:16,620
It's going to be-- and I'm going to write it right here-- it's a program called eval.

98
00:05:22,900 --> 00:05:30,030
And it's a procedure of two arguments in expression of an environment.

101
00:05:31,860 --> 00:05:34,940
And like every interesting procedure, it's a case analysis.

104
00:05:40,460 --> 00:05:44,210
But before I start on this, I want to tell you some things.

105
00:05:44,210 --> 00:05:54,210
The program we're going to write on the blackboard is ugly, dirty, disgusting, not the way I would write this is a professional.

108
00:05:54,210 --> 00:06:02,550
It is written with concrete syntax, meaning you've got really to use lots of CARs and CDRs which is exactly what I told you not to do.

111
00:06:02,550 --> 00:06:12,420
That's on purpose in this case, because I want it to be small, compact, fit on the blackboard so you can get the whole thing.

114
00:06:12,420 --> 00:06:15,800
So I don't want to use long names like I normally use.

115
00:06:15,800 --> 00:06:19,580
I want to use CAR-CDR because it's short.

116
00:06:19,580 --> 00:06:20,950
Now, that's a trade-off.

117
00:06:20,950 --> 00:06:23,570
I don't want you writing programs like this.

118
00:06:23,570 --> 00:06:26,090
This is purely for an effect.

119
00:06:26,090 --> 00:06:31,270
Now, you're going to have to work a little harder to read it, but I'm going to try to make it clear as I'm writing it.

122
00:06:31,270 --> 00:06:51,670
I'm also-- this is a pretty much complete interpreter, but there's going to be room for putting in more things-- I'm going to leave out definition and assignment, just because they are not essential, for a mathematical reason I'll show you later and also they take up more space.

128
00:06:51,670 --> 00:06:54,170
But, in any case, what do we have to do?

129
00:06:54,170 --> 00:07:02,030
We have to do a dispatch which breaks the types of expressions up into particular classes.

131
00:07:02,030 --> 00:07:03,525
So that's what we're going to have here.

132
00:07:03,525 --> 00:07:05,150
Well, what expressions are there?

133
00:07:05,150 --> 00:07:06,810
Let's look at the kinds of expressions.

134
00:07:06,810 --> 00:07:10,420
We can have things like the numeral three.

135
00:07:10,420 --> 00:07:12,720
What do I want that to do?

136
00:07:12,720 --> 00:07:17,050
I can make choices, but I think right now, I want it to be a three.

138
00:07:17,050 --> 00:07:18,860
That's what I want.

139
00:07:18,860 --> 00:07:19,800
So that's easy enough.

140
00:07:19,800 --> 00:07:31,970
That means I want, if the thing is a number, the expression, that I want the expression itself as the answer.

144
00:07:35,420 --> 00:07:39,390
Now the next possibility is things that we represent as symbols.

146
00:07:39,390 --> 00:07:47,614
Examples of symbols are things like x, n, eval, number, x.

147
00:07:47,614 --> 00:07:49,630
What do I mean them to be?

148
00:07:49,630 --> 00:07:51,690
Those are things that stand for other things.

149
00:07:51,690 --> 00:07:54,770
Those are the variables of our language.

150
00:07:54,770 --> 00:08:02,930
And so I want to be able to say, for example, that x, for example, transforms to it's value which might be three.

152
00:08:02,930 --> 00:08:07,920
Or I might ask something like car.

153
00:08:07,920 --> 00:08:23,100
I want to have as its value-- be something like some procedure, which I don't know what is inside there, perhaps a machine language code or something like that.

157
00:08:23,100 --> 00:08:24,430
So, well, that's easy enough.

158
00:08:24,430 --> 00:08:27,890
I'm going to push that off on someone else.

159
00:08:27,890 --> 00:08:40,159
If something is a symbol, if the expression is a symbol, then I want the answer to be the result, looking up the expression in the environment.

163
00:08:46,480 --> 00:08:54,060
Now the environment is a dictionary which maps the symbol names to their values.

165
00:08:54,060 --> 00:08:56,280
And that's all it is.

166
00:08:56,280 --> 00:08:57,530
How it's done?

167
00:08:57,530 --> 00:08:59,760
Well, we'll see that later.

168
00:08:59,760 --> 00:09:01,670
It's very easy.

169
00:09:01,670 --> 00:09:04,670
It's easy to make data structures that are tables of various sorts.

171
00:09:04,670 --> 00:09:10,040
But it's only a table, and this is the access routine for some table.

173
00:09:10,040 --> 00:09:17,430
Well, the next thing, another kind of expression-- you have things that are described constants that are not numbers, like 'foo.

177
00:09:20,170 --> 00:09:31,520
Well, for my convenience, I want to syntactically transform that into a list structure which is, quote foo.

180
00:09:35,140 --> 00:09:48,780
A quoted object, whatever it is, is going to be actually an abbreviation, which is not part of the evaluator but happens somewhere else, an abbreviation for an expression that looks like this.

184
00:09:48,780 --> 00:09:55,615
This way, I can test for the type of the expression as being a quotation by examining the car of the expression.

187
00:09:58,460 --> 00:10:01,650
So I'm not going to worry about that in the evaluator.

188
00:10:01,650 --> 00:10:05,540
It's happening somewhere earlier in the reader or something.

190
00:10:05,540 --> 00:10:25,140
If the expression of the expression is quote, then what I want, I want quote foo to itself evaluate to foo.

192
00:10:25,140 --> 00:10:27,530
It's a constant.

193
00:10:27,530 --> 00:10:30,645
This is just a way of saying that this evaluates to itself.

195
00:10:33,150 --> 00:10:33,660
What is that?

196
00:10:33,660 --> 00:10:51,290
That's the second of the list. It's the second element of the list. The second element of the list is it's CADR. So I'm just going to write here, CADR.

199
00:10:51,290 --> 00:10:52,510
What else do we have here?

200
00:10:52,510 --> 00:11:04,160
We have lambda expressions, for example, lambda of x plus x y.

202
00:11:04,160 --> 00:11:09,600
Well, I going have to have some representation for the procedure which is the value of an expression, of a lambda expression.

205
00:11:09,600 --> 00:11:13,030
The procedure here is not the expression lambda x.

206
00:11:13,030 --> 00:11:16,170
That's the description of it, the textual description.

207
00:11:16,170 --> 00:11:27,360
However, what what I going to expect to see here is something which contains an environment as one of its parts if I'm implementing a lexical language.

210
00:11:27,360 --> 00:11:30,790
And so what I'd like to see is some type flags.

211
00:11:30,790 --> 00:11:39,060
I'm going to have to be able to distinguish procedures later, procedures which were produced by lambdas, from ones that may be primitive.

214
00:11:39,060 --> 00:11:44,935
And so I'm going to have some flag, which I'll just arbitrarily call closure, just for historical reasons.

217
00:11:47,760 --> 00:11:49,920
Now, to say what parts of this are important.

218
00:11:49,920 --> 00:11:54,220
I'm going to need to know the bound variable list and the body.

220
00:11:54,220 --> 00:12:03,795
Well, that's the CDR of this, so it's going to be x and plus x y and some environment.

223
00:12:08,170 --> 00:12:18,520
Now this is not something that users should ever see, this is purely a representation, internally, for a procedure object.

226
00:12:18,520 --> 00:12:26,340
It contains a bound variable list, a body, and an environment, and some type tag saying, I am a procedure.

228
00:12:26,340 --> 00:12:28,080
I'm going to make one now.

229
00:12:28,080 --> 00:13:10,250
So if the CAR of the expression is quote lambda, then what I'm going to put here is-- I'm going to make a list of closure, the CDR of the procedure description was everything except the lambda, and the current environment.

234
00:13:10,250 --> 00:13:15,190
This implements the rule for environments in the environment model.

236
00:13:15,190 --> 00:13:19,210
It has to do with construction of procedures from lambda expressions.

238
00:13:19,210 --> 00:13:32,240
The environment that was around at the time the evaluator encountered the lambda expression is the environment where the procedure resulting interprets it's free variables.

243
00:13:34,720 --> 00:13:35,920
So that's part of that.

244
00:13:35,920 --> 00:13:39,210
And so we have to capture that environment as part of the procedure object.

246
00:13:39,210 --> 00:13:41,750
And we'll see how that gets used later.

247
00:13:41,750 --> 00:13:54,520
There are also conditional expressions of things like COND of say, p one, e one, p two, e two.

249
00:13:54,520 --> 00:14:03,480
Where this is a predicate, a predicate is a thing that is either true or false, and the expression to be evaluated if the predicate is true.

252
00:14:03,480 --> 00:14:06,790
A set of clauses, if you will, that's the name for such a thing.

254
00:14:06,790 --> 00:14:09,360
So I'm going put that somewhere else.

255
00:14:09,360 --> 00:14:12,420
We're going to worry about that in another piece of code.

256
00:14:12,420 --> 00:14:32,050
So EQ--  if the CAR of the expression is COND, then I'm going to do nothing more than evaluate the COND, the CDR of the expression.

262
00:14:34,080 --> 00:14:38,380
That's all the clauses in the environment that I'm given.

264
00:14:41,430 --> 00:14:56,590
Well, there's one more case, arbitrary thing like the sum of x and three, where this is an operator applied to operands, and there's nothing special about it.

267
00:14:56,590 --> 00:14:59,850
It's not one of the special cases, the special forms.

268
00:14:59,850 --> 00:15:09,650
These are the special forms.

269
00:15:09,650 --> 00:15:14,370
And if I were writing here a professional program, again, I would somehow make this data directed.

271
00:15:14,370 --> 00:15:22,360
So there wouldn't be a sequence of conditionals here, there'd be a dispatch on some bits if I were trying to do this in a more professional way.

274
00:15:22,360 --> 00:15:26,710
So that, in fact, I can add to the thing without changing my program much.

276
00:15:26,710 --> 00:15:31,280
So, for example, they would run fast, but I'm not worried about that.

278
00:15:31,280 --> 00:15:34,890
Here we're trying to look at this in its entirety.

279
00:15:34,890 --> 00:15:37,360
So it's else.

280
00:15:37,360 --> 00:15:38,560
Well, what do we do?

281
00:15:38,560 --> 00:15:40,965
In this case, I have to somehow do an addition.

283
00:15:44,350 --> 00:15:46,565
Well, I could find out what the plus is.

284
00:15:46,565 --> 00:15:50,550
I have to find out what the x and the three are.

285
00:15:50,550 --> 00:15:58,020
And then I have to apply the result of finding what the plus is to the result of finding out what the x and the three are.

288
00:15:58,020 --> 00:15:59,830
We'll have a name for that.

289
00:15:59,830 --> 00:16:20,480
So I'm going to apply the result of evaluating the CAR of the expression-- the car of the expression is the operator-- in the environment given.

293
00:16:20,480 --> 00:16:24,050
So evaluating the operator gets me the procedure.

294
00:16:24,050 --> 00:16:27,290
Now I have to evaluate all the operands to get the arguments.

295
00:16:27,290 --> 00:16:38,835
I'll call that EVLIST, the CDR of the operands, of the expression, with respect to the environment.

298
00:16:41,940 --> 00:16:48,070
EVLIST will come up later-- EVLIST, apply, COND pair, COND, lambda, define.

301
00:16:50,900 --> 00:16:56,590
So that what you are seeing here now is pretty much all there is in the evaluator itself.

303
00:16:56,590 --> 00:17:07,470
It's the case dispatch on the type of the expression with the default being a general application or a combination.

306
00:17:17,520 --> 00:17:20,089
Now there is lots of things we haven't defined yet.

307
00:17:20,089 --> 00:17:21,780
Let's just look at them and see what they are.

308
00:17:21,780 --> 00:17:25,480
We're going to have to do this later, evcond.

309
00:17:25,480 --> 00:17:27,579
We have to write apply.

310
00:17:27,579 --> 00:17:31,790
We're going to have to write EVLIST. We're going to write LOOKUP.

312
00:17:31,790 --> 00:17:33,430
I think that's everything, isn't there?

313
00:17:33,430 --> 00:17:38,570
Everything else is something which is simple, or primitive, or something like that.

315
00:17:38,570 --> 00:17:44,450
And, of course, we could many more special forms here, but that would be a bad idea in general in a language.

317
00:17:44,450 --> 00:17:47,690
You make a language very complicated by putting a lot of things in there.

319
00:17:47,690 --> 00:17:54,010
The number of reserve words that should exist in a language should be no more than a person could remember on his fingers and toes.

322
00:17:54,010 --> 00:17:59,410
And I get very upset with languages which have hundreds of reserve words.

324
00:17:59,410 --> 00:18:00,710
But that's where the reserve words go.

326
00:18:04,750 --> 00:18:09,640
Well, now let's get to the next part of this, the kernel, apply.

328
00:18:09,640 --> 00:18:11,590
What else is this doing?

329
00:18:11,590 --> 00:18:26,610
Well, apply's job is to take a procedure and apply it to its arguments after both have been evaluated to come up with a procedure and the arguments rather the operator symbols and the operand symbols, whatever they are-- symbolic expressions.

335
00:18:33,270 --> 00:18:43,280
So we will define apply to be a procedure of two arguments, a procedure and arguments.

338
00:18:47,110 --> 00:18:48,080
And what does it do?

339
00:18:48,080 --> 00:18:49,720
It does nothing very complicated.

340
00:18:49,720 --> 00:18:50,970
It's got two cases.

342
00:18:53,580 --> 00:19:06,930
Either the procedure is primitive--  And I don't know exactly how that is done.

345
00:19:06,930 --> 00:19:18,550
It's possible there's some type information just like we made closure for, here, being the description of the type of a compound thing-- probably so.

349
00:19:18,550 --> 00:19:27,350
But it is not essential how that works, and, in fact, it turns out, as you probably know or have deduced, that you don't need any primitives anyway.

352
00:19:27,350 --> 00:19:33,190
You can compute anything without them because some of the lambda that I've been playing with.

354
00:19:33,190 --> 00:19:34,750
But it's nice to have them.

355
00:19:34,750 --> 00:19:38,060
So here we're going to do some magic which I'm not going to explain.

357
00:19:38,060 --> 00:19:42,860
Go to machine language, apply primop.

358
00:19:42,860 --> 00:19:44,850
Here's how it adds.

359
00:19:44,850 --> 00:19:46,100
Execute an add instruction.

361
00:19:50,360 --> 00:19:54,940
However, the interesting part of a language is the glue by which the predicates are glued together.

363
00:19:54,940 --> 00:19:56,910
So let's look at that.

364
00:19:56,910 --> 00:20:07,620
Well, the other possibility is that this is a compound made up by executing a lambda expression, this is a compound procedure.

367
00:20:07,620 --> 00:20:10,110
Well, we'll check its type.

368
00:20:10,110 --> 00:20:24,500
If it is closure, if it's one of those, then I have to do an eval of the body.

370
00:20:24,500 --> 00:20:44,260
The way I do this, the way I deal with this at all, is the way I evaluate the application of a procedure to its arguments, is by evaluating the body of the procedure in the environment resulting from extending the environment of the procedure with the bindings of the formal parameters of the procedure to the arguments that were passed to it.

378
00:20:47,030 --> 00:20:48,280
That was a long sentence.

380
00:20:51,130 --> 00:20:52,822
Well that's easy enough.

381
00:20:52,822 --> 00:20:56,214
Now here's going to be a lot of CAR-CDRing.

382
00:20:56,214 --> 00:20:59,400
I have to get the body of the procedure.

383
00:20:59,400 --> 00:21:02,960
Where's the body of the procedure in here?

384
00:21:02,960 --> 00:21:06,130
Well here's the CAR, here's the CDR is the whole rest of this.

386
00:21:06,130 --> 00:21:13,200
So here's the CADR. And so I see, what I have here is the body is the second element of the second element of the procedure.

389
00:21:13,200 --> 00:21:19,170
So it's the CADR of the CADR or the CADADR.

390
00:21:19,170 --> 00:21:27,495
It's the C-A-D-A-D-R, CADADR of the procedure.

392
00:21:30,260 --> 00:21:43,500
To evaluate the body in the result of binding that's making up more environment, well I need the formal parameters of the of the procedure, what is that?

395
00:21:43,500 --> 00:21:48,780
That's the CAR of the CDR. It's horrible isn't it?

397
00:21:52,440 --> 00:21:55,440
--of the procedure.

398
00:21:55,440 --> 00:22:04,540
Bind that to the arguments that were passed in the environment, which is passed also as part of the procedure.

400
00:22:04,540 --> 00:22:16,315
Well, that's the CAR of the CDR of the CDR of this, CADDR, of the procedure.

403
00:22:20,290 --> 00:22:39,000
Bind, eval, pair, COND, lamda, define-- Now, of course, if I were being really a neat character, and I was being very careful, I would actually put an extra case here for checking for certain errors like, did you try to apply one to an argument?

408
00:22:39,000 --> 00:22:42,570
You get a undefined procedure type.

409
00:22:42,570 --> 00:22:45,500
So I may as well do that anyway.

410
00:22:45,500 --> 00:22:57,610
--else, some sort of error, like that.

411
00:22:57,610 --> 00:23:10,750
Now, of course, again, in some sort of more real system, written for professional reasons, this would be written with a case analysis done by some sort of dispatch.

414
00:23:10,750 --> 00:23:16,220
Over here, I would probably have other cases like, is this compiled code?

416
00:23:16,220 --> 00:23:17,020
It's very important.

417
00:23:17,020 --> 00:23:25,880
I might have distinguished the kind of code that's produced by a directly evaluating a lambda in interpretation from code that was produced by somebody's compiler or something like that.

421
00:23:25,880 --> 00:23:27,230
And we'll talk about that later.

422
00:23:27,230 --> 00:23:30,510
Or is this a piece Fortran program I have to go off and execute.

424
00:23:30,510 --> 00:23:32,920
It's a perfectly possible thing, at this point, to do that.

426
00:23:32,920 --> 00:23:44,360
In fact, in this concrete syntax evaluator I'm writing here, there's an assumption built in that this is Lisp, because I'm using CARs and CDRs.

429
00:23:44,360 --> 00:23:46,750
CAR means the operator, and CDR means the operand.

430
00:23:46,750 --> 00:23:56,160
In the text, there is an abstract syntax evaluator for which these could be-- these are given abstract names like operator, and operand, and all these other things are like that.

434
00:23:56,160 --> 00:24:01,570
And, in that case, you could reprogram it to be ALGOL with no problem.

437
00:24:03,760 --> 00:24:08,660
Well, here we have added another couple of things that we haven't defined.

440
00:24:10,810 --> 00:24:15,050
I don't think I'll worry about these at all, however, this one will be interesting later.

443
00:24:17,930 --> 00:24:20,550
Let's just proceed through this and get it done.

444
00:24:20,550 --> 00:24:23,060
There's only two more blackboards so it can't be very long.

447
00:24:27,056 --> 00:24:30,070
It's carefully tailored to exactly fit.

448
00:24:30,070 --> 00:24:30,980
Well, what do we have left?

449
00:24:30,980 --> 00:24:33,730
We have to define EVLIST, which is over here.

450
00:24:33,730 --> 00:24:44,240
And EVLIST is nothing more than a map down a bunch of operands producing arguments.

452
00:24:44,240 --> 00:24:45,820
But I'm going to write it out.

453
00:24:45,820 --> 00:24:53,610
And one of the reasons I'm going to write this out is for a mystical reason, which is I want to make this evaluator so simple that it can understand itself.

457
00:24:56,450 --> 00:25:00,230
I'm going to really worry about that a little bit.

458
00:25:00,230 --> 00:25:02,850
So let's write it out completely.

459
00:25:02,850 --> 00:25:06,080
See, I don't want to worry about whether or not the thing can pass functional arguments.

461
00:25:06,080 --> 00:25:08,980
The value evaluator is not going to use them.

462
00:25:08,980 --> 00:25:10,880
The evaluator is not going to produce functional values.

463
00:25:10,880 --> 00:25:24,070
So even if there were a different, alternative language that were very close to this, this evaluates a complex language like Scheme which does allow procedural arguments, procedural values, and procedural data.

467
00:25:24,070 --> 00:25:31,580
But even if I were evaluating ALGOL, which doesn't allow procedural values, I could use this evaluator.

469
00:25:31,580 --> 00:25:34,050
And this evaluator is not making any assumptions about that.

471
00:25:34,050 --> 00:25:40,640
And, in fact, if this value were to be restricted to not being able to that, it wouldn't matter, because it doesn't use any of those clever things.

474
00:25:40,640 --> 00:25:44,070
So that's why I'm arranging this to be super simple.

475
00:25:44,070 --> 00:25:47,810
This is sort of the kernel of all possible language evaluators.

477
00:25:47,810 --> 00:25:49,420
How about that?

478
00:25:49,420 --> 00:25:53,820
Evlist--  well, what is it?

481
00:25:53,820 --> 00:26:33,260
It's the procedure of two arguments, l and an environment, where l is a list such that if the list of arguments is the empty list, then the result is the empty list. Otherwise, I want to cons up the result of evaluating the CAR of the list of operands in the environment.

487
00:26:33,260 --> 00:26:50,130
So I want the first operand evaluated, and I'm going to make a list of the results by CONSing that onto the result of this EVLISTing as a CDR recursion, the CDR of the list relative to the same environment.

492
00:26:53,350 --> 00:27:03,620
Evlist, cons, else, COND, lambda, define--  And I have one more that I want to put on the blackboard.

495
00:27:03,620 --> 00:27:05,470
It's the essence of this whole thing.

496
00:27:05,470 --> 00:27:08,130
And there's some sort of next layer down.

498
00:27:14,540 --> 00:27:18,880
Conditionals-- conditionals are the only thing left that are sort of substantial.

501
00:27:18,880 --> 00:27:25,530
Then below that, we have to worry about things like lookup and bind, and we'll look at that in a second.

503
00:27:25,530 --> 00:27:31,600
But of the substantial stuff at this level of detail, next important thing is how you deal with conditionals.

505
00:27:31,600 --> 00:27:33,330
Well, how do we have a conditional thing?

507
00:27:37,670 --> 00:27:44,720
It's a procedure of a set of clauses and an environment.

509
00:27:47,340 --> 00:27:49,820
And what does it do?

510
00:27:49,820 --> 00:28:04,520
It says, if I've no more clauses, well, I have to give this a value.

512
00:28:04,520 --> 00:28:06,540
It could be that it was an error.

513
00:28:06,540 --> 00:28:10,060
Supposing it run off the end of a conditional, it's pretty arbitrary.

515
00:28:10,060 --> 00:28:13,650
It's up to me as programmer to choose what I want to happen.

516
00:28:13,650 --> 00:28:20,100
It's convenient for me, right now, to write down that this has a value which is the empty list, doesn't matter.

518
00:28:20,100 --> 00:28:23,110
For error checking, some people might prefer something else.

520
00:28:23,110 --> 00:28:25,570
But the interesting things are the following ones.

521
00:28:25,570 --> 00:28:40,265
If I've got an else clause--  You see, if I have a list of clauses, then each clause is a list. And so the predicate part is the CAAR of the clauses.

527
00:28:43,560 --> 00:28:51,090
It's the CAR, which is the first part of the first clause in the list of clauses.

529
00:28:51,090 --> 00:28:59,800
If it's an else, then it means I want my result of the conditional to be the result of evaluating the matching expression.

532
00:28:59,800 --> 00:29:22,195
So I eval the CADR. So this is the first clause, the second element of it, CADAR-- CADAR of a CAR-- of the clauses, with respect to the environment.

537
00:29:26,620 --> 00:29:29,630
Now the next possibility is more interesting.

538
00:29:29,630 --> 00:29:44,360
If it's false, if the first predicate in the predicate list is not an else, and it's not false, if it's not the word else, and if it's not a false thing-- Let's write down what it is if it's a false thing.

542
00:29:44,360 --> 00:30:04,180
If the result of evaluating the first predicate, the clauses--  respect the environment, if that evaluation yields false, then it means, I want to look at the next clause.

547
00:30:04,180 --> 00:30:05,990
So I want to discard the first one.

548
00:30:05,990 --> 00:30:16,700
So we just go around loop, evcond, the CDR of the clauses relative to that environment.

551
00:30:21,240 --> 00:30:41,960
And otherwise, I had a true clause, in which case, what I want is to evaluate the CADAR of the clauses relative to that environment.

555
00:30:48,200 --> 00:30:51,210
Boy, it's almost done.

556
00:30:51,210 --> 00:30:53,730
It's quite close to done.

557
00:30:53,730 --> 00:30:56,210
I think we're going to finish this part off.

558
00:30:56,210 --> 00:31:01,220
So just buzzing through this evaluator, but so far you're seeing almost everything.

560
00:31:01,220 --> 00:31:04,040
Let's look at the next transparency here.

562
00:31:08,980 --> 00:31:11,980
Here is bind.

563
00:31:11,980 --> 00:31:15,460
Bind is for making more table.

564
00:31:15,460 --> 00:31:22,800
And what we are going to do here is make a-- we're going to make a no-frame for an environment structure.

566
00:31:22,800 --> 00:31:28,080
The environment structure is going to be represented as a list of frames.

568
00:31:28,080 --> 00:31:49,690
So given an existing environment structure, I'm going to make a new environment structure by consing a new frame onto the existing environment structure, where the new frame consists of the result of pairing up the variables, which are the bound variables of the procedure I'm applying, to the values which are the arguments that were passed that procedure.

575
00:31:49,690 --> 00:31:58,391
This is just making a list, adding a new element to our list of frames, which is an environment structure, to make a new environment.

578
00:31:58,391 --> 00:32:01,540
Where pair-up is very simple.

579
00:32:01,540 --> 00:32:09,720
Pair-up is nothing more than if I have a list of variables and a list of values, well, if I run out of variables and if I run out of values, everything's OK.

582
00:32:09,720 --> 00:32:12,990
Otherwise, I've given too many arguments.

583
00:32:12,990 --> 00:32:18,560
If I've not run out of variables, but I've run out of values, that I have too few arguments.

585
00:32:18,560 --> 00:32:42,950
And in the general case, where I don't have any errors, and I'm not done, then I really am just adding a new pair of the first variable with the first argument, the first value, onto a list resulting from pairing-up the rest of the variables with the rest of the values.

590
00:32:42,950 --> 00:32:46,620
Lookup is of course equally simple.

591
00:32:46,620 --> 00:32:54,650
If I have to look up a symbol in an environment, well, if the environment is empty, then I've got an unbound variable.

593
00:32:54,650 --> 00:33:05,930
Otherwise, what I'm going to do is use a special pair list lookup procedure, which we'll have very shortly, of the symbol in the first frame of the environment.

596
00:33:05,930 --> 00:33:09,200
Since I know the environment is not empty, it must have a first frame.

598
00:33:09,200 --> 00:33:11,140
So I lookup the symbol in the first frame.

599
00:33:11,140 --> 00:33:15,150
That becomes the value cell here.

600
00:33:15,150 --> 00:33:23,720
And then, if the value cell is empty, if there is no such value cell, then I have to continue and look at the rest of the frames.

603
00:33:23,720 --> 00:33:25,990
It means there was nothing found there.

604
00:33:25,990 --> 00:33:32,010
So that's a property of ASSQ is it returns emptiness if it doesn't find something.

606
00:33:32,010 --> 00:33:41,050
but if it did find something, then I'm going to use the CDR of the value cell here, which is the thing that was the pair consisting of the variable and the value.

609
00:33:41,050 --> 00:33:45,000
So the CDR of it is the value part.

610
00:33:45,000 --> 00:33:47,970
Finally, ASSQ is something you've probably seen already.

611
00:33:47,970 --> 00:33:53,760
ASSQ takes a symbol and a list of pairs, and if the list is empty, it's empty.

613
00:33:53,760 --> 00:33:59,820
If the symbol is the first thing in the list-- That's an error.

615
00:33:59,820 --> 00:34:04,160
That should be CAAR, C-A-A-R. Everybody note that.

617
00:34:07,730 --> 00:34:08,980
Right there, OK?

619
00:34:13,121 --> 00:34:35,190
And in any case, if the symbol is the CAAR of the A list, then I want the first, the first pair, in the A list. So, in other words, if this is the key matching the right entry, otherwise, I want to look up that symbol in the rest. Sorry for producing a bug, bugs appear.

624
00:34:35,190 --> 00:34:39,639
Well, in any case, you're pretty much seeing the whole thing now.

627
00:34:41,880 --> 00:34:49,600
It's a very beautiful thing, even though it's written in an ugly style, being the kernel of every language.

629
00:34:49,600 --> 00:34:51,460
I suggest that we just-- let's look at it for a while.

632
00:34:56,749 --> 00:35:49,750
[MUSIC PLAYING]

633
00:35:49,750 --> 00:35:51,000
Are there any questions?

635
00:36:01,180 --> 00:36:04,044
Alright, I suppose it's time to take a small break then.

636
00:36:04,044 --> 00:36:56,780
[MUSIC PLAYING]

637
00:36:56,780 --> 00:37:03,470
OK, now we're just going to do a little bit of practice understanding what it is we've just shown you.

639
00:37:03,470 --> 00:37:11,500
What we're going to do is go through, in detail, an evaluation by informally substituting through the interpreter.

642
00:37:11,500 --> 00:37:25,330
And since we have no assignments or definitions in this interpreter, we have no possible side effects, and so the we can do substitution with impunity and not worry about results.

646
00:37:25,330 --> 00:37:30,690
So the particular problem I'd like to look at is it an interesting one.

648
00:37:30,690 --> 00:37:59,890
It's the evaluation of quote, open, open, open, lambda of x, lambda of y plus x y, lambda, lambda, applied to three, applied to four, in some global environment which I'll call e0.

653
00:38:04,930 --> 00:38:14,300
So what we have here is a procedure of one argument x, which produces as its value a procedure of one argument y, which adds x to y.

656
00:38:14,300 --> 00:38:17,960
We are applying the procedure of one argument x to three.

657
00:38:17,960 --> 00:38:21,400
So x should become three.

658
00:38:21,400 --> 00:38:26,167
And the result of that should be procedure of one argument y, which will then apply to 4.

661
00:38:28,910 --> 00:38:34,790
And there is a very simple case, they will then add those results.

663
00:38:34,790 --> 00:38:37,660
And now in order to do that, I want to make a very simple environment model.

665
00:38:37,660 --> 00:38:44,460
And at this point, you should already have in your mind the environments that this produces.

667
00:38:44,460 --> 00:38:56,740
But we're going to start out with a global environment, which I'll call e0, which is that.

669
00:38:56,740 --> 00:39:31,270
And it's going to have in it things, definitions for plus, and times, and-- using Greek letters, isn't that interesting, for the objects-- and minus, and quotient, and CAR, and CDR, and CONS, and EQ, and everything else you might imagine in a global environment.

676
00:39:31,270 --> 00:39:39,220
It's got something there for each of those things, something the machine is born with, that's e0.

678
00:39:39,220 --> 00:39:42,940
Now what does it mean to do this evaluation?

679
00:39:42,940 --> 00:39:48,670
Well, we go through the set of special forms. First of all, this is not a number.

681
00:39:48,670 --> 00:39:50,380
This is not a symbol.

683
00:39:53,210 --> 00:39:56,520
Gee, it's not a quoted expression.

684
00:39:56,520 --> 00:40:00,600
This is a quoted expression, but that's not what I interested in.

686
00:40:00,600 --> 00:40:05,890
The question is, whether or not the thing which is quoted is quoted expression?

688
00:40:05,890 --> 00:40:07,960
I'm evaluating an expression.

689
00:40:07,960 --> 00:40:11,410
This just says it's this particular expression.

690
00:40:11,410 --> 00:40:12,660
This is not a quoted expression.

692
00:40:15,230 --> 00:40:19,120
It's not a thing that begins with lambda.

693
00:40:19,120 --> 00:40:22,030
It's not a thing that begins with COND.

694
00:40:22,030 --> 00:40:26,310
Therefore, it's an application of its of an operated operands.

696
00:40:26,310 --> 00:40:28,570
It's a combination.

697
00:40:28,570 --> 00:40:36,480
The combination thus has this as the operator and this is the operands.

700
00:40:40,130 --> 00:41:24,450
Well, that means that what I'm going to do is transform this into apply of eval, of quote, open, open lambda of x, lambda of y-- I'm evaluating the operator-- plus x y, in the environment, also e0, with the operands that I'm going to apply this to, the arguments being the result of EVLIST, the list containing four, fin e0.

708
00:41:29,010 --> 00:41:36,840
I'm using this funny notation here for e0 because this should be that environment.

710
00:41:36,840 --> 00:41:39,890
I haven't a name for it, because I have no environment to name it in.

713
00:41:41,960 --> 00:41:47,730
So this is just a representation of what would be a quoted expression, if you will.

715
00:41:47,730 --> 00:41:53,040
The data structure, which is the environment, goes there.

716
00:41:53,040 --> 00:41:55,850
Well, that's what we're seeing here.

717
00:41:55,850 --> 00:41:59,610
Well in order to do this, I have to do this, and I have to do that.

719
00:41:59,610 --> 00:42:03,770
Well this one's easy, so why don't we do that one first.

720
00:42:03,770 --> 00:42:09,520
This turns into apply of eval-- just copying something now.

722
00:42:09,520 --> 00:42:11,000
Most of the substitution rule is copying.

724
00:42:18,530 --> 00:42:23,350
So I'm going to not say the words when I copy, because it's faster.

727
00:42:26,100 --> 00:42:48,910
And then the EVLIST is going to turn into a cons, of eval, of four, in e0--  because it was not an empty list-- onto the result of EVLISTing, on the empty list, in e0.

733
00:42:52,580 --> 00:42:55,800
And I'm going to start leaving out steps soon, because it's going to get boring.

736
00:42:59,870 --> 00:43:20,240
But this is basically the same thing as apply, of eval--  I'm going to keep doing this-- the lambda of x, the lambda of y, plus xy, 3, close, e0.

740
00:43:20,240 --> 00:43:21,490
I'm a pretty good machine.

742
00:43:24,690 --> 00:43:28,790
Well, eval of four, that's meets the question, is it a number.

744
00:43:28,790 --> 00:43:35,280
So that's cons, cons of 4.

745
00:43:35,280 --> 00:43:39,240
And EVLIST of the empty list is the empty list, so that's this.

748
00:43:43,270 --> 00:43:48,710
And that's very simple to understand, because that means the list containing four itself.

750
00:43:48,710 --> 00:44:13,940
So this is nothing more than apply of eval, quote, open, open, lambda of x, lambda of y, plus x y, three applied to, e0, applied to the list four-- bang.

754
00:44:13,940 --> 00:44:15,190
So that's that step.

756
00:44:18,100 --> 00:44:20,360
Now let's look at the next, more interesting thing.

757
00:44:20,360 --> 00:44:23,070
What do I do to evaluate that?

758
00:44:23,070 --> 00:44:29,460
Evaluating this means I have to evaluate-- Well, it's not.

760
00:44:29,460 --> 00:44:31,680
It's nothing but an application.

761
00:44:31,680 --> 00:44:33,570
It's not one of the special things.

762
00:44:33,570 --> 00:44:46,570
If the application of this operator, which we see here-- here's the operator-- applied to this operands, that combination.

765
00:44:46,570 --> 00:44:52,370
But we know how to do that, because that's the last case of the conditional.

767
00:44:52,370 --> 00:45:01,160
So substituting in for this evaluation, it's apply of eval of the operator in the EVLIST of the operands.

769
00:45:01,160 --> 00:45:25,350
Well, it's apply, of apply, of eval, of quote, open, lambda of x, lambda of y, plus x y, lambda, lambda, in environment e0.

773
00:45:30,520 --> 00:45:35,230
I'm going to short circuit the evaluation of the operands , because they're the same as they were before.

775
00:45:35,230 --> 00:45:39,330
I got a list containing three, apply that, and apply that to four.

778
00:45:42,780 --> 00:45:44,410
Well let's see.

779
00:45:44,410 --> 00:45:49,450
Eval of a lambda expression produces a procedure object.

781
00:45:52,030 --> 00:46:12,130
So this is apply, of apply, of the procedure object closure, which contains the body of the procedure, x, which is lambda-- which binds x [UNINTELLIGIBLE]

784
00:46:12,130 --> 00:46:20,630
the internals of the body, it returns the procedure of one argument y, which adds x to y.

787
00:46:23,210 --> 00:46:30,340
Environment e0 is now captured in it, because this was evaluated with respect to e0.

789
00:46:30,340 --> 00:46:33,040
e0 is part now of the closure object.

790
00:46:33,040 --> 00:46:41,300
Apply that to open, three, close, apply, to open, 4, close, apply.

793
00:46:47,390 --> 00:46:57,150
So going from this step to this step meant that I made up a procedure object which captured in it e0 as part of the procedure object.

796
00:46:57,150 --> 00:46:58,620
Now, we're going to pass those to apply.

797
00:46:58,620 --> 00:47:02,710
We have to apply this procedure to that set of arguments.

799
00:47:02,710 --> 00:47:07,380
Well, but that procedure is not primitive.

800
00:47:07,380 --> 00:47:13,710
It's, in fact, a thing which has got the tag closure, and, therefore, what we have to do is do a bind.

802
00:47:13,710 --> 00:47:15,830
We have to bind.

803
00:47:15,830 --> 00:47:28,230
A new environment is made at this point, which has as its parent environment the one over here, e0, that environment.

807
00:47:30,320 --> 00:47:31,570
And we'll call this one, e1.

809
00:47:34,620 --> 00:47:36,040
Now what's bound in there?

810
00:47:36,040 --> 00:47:38,620
x is bound to three.

811
00:47:38,620 --> 00:47:41,480
So I have x equal three.

812
00:47:41,480 --> 00:47:42,730
That's what's in there.

814
00:47:44,940 --> 00:47:46,240
And we'll call that e1.

815
00:47:46,240 --> 00:48:00,290
So what this transforms into is an eval of the body of this, which is this, the body of that procedure, in the environment that you just saw.

818
00:48:00,290 --> 00:48:16,520
So that's an apply, of eval, quote, open, lambda of y, plus x y-- the body--  in e1.

823
00:48:20,660 --> 00:48:28,680
And apply the result of that to four, open, close, 4-- list of arguments.

825
00:48:28,680 --> 00:48:33,110
Well, that's sensible enough because evaluating a lambda, I know what to do.

827
00:48:33,110 --> 00:48:52,150
That means I apply, the procedure which is closure, binds one argument y, adds x to y, with e1 captured in it.

830
00:48:55,790 --> 00:48:57,800
And you should really see this.

831
00:48:57,800 --> 00:49:00,140
I somehow manufactured a closure.

832
00:49:00,140 --> 00:49:01,790
I should've put this here.

833
00:49:01,790 --> 00:49:03,040
There was one over here too.

835
00:49:06,230 --> 00:49:08,080
Well, there's one here now.

836
00:49:08,080 --> 00:49:17,880
I've captured e1, and this is the procedure of one argument y, whatever this is.

838
00:49:17,880 --> 00:49:20,435
That's what that is there, that closure.

840
00:49:23,040 --> 00:49:26,230
I'm going to apply that to four.

842
00:49:30,690 --> 00:49:31,940
Well, that's easy enough.

844
00:49:36,830 --> 00:49:49,540
That means I have to make a new environment by copying this pointer, which was the pointer of the procedure, which binds y equal 4 with that environment.

847
00:49:49,540 --> 00:49:52,460
And here's my new environment, which I'll call e2.

849
00:49:55,870 --> 00:50:01,910
And, of course, this application then is evaluate the body in e2.

851
00:50:01,910 --> 00:50:13,710
So this is eval, the body, which is plus x y, in the environment e2.

853
00:50:13,710 --> 00:50:37,340
But this is an application, so this is the apply, of eval, plus in e2, an EVLIST, quote, open, x y, in e2.

856
00:50:44,880 --> 00:50:45,590
Well, but let's see.

857
00:50:45,590 --> 00:50:54,190
That is apply, the object which is a result of that and plus.

859
00:50:54,190 --> 00:51:01,780
So here we are in e2, plus is not here, it's not here, oh, yes, but's here as some primitive operator.

861
00:51:01,780 --> 00:51:04,745
So it's the primitive operator for addition.

863
00:51:08,490 --> 00:51:14,370
Apply that to the result of evaluating x and y in e2.

864
00:51:14,370 --> 00:51:18,340
But we can see that x is three and y is four.

865
00:51:18,340 --> 00:51:23,936
So that's a three and four, here.

866
00:51:23,936 --> 00:51:26,280
And that magically produces for me a seven.

868
00:51:30,520 --> 00:51:40,470
I wanted to go through this so you would see, essentially, one important ingredient, which is what's being passed around, and who owns what, and what his job is.

871
00:51:40,470 --> 00:51:41,700
So what do we have here?

872
00:51:41,700 --> 00:51:46,520
We have eval, and we have apply, the two main players.

874
00:51:49,370 --> 00:51:52,320
And there is a big loop the goes around like this.

875
00:51:52,320 --> 00:52:06,270
Which is eval produces a procedure and arguments for apply.

877
00:52:06,270 --> 00:52:09,710
Now some things eval could do by itself.

878
00:52:09,710 --> 00:52:10,860
Those are little self things here.

879
00:52:10,860 --> 00:52:12,700
They're not interesting.

880
00:52:12,700 --> 00:52:16,240
Also eval evaluates all of the arguments, one after another.

881
00:52:16,240 --> 00:52:17,650
That's not very interesting.

882
00:52:17,650 --> 00:52:22,300
Apply can apply some procedures like plus, not very interesting.

884
00:52:22,300 --> 00:52:32,880
However, if apply can't apply a procedure like plus, it produces an expression and environment for eval.

887
00:52:35,470 --> 00:52:43,740
The procedural arguments wrap up essentially the state of a computation and, certainly, the expression of environment.

889
00:52:43,740 --> 00:52:48,820
And so what we're actually going to do next is not the complete state, because it doesn't say who wants the answers.

893
00:52:51,280 --> 00:52:58,970
But what we're going to do-- it's always got something like an expression of environment or procedure and arguments as the main loop that we're going around.

896
00:52:58,970 --> 00:53:12,280
There are minor little sub loops like eval through EVLIST, or eval through evcond, or apply through a primitive apply.

900
00:53:16,140 --> 00:53:18,500
But they're not the essential things.

901
00:53:18,500 --> 00:53:21,860
So that's what I wanted you to see.

902
00:53:21,860 --> 00:53:23,110
Are there any questions?

904
00:53:25,930 --> 00:53:28,690
Yes.

905
00:53:28,690 --> 00:53:37,070
AUDIENCE: I'm trying to understand how x got down to three instead of four.

907
00:53:37,070 --> 00:53:41,310
At the early part of the-- PROFESSOR: Here.

909
00:53:41,310 --> 00:53:43,310
You want to know how x got down to three?

910
00:53:43,310 --> 00:53:51,040
AUDIENCE: Because x is the outer procedure, and x and y are the inner procedure.

912
00:53:51,040 --> 00:53:52,570
PROFESSOR: Fine.

913
00:53:52,570 --> 00:53:55,280
Well, I was very careful and mechanical.

914
00:53:55,280 --> 00:54:00,610
First of all, I should write those procedures again for you, pretty printed.

916
00:54:00,610 --> 00:54:03,830
First order of business, because you're probably not reading them well.

918
00:54:03,830 --> 00:54:26,140
So I have here that procedure of-- was it x over there-- which is-- value of that procedure of y, which adds x to y, lambda, lambda, applied that to three, takes the result of that, and applied that to four.

924
00:54:26,140 --> 00:54:28,810
Is that not what I wrote?

925
00:54:28,810 --> 00:54:40,735
Now, you should immediately see that here is an application-- let me get a white piece of chalk-- here is an application, a combination.

930
00:54:44,300 --> 00:54:51,040
That combination has this as the operator and this as the operand.

932
00:54:51,040 --> 00:54:54,900
The three is going in for the x here.

933
00:54:54,900 --> 00:55:01,530
The result of this is a procedure of one argument y, which gets applied to four.

935
00:55:01,530 --> 00:55:04,190
So you just weren't reading the expression right.

936
00:55:04,190 --> 00:55:13,340
The way you see that over here is that here I have the actual procedure object, x.

938
00:55:13,340 --> 00:55:18,980
It's getting applied to three, the list containing three.

939
00:55:18,980 --> 00:55:24,080
What I'm left over with is something which gets applied to four.

941
00:55:24,080 --> 00:55:25,330
Are there any other questions?

943
00:55:28,600 --> 00:55:30,900
Time for our next small break then.

944
00:55:30,900 --> 00:55:33,735
Thank you.

945
00:55:33,735 --> 00:56:08,410
[MUSIC PLAYING]

946
00:56:08,410 --> 00:56:17,960
Let's see, at this point, you should be getting the feeling, what's this nonsense this Sussman character is feeding me?

950
00:56:20,740 --> 00:56:24,800
There's an awful lot of strange nonsense here.

951
00:56:24,800 --> 00:56:30,892
After all, he purported to explain to me Lisp, and he wrote me a Lisp program on the blackboard.

953
00:56:30,892 --> 00:56:38,370
The Lisp program was intended to be interpreted for Lisp, but you need a Lisp interpreter in order to understand that program.

956
00:56:38,370 --> 00:56:44,150
How could that program have told me anything there is to be known about Lisp?

958
00:56:44,150 --> 00:56:45,795
How is that not completely vacuous?

960
00:56:48,490 --> 00:56:50,990
It's a very strange thing.

961
00:56:50,990 --> 00:56:52,430
Does it tell me anything at all?

963
00:56:56,070 --> 00:57:03,105
Well, you see, the whole thing is sort of like these Escher's hands that we see on this slide.

966
00:57:06,180 --> 00:57:17,110
Yes, eval and apply each sort of draw each other and construct the real thing, which can sit out and draw itself.

969
00:57:17,110 --> 00:57:20,550
Escher was a very brilliant man, he just didn't know the names of these spirits.

972
00:57:23,910 --> 00:57:36,090
Well, I'm going to do now, is I'm going to try to convince you that both this mean something, and, as a aside, I'm going to show you why you don't need definitions.

975
00:57:36,090 --> 00:57:44,890
Just turns out that that sort of falls out, why definitions are not essential in a mathematical sense for doing all the things we need to do for computing.

979
00:57:49,070 --> 00:57:50,690
Well, let's see here.

980
00:57:50,690 --> 00:57:54,870
Consider the following small program, what does it mean?

981
00:57:54,870 --> 00:57:57,035
This is a program for computing exponentials.

983
00:58:07,270 --> 00:58:22,070
The exponential of x to the nth power is if--  and is zero, then the result is one.

986
00:58:22,070 --> 00:58:33,930
Otherwise, I want the product of x and the result of exponentiating x to the n minus one power.

989
00:58:42,858 --> 00:58:46,630
I think I got it right.

990
00:58:46,630 --> 00:58:49,470
Now this is a recursive definition.

991
00:58:49,470 --> 00:58:56,410
It's a definition of the exponentiation procedure in terms of itself.

993
00:58:56,410 --> 00:59:05,650
And, as it has been mentioned before, your high school geometry teacher probably gave you a hard time about things like that.

996
00:59:05,650 --> 00:59:07,910
Was that justified?

997
00:59:07,910 --> 00:59:13,430
Why does this self referential definition make any sense?

998
00:59:13,430 --> 00:59:17,600
Well, first of all, I'm going to convince you that your high school geometry teacher was I telling you nonsense.

1001
00:59:20,370 --> 00:59:24,490
Consider the following set of definitions here.

1002
00:59:24,490 --> 00:59:33,070
x plus y equals three, and x minus y equal one.

1003
00:59:33,070 --> 00:59:37,490
Well, gee, this tells you x in terms of y, and this one tells you y in terms of x, presumably.

1006
00:59:40,150 --> 00:59:42,950
And yet this happens to have a unique solution in x and y.

1008
00:59:55,910 --> 01:00:06,600
However, I could also write two x plus two y is six.

1009
01:00:06,600 --> 01:00:09,610
These two equations have an infinite number solutions.

1011
01:00:15,730 --> 01:00:24,070
And I could write you, for example, x minus y equal 2, and these two equations have no solutions.

1014
01:00:29,820 --> 01:00:39,510
Well, I have here three sets of simultaneous linear equations, this set, this set, and this set.

1016
01:00:39,510 --> 01:00:42,900
But they have different numbers of solutions.

1017
01:00:42,900 --> 01:00:45,760
The number of solutions is not in the form of the equations.

1018
01:00:45,760 --> 01:00:48,350
They all three sets have the same form.

1019
01:00:48,350 --> 01:00:50,205
The number of solutions is in the content.

1021
01:00:53,000 --> 01:00:59,660
I can't tell by looking at the form of a definition whether it makes sense, only by its detailed content.

1023
01:00:59,660 --> 01:01:05,100
What are the coefficients, for example, in the case of linear equations?

1025
01:01:05,100 --> 01:01:16,030
So I shouldn't expect to be able to tell looking at something like this, from some simple things like, oh yes, EXPT is the solution of this recursion equation.

1028
01:01:16,030 --> 01:01:26,040
Expt is the procedure which if substituted in here, gives me EXPT back.

1030
01:01:26,040 --> 01:01:37,200
I can't tell, looking at this form, whether or not there's a single, unique solution for EXPT, an infinite number of solutions, or no solutions.

1033
01:01:37,200 --> 01:01:40,490
It's got to be how it counts and things like that, the details.

1035
01:01:40,490 --> 01:01:42,900
And it's harder in programming than linear algebra.

1036
01:01:42,900 --> 01:01:45,210
There aren't too many theorems about it in programming.

1038
01:01:48,450 --> 01:01:53,970
Well, I want to rewrite these equations a little bit, these over here.

1040
01:01:53,970 --> 01:01:56,770
Because what we're investigating is equations like this.

1042
01:01:56,770 --> 01:02:04,730
But I want to play a little with equations like this that we understand, just so we get some insight into this kind of question.

1045
01:02:04,730 --> 01:02:19,380
We could rewrite our equations here, say these two, the ones that are interesting, as x equals three minus y, and y equals x minus one.

1049
01:02:22,010 --> 01:02:24,050
What do we call this transformation?

1050
01:02:24,050 --> 01:02:26,095
This is a linear transformation, t.

1052
01:02:29,430 --> 01:02:37,370
Then what we're getting here is an equation x y equals t of x y.

1055
01:02:42,990 --> 01:02:44,560
What am I looking for?

1056
01:02:44,560 --> 01:02:47,040
I'm looking for a fixed point of t.

1057
01:02:47,040 --> 01:02:59,350
The solution is a fixed point of t.

1059
01:03:01,910 --> 01:03:10,880
So the methods we should have for looking for solutions to equations, if I can do it by fixed points, might be applicable.

1062
01:03:10,880 --> 01:03:22,410
If I have a means of finding a solution to an equations by fixed points-- just, might not work-- but it might be applicable to investigating solutions of equations like this.

1068
01:03:27,240 --> 01:03:30,260
But what I want you to feel is that this is an equation.

1069
01:03:30,260 --> 01:03:45,010
It's an expression with several instances of various names which puts a constraint on the name, saying what that name could have as its value, rather than some sort of mechanical process of substitution right now.

1074
01:03:47,740 --> 01:03:51,220
This is an equation which I'm going to try to solve.

1075
01:03:51,220 --> 01:03:53,960
Well, let's play around and solve it.

1076
01:03:53,960 --> 01:04:00,320
First of all, I want to write down the function which corresponds to t.

1078
01:04:00,320 --> 01:04:06,960
First I want to write down the function which corresponds to t whose fixed point is the answer to this question.

1081
01:04:11,950 --> 01:04:14,240
Well, let's consider the following procedure f.

1083
01:04:16,870 --> 01:04:19,340
I claim it computes that function.

1084
01:04:19,340 --> 01:04:33,430
f is that procedure of one argument g, which is that procedure of two arguments x and n.

1086
01:04:33,430 --> 01:05:00,690
Which have the property that if n is zero, then the result is one, otherwise, the result is the product of x and g, applied to x, and minus n1.

1090
01:05:03,370 --> 01:05:30,930
g, times, else, COND, lambda, lambda--  Here f is a procedure, which if I had a solution to that equation, if I had a good exponentiation procedure, and I applied f to that procedure, then the result would be a good exponentiation procedure.

1097
01:05:37,460 --> 01:05:39,420
Because, what does it do?

1098
01:05:39,420 --> 01:05:54,670
Well, all it is is exposing g were a good exponentiation procedure, well then this would produce, as its value, a procedure to arguments x and n, such that if n were 0, the result would be one, which is certainly true of exponentiation.

1103
01:05:54,670 --> 01:06:03,470
Otherwise, it will be the result of multiplying x by the exponentiation procedure given to me with x and n minus one as arguments.

1106
01:06:03,470 --> 01:06:14,620
So if this computed the correct exponentiation for n minus one, then this would be the correct exponentiation for exponent n, so this would have been the right exponentiation procedure.

1111
01:06:17,500 --> 01:06:32,320
So what I really want to say here is E-X-P-T is a fixed point of f.

1114
01:06:37,550 --> 01:06:40,060
Now our problem is there might be more than one fixed point.

1115
01:06:40,060 --> 01:06:43,270
There might be no fixed points.

1116
01:06:43,270 --> 01:06:44,810
I have to go hunting for the fixed points.

1118
01:06:48,290 --> 01:06:49,540
Got to solve this equation.

1120
01:06:52,160 --> 01:06:55,580
Well there are various ways to hunt for fixed points.

1121
01:06:55,580 --> 01:07:00,815
Of course, the one we played with at the beginning of this term worked for cosine.

1124
01:07:06,080 --> 01:07:16,090
Go into radians mode on your calculator and push cosine, and just keep doing it, and you get to some number which is about 0.73 or 0.74.

1127
01:07:16,090 --> 01:07:17,340
I can't remember which.

1129
01:07:22,900 --> 01:07:33,770
By iterating a function, whose fixed point I'm searching for, it is sometimes the case that that function will converge in producing the fixed point.

1132
01:07:33,770 --> 01:07:39,910
I think we luck out in this case, so let's look for it.

1133
01:07:39,910 --> 01:07:48,030
Let's look at this slide.

1134
01:07:48,030 --> 01:07:51,390
Consider the following sequence of procedures.

1136
01:07:56,400 --> 01:08:02,940
e0 over here is the procedure which does nothing at all.

1137
01:08:02,940 --> 01:08:07,780
It's the procedure which produces an error for any arguments you give it.

1139
01:08:07,780 --> 01:08:09,030
It's basically useless.

1141
01:08:14,480 --> 01:08:20,080
Well, however, I can make an approximation.

1142
01:08:20,080 --> 01:08:26,990
Let's consider it the worst possible approximation to exponentiation, because it does nothing.

1144
01:08:26,990 --> 01:08:37,380
Well, supposing I substituted e0 for g by calling f, as you see over here on e0.

1146
01:08:37,380 --> 01:08:40,729
So you see over here, have e0 there.

1147
01:08:40,729 --> 01:08:43,859
Then gee, what's e1?

1148
01:08:43,859 --> 01:08:49,325
e1 is a procedure which exponentiate things to the 0th power, with no trouble.

1150
01:08:49,325 --> 01:08:54,250
It gets the right answer, anything to the zero is one, and it makes an error on anything else.

1153
01:08:57,390 --> 01:09:07,310
Well, now what if I take e1 and I substitute if for g by calling f on e1?

1156
01:09:10,500 --> 01:09:15,670
Oh gosh, I have here a procedure of two arguments.

1157
01:09:15,670 --> 01:09:24,200
Now remember e1 was appropriate for taking exponentiations of 0, for raising to the 0 exponent.

1159
01:09:24,200 --> 01:09:29,520
So here, is n is 0, the result is one, so this guy is good for that too.

1161
01:09:29,520 --> 01:09:35,979
However, I can use something for raising to the 0th power to multiply it by x to raise something to the first power.

1163
01:09:35,979 --> 01:09:39,670
So e2 is good for both power 0 and one.

1165
01:09:43,800 --> 01:09:47,899
And e3 is constructed from e2 in the same way.

1166
01:09:47,899 --> 01:09:55,120
And e3, of course, by the same argument is good for powers 0, one, and two.

1168
01:09:55,120 --> 01:10:02,520
And so I will assert for you, without proof, because the proof is horribly difficult.

1170
01:10:02,520 --> 01:10:07,710
And that's the sort of thing that people called denotational semanticists do.

1172
01:10:07,710 --> 01:10:10,265
This great idea was invented by Scott and Strachey.

1174
01:10:14,240 --> 01:10:24,240
They're very famous mathematician types who invented the interpretation for these programs that we have that I'm talking to you about right now.

1177
01:10:24,240 --> 01:10:32,220
And they proved, by topology that there is such a fixed point in the cases that we want.

1179
01:10:32,220 --> 01:10:43,680
But the assertion is E-X-P-T is limit as n goes to infinity of em.

1181
01:10:43,680 --> 01:10:47,900
and And that we've constructed this by the following way.

1183
01:10:50,520 --> 01:11:01,120
--is Well, it's f of, f of, f of, f of, f of-- f applied to anything at all.

1185
01:11:01,120 --> 01:11:05,320
It didn't matter what that was, because, in fact, this always produces an error.

1188
01:11:07,540 --> 01:11:16,380
Applied to this--  That's by infinite nesting of f's.

1191
01:11:16,380 --> 01:11:19,760
So now my problem is to make some infinite things.

1193
01:11:22,590 --> 01:11:24,920
We need some infinite things.

1194
01:11:24,920 --> 01:11:28,980
How am I going to nest up an f an infinite number of times?

1195
01:11:28,980 --> 01:11:32,380
I'd better construct this.

1196
01:11:32,380 --> 01:11:32,930
Well, I don't know.

1197
01:11:32,930 --> 01:11:34,810
How would I make an infinite loop at all?

1198
01:11:34,810 --> 01:11:38,340
Let's take a very simple infinite loop, the simplest infinite loop imaginable.

1201
01:11:43,550 --> 01:12:07,440
If I were to take that procedure of one argument x which applies x to x and apply that to the procedure of one argument x which applies x to x, then this is an infinite loop.

1205
01:12:07,440 --> 01:12:09,980
The reason why this is an infinite loop is as follows.

1206
01:12:09,980 --> 01:12:18,850
The way I understand this is I substitute the argument for the formal parameter in the body.

1208
01:12:18,850 --> 01:12:29,660
But if I do that, I take for each of these x's, I substitute one of these, making a copy of the original expression I just started with, the simplest infinite loop.

1213
01:12:35,440 --> 01:12:43,090
Now I want to tell you about a particular operator which is constructed by a perturbation from this infinite loop.

1216
01:12:47,040 --> 01:12:48,290
I'll call it y.

1218
01:12:52,290 --> 01:13:04,480
This is called Curry's Paradoxical Combinator of y after a fellow by the name of Curry, who was a logician of the 1930s also.

1221
01:13:04,480 --> 01:13:09,330
And if I have a procedure of one argument f, what's it going to have in it?

1223
01:13:09,330 --> 01:13:27,899
It's going to have a kind of infinite loop in it, which is that procedure of one argument x which applies f to x of x, applied to that procedure of one argument x, which applies f to f of x.

1228
01:13:32,300 --> 01:13:34,590
Now what's this do?

1229
01:13:34,590 --> 01:13:42,950
Suppose we apply y to F. Well, that's easy enough.

1230
01:13:42,950 --> 01:13:46,910
That's this capital F over here.

1231
01:13:46,910 --> 01:13:49,920
Well, the easiest thing to say there is, I substitute F for here.

1234
01:13:55,320 --> 01:14:02,800
So that's going to give me, basically-- because then I'm going to substitute this for x in here.

1237
01:14:08,970 --> 01:14:11,730
Let me actually do it in steps, so you can see it completely.

1239
01:14:11,730 --> 01:14:15,020
I'm going to be very careful.

1240
01:14:15,020 --> 01:14:37,910
This is open, open, lambda of x , capital F, x, x, applied to itself, F of x of x.

1242
01:14:37,910 --> 01:15:11,510
Substituting this for this in here, this is F applied to-- what is it-- substituting this in here, open, open, lambda of x, F, of x and x, applied to lambda of x, F of x of x, F, lambda, pair, F.

1247
01:15:11,510 --> 01:15:13,420
Oh, but what is this?

1248
01:15:13,420 --> 01:15:20,030
This thing over here that I just computed, is this thing over here.

1250
01:15:20,030 --> 01:15:23,370
But I just wrapped another F around it.

1251
01:15:23,370 --> 01:15:27,850
So by applying y to F, I make an infinite series of F's.

1252
01:15:27,850 --> 01:15:33,170
If I just let this run forever, I'll just keep making more and more F's outside.

1254
01:15:33,170 --> 01:15:36,855
I ran an infinite loop which is useless, but it doesn't matter that the inside is useless.

1257
01:15:40,220 --> 01:16:04,450
So y of F is F applied to y of F. So y is a magical thing which, when applied to some function, produces the object which is the fixed point of that function, if it exists, and if this all works.

1262
01:16:07,910 --> 01:16:11,630
Because, indeed, if I take y of F and put it into F, I get y of F out.

1265
01:16:16,240 --> 01:16:23,860
Now I want you to think this in terms of the eval-apply interpreter for a bit.

1267
01:16:23,860 --> 01:16:28,540
I wrote down a whole bunch of recursion equations out there.

1268
01:16:28,540 --> 01:16:31,470
They're simultaneous in the same way these are simultaneous equations.

1270
01:16:31,470 --> 01:16:33,310
Exponentiation was not a simultaneous equation.

1271
01:16:33,310 --> 01:16:38,150
It was only one variable I was looking for a meaning for.

1272
01:16:38,150 --> 01:16:58,220
But what Lisp is is the fixed point of the process which says, if I knew what Lisp was and substituted it in for eval, and apply, and so on, on the right hand sides of all those recursion equations, then if it was a real good Lisp, is a real one, then the left hand side would also be Lisp.

1278
01:16:58,220 --> 01:16:59,565
So I made sense of that definition.

1280
01:17:02,420 --> 01:17:05,410
Now whether or not there's an answer isn't so obvious.

1281
01:17:05,410 --> 01:17:07,740
I can't attack that.

1282
01:17:07,740 --> 01:17:10,660
Now these arguments that I'm giving you now are quite dangerous.

1284
01:17:10,660 --> 01:17:13,570
Let's look over here.

1285
01:17:13,570 --> 01:17:14,610
These are limit arguments.

1286
01:17:14,610 --> 01:17:21,255
We're talking about limits, and it's really calculus, or topology, or something like that, a kind of analysis.

1288
01:17:21,255 --> 01:17:23,380
Now here's an argument that you all believe.

1289
01:17:23,380 --> 01:17:29,660
And I want to make sure you realize that I could be bullshitting you.

1291
01:17:29,660 --> 01:17:30,910
What is this?

1293
01:17:34,250 --> 01:17:42,820
u is the sum of 1/2, 1/4, and 1/8, and so on, the sum of a geometric series.

1295
01:17:42,820 --> 01:17:44,820
And, of course, I could play a game here.

1296
01:17:44,820 --> 01:17:47,570
u minus one is 1/2, plus 1/4, plus 1/8, and so on.

1298
01:17:53,590 --> 01:17:56,680
What I could do here-- oops.

1300
01:17:56,680 --> 01:17:58,920
There is a parentheses error here.

1301
01:17:58,920 --> 01:18:03,990
But I can put here two times u minus one is one plus 1/2, plus 1/4, plus 1/8.

1304
01:18:07,570 --> 01:18:08,820
Can I fix that?

1306
01:18:14,010 --> 01:18:16,125
Yes, well.

1308
01:18:19,520 --> 01:18:30,300
But that gives me back two times u minus one is u, therefore, we conclude that u is two.

1310
01:18:30,300 --> 01:18:31,830
And this actually is true.

1311
01:18:31,830 --> 01:18:33,910
There's no problem like that.

1312
01:18:33,910 --> 01:18:38,540
But supposing I did something different.

1313
01:18:38,540 --> 01:18:41,470
Supposing I start up with something which manifestly has no sum.

1315
01:18:41,470 --> 01:18:47,390
v is one, plus two, plus four, plus 8, plus dot, dot, dot.

1316
01:18:47,390 --> 01:18:52,010
Well, v minus one is surely two, plus four, plus eight, plus dot, dot, dot.

1318
01:18:52,010 --> 01:18:57,410
v minus one over two, gee, that looks like v again.

1319
01:18:57,410 --> 01:19:03,070
From that I should be able to conclude that-- that's also wrong, apparently.

1321
01:19:03,070 --> 01:19:04,510
v equals minus one.

1323
01:19:12,455 --> 01:19:15,280
That should be a minus one.

1324
01:19:15,280 --> 01:19:16,735
And that's certainly a false conclusion.

1326
01:19:22,000 --> 01:19:30,750
So when you play with limits, arguments that may work in one case they may not work in some other case.

1328
01:19:30,750 --> 01:19:32,240
You have to be very careful.

1329
01:19:32,240 --> 01:19:35,752
The arguments have to be well formed.

1330
01:19:35,752 --> 01:19:43,270
And I don't know, in general, what the story is about arguments like this.

1332
01:19:43,270 --> 01:19:46,060
We can read a pile of topology and find out.

1333
01:19:46,060 --> 01:19:53,260
But, surely, at least you understand now, why it might be some meaning to the things we've been writing on the blackboard.

1336
01:19:53,260 --> 01:19:56,480
And you understand what that might mean.

1337
01:19:56,480 --> 01:20:09,320
So, I suppose, it's almost about time for you to merit being made a member of the grand recursive order of lambda calculus hackers.

1340
01:20:09,320 --> 01:20:10,820
This is the badge.

1341
01:20:10,820 --> 01:20:21,890
Because you now understand, for example, what it says at the very top, y F equals F y F. Thank you.

1343
01:20:21,890 --> 01:20:24,710
Are there any questions?

1344
01:20:24,710 --> 01:20:25,150
Yes, Lev.

1345
01:20:25,150 --> 01:20:34,090
AUDIENCE: With this, it seems that then there's no need to define, as you imply, to just remember a value, to apply it later.

1348
01:20:34,090 --> 01:20:36,490
Defines were kind of a side-effect it seemed in the language.

1350
01:20:36,490 --> 01:20:37,075
[INTERPOSING]

1351
01:20:37,075 --> 01:20:39,300
are order dependent.

1352
01:20:39,300 --> 01:20:43,150
Does this eliminate the side-effect from the [INTERPOSING]

1354
01:20:43,150 --> 01:20:49,180
PROFESSOR: The answer is, this is not the way these things were implemented.

1356
01:20:49,180 --> 01:21:03,690
Define, indeed is implemented as an operation that actually modifies an environment structure, changes the frame that the define is executed in.

1359
01:21:03,690 --> 01:21:11,340
And there are many reasons for that, but a lot of this has to do with making an interactive system.

1361
01:21:11,340 --> 01:21:24,090
What this is saying is that if you've made a system, and you know you're not going to do any debugging or anything like that, and you know everything there is all at once, and you want to say, what is the meaning of a final set of equations?

1366
01:21:24,090 --> 01:21:25,790
This gives you a meaning for it.

1367
01:21:25,790 --> 01:21:35,000
But in order to make an interactive system, where you can change the meaning of one thing without changing everything else, incrementally, you can't do that by implementing it this way.

1372
01:21:40,990 --> 01:21:41,860
Yes.

1373
01:21:41,860 --> 01:21:44,650
AUDIENCE: Another question on your danger slide.

1374
01:21:44,650 --> 01:21:50,300
It seemed that the two examples that you gave had to do with convergence and non-convergence?

1376
01:21:50,300 --> 01:22:05,430
And that may or may not have something to do with function theory in a way which would lead you to think of it in terms of linear systems, or non-linear systems. How does this convergence relate to being able to see a priori what properties of that might be violated?

1381
01:22:05,430 --> 01:22:07,680
PROFESSOR: I don't know.

1382
01:22:07,680 --> 01:22:10,610
The answer is, I don't know under what circumstances.

1383
01:22:10,610 --> 01:22:16,910
I don't know how to translate that into less than an hour of talk more.

1385
01:22:16,910 --> 01:22:22,720
What are the conditions under which, for which we know that these things converge?

1387
01:22:22,720 --> 01:22:32,810
And v, all that was telling you that arguments that are based on convergence are flaky if you don't know the convergence beforehand.

1390
01:22:32,810 --> 01:22:34,440
You can make wrong arguments.

1391
01:22:34,440 --> 01:22:40,690
You can make deductions, as if you know the answer, and not be stopped somewhere by some obvious contradiction.

1393
01:22:40,690 --> 01:23:03,020
AUDIENCE: So can we say then that if F is a convergent mathematical expression, then the recursion property can be-- PROFESSOR: Well, I think there's a technical kind of F, there is a technical description of those F's that have the property that when you iteratively apply them like this, you converge.

1400
01:23:03,020 --> 01:23:09,370
Things that are monotonic, and continuous, and I forgot what else.

1402
01:23:09,370 --> 01:23:13,430
There is a whole bunch of little conditions like that which have this property.

1404
01:23:13,430 --> 01:23:22,010
Now the real problem is deducing from looking at the F, its definition here, whether not it has those properties, and that's very hard.

1407
01:23:22,010 --> 01:23:23,280
The properties are easy.

1408
01:23:23,280 --> 01:23:24,580
You can write them down.

1409
01:23:24,580 --> 01:23:26,930
You can look in a book by Joe Stoy.

1410
01:23:26,930 --> 01:23:29,910
It's a great book-- Stoy.

1413
01:23:31,780 --> 01:23:41,800
It's called, The Scott-Strachey Method of Denotational Semantics, and it's by Joe Stoy, MIT Press.

1416
01:23:47,960 --> 01:23:51,880
And he works out all this in great detail, enough to horrify you.

1419
01:23:55,080 --> 01:23:56,330
But it really is readable.

1421
01:24:09,150 --> 01:24:11,490
OK, well, thank you.

1422
01:24:11,490 --> 01:24:13,780
Time for the bigger break, I suppose.

