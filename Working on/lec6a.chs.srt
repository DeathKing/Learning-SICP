1
00:00:18,550 --> 00:00:22,230
上次Gerry教授揭晓了秘密

2
00:00:22,230 --> 00:00:26,350
他介绍了赋值的概念

3
00:00:26,350 --> 00:00:33,405
赋值与状态

4
00:00:37,620 --> 00:00:45,350
正如我们所见，语言引入了赋值与状态，其含义是相当令人惊骇的

5
00:00:45,350 --> 00:00:48,865
首先，计算的代换模型失效了

6
00:00:48,865 --> 00:00:58,130
我们不得不使用更为复杂的环境模型和这种带图解的机械性的东西，甚至还要讲解声明编程语言中意味着什么

7
00:00:58,130 --> 00:01:00,260
这不仅仅是技术上的一点

8
00:01:00,260 --> 00:01:05,870
看，代换模型在这里完全失效了，我们得想些其它办法

9
00:01:05,870 --> 00:01:10,730
代换模型什么都做不了

10
00:01:10,730 --> 00:01:18,080
因为突然地，一个变量不仅仅代表着一个值了

11
00:01:18,080 --> 00:01:23,630
变量现在用来指定一个存放值的位置

12
00:01:23,630 --> 00:01:25,885
并且在这个位置的值是可以变的

13
00:01:30,280 --> 00:01:40,410
比如像 (f x) 这个表达式就可能有副作用

14
00:01:40,410 --> 00:01:49,730
如果我们执行(f x)得到某些值，之后我们再次执行(f x)，可能因为执行顺序的关系而得到不同的值

15
00:01:49,730 --> 00:01:54,030
所以突然间，我们不能仅仅关注于值，也要开始关注时间

16
00:01:57,970 --> 00:02:02,520
序对也不仅仅只是CAR和CDR了

17
00:02:02,520 --> 00:02:08,449
序对不仅是它的CAR和CDR，更是它的“同一”

18
00:02:08,449 --> 00:02:11,650
所以一个序对有“同一”

19
00:02:11,650 --> 00:02:12,900
它是一个对象

20
00:02:21,330 --> 00:02:30,900
两个CAR与CDR相同的序对可能相同也可能不同，因为我们必须关注“共享”

21
00:02:34,960 --> 00:02:40,480
一引入赋值。这些都变成要考虑的问题了

22
00:02:40,480 --> 00:02:45,400
确实，这和我们说讲代换的时候差别悬殊

23
00:02:45,400 --> 00:02:53,540
技术角度来看，我们必须相加机械的思考程序语言，因此看待事情也变得更加困难

24
00:02:53,540 --> 00:02:55,960
我们还不能仅仅用数学的方式来思考

25
00:02:55,960 --> 00:03:04,050
哲学上也很难理解，什么是事物的改变？两个事物是否相同？我们突然要开始思考这类问题

26
00:03:04,050 --> 00:03:18,210
并且，编程也更加困难，正如Gerry上次演示的，会有很多由于别名与顺序引发的bug，对于不考虑对象的语言，这些问题是绝对不会出现的

27
00:03:18,210 --> 00:03:23,635
我们是怎样陷入这样的困境的呢？

28
00:03:23,635 --> 00:03:42,760
想想我们之前所做的，原因就在于我们想要构造模块化的系统，而且这些模块的划分是很自然的

29
00:03:42,760 --> 00:04:06,980
举例来说，我们构造一个随机数生成器并打包生成器的状态，所以我们可以把求随机数的计算过程与蒙特卡罗方法相分离，与那个用随机数求Pi的计算过程相分离

30
00:04:06,980 --> 00:04:24,900
相似地，如果我们动身去构建一个现实世界的模型，我们就想要程序自然的分成很多部分，每一部分各自代表着我们在现实世界所看到的事物

31
00:04:24,900 --> 00:04:35,160
举个例子，看到一个电子电路，我们可能会说，哇，这有一个电路板，它有一个这样的元件，有一个那样的元件

32
00:04:40,100 --> 00:04:43,580
这些元件在某种程度上都有“同一”

33
00:04:43,580 --> 00:04:45,550
它们都有各自的状态

34
00:04:45,550 --> 00:04:48,580
状态附着在电路上

35
00:04:48,580 --> 00:04:52,610
我们把这个元件看作一个不同于其它对象的对象

36
00:04:52,610 --> 00:05:02,170
当系统发生变化，我们想着，信号从这里过来，可能在这里改变了一个状态，信号又到了那里，和一个存储在那里的状态相互作用，等等

37
00:05:06,860 --> 00:05:23,365
所以我们在做的是构建一个如实映射现实的电脑系统，每一部分都与现实的某一部分相对应，用这样的方法来构建的话，系统便很容易的分成模块

38
00:05:23,365 --> 00:05:33,610
这样来构造系统的原因是想说明
介绍如此复杂的技术与计算机本身没有什么关系

39
00:05:33,610 --> 00:05:44,550
看到了吧，我们付出了这么大的代价来编写映射现实世界的程序，却因为我们错误的认知现实而失败

40
00:05:44,550 --> 00:05:50,150
或许时间只是错觉，什么都没有改变

41
00:05:50,150 --> 00:05:55,820
举例来说，我拿起这个粉笔，我们会想，哦，这是一个对象，它有自己的状态

42
00:05:55,820 --> 00:05:59,710
每时每刻，它都有一个位置与速度

43
00:05:59,710 --> 00:06:01,240
如果我们做点什么，就可以改变它的状态

44
00:06:04,340 --> 00:06:11,340
但是你如果了解一点相对性的概念，你可能不会认为粉笔的路径是某种东西随着时间运动而形成的

45
00:06:11,340 --> 00:06:16,020
把整个粉笔的存在认为是时空中的路径，这是很有洞察力的

46
00:06:16,020 --> 00:06:18,040
全部都展开了

47
00:06:18,040 --> 00:06:19,840
没有单独的位置与速度

48
00:06:19,840 --> 00:06:24,640
只有在时空中不变的存在

49
00:06:24,640 --> 00:06:41,490
相似地，如果我们想象这些电子系统是一个信号处理系统，组合这个系统的工程师可不会这样想，“哦，每个瞬间有一个电压过来，

50
00:06:41,490 --> 00:06:43,340
转换成了某种东西，

51
00:06:43,340 --> 00:06:46,810
影响了这里的状态，还改变了那里的状态”

52
00:06:46,810 --> 00:06:50,420
没有一个做信号处理的会这样想

53
00:06:50,420 --> 00:06:58,060
相反，你说这里有一个在时间上伸展的信号

54
00:06:58,060 --> 00:07:09,570
如果有一个滤波器，就会把整个信号变成整个完全不同的输出信号

55
00:07:09,570 --> 00:07:14,160
你不必考虑在某个时间点上事物的状态

56
00:07:14,160 --> 00:07:22,230
以某种方式，把这个盒子作为完整的东西，而不是在某些个特定时间的状态的集合

57
00:07:28,250 --> 00:07:41,130
好的，今天我们就从信号处理工程师的角度而不是之前以对象思考的角度来分解系统

58
00:07:41,130 --> 00:07:43,310
它被称为“流处理”

59
00:07:54,570 --> 00:08:17,210
我们打算展示如何使那些对时间过度关注的程序更具统一性，而且可以从中看到很多的共性

60
00:08:17,210 --> 00:08:19,910
我们来对比这两个过程

61
00:08:23,260 --> 00:08:25,690
第一个是这样

62
00:08:25,690 --> 00:08:27,770
想像这有一个树

63
00:08:30,400 --> 00:08:33,179
一个自然数的树

64
00:08:33,179 --> 00:08:34,429
还是一个二叉树

65
00:08:39,100 --> 00:08:40,230
看起来就像这样

66
00:08:40,230 --> 00:08:44,990
在每个结点上都有一个数

67
00:08:44,990 --> 00:08:57,210
我们想计算的是，对这个树中所有的奇数，计算它们的平方和

68
00:08:57,210 --> 00:08:59,480
看起来很熟悉

69
00:08:59,480 --> 00:09:02,930
这里我们用递归的方式来计算

70
00:09:02,930 --> 00:09:08,680
观察每个叶子结点，如果是奇数我们求它的平方，如果是偶数我们不需要，也就是0

71
00:09:08,680 --> 00:09:17,640
递归求解，我们知道 一棵树的解 = 左子树的解 + 右子树的解，就这样递归下去

72
00:09:17,640 --> 00:09:20,360
这种思考方式我们已经很熟悉了

73
00:09:20,360 --> 00:09:23,960
我们来看看幻灯片

74
00:09:23,960 --> 00:09:37,160
计算一棵树的奇数平方和，这里有一个判断，是否是一个叶子结点，断而判断是否是一个奇数，然后我们计算它的平方，否则就取0

75
00:09:37,160 --> 00:09:42,120
然后，整个的解就是左、右子树解的总和

76
00:09:46,340 --> 00:09:51,560
好的，现在我们对比第二个问题

77
00:09:51,560 --> 00:09:59,270
假如给你一个整数n，还有一些函数来计算每一个从1到n的数

78
00:09:59,270 --> 00:10:05,600
然后我想把那些所有满足特定属性的值收集到一个列表中

79
00:10:05,600 --> 00:10:06,880
这是一个广泛的概述

80
00:10:06,880 --> 00:10:14,210
说的更具体一点，假如对于每个整数k，计算第k个斐波那契数

81
00:10:14,210 --> 00:10:19,050
然后挑出其中的奇数并把它们放入一个列表

82
00:10:19,050 --> 00:10:20,710
这个过程是这样的

83
00:10:23,730 --> 00:10:26,240
寻找n个斐波那契数中的奇数

84
00:10:26,240 --> 00:10:28,910
这里是一个循环的标准写法

85
00:10:28,910 --> 00:10:30,800
一个递归

86
00:10:30,800 --> 00:10:40,370
一个循环，参数是k，如果k大于n，返回空列表；否则计算第k个斐波那契数，称它为f

87
00:10:40,370 --> 00:10:47,690
如果是奇数，我们把它与从k+1计算得到的列表相连接

88
00:10:47,690 --> 00:10:50,390
否则，我们只取从k+1计算得到的结果

89
00:10:50,390 --> 00:10:53,000
这是迭代式循环的标准写法

90
00:10:53,000 --> 00:10:57,600
我们以1为参数开始这个循环

91
00:10:57,600 --> 00:11:01,600
好的，这就是这两个过程

92
00:11:01,600 --> 00:11:02,900
直观来看，它们两个没有什么共同点

93
00:11:02,900 --> 00:11:04,390
结构完全不同

94
00:11:04,390 --> 00:11:11,330
但是从一个特定的角度来看，两个过程做的事情是一样的

95
00:11:11,330 --> 00:11:26,980
如果我是一个信号处理工程师，我可能会说，第一个过程枚举了树叶结点

96
00:11:31,160 --> 00:11:35,330
可以认为是一个全部是树叶结点的信号从这里输出

97
00:11:35,330 --> 00:11:45,190
然后把信号导入某个过滤器，过滤出其中的奇数

98
00:11:45,190 --> 00:11:49,000
通过这样的一个变换器

99
00:11:49,000 --> 00:11:51,420
对每一个输出，我们对其取平方

100
00:11:54,200 --> 00:11:58,290
最后把结果累积在一起

101
00:11:58,290 --> 00:12:03,340
我们通过从0开始的加法来累计它们

102
00:12:07,140 --> 00:12:08,210
这是第一个程序

103
00:12:08,210 --> 00:12:11,780
第二个程序，也可以用一个非常非常相似的方法来描述

104
00:12:11,780 --> 00:12:19,080
枚举了从1到n的所有整数

105
00:12:22,500 --> 00:12:29,270
对于每个数，计算斐波那契数，通过一个转换器

106
00:12:29,270 --> 00:12:35,976
对于输出的结果，再通过奇偶性进行过滤

107
00:12:35,976 --> 00:12:39,350
最后，我们将这些放入累积器

108
00:12:39,350 --> 00:12:47,110
这里我们累积出一个列表，传递CONS方法，与空列表作为参数

109
00:12:47,110 --> 00:12:51,900
从这个角度来看，这两个程序真的是太相似了

110
00:12:51,900 --> 00:12:58,050
问题在于两个程序的写法导致我们看不出其中的共性

111
00:12:58,050 --> 00:13:06,300
我们回头再来看第一个奇数平方和的问题，问题来了，枚举器是什么？

112
00:13:06,300 --> 00:13:08,140
程序中哪一部分有枚举的作用？

113
00:13:08,140 --> 00:13:11,230
枚举不是仅仅在一个地方表现出来的

114
00:13:11,230 --> 00:13:17,160
在叶子结点的判断处存在一部分

115
00:13:17,160 --> 00:13:20,630
也下面的递归结构中也有体现

116
00:13:23,150 --> 00:13:24,120
累积器又在哪儿呢？

117
00:13:24,120 --> 00:13:25,680
和枚举器类似，也不是在一个地方

118
00:13:25,680 --> 00:13:32,180
它由 0 和 + 这两个地方体现出来

119
00:13:32,180 --> 00:13:34,510
累积器的完整过程并不体在唯一一个地方

120
00:13:34,510 --> 00:13:44,470
相似地，我们来观察奇数斐波那契数的例子，程序中也存在枚举器与累积器的含义，但是有些不同

121
00:13:44,470 --> 00:13:55,680
枚举的含义部分的表现在 ( > k n) 的判断中，部分的表现在下面的递归调用中

122
00:13:55,680 --> 00:14:03,600
同样地，累积的含义也被混杂在其中，比如在这里和那里

123
00:14:03,600 --> 00:14:14,360
我们之前所画出的盒子在我们的程序中完全看不出来，因为它们混杂在一起了

124
00:14:14,360 --> 00:14:16,290
因此，这些程序并没有很好的对问题进行划分

125
00:14:19,450 --> 00:14:31,060
回到计算机科学的基本原理上来，为了控制某种东西，你需要给它命名，即使我们如此思考，我们也并没有完全地控制住它，因为我们没有明确地深入它的内部

126
00:14:31,060 --> 00:14:35,510
我们没有一个好的语言来说明

127
00:14:35,510 --> 00:14:44,515
好吧，我们来发明合适的语言来构造这些部分

128
00:14:44,515 --> 00:14:50,480
这种语言的关键在于 这些叫作信号的东西到底是什么？

129
00:14:50,480 --> 00:14:53,320
这些沿着箭头传递的又是什么？

130
00:14:56,880 --> 00:15:07,980
直接说明吧，这些东西将变成一种叫做流的数据结构，也是发明这个语言的关键

131
00:15:07,980 --> 00:15:08,600
什么是流呢？

132
00:15:08,600 --> 00:15:12,220
流，和其它的相似，是一种数据抽象

133
00:15:12,220 --> 00:15:16,870
所以，我先说明它的选择器与构造器分别是什么

134
00:15:16,870 --> 00:15:21,435
构造器我们称其为CONS-stream

135
00:15:25,690 --> 00:15:32,040
CONS-stream把两个事物放在一起构造出一个流

136
00:15:32,040 --> 00:15:38,010
选择器叫作HEAD，用于从流中提取数据

137
00:15:38,010 --> 00:15:44,720
可以提取head，也要可以提取tail

138
00:15:44,720 --> 00:15:53,160
我把我和George的约定告诉你，是想让你明确到底是什么相关的法则

139
00:15:53,160 --> 00:16:28,440
对于任何的x与y，(HEAD (CONS-STREAM x y)) => x，(TAIL (CONS-STREAM)) => y

140
00:16:28,440 --> 00:16:34,750
一个构造函数，两个选择函数，一个法则，就是这些

141
00:16:34,750 --> 00:16:36,980
这里有点可疑

142
00:16:36,980 --> 00:16:52,810
你可能注意到了这完全和CONS，CAR，CDR序对相关的法则完全一样啊，把CONS-STREAM换成CONS，HEAD换成CAR，TAIL换成CDR，就完全一样了

143
00:16:52,810 --> 00:16:55,130
事实上，还有另一个东西

144
00:16:55,130 --> 00:17:08,319
我们有一个叫空流的东西，像空列表

145
00:17:08,319 --> 00:17:10,030
为什么我要介绍这个术语呢？

146
00:17:10,030 --> 00:17:12,780
为什么我不直接说序对与列表呢？

147
00:17:12,780 --> 00:17:15,510
好吧，我们将会看到

148
00:17:15,510 --> 00:17:21,560
暂时地，如果你喜欢，为什么不把流假装作列表的另一种术语

149
00:17:21,560 --> 00:17:28,150
一会儿我们就知道了为什么我们需要这样的抽象而不是仅仅把它叫做列表

150
00:17:32,300 --> 00:17:42,120
好的，有了流之后，我们开始构建操作流的语言，有太多有用的东西了

151
00:17:42,120 --> 00:18:05,666
举例来说，我们构建自己的map-stream，以一个流s和一个过程作为参数，生成一个新的流，其中这个过程应用于所有s的后继节点

152
00:18:05,666 --> 00:18:07,400
我们以前见过类似的

153
00:18:07,400 --> 00:18:10,950
就是我们以前操作列表的map

154
00:18:10,950 --> 00:18:14,650
除了判断empty-stream的部分，完全就和map一样

155
00:18:14,650 --> 00:18:15,560
哦，我忘了说了

156
00:18:15,560 --> 00:18:20,510
empty-stream?就和null?差不多，如果是空的，就生成一个空的流

157
00:18:20,510 --> 00:18:33,140
否则，就生成一个新的流，第一个元素是过程作用于流的HEAD的值，剩下的是map-stream对流的TAIL作用的结果

158
00:18:33,140 --> 00:18:37,030
看起来着实太像我们之前所讲的map了

159
00:18:37,030 --> 00:18:38,350
还有另一件事

160
00:18:38,350 --> 00:18:40,460
过滤器，就是那个用来过滤的盒子

161
00:18:40,460 --> 00:18:43,890
以一个谓词和一个流作为参数

162
00:18:43,890 --> 00:18:50,160
生成一个新的流，包含了所有在流s中满足谓词pred的元素

163
00:18:50,160 --> 00:18:51,270
分条件来看

164
00:18:51,270 --> 00:18:56,280
当流s是空的，就返回一个空流

165
00:18:56,280 --> 00:19:00,060
这里，用谓词来判断流的头元素

166
00:19:00,060 --> 00:19:08,220
如果为真，就把这个元素和过滤流的尾元素得到的结果连接在一起

167
00:19:08,220 --> 00:19:13,500
否则，如果谓词判断为假，就只返回过滤流的尾元素的结果

168
00:19:13,500 --> 00:19:16,595
这就是过滤器的原理

169
00:19:16,595 --> 00:19:18,560
剩下的我快速过一遍

170
00:19:18,560 --> 00:19:20,880
这些在书上都有，下去可以自己看

171
00:19:20,880 --> 00:19:22,110
来马上过一遍

172
00:19:22,110 --> 00:19:23,260
过程accumulate

173
00:19:23,260 --> 00:19:31,560
accumulate以一种连接事物的方式，将初始值和流粘合在一起

174
00:19:31,560 --> 00:19:33,970
如果流为空，返回初始值

175
00:19:33,970 --> 00:19:40,900
否则，就连接流的头和accumulate流的尾的结果

176
00:19:40,900 --> 00:19:42,830
这就是我把事物累积在一起的方法

177
00:19:42,830 --> 00:19:45,830
用加法来累积

178
00:19:45,830 --> 00:19:48,060
如何枚举树上的叶子节点呢？

179
00:19:48,060 --> 00:19:56,640
如果这个树只是一个叶子节点，我就构造一个只是一个叶子节点的树

180
00:19:56,640 --> 00:20:04,340
否则，就把左、右子树枚举的结果合并起来

181
00:20:04,340 --> 00:20:08,130
就像之前对列表的操作一样

182
00:20:13,190 --> 00:20:13,850
再来看这个

183
00:20:13,850 --> 00:20:19,150
和合并两个列表的操作太相似了

184
00:20:19,150 --> 00:20:21,810
如何枚举整数呢？

185
00:20:21,810 --> 00:20:28,106
两个参数，一个小的一个大的，生成一个包含从小到大所有整数的流

186
00:20:28,106 --> 00:20:31,890
由此，我们就可以构造这一整串的元件

187
00:20:31,890 --> 00:20:37,670
这就是我们说的用来操作流的语言，当我们有了流，就可以用操纵它们来做点事情

188
00:20:37,670 --> 00:20:40,200
又一次地，我们构建了新的语言

189
00:20:40,200 --> 00:20:43,060
现在，就用这种语言来描述上面的东西

190
00:20:43,060 --> 00:20:47,310
这是累加奇数平方的过程

191
00:20:47,310 --> 00:20:54,590
你会发现，看起来完全和用信号处理画出的块状图相吻合

192
00:20:54,590 --> 00:21:01,320
要计算树上奇数平方和，先枚举树上的叶子结点

193
00:21:01,320 --> 00:21:04,830
过滤出奇数

194
00:21:04,830 --> 00:21:06,220
用平方来映射

195
00:21:09,320 --> 00:21:14,760
最后用加法来累积，初始值是0

196
00:21:14,760 --> 00:21:17,290
这就是我们想要的

197
00:21:17,290 --> 00:21:22,050
求奇数婓波那契数，和这个是相似地

198
00:21:22,050 --> 00:21:30,920
从1到n枚举整数，用计算婓波那契数的过程作映射

199
00:21:30,920 --> 00:21:34,810
过滤出奇数的部分

200
00:21:34,810 --> 00:21:43,650
最后用CONS连接起来，初始值是空列表

201
00:21:43,650 --> 00:21:47,680
大功告成，这么做有什么优势呢？

202
00:21:47,680 --> 00:21:51,880
先是，这些构造出的元件可以随意的混合搭配

203
00:21:51,880 --> 00:22:06,210
举个例子，如果我把这里改变一下，想要计算整数的平方再进行过滤，我只需要简单的拿一个像square的元件放在这里就行

204
00:22:06,210 --> 00:22:18,030
或者，我想计算整个树上的婓波那契数而不是树叶结点的序列，只需要替换这个枚举器

205
00:22:18,030 --> 00:22:38,130
看，流处理的优势是，我们建立了 -- 这是课程中一个相对大一些的课题 -- 我们构造了合理的接口，还可以随意粘合起来

206
00:22:38,130 --> 00:22:45,750
像这样如map和filter的标准组件，我们可以拿过来随意组合去构造程序

207
00:22:45,750 --> 00:22:50,090
还可以看到程序的共性

208
00:22:50,090 --> 00:22:53,860
我应该说一下，现在仅仅展示了两个过程而已

209
00:22:53,860 --> 00:23:01,410
强调一下，像这种把map，filter，accumulate组合起来构建程序的方式是非常非常通用的

210
00:23:01,410 --> 00:23:30,710
这是生成和测试程序的范式。举例来看，Richarc Waters，MIT的毕业生，开展过一项研究，他分析了IBM的科学计算程序库，发现其中60%的部分都可以用这样的范式来准确的表示出来，而且只用map，filter，accumulate这三个东西

211
00:23:30,710 --> 00:23:31,960
好，让我们休息一会

212
00:23:36,620 --> 00:23:37,870
有问题吗？

213
00:23:40,470 --> 00:23:48,380
整件事情的本质好像只是因为你用了一个统一、简单的数据结构 -- 流

214
00:23:48,380 --> 00:23:48,920
嗯啊

215
00:23:48,920 --> 00:23:53,710
本质应该是，那些约定接口的定义 

216
00:23:53,710 --> 00:23:55,610
然后才可以把东西组合起来

217
00:23:55,610 --> 00:24:00,890
流只是，就像你说的，只是一种可以支持那样统一操作的数据结构而已

218
00:24:00,890 --> 00:24:03,600
从某种程度来看，这非常像APL

219
00:24:03,600 --> 00:24:09,560
APL有着相似的思想，除了在APL中，你可以不用流，用数组和向量也是可以的

220
00:24:09,560 --> 00:24:14,815
而且APL的威力就在于此

221
00:24:19,910 --> 00:24:20,910
明白了，谢谢

222
00:24:20,910 --> 00:24:22,160
休息一下

223
00:24:57,470 --> 00:24:57,610
好的

224
00:24:57,610 --> 00:25:10,810
我们已经见识过了如何用流来组织计算过程。下面我再举一些更复杂的例子

225
00:25:10,810 --> 00:25:16,810
我们来思考一下这样一种有用的过程

226
00:25:16,810 --> 00:25:19,960
假如我有一个流

227
00:25:19,960 --> 00:25:23,730
流中的元素本身就是一个流

228
00:25:23,730 --> 00:25:26,530
一开始是1，2，3

229
00:25:32,600 --> 00:25:33,880
就是这个流

230
00:25:33,880 --> 00:25:40,100
流中的元素也是一个流

231
00:25:40,100 --> 00:25:52,080
现在我想用一个流把其中的所有元素都聚集在一起，即把所有元素从子流中提取出来最后放在一起

232
00:25:52,080 --> 00:25:56,960
只是想给你们展示一下这个语言其它的使用方式，很简单，把这个过程叫做flatten

233
00:25:56,960 --> 00:26:13,960
现在来定义这个过程，去flatten流中的子流，这是到底是什么？

234
00:26:13,960 --> 00:26:16,240
也就是一个累积的过程

235
00:26:16,240 --> 00:26:26,450
我想用append来做累积，连接地累积

236
00:26:26,450 --> 00:26:54,370
APPEND-STREAM作为组合过程，THE-EMPTY-STREAM为初始值，累积这个流

237
00:26:54,370 --> 00:27:00,830
这就是一个明显的例子，你可以用高阶的东西去做更有趣的事情

238
00:27:00,830 --> 00:27:05,100
事实上，还有另外有用的东西

239
00:27:05,100 --> 00:27:21,840
定义一个过程flat-map，以一个过程和一个流作为参数

240
00:27:21,840 --> 00:27:25,720
And what this is going to do is f will be a stream of elements.

241
00:27:25,720 --> 00:27:31,950
f是一个过程，它操作一个流，生成另一个流

242
00:27:31,950 --> 00:27:36,000
我要做的是把所有的元素和所有的流合并起来

243
00:27:36,000 --> 00:27:51,350
所以就是 (FLATTEN (MAP F S))

244
00:27:51,350 --> 00:27:54,290
每次我调用F，就得到另一个流

245
00:27:54,290 --> 00:27:58,385
如果用F来映射S中的子流，我就得到另一个“流的流”，然后再进行flatten

246
00:27:58,385 --> 00:28:06,360
好的，我想再使用这种方式来解决另一个大家很熟悉的问题

247
00:28:06,360 --> 00:28:14,190
这个问题和你以前看到过的许多问题一样，尽管不是很特别

248
00:28:14,190 --> 00:28:15,490
一个整数n

249
00:28:18,480 --> 00:28:51,910
找出所有的序对 ( i j )，0 < j < i <= n，并且 i + j 是一个质数

250
00:28:55,740 --> 00:29:06,640
如果 n = 6，画一个小表格，这里 i，j，i + j

251
00:29:09,700 --> 00:29:15,520
I = 2，J = 1，I + J就是3

252
00:29:15,520 --> 00:29:21,210
然后 I = 3，J = 2，I + J就是5

253
00:29:21,210 --> 00:29:28,400
4，1，5也是一样的，等等，直到 I 到了6

254
00:29:28,400 --> 00:29:37,350
我想要这个过程返回的是由这样的 I J I+J 三元组组成的流

255
00:29:37,350 --> 00:29:41,530
对于整数n，我想得到一个这样流

256
00:29:41,530 --> 00:29:43,680
好的，听起来很简单

257
00:29:43,680 --> 00:29:47,230
开始做做看

258
00:29:47,230 --> 00:29:50,150
先这样开始

259
00:29:50,150 --> 00:29:56,440
对于每一个整数 I，生成一个流

260
00:29:56,440 --> 00:30:00,660
i 从 1 取到 n，每个 i 都生成一个流

261
00:30:00,660 --> 00:30:02,230
这个流将会是什么样子？

262
00:30:02,230 --> 00:30:04,180
先从生成所有的开始

263
00:30:04,180 --> 00:30:20,710
对于每个 i 来说，生成的结果是这样的：对于整数 j，1 <= j <= i - 1，生成 (i j) 的序对

264
00:30:23,780 --> 00:30:30,712
对于 j 的每个取值，都生成一个序对

265
00:30:30,712 --> 00:30:33,170
对于每个 i，都生成一个序对的流

266
00:30:33,170 --> 00:30:34,590
最后进行flatmap

267
00:30:34,590 --> 00:30:38,730
现在，我们就得到了所有满足要求的序对了

268
00:30:38,730 --> 00:30:39,850
就是这样

269
00:30:39,850 --> 00:30:42,990
来测试一下

270
00:30:42,990 --> 00:30:51,660
刚才flatmap得到的结果，进行过滤

271
00:30:51,660 --> 00:31:02,070
i 是列表第一个元素，j 是第二个，这里的谓词用来检测 i + j 的值是否是质数

272
00:31:02,070 --> 00:31:06,540
用这个lambda对所有的序对进行过滤

273
00:31:06,540 --> 00:31:09,420
剩下的就是我们想要的

274
00:31:09,420 --> 00:31:19,610
然后我们继续，把过滤得到的结果再次进行map操作，得到 i j i+j 的三元组

275
00:31:19,610 --> 00:31:22,910
这就是过程 prime-sum-pairs

276
00:31:22,910 --> 00:31:24,480
最后只需要过一遍，这就是整个过程

277
00:31:27,945 --> 00:31:30,750
一个map，一个filter，一个flatmap

278
00:31:34,850 --> 00:31:37,120
所有的东西都在这里了，尽管看起来可读性不是那么好

279
00:31:37,120 --> 00:31:40,000
这只是flatmap的一个延伸

280
00:31:40,000 --> 00:31:54,200
这个例子很好的体现了嵌套循环的要点。看起来就像map的flatmap的flatmap的flatmap

281
00:31:54,200 --> 00:32:03,230
所以我们不仅仅枚举单个个体，还要通过使用flatmap，达到像其它语言中嵌套循环的效果

282
00:32:03,230 --> 00:32:08,410
当然，一直写这些flatmap很烦人

283
00:32:08,410 --> 00:32:15,480
尽管prime-sum-pairs其中单独的部分很容易，但整体看起来还是十分复杂

284
00:32:15,480 --> 00:32:21,040
如果你喜欢，可以引进一个叫collect的语法糖

285
00:32:21,040 --> 00:32:26,160
collect只是一个对嵌套flatmap的缩写

286
00:32:26,160 --> 00:32:29,620
这里我们用collect把prime-sum-pairs写一遍

287
00:32:29,620 --> 00:32:58,040
它的意思是这样，我想collect这样的结果，元素以 i j i+j 三元组的形式，i 从1到n，j 从1到i-1，还要满足 i+j 是质数

288
00:32:58,040 --> 00:33:00,690
我可以认为这个collect过程是通用的

289
00:33:00,690 --> 00:33:03,420
你可以在书上找到它的详细定义

290
00:33:03,420 --> 00:33:08,820
当然，你可以把这个元件看作和以前的元件一样

291
00:33:08,820 --> 00:33:16,310
collect这个过程不过是一个可以自动生成嵌套flatmap的语法糖罢了

292
00:33:16,310 --> 00:33:22,120
好的，我们再来看另一个例子

293
00:33:22,120 --> 00:33:30,200
这是一个十分出名的例子，经常用来演示回溯算法，就是“八皇后问题”

294
00:33:30,200 --> 00:33:32,370
这是一个棋盘

295
00:33:32,370 --> 00:33:38,000
八皇后问题是说，找到一种放置皇后的方式，使得任意的两个皇后不会相互攻击

296
00:33:38,000 --> 00:33:41,430
这是一个解

297
00:33:41,430 --> 00:33:51,410
使得任意两个皇后不在同一行，同一列而且不在同一对角线上

298
00:33:51,410 --> 00:33:56,400
有一个解决这个问题的标准解法

299
00:33:59,740 --> 00:34:04,940
首先我们要做是，站在George的层面

300
00:34:04,940 --> 00:34:08,095
找到一种表示棋盘与位置的方式

301
00:34:08,095 --> 00:34:09,800
这个并不需要太担心

302
00:34:09,800 --> 00:34:12,540
假设我们有一个谓词safe

303
00:34:16,040 --> 00:34:25,400
safe要做的是，假如一些皇后已经放在棋盘上，判断在另一个点再放置一个皇后是否是安全的？

304
00:34:25,400 --> 00:34:32,889
safe的参数，一个row，一个column

305
00:34:32,889 --> 00:34:42,370
那将是我尝试放下一个皇后的地方和剩下的位置

306
00:34:45,420 --> 00:34:58,300
safe要判断的是在剩下的皇后已经放置的情况下，再放置一个皇后是否是安全的

307
00:34:58,300 --> 00:34:59,360
不用过分深究这个

308
00:34:59,360 --> 00:35:01,380
那是George的问题，也不难写出来

309
00:35:01,380 --> 00:35:10,530
只需要检测行，列，对角线而已

310
00:35:10,530 --> 00:35:13,590
嗯，那这个程序要怎么组织呢？

311
00:35:13,590 --> 00:35:20,116
有一种经典的方式，我们称为“回溯”

312
00:35:20,116 --> 00:35:31,290
它说的是这个，考虑把第一个皇后放在第一列的方式

313
00:35:31,290 --> 00:35:32,580
有8种

314
00:35:32,580 --> 00:35:35,880
试一下第一个

315
00:35:35,880 --> 00:35:37,300
第一行第一列

316
00:35:37,300 --> 00:35:43,360
分支表示了每一层所有的可能性

317
00:35:43,360 --> 00:35:45,875
我试着把皇后放在第一列

318
00:35:45,875 --> 00:35:49,980
好的，已经放下了，现在就在这个基础上放置第二列的皇后

319
00:35:53,035 --> 00:35:56,920
我试试把第一个皇后，在第一列上的那个皇后，放在第一行

320
00:35:56,920 --> 00:35:59,050
不好意思

321
00:35:59,050 --> 00:36:01,390
然后，把第二个皇后也放在第一行

322
00:36:01,390 --> 00:36:02,090
这不行

323
00:36:02,090 --> 00:36:04,200
所以又回到这里

324
00:36:04,200 --> 00:36:07,510
然后，我们把这个皇后放在第二行吗？

325
00:36:07,510 --> 00:36:08,550
对角线冲突了，也不好

326
00:36:08,550 --> 00:36:09,760
第三行怎么样？

327
00:36:09,760 --> 00:36:12,790
这样可以

328
00:36:12,790 --> 00:36:15,380
下一个皇后可以放在第一行吗？

329
00:36:15,380 --> 00:36:19,195
我不再想像更多的棋盘，假设这是对的

330
00:36:19,195 --> 00:36:20,450
我就尝试下一个

331
00:36:20,450 --> 00:36:24,170
在每一个地方，尽可能的沿着树往下

332
00:36:24,170 --> 00:36:25,640
然后倒退

333
00:36:25,640 --> 00:36:33,260
如果到了这里，不能再往下了，就回到这里，生成这个子树

334
00:36:33,260 --> 00:36:35,050
绕来绕去

335
00:36:35,050 --> 00:36:40,090
最后，一路求解下来，就会得到答案

336
00:36:40,090 --> 00:36:45,930
这是以前人工智能编程的经典范式

337
00:36:45,930 --> 00:36:47,300
回溯查找

338
00:36:57,470 --> 00:37:03,860
这真的没有必要

339
00:37:03,860 --> 00:37:06,550
当我想像这个东西时感到很疑惑

340
00:37:06,550 --> 00:37:08,550
你也看到了，这很复杂

341
00:37:08,550 --> 00:37:10,760
而且这种复杂还很难描述

342
00:37:10,760 --> 00:37:12,390
为什么会这样？

343
00:37:12,390 --> 00:37:18,580
程序太费时间了

344
00:37:18,580 --> 00:37:22,320
耗时太长了，试试那个，试试这个，又回来，直到没有其它可能性

345
00:37:22,320 --> 00:37:24,340
很复杂

346
00:37:24,340 --> 00:37:31,200
如果我不担心时间，就有一个更简单的方式来描述

347
00:37:31,200 --> 00:37:43,400
假设我有一个k-1层的树

348
00:37:43,400 --> 00:37:53,560
现在，我需要去找到在第k列放置皇后的所有方式

349
00:37:53,560 --> 00:37:54,610
假设是这样

350
00:37:54,610 --> 00:37:57,070
不要担心我是怎么得到的

351
00:37:57,070 --> 00:37:59,200
现在，如果扩充下去呢？

352
00:37:59,200 --> 00:38:02,480
怎样找到所有在下一列中放皇后的可能性呢？

353
00:38:02,480 --> 00:38:03,620
很简单

354
00:38:03,620 --> 00:38:16,160
对于已有的位置，把下个皇后放在每一行上

355
00:38:16,160 --> 00:38:22,080
然后，把所有放置的位置，用safe进行过滤

356
00:38:22,080 --> 00:38:26,860
不像之前那样，把树的生成一步一步想的那么清楚，假设树已经生成了

357
00:38:29,680 --> 00:38:37,800
为了从k-1层扩展到k层，需要尝试所有可能性最后保留安全的排列

358
00:38:37,800 --> 00:38:39,300
就得到一个k层树的结果

359
00:38:39,300 --> 00:38:44,530
这是一个解决八皇后的递归策略

360
00:38:44,530 --> 00:38:45,780
好的，我们来看看

361
00:38:50,280 --> 00:39:01,030
在特定大小的棋盘解决八皇后问题，我们写一个子过程 fill-columns

362
00:39:01,030 --> 00:39:06,086
这个过程把皇后一直放置到列k

363
00:39:06,086 --> 00:39:07,700
这是一个递归的模式

364
00:39:07,700 --> 00:39:12,990
最后用棋盘具体的大小作为参数来调用fill-columns

365
00:39:12,990 --> 00:39:20,360
fill-columns是用来说明如何在 k 列 size 行的棋盘上放置皇后

366
00:39:20,360 --> 00:39:23,940
如果k是0，就不用做什么

367
00:39:23,940 --> 00:39:26,710
结果是一个空的棋盘

368
00:39:26,710 --> 00:39:28,070
否则就做点别的

369
00:39:28,070 --> 00:39:30,522
这里将要使用collect

370
00:39:30,522 --> 00:39:31,772
这是collect

371
00:39:34,530 --> 00:39:41,910
我找到了所有在前k-1列中放皇后的方法

372
00:39:41,910 --> 00:39:43,320
这是我设置的

373
00:39:43,320 --> 00:39:48,880
想像这棵树下降直到k-1层

374
00:39:48,880 --> 00:39:54,130
然后我尝试每一行

375
00:39:54,130 --> 00:39:58,040
总行数就是size，枚举了所有行数

376
00:39:58,040 --> 00:40:08,950
现在要做的是，将第k列上所有的可能性与已经放置的皇后整合

377
00:40:08,950 --> 00:40:10,200
整合在一起

378
00:40:10,200 --> 00:40:11,290
这是George的问题了

379
00:40:11,290 --> 00:40:13,640
像safe一样

380
00:40:13,640 --> 00:40:19,660
我们要做的就是，拿一行，一列和剩下的位置，然后做一个新的位置集合

381
00:40:19,660 --> 00:40:34,620
我把第k列可放置的行的位置和剩下的皇后结合起来，而剩下的皇后都已经摆放好了

382
00:40:34,620 --> 00:40:43,240
新的行遍历了所有的可能性，过滤出安全的位置

383
00:40:43,240 --> 00:40:46,500
这就是整个程序了

384
00:40:46,500 --> 00:40:49,840
整个过程

385
00:40:49,840 --> 00:40:56,680
不只这样，不仅解决了八皇后问题，还顺便给出了所有的解

386
00:40:56,680 --> 00:40:58,480
运行结束之后，就得到一个流

387
00:40:58,480 --> 00:41:01,900
流中的元素是所有的解

388
00:41:05,310 --> 00:41:06,260
为什么这个更简单一点呢？

389
00:41:06,260 --> 00:41:12,720
我们已经描述了整个想法，它是一些在时间中发生，有状态的过程

390
00:41:12,720 --> 00:41:14,420
我们只说，这是这个东西的整个集合

391
00:41:14,420 --> 00:41:18,260
这就是更加简单的原因

392
00:41:18,260 --> 00:41:20,110
我们已经转变了观念

393
00:41:20,110 --> 00:41:22,820
记住，这就是我们的开始

394
00:41:22,820 --> 00:41:26,230
我们转变了建模的观念

395
00:41:26,230 --> 00:41:31,750
我们停止对那些随着时间变化的，有过程与状态的东西进行建模

396
00:41:31,750 --> 00:41:40,750
代为替代，我们对全局进行建模，就像粉笔飞行那样而不时关注其每一时刻的状态

397
00:41:40,750 --> 00:41:42,000
有什么问题吗？

398
00:41:43,810 --> 00:41:54,030
在我看来回溯会搜索到第一个解，而这个递归搜索却找到了所有的解

399
00:41:54,030 --> 00:42:01,360
如果搜索的空间足够的大，这样来搜索好像不太可能吧

400
00:42:01,360 --> 00:42:08,570
嗯，这个问题的答案是剩下的课要讲的内容

401
00:42:08,570 --> 00:42:10,540
很好的问题

402
00:42:13,522 --> 00:42:22,220
先不要尝试去预见后面的课，你应该对这个要点产生怀疑，这的确十分让人起疑

403
00:42:22,220 --> 00:42:24,830
尽管这个看起来不错，难道不低效吗？

404
00:42:24,830 --> 00:42:28,100
这就是用尝试另一种方式的原因

405
00:42:28,100 --> 00:42:30,020
因此这个问题之后我再回答

406
00:42:33,350 --> 00:42:34,600
好的，休息时间

407
00:43:29,650 --> 00:43:35,600
现在你应该也开始怀疑了

408
00:43:35,600 --> 00:43:53,740
我已经展示了这种简单优雅的组合程序的方法，不像那些传统的累积奇数或者计算奇数的斐波那契数

409
00:43:53,740 --> 00:44:00,440
也不像这些混合enumerator filter和accumulator的方法

410
00:44:00,440 --> 00:44:13,800
使用这种混合的方式来构建程序，我们并没有完全发挥流的这种概念性的优势

411
00:44:13,800 --> 00:44:18,340
另一方面，不这样来组合的其它的程序都很丑陋

412
00:44:18,340 --> 00:44:19,460
为什么会这样？

413
00:44:19,460 --> 00:44:33,620
可能是计算机科学家没有注意到 你只做了这件事就在编程上获得了难得的优雅性？

414
00:44:33,620 --> 00:44:36,760
肯定有什么窍门

415
00:44:36,760 --> 00:44:39,510
事实上这一窍门也很容易发现

416
00:44:39,510 --> 00:44:42,030
我们来看看接下来的这个问题

417
00:44:42,030 --> 00:44:54,105
假设我让你找到1,000到1,000,000这间的第二个素数，或者10,000到100,000,000的第二个素数或者什么之类的

418
00:44:54,105 --> 00:44:55,550
可能你想，这很容易

419
00:44:55,550 --> 00:44:57,080
我可以用流来解决

420
00:44:57,080 --> 00:45:04,160
我需要做的就是从10,000枚举到1,000,000

421
00:45:04,160 --> 00:45:06,800
从中挑出每一个数字

422
00:45:06,800 --> 00:45:11,762
用检测素数性的谓词来过滤全部的数

423
00:45:11,762 --> 00:45:13,170
取出其中的第二个，就是我们想要的

424
00:45:13,170 --> 00:45:16,130
正是TAIL的HEAD

425
00:45:16,130 --> 00:45:17,380
这看起来非常的荒谬

426
00:45:21,660 --> 00:45:27,040
我们的机器都没有这么大的空间来存放这些整数，更别说来检测它们了

427
00:45:27,040 --> 00:45:29,810
然后我只取其中的第二个

428
00:45:29,810 --> 00:45:45,090
看吧，这种组合enumerate，accumulate的编程方式很有威力，但也有弱点

429
00:45:45,090 --> 00:45:46,670
所以关键在于，我们不需要做所有的事

430
00:45:46,670 --> 00:45:55,210
这个在概念上更加丑陋的东西使它更高效了

431
00:45:55,210 --> 00:45:57,800
是这样来混合的

432
00:45:57,800 --> 00:46:00,420
我今天一早上所做的好像都是在迷惑你们一样

433
00:46:00,420 --> 00:46:05,840
我给你们展示了这种优雅的编程方式，除了这个不行

434
00:46:05,840 --> 00:46:09,040
不卖关子了，接下来，见证奇迹的时刻

435
00:46:09,040 --> 00:46:14,870
这个游戏里，我们有蛋糕，并且还可以吃它

436
00:46:14,870 --> 00:46:36,310
我的意思是，我们完全可以用流来这样的组织程序，当机器真正运行的时候，和那种生成与检测混合在一起的程序一样高效

437
00:46:36,310 --> 00:46:40,770
听起来不可思议

438
00:46:40,770 --> 00:46:43,690
关键在于，流不是列表

439
00:46:48,090 --> 00:46:52,115
一会儿我们就会看到，现在，先来看看幻灯片

440
00:46:52,115 --> 00:47:05,360
类比于信号处理系统，这个例子里是一些整数

441
00:47:05,360 --> 00:47:10,940
这里的filter和它连接在一起并且揪住了它们

442
00:47:10,940 --> 00:47:16,790
这里可以放置另外的东西来揪住filter的输出

443
00:47:16,790 --> 00:47:24,590
想像这样的图景，有人想要得到第一个质数，从filter中揪出来

444
00:47:24,590 --> 00:47:28,020
filter相继地去揪出一个整数来计算

445
00:47:28,020 --> 00:47:30,930
看完这些之后，然后想，哦，想要第二个质数

446
00:47:30,930 --> 00:47:33,710
第二个是什么？

447
00:47:33,710 --> 00:47:40,500
当你不去尝试揪出东西时，就不会有计算发生

448
00:47:40,500 --> 00:47:41,410
我们再来试试

449
00:47:41,410 --> 00:47:43,815
这是一个小设备

450
00:47:43,815 --> 00:47:49,830
Eric Grimson发明的，他曾经也在MIT教这门课

451
00:47:49,830 --> 00:47:54,780
把这个比作流，就像一串整数一样

452
00:47:54,780 --> 00:47:58,700
这些是一些处理工序

453
00:47:58,700 --> 00:48:02,600
就像是map，filter之类的东西

454
00:48:05,570 --> 00:48:12,670
如果我把流当作列表来演示这个过程，来看看，先进行第一个filter

455
00:48:12,670 --> 00:48:14,070
这些全都要处理

456
00:48:14,070 --> 00:48:19,610
针对这个流，不断的处理，处理

457
00:48:19,610 --> 00:48:21,910
然后得到一个新的流

458
00:48:21,910 --> 00:48:24,070
结果现在在我的手上

459
00:48:24,070 --> 00:48:25,260
然后和第二个接通

460
00:48:25,260 --> 00:48:28,110
又处理了全部的流

461
00:48:28,110 --> 00:48:29,510
得到一个新流

462
00:48:32,130 --> 00:48:36,360
然后类似地，取这个结果，用相同的方式再次处理

463
00:48:36,360 --> 00:48:43,860
如果把流仅仅当做列表的话，计算的过程就是这样的

464
00:48:43,860 --> 00:48:50,230
但是事实上，流不是列表，流就是流。你应该这样来想像

465
00:48:50,230 --> 00:48:57,130
我把这些小玩意连接起来，数据在其中流动

466
00:48:59,960 --> 00:49:05,980
这里是流的来源，开始生成整数

467
00:49:05,980 --> 00:49:07,580
如果我想要一个整数，会发生什么？

468
00:49:07,580 --> 00:49:10,200
我揪住最后的这里

469
00:49:10,200 --> 00:49:13,090
这个元素可能会说，哥们，我需要更多的数据

470
00:49:13,090 --> 00:49:15,830
所以，这个到这里，又开始揪住那个

471
00:49:15,830 --> 00:49:17,890
同样说，哥们，给我来点数据

472
00:49:17,890 --> 00:49:21,640
然后这个又揪住了下一个东西，可能是一个fiiler，哥们，来点数据啊

473
00:49:21,640 --> 00:49:25,780
最后的这一点东西，只有在去揪它的时候才会生成

474
00:49:25,780 --> 00:49:30,760
只有我去揪住末尾这里的时候，才会有数据通过这些元件得到处理

475
00:49:30,760 --> 00:49:37,830
把流当作流和把流当作列表，就是这样的区别

476
00:49:40,600 --> 00:49:42,430
说了这么多，到底怎么来实现呢？

477
00:49:42,430 --> 00:49:43,400
我希望你们这样来想

478
00:49:43,400 --> 00:49:44,947
窍门在于如何构造流

479
00:49:47,930 --> 00:49:56,920
我们想要把流组织成一种有需要时才会逐渐计算得到自身元素的数据结构

480
00:49:59,220 --> 00:50:04,490
基本思想在于，再次强调，这种思想贯穿整个课程

481
00:50:04,490 --> 00:50:09,240
那就是，数据与过程之间并没有绝对的界限

482
00:50:09,240 --> 00:50:16,810
流会是这样的一种结构，你可以想象树的叶子的流

483
00:50:16,810 --> 00:50:23,550
但是不得不说，其中包含着计算方法的过程着实很精妙

484
00:50:23,550 --> 00:50:25,930
好吧，实际来看一下

485
00:50:25,930 --> 00:50:28,460
事实上我们不需要其它高深的原理

486
00:50:28,460 --> 00:50:35,460
这个事实已经有了我们所需要的一切东西，那就是了解如何把过程作为一级对象来处理

487
00:50:35,460 --> 00:50:36,880
来看看这个关键之处

488
00:50:36,880 --> 00:50:39,030
关键是，记住，我们有实际的操作方法

489
00:50:39,030 --> 00:50:48,080
CONS-STREAM HEAD TAIL

490
00:50:48,080 --> 00:50:55,080
一开始，你可以把这个想像成CONS，这个是CAR，这个是CDR，事实上没这么简单

491
00:50:55,080 --> 00:50:57,550
现在我们来具体看看它们到底是什么

492
00:50:57,550 --> 00:51:19,540
(CONS-STREAM X Y) 是这个东西的缩写形式

493
00:51:19,540 --> 00:51:28,000
(CONS X (DELAY Y))

494
00:51:31,188 --> 00:51:39,790
在我具体解释清楚之前，先把剩下的写完，(HEAD S) 就是 (CAR S)

495
00:51:42,380 --> 00:51:56,120
(TAIL S) 是 (FORCE (CDR S))

496
00:51:56,120 --> 00:51:58,060
我来具体解释一下

497
00:51:58,060 --> 00:52:01,420
DELAY看起来很神奇

498
00:52:01,420 --> 00:52:10,600
DELAY所做是取一个表达式，然后做了一个约定，有需要的时候再来计算我

499
00:52:10,600 --> 00:52:11,980
这里并没有做实际的计算

500
00:52:11,980 --> 00:52:14,820
只是一个延期的约定

501
00:52:14,820 --> 00:52:17,110
承诺要做这样的事

502
00:52:17,110 --> 00:52:25,360
CONS-STREAM所做的就是把X和一个计算Y的约定相组合

503
00:52:28,230 --> 00:52:31,840
如果你想取头，就是序对的CAR

504
00:52:31,840 --> 00:52:39,110
关键在于尾操作，对承诺进行FORCE调用

505
00:52:39,110 --> 00:52:44,610
TAIL会说，好吧，遵守承诺进行计算

506
00:52:44,610 --> 00:52:47,430
这才开始实际的计算

507
00:52:47,430 --> 00:52:48,740
这就是它的实际工作方式

508
00:52:48,740 --> 00:52:51,550
这就是CONS-STREAM，HEAD，TAIL的真实面目了

509
00:52:54,196 --> 00:52:55,570
具体演示一下

510
00:52:55,570 --> 00:52:58,410
我会非常小心的过一遍

511
00:52:58,410 --> 00:53:08,650
现在从计算10,000到1,000,1000中的第二个质数这个实例来看，那具体是怎么运行的

512
00:53:08,650 --> 00:53:11,610
好的，我们从这个表达式开始

513
00:53:15,820 --> 00:53:26,710
第二个质数 -- 就是(HEAD (TAIL (FILTER (PRIME? (E-I 10000 1000000)))))

514
00:53:26,710 --> 00:53:28,400
这究竟是什么？

515
00:53:28,400 --> 00:53:40,250
就是10,000至1,000,000之间到底是什么？好，如果你开始枚举之间的整数，就构造了一个流

516
00:53:40,250 --> 00:53:54,480
CONS-STREAM实际代换过来是(CONS 10000 (DELAY (E-I 10001 1000000)))

517
00:53:54,480 --> 00:53:55,750
这也就是上面这个表达式

518
00:53:55,750 --> 00:53:57,640
现在我使用代换模型

519
00:53:57,640 --> 00:54:01,010
我们可以用代换模型的原因是这里并没有涉及时间与状态的副作用

520
00:54:04,270 --> 00:54:08,380
这里还有一个计算10001至1000000的承诺

521
00:54:08,380 --> 00:54:09,850
所以到现在为止，只有一个整数被枚举了出来

522
00:54:14,380 --> 00:54:16,580
然后用filter去过滤

523
00:54:19,900 --> 00:54:22,360
我们再来细看filter这个东西

524
00:54:22,360 --> 00:54:25,460
filter首先测试 (HEAD S)

525
00:54:25,460 --> 00:54:33,500
这里，测试到的是10,000，不是素数

526
00:54:33,500 --> 00:54:39,220
然后就开始递归的过滤TAIL的部分

527
00:54:39,220 --> 00:54:46,340
TAIL是什么呢？就是那个继续计算的承诺

528
00:54:46,340 --> 00:54:49,680
开始计算尾了，尾说，好，我履行承诺继续计算

529
00:54:49,680 --> 00:55:00,880
履行承诺的意思是继续枚举10,001到1,000,000之间的整数

530
00:55:00,880 --> 00:55:02,970
现在看起来像是这样

531
00:55:07,810 --> 00:55:11,960
现在，就又回到了最开始枚举的部分

532
00:55:11,960 --> 00:55:19,740
(CONS 10001 (DELAY (E-I 10002 1000000))))

533
00:55:19,740 --> 00:55:23,060
现在filter又开始针对10,001进行过滤了

534
00:55:23,060 --> 00:55:25,120
又要开始判断是不是质数

535
00:55:25,120 --> 00:55:27,550
结果不是

536
00:55:27,550 --> 00:55:29,610
然后再继续履行承诺计算下去

537
00:55:32,920 --> 00:55:37,100
然后，我觉得第一个质数可能是10,009

538
00:55:37,100 --> 00:55:40,465
在这个点才停下来

539
00:55:40,465 --> 00:55:45,240
这只是第一个质数，我们需要的是第二个

540
00:55:45,240 --> 00:55:47,030
所以，又开始了

541
00:55:47,030 --> 00:55:53,130
你会发现，你需要多少，它才生成多少，不多不少

542
00:55:56,690 --> 00:56:04,930
enumerator不会生成比filter的要求更多的数要它去过滤

543
00:56:04,930 --> 00:56:11,255
filter也不会生成比你的要求更多的东西

544
00:56:11,255 --> 00:56:28,160
You see, what's happened is we've put that mixing of generation and test into what actually happens in the computer, even though that's not apparently what's happening from looking at our programs.

545
00:56:28,160 --> 00:56:30,230
OK, well, that seemed easy.

546
00:56:30,230 --> 00:56:33,326
All of this mechanism got put into this magic delay.

547
00:56:33,326 --> 00:56:36,900
So you're saying, gee, that must be where the magic is.

548
00:56:36,900 --> 00:56:39,070
But see there's no magic there either.

549
00:56:39,070 --> 00:56:40,610
You know what delay is.

550
00:56:40,610 --> 00:56:56,490
Delay on some expression is just an abbreviation for--  well, what's a promise to compute an expression?

551
00:56:56,490 --> 00:57:03,000
Lambda of nil, procedure of no arguments, which is that expression.

552
00:57:03,000 --> 00:57:03,930
That's what a procedure is.

553
00:57:03,930 --> 00:57:06,050
It says I'm going to compute an expression.

554
00:57:06,050 --> 00:57:07,460
What's force?

555
00:57:07,460 --> 00:57:10,800
How do I take up a promise?

556
00:57:10,800 --> 00:57:15,890
Well, force of some procedure, a promise, is just run it.

557
00:57:18,710 --> 00:57:20,120
Done.

558
00:57:20,120 --> 00:57:23,580
So there's no magic there at all.

559
00:57:23,580 --> 00:57:26,440
Well, what have we done?

560
00:57:26,440 --> 00:57:30,960
We said the old style, traditional style of programming is more efficient.

561
00:57:30,960 --> 00:57:35,260
And the stream thing is more perspicuous.

562
00:57:35,260 --> 00:57:43,350
And we managed to make the stream procedures run like the other procedures by using delay.

563
00:57:43,350 --> 00:57:54,440
And the thing that delay did for us was to de-couple the apparent order of events in our programs from the actual order of events that happened in the machine.

564
00:57:54,440 --> 00:57:56,540
That's really what delay is doing.

565
00:57:56,540 --> 00:57:58,290
That's exactly the whole point.

566
00:57:58,290 --> 00:58:09,182
We've given up the idea that our procedures, as they run, or as we look at them, mirror some clear notion of time.

567
00:58:09,182 --> 00:58:16,690
And by giving that up, we give delay the freedom to arrange the order of events in the computation the way it likes.

568
00:58:16,690 --> 00:58:17,610
That's the whole idea.

569
00:58:17,610 --> 00:58:24,200
We de-couple the apparent order of events in our programs from the actual order of events in the computer.

570
00:58:24,200 --> 00:58:25,770
OK, well there's one more detail.

571
00:58:25,770 --> 00:58:29,730
It's just a technical detail, but it's actually an important one.

572
00:58:29,730 --> 00:58:39,320
As you run through these recursive programs unwinding, you'll see a lot of things that look like tail of the tail of the tail.

573
00:58:39,320 --> 00:58:43,860
That's the kind of thing that would happen as I go CONSing down a stream all the way.

574
00:58:43,860 --> 00:59:05,290
And if each time I'm doing that, each time to compute a tail, I evaluate a procedure which then has to go re-compute its tail, and re-compute its tail and recompute its tail each time, you can see that's very inefficient compared to just having a list where the elements are all there, and I don't have to re-compute each tail every time I get the next tail.

575
00:59:05,290 --> 00:59:20,390
So there's one little hack to slightly change what delay is, and make it a thing which is-- I'll write it this way.

576
00:59:20,390 --> 00:59:31,000
The actual implementation, delay is an abbreviation for this thing, memo-proc of a procedure.

577
00:59:31,000 --> 00:59:35,150
Memo-proc is a special thing that transforms a procedure.

578
00:59:35,150 --> 00:59:44,806
What it does is it takes a procedure of no arguments and it transforms it into a procedure that'll only have to do its computation once.

579
00:59:44,806 --> 00:59:48,700
And what I mean by that is, you give it a procedure.

580
00:59:48,700 --> 01:00:02,360
The result of memo-proc will be a new procedure, which the first time you call it, will run the original procedure, remember what result it got, and then from ever on after, when you call it, it just won't have to do the computation.

581
01:00:02,360 --> 01:00:05,200
It will have cached that result someplace.

582
01:00:05,200 --> 01:00:06,550
And here's an implementation of memo-proc.

583
01:00:11,210 --> 01:00:12,710
Once you have the idea, it's easy to implement.

584
01:00:12,710 --> 01:00:17,390
Memo-proc is this little thing that has two little flags in there.

585
01:00:17,390 --> 01:00:20,320
It says, have I already been run?

586
01:00:20,320 --> 01:00:23,620
And initially it says, no, I haven't already been run.

587
01:00:23,620 --> 01:00:29,070
And what was the result I got the last time I was run?

588
01:00:29,070 --> 01:00:34,360
So memo-proc takes a procedure called proc, and it returns a new procedure of no arguments.

589
01:00:34,360 --> 01:00:38,610
Proc is supposed to be a procedure of no arguments.

590
01:00:38,610 --> 01:00:44,430
And it says, oh, if I'm not already run, then I'm going to do a sequence of things.

591
01:00:44,430 --> 01:00:48,450
I'm going to compute proc, I'm going to save that.

592
01:00:48,450 --> 01:00:51,140
I'm going to stash that in the variable result.

593
01:00:51,140 --> 01:00:56,610
I'm going to make a note to myself that I've already been run, and then I'll return the result.

594
01:00:56,610 --> 01:00:59,010
So that's if you compute it if it's not already run.

595
01:00:59,010 --> 01:01:03,420
If you call it and it's already been run, it just returns the result.

596
01:01:03,420 --> 01:01:08,400
So that's a little clever hack called memoization.

597
01:01:08,400 --> 01:01:15,270
And in this case, it short circuits having to re-compute the tail of the tail of the tail of the tail of the tail.

598
01:01:15,270 --> 01:01:17,810
So there isn't even that kind of inefficiency.

599
01:01:17,810 --> 01:01:24,210
And in fact, the streams will run with pretty much the same efficiency as the other programs precisely.

600
01:01:24,210 --> 01:01:33,610
And remember, again, the whole idea of this is that we've used the fact that there's no really good dividing line between procedures and data.

601
01:01:33,610 --> 01:01:38,760
We've written data structures that, in fact, are sort of like procedures.

602
01:01:38,760 --> 01:01:49,620
And what that's allowed us to do is take an example of a common control structure, in this place iteration.

603
01:01:49,620 --> 01:01:55,496
And we've built a data structure which, since itself is a procedure, kind of has this iteration control structure in it.

604
01:01:55,496 --> 01:01:58,650
And that's really what streams are.

605
01:01:58,650 --> 01:01:59,900
OK, questions?

606
01:02:03,950 --> 01:02:13,052
AUDIENCE: Your description of tail-tail-tail, if I understand it correctly, force is actually execution of a procedure, if it's done without this memo-proc thing.

607
01:02:13,052 --> 01:02:16,380
And you implied that memo-proc gets around that problem.

608
01:02:16,380 --> 01:02:23,910
Doesn't it only get around it if tail-tail-tail is always executing exactly the same-- PROFESSOR: Oh, that's-- sure.

609
01:02:23,910 --> 01:02:26,050
AUDIENCE: I guess I missed that point.

610
01:02:26,050 --> 01:02:26,540
PROFESSOR: Oh, sure.

611
01:02:26,540 --> 01:02:31,290
I mean the point is--  yeah.

612
01:02:31,290 --> 01:02:34,160
I mean I have to do a computation to get the answer.

613
01:02:34,160 --> 01:02:42,980
But the point is, once I've found the tail of the stream, to get the tail of the tail, I shouldn't have had to re-compute the first tail.

614
01:02:42,980 --> 01:02:46,460
See, and if I didn't use memo-proc, that re-computation would have been done.

615
01:02:46,460 --> 01:02:47,710
AUDIENCE: I understand now.

616
01:02:50,830 --> 01:02:56,830
AUDIENCE: In one of your examples, you mentioned that we were able to use the substitution model because there are no side effects.

617
01:02:56,830 --> 01:03:03,620
What if we had a single processing unit-- if we had a side effect, if we had a state?

618
01:03:03,620 --> 01:03:09,120
Could we still practically build the stream model?

619
01:03:09,120 --> 01:03:09,530
PROFESSOR: Maybe.

620
01:03:09,530 --> 01:03:10,540
That's a hard question.

621
01:03:10,540 --> 01:03:18,960
I'm going to talk a little bit later about the places where substitution and side effects don't really mix very well.

622
01:03:18,960 --> 01:03:25,170
But in general, I think the answer is unless you're very careful, any amount of side effect is going to mess up everything.

623
01:03:35,490 --> 01:03:39,410
AUDIENCE: Sorry, I didn't quite understand the memo-proc operation.

624
01:03:39,410 --> 01:03:41,990
When do you execute the lambda?

625
01:03:41,990 --> 01:03:47,600
In other words, when memo-proc is executed, just this lambda expression is being generated.

626
01:03:47,600 --> 01:03:50,390
But it's not clear to me when it's executed.

627
01:03:50,390 --> 01:03:51,350
PROFESSOR: Right.

628
01:03:51,350 --> 01:03:57,930
What memo-proc does-- remember, the thing that's going into memo-proc, the thing proc, is a procedure of no arguments.

629
01:03:57,930 --> 01:04:00,390
And someday, you're going to call it.

630
01:04:00,390 --> 01:04:06,620
Memo-proc translates that procedure into another procedure of no arguments, which someday you're going to call.

631
01:04:06,620 --> 01:04:09,890
That's that lambda.

632
01:04:09,890 --> 01:04:24,100
So here, where I initially built as my tail of the stream, say, this procedure of no arguments, which someday I'll call.

633
01:04:24,100 --> 01:04:30,650
Instead, I'm going to have the tail of the stream be memo-proc of it, which someday I'll call.

634
01:04:30,650 --> 01:04:47,642
So that lambda of nil, that gets called when you call the memo-proc, when you call the result of that memo-proc, which would be ordinarily when you would have called the original thing that you set it.

635
01:04:47,642 --> 01:04:52,610
AUDIENCE: OK, the reason I ask is I had a feeling that when you call memo-proc, you just return this lambda.

636
01:04:52,610 --> 01:04:53,770
PROFESSOR: That's right.

637
01:04:53,770 --> 01:04:58,100
When you call memo-proc, you return the lambda.

638
01:04:58,100 --> 01:05:02,270
You never evaluate the expression at all, until the first time that you would have evaluated it.

639
01:05:07,590 --> 01:05:14,240
AUDIENCE: Do I understand it right that you actually have to build the list up, but the elements of the list don't get evaluated?

640
01:05:14,240 --> 01:05:15,630
The expressions don't get evaluated?

641
01:05:15,630 --> 01:05:18,540
But at each stage, you actually are building a list.

642
01:05:18,540 --> 01:05:20,700
PROFESSOR: That's-- I really should have said this.

643
01:05:20,700 --> 01:05:22,270
That's a really good point.

644
01:05:22,270 --> 01:05:23,660
No, it's not quite right.

645
01:05:23,660 --> 01:05:25,080
Because what happens is this.

646
01:05:25,080 --> 01:05:26,890
Let me draw this as pairs.

647
01:05:26,890 --> 01:05:32,740
Suppose I'm going to make a big stream, like enumerate interval, 1 through 1 billion.

648
01:05:32,740 --> 01:05:43,045
What that is, is a pair with a 1 and a promise.

649
01:05:46,520 --> 01:05:47,890
That's exactly what it is.

650
01:05:47,890 --> 01:05:49,140
Nothing got built up.

651
01:05:51,600 --> 01:05:56,370
When I go and force this, and say, what happens?

652
01:05:56,370 --> 01:06:00,530
Well, this thing is now also recursively a CONS.

653
01:06:00,530 --> 01:06:11,350
So that this promise now is the next thing, which is a 2 and a promise to do more.

654
01:06:11,350 --> 01:06:14,470
And so on and so on and so on.

655
01:06:14,470 --> 01:06:18,200
So nothing gets built up until you walk down the stream.

656
01:06:18,200 --> 01:06:25,500
Because what's sitting here is not the list, but a promise to generate the list. And by promise, technically I mean procedure.

657
01:06:28,050 --> 01:06:30,485
So it doesn't get built up.

658
01:06:30,485 --> 01:06:34,280
Yeah, I should have said that before this point.

659
01:06:34,280 --> 01:06:34,490
OK.

660
01:06:34,490 --> 01:06:34,790
Thank you.

661
01:06:34,790 --> 01:06:36,340
Let's take a break.

