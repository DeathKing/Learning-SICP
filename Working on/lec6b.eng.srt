1
00:00:20,970 --> 00:00:28,870
PROFESSOR: OK, well, we've been looking at streams, this signal processing way of putting systems together.

3
00:00:28,870 --> 00:00:40,635
And remember, the key idea is that we decouple the apparent order of events in our programs from the actual order of events in the computer.

6
00:00:40,635 --> 00:00:47,500
And that means that we can start dealing with very long streams and only having to generate the elements on demand.

9
00:00:47,500 --> 00:00:51,560
That sort of on-demand computation is built into the stream's data structure.

12
00:00:54,450 --> 00:00:58,040
So if we have a very long stream, we only compute what we need.

14
00:00:58,040 --> 00:01:00,750
The things only get computed when we actually ask for them.

15
00:01:00,750 --> 00:01:02,110
Well, what are examples?

16
00:01:02,110 --> 00:01:04,800
Are they actually asking for them?

17
00:01:04,800 --> 00:01:11,050
For instance, we might ask for the n-th element of a stream.

19
00:01:16,360 --> 00:01:20,400
Here's a procedure that computes the n-th element of a stream.

21
00:01:20,400 --> 00:01:25,570
An integer n, the n-th element of some stream s, and we just recursively walk down the stream.

23
00:01:25,570 --> 00:01:27,960
And the end of 0, we compute the head.

24
00:01:27,960 --> 00:01:34,310
Otherwise, it's the n-th the minus 1 element of the tail of the stream.

26
00:01:34,310 --> 00:01:41,700
Those two are just like for Lisp, but the difference is those elements aren't going to get computed until we walk down, taking successive n-ths.

29
00:01:41,700 --> 00:01:45,910
So that's one way that the stream elements might get forced.

31
00:01:45,910 --> 00:01:49,300
And another way, here's a little procedure that prints a stream.

33
00:01:49,300 --> 00:01:54,150
We say print a stream, so to print a stream s.

34
00:01:54,150 --> 00:01:55,315
Well, what do we do?

35
00:01:55,315 --> 00:01:59,720
We print the head of the stream, and that will cause the head to be computed.

37
00:01:59,720 --> 00:02:04,990
And then we recursively print stream the tail of the stream.

38
00:02:04,990 --> 00:02:09,660
And if we're already done, maybe we have to return something about the message done.

40
00:02:09,660 --> 00:02:14,310
OK, and then so if you make a stream, you could say here's the stream, this very long stream.

42
00:02:14,310 --> 00:02:21,320
And then you say print the stream, and the elements of the stream will get computed successively as that print calls them.

45
00:02:21,320 --> 00:02:24,680
They won't get all computed initially.

46
00:02:24,680 --> 00:02:30,190
So in this way, we can deal with some very long streams.

47
00:02:30,190 --> 00:02:33,600
Well, how long can a stream be?

48
00:02:33,600 --> 00:02:36,360
Well, it can be infinitely long.

49
00:02:36,360 --> 00:02:38,920
Let's look at an example here on the computer.

50
00:02:38,920 --> 00:02:57,420
I could walk up to this computer, and I could say-- how about we'll define the stream of integers starting with some number N, the stream of positive integers starting with some number n.

55
00:02:59,760 --> 00:03:19,010
And that's cons-stream of n onto the integers from one more.

58
00:03:24,680 --> 00:03:25,930
So there are the integers.

60
00:03:28,800 --> 00:03:31,500
Then I could say let's get all the integers.

62
00:03:34,410 --> 00:03:44,580
define the stream of integers to be the integers starting with 1.

65
00:03:48,840 --> 00:04:02,995
And now if I say something like what's the what's the 20th integer.

67
00:04:02,995 --> 00:04:07,270
So it's 21 because we start counting at 0.

68
00:04:07,270 --> 00:04:09,450
Or I can do more complicated things.

69
00:04:09,450 --> 00:04:10,840
Let me to define a little predicate here.

71
00:04:13,740 --> 00:04:19,160
How about define no-seven.

72
00:04:19,160 --> 00:04:23,376
It's going to test an integer, and it's going to say it's not.

75
00:04:28,820 --> 00:04:38,175
I take the remainder of x by 7, I don't get 0.

77
00:04:41,890 --> 00:04:58,885
And then I could say define the integers with no sevens to be, take all the integers and filter them to have no sevens.

80
00:05:11,570 --> 00:05:16,360
So now I've got the stream of all the integers that are not divisible by seven.

82
00:05:16,360 --> 00:05:28,320
So if I say what's the 100th integer and the list not divisible by seven, I get 117.

84
00:05:28,320 --> 00:05:35,270
Or if I'd like to say well, gee, what are all of them?

85
00:05:35,270 --> 00:05:41,700
So I could say print stream all these integers with no seven, it goes off printing.

88
00:05:45,100 --> 00:05:47,070
You may have to wait a very long time to see them all.

90
00:05:52,670 --> 00:06:01,100
Well, you can start asking, gee, is it really true that this data structure with the integers is really all the integers?

93
00:06:01,100 --> 00:06:04,053
And let me draw a picture of that program I just wrote.

95
00:06:08,170 --> 00:06:19,775
Here's the definition of the integers again that I just typed in, Right it's a cons of the first integer under the integer starting with the rest. Now, we can make a picture of that and see what it looks like.

100
00:06:22,720 --> 00:06:27,420
Conceptually, what I have is a box that's the integer starting with n.

102
00:06:27,420 --> 00:06:37,705
It takes in some number n, and it's going to return a stream of-- this infinite stream of all integers starting with n.

105
00:06:37,705 --> 00:06:38,690
And what do I do?

106
00:06:38,690 --> 00:06:42,470
Well, this is an integers from box.

108
00:06:45,070 --> 00:06:45,800
What's it got in it?

109
00:06:45,800 --> 00:06:54,110
Well, it takes in this n, and it increments it.

111
00:06:58,030 --> 00:07:03,170
And then it puts the result into recursively another integer's from box.

114
00:07:06,870 --> 00:07:14,270
It takes the result of that and the original n and puts those together with a cons and forms a stream.

116
00:07:14,270 --> 00:07:18,530
So that's a picture of that program I wrote.

117
00:07:18,530 --> 00:07:18,780
Let's see.

118
00:07:18,780 --> 00:07:23,320
These kind of diagrams we first saw drawn by Peter Henderson, the same guy who did the Escher language.

120
00:07:23,320 --> 00:07:28,530
We call them Henderson diagrams. And the convention here is that you put these things together.

122
00:07:28,530 --> 00:07:37,270
And the solid lines are things coming out are streams, and dotted lines are initial values going in.

124
00:07:37,270 --> 00:07:43,070
So this one has the shape of-- it takes in some integer, some initial value, and outputs a stream.

128
00:07:46,410 --> 00:07:48,380
Again, you can ask.

129
00:07:48,380 --> 00:07:52,340
Is that data structure integers really all the integers?

131
00:07:52,340 --> 00:07:58,190
Or is it is something that's cleverly arranged so that whenever you look for an integer you find it there?

133
00:07:58,190 --> 00:07:59,780
That's sort of a philosophical question, right?

134
00:07:59,780 --> 00:08:04,450
If something is there whenever you look, is it really there or not?

136
00:08:04,450 --> 00:08:09,420
It's sort of the same sense in which the money in your savings account is in the bank.

139
00:08:12,380 --> 00:08:19,830
Well, let me do another example.

140
00:08:19,830 --> 00:08:28,470
Gee, we started the course with an algorithm from Alexandria, which was Heron of Alexandria's algorithm for computing the square root.

143
00:08:28,470 --> 00:08:32,030
Let's take a look at another Alexandrian algorithm.

144
00:08:32,030 --> 00:08:39,110
This one is Eratosthenes method for computing all of the primes.

147
00:08:41,169 --> 00:08:42,830
It is called the Sieve of Eratosthenes.

148
00:08:42,830 --> 00:08:53,880
And what you do is you start out, and you list all the integers, say, starting with 2.

150
00:08:53,880 --> 00:08:57,310
And then you take the first integer, and you say, oh, that's prime.

152
00:08:57,310 --> 00:09:01,230
And then you go look at the rest, and you cross out all the things divisible by 2.

154
00:09:01,230 --> 00:09:05,250
So I cross out this and this and this.

155
00:09:05,250 --> 00:09:11,160
This takes a long time because I have to do it for all of the integers.

157
00:09:11,160 --> 00:09:22,010
So I go through the entire list of integers, crossing the ones divisible by 2.

159
00:09:22,010 --> 00:09:27,040
And now when I finish with all of the integers, I go back and look and say what am I left with?

161
00:09:27,040 --> 00:09:29,330
Well, the first thing that starts there is 3.

162
00:09:29,330 --> 00:09:30,770
So 3 is a prime.

163
00:09:30,770 --> 00:09:35,120
And now I go back through what I'm left with, and I cross out all the things divisible by 3.

165
00:09:35,120 --> 00:09:44,050
So let's see, 9 and 15 and 21 and 27 and 33 and so on.

166
00:09:44,050 --> 00:09:45,350
I won't finish.

167
00:09:45,350 --> 00:09:47,250
Then I see what I'm left with.

168
00:09:47,250 --> 00:09:50,860
And the next one I have is 5.

169
00:09:50,860 --> 00:09:54,540
Now I can through the rest, and I find the first one that's divisible by 5.

171
00:09:54,540 --> 00:09:58,030
I cross out from the remainder all the ones that are divisible by 5.

173
00:09:58,030 --> 00:10:01,890
And I do that, and then I go through and find 7.

174
00:10:01,890 --> 00:10:06,810
Go through all the rest, cross out things divisible 7, and I keep doing that forever.

176
00:10:06,810 --> 00:10:10,120
And when I'm done, what I'm left with is a list of all the primes.

178
00:10:10,120 --> 00:10:15,430
So that's the Sieve of Eratosthenes.

179
00:10:15,430 --> 00:10:17,930
Let's look at it as a computer program.

180
00:10:17,930 --> 00:10:19,550
It's a procedure called sieve.

182
00:10:27,910 --> 00:10:30,480
Now, I just write what I did.

183
00:10:30,480 --> 00:10:34,510
I'll say to sieve some stream s.

185
00:10:38,770 --> 00:10:41,870
I'm going to build a stream whose first element is the head of this.

187
00:10:41,870 --> 00:10:59,020
Remember, I always found the first thing I was left with, and the rest of it is the result of taking the tail of this, filtering it to throw away all the things that are divisible by the head of this, and now sieving the result.

191
00:10:59,020 --> 00:11:01,980
That's just what I did.

192
00:11:01,980 --> 00:11:06,900
And now to get the infinite stream of times, we just sieve all the integers starting from 2.

195
00:11:14,920 --> 00:11:16,300
Let's try that.

196
00:11:16,300 --> 00:11:19,760
We can actually do it.

197
00:11:19,760 --> 00:11:41,350
I typed in the definition of sieve before, I hope, so I can say something like define the primes to be the result of sieving the integers starting with 2.

201
00:11:46,760 --> 00:11:48,100
So now I've got this list of primes.

202
00:11:48,100 --> 00:11:50,990
That's all of the primes, right?

203
00:11:50,990 --> 00:12:01,010
So, if for example, what's the 20th prime in that list?

204
00:12:01,010 --> 00:12:02,540
73.

205
00:12:02,540 --> 00:12:07,750
See, and that little pause, it was only at the point when I started asking for the 20th prime is that it started computing.

209
00:12:10,370 --> 00:12:14,960
Or I can say here let's look at all of the primes.

211
00:12:22,780 --> 00:12:25,350
And there it goes computing all of the primes.

212
00:12:25,350 --> 00:12:28,570
Of course, it will take a while again if I want to look at all of them, so let's stop it.

215
00:12:32,030 --> 00:12:33,130
Let me draw you a picture of that.

216
00:12:33,130 --> 00:12:34,890
Well, I've got a picture of that.

217
00:12:34,890 --> 00:12:37,900
What's that program really look like?

218
00:12:37,900 --> 00:12:42,610
Again, some practice with these diagrams, I have a sieve box.

220
00:12:42,610 --> 00:12:43,560
How does sieve work?

221
00:12:43,560 --> 00:12:44,810
It takes in a stream.

223
00:12:48,850 --> 00:12:50,870
It splits off the head from the tail.

224
00:12:50,870 --> 00:12:54,970
And the first thing that's going to come out of the sieve is the head of the original stream.

227
00:12:57,796 --> 00:13:02,550
Then it also takes the head and uses that.

228
00:13:02,550 --> 00:13:03,850
It takes the stream.

229
00:13:03,850 --> 00:13:09,152
It filters the tail and uses the head to filter for nondivisibility.

231
00:13:09,152 --> 00:13:15,130
It takes the result of nondivisibility and puts it through another sieve box and puts the result together.

233
00:13:15,130 --> 00:13:19,650
So you can think of this sieve a filter, but notice that it's an infinitely recursive filter.

235
00:13:19,650 --> 00:13:27,130
Because inside the sieve box is another sieve box, and inside that is another sieve box and another sieve box.

237
00:13:27,130 --> 00:13:28,960
So you see we start getting some very powerful things.

238
00:13:28,960 --> 00:13:36,690
We're starting to mix this signal processing view of the world with things like recursion that come from computation.

241
00:13:36,690 --> 00:13:40,970
And there are all sorts of interesting things you can do that are like this.

243
00:13:40,970 --> 00:13:42,220
All right, any questions?

245
00:13:48,190 --> 00:13:49,440
OK, let's take a break.

247
00:14:28,820 --> 00:14:32,690
Well, we've been looking at a couple of examples of stream programming.

250
00:14:34,790 --> 00:14:41,490
All the stream procedures that we've looked at so far have the same kind of character.

252
00:14:41,490 --> 00:14:51,000
We've been writing these recursive procedures that kind of generate these stream elements one at a time and put them together in cons-streams. So we've been thinking a lot about generators.

256
00:14:51,000 --> 00:15:07,350
There's another way to think about stream processing, and that's to focus not on programs that sort of process these elements as you walk down the stream, but on things that kind of process the streams all at once.

260
00:15:07,350 --> 00:15:12,410
To show you what I mean, let me start by defining two procedures that will come in handy.

262
00:15:12,410 --> 00:15:22,330
The first one's called add streams. Add streams takes two streams: s1 and s2.

264
00:15:22,330 --> 00:15:22,460
and.

265
00:15:22,460 --> 00:15:32,970
It's going to produce a stream whose elements are the are the corresponding sums. We just sort of add them element-wise.

267
00:15:32,970 --> 00:15:36,810
If either stream is empty, we just return the other one.

268
00:15:36,810 --> 00:15:50,090
Otherwise, we're going to make a new stream whose head is the sum of the two heads and whose tail is the result of recursively adding the tails.

271
00:15:50,090 --> 00:15:53,150
So that will produce the element-wise sum of two streams.

273
00:15:53,150 --> 00:15:57,500
And then another useful thing to have around is scale stream.

275
00:15:57,500 --> 00:16:09,710
Scale stream takes some constant number in a stream s and is going to produce the stream of elements of s multiplied by this constant.

278
00:16:09,710 --> 00:16:18,290
And that's easy, that's just a map of the function of an element that multiplies it by the constant, and we map that down the stream.

282
00:16:20,520 --> 00:16:27,910
So given those two, let me show you what I mean by programs that operate on streams all at once.

284
00:16:27,910 --> 00:16:30,200
Let's look at this.

285
00:16:30,200 --> 00:16:31,680
Suppose I write this.

286
00:16:31,680 --> 00:16:52,190
I say define--  I'll call it ones-- to be cons-stream of 1 onto ones.

291
00:16:54,860 --> 00:16:56,950
What's that?

292
00:16:56,950 --> 00:17:03,330
That's going to be an infinite stream of ones because the first thing is 1.

294
00:17:03,330 --> 00:17:11,780
And the tail of it is a thing whose first thing is 1 and whose tail is a thing whose first thing is 1 and so on and so on and so on.

297
00:17:11,780 --> 00:17:15,130
So that's an infinite stream of ones.

298
00:17:15,130 --> 00:17:18,599
And now using that, let me give you another definition of the integers.

300
00:17:18,599 --> 00:17:48,270
We can define the integers to be-- well, the first integer we'll take to be 1, this cons-stream of 1 onto the element-wise sum onto add streams of the integers to ones.

305
00:17:54,950 --> 00:18:06,640
The integers are a thing whose first element is 1, and the rest of them you get by taking those integers and incrementing each one by one.

308
00:18:06,640 --> 00:18:13,940
So the second element of the integers is the first element of the integers incremented by one.

310
00:18:13,940 --> 00:18:31,250
And the rest of that is the next one, and the third element of that is the same as the first element of the tail of the integers incremented by one, which is the same as the first element of the original integers incremented by one and incremented by one again and so on.

316
00:18:35,240 --> 00:18:36,310
That looks pretty suspicious.

317
00:18:36,310 --> 00:18:40,150
See, notice that it works because of delay.

318
00:18:40,150 --> 00:18:43,870
See, this looks like-- let's take a look at ones.

320
00:18:43,870 --> 00:18:51,130
This looks like it couldn't even be processed because it's suddenly saying in order to know what ones is, I say it's cons-stream of something onto ones.

323
00:18:51,130 --> 00:18:55,250
The reason that works is because of that very sneaky hidden delay in there.

325
00:18:55,250 --> 00:19:00,290
Because what this really is, remember, cons-stream is just an abbreviation.

327
00:19:00,290 --> 00:19:08,785
This really is cons of 1 onto delay of ones.

329
00:19:12,140 --> 00:19:15,500
So how does that work?

330
00:19:15,500 --> 00:19:18,020
You say I'm going to define ones.

331
00:19:18,020 --> 00:19:20,700
First I see what ones is supposed to be defined as.

332
00:19:20,700 --> 00:19:32,710
Well, ones is supposed to be defined as a cons whose first part is 1 and whose second part is, well, it's a promise to compute something that I don't worry about yet.

335
00:19:32,710 --> 00:19:37,270
So it doesn't bother me that at the point I do this definition, ones isn't defined.

337
00:19:37,270 --> 00:19:40,670
Having run the definition now, ones is defined.

338
00:19:40,670 --> 00:19:44,920
So that when I go and look at the tail of it, it's defined.

339
00:19:44,920 --> 00:19:46,590
It's very sneaky.

340
00:19:46,590 --> 00:19:48,470
And an integer is the same way.

341
00:19:48,470 --> 00:19:53,210
I can refer to integers here because hidden way down-- because of this cons-stream.

343
00:19:53,210 --> 00:19:57,050
It's the cons-stream of 1 onto something that I don't worry that yet.

345
00:19:57,050 --> 00:20:02,570
So I don't look at it, and I don't notice that integers isn't defined at the point where I try and run the definition.

349
00:20:06,320 --> 00:20:12,430
OK, let me draw a picture of that integers thing because it still maybe seems a little bit shaky.

351
00:20:12,430 --> 00:20:15,020
What do I do?

352
00:20:15,020 --> 00:20:26,590
I've got the stream of ones, and that sort of comes in and goes into an adder that's going to be this add streams thing.

356
00:20:29,310 --> 00:20:35,760
And that goes in-- that's going to put out the integers.

359
00:20:40,760 --> 00:20:48,060
And the other thing that goes into the adder here is the integer, so there's a little feedback loop.

361
00:20:48,060 --> 00:20:53,180
And all I need to start it off is someplace I've got a stick that initial 1.

364
00:20:57,100 --> 00:21:02,910
In a real signal processing thing, this might be a delay element with that was initialized to 1.

366
00:21:02,910 --> 00:21:07,860
But there's a picture of that ones program.

367
00:21:07,860 --> 00:21:17,360
And in fact, that looks a lot like-- if you've seen real signal block diagram things, that looks a lot like accumulators, finite state accumulators.

370
00:21:17,360 --> 00:21:28,440
And in fact, we can modify this a little bit to change this into something that integrates a stream or a finite state accumulator, however you like to think about it.

374
00:21:28,440 --> 00:21:45,700
So instead of the ones coming in and getting out the integers, what we'll do is say there's a stream s coming in, and we're going to get out the integral of this, successive values of that, and it looks almost the same.

378
00:21:45,700 --> 00:21:54,260
The only thing we're going to do is when s comes in here, before we just add it in we're going to multiply it by some number dt.

382
00:21:57,680 --> 00:22:00,000
And now what we have here, this is exactly the same thing.

384
00:22:00,000 --> 00:22:04,020
We have a box, which is an integrator.

386
00:22:09,790 --> 00:22:19,980
And it takes in a stream s, and instead of 1 here, we can put the additional value for the integral.

388
00:22:19,980 --> 00:22:25,270
And that one looks very much like a signal processing block diagram program.

390
00:22:25,270 --> 00:22:27,980
In fact, here's the procedure that looks exactly like that.

392
00:22:31,490 --> 00:22:34,010
Find the integral of a stream.

393
00:22:34,010 --> 00:22:42,230
So an integral's going to take a stream and produce a new stream, and it takes in an initial value and some time constant.

396
00:22:42,230 --> 00:22:43,040
And what do we do?

397
00:22:43,040 --> 00:22:49,400
Well, we internally define this thing int, and we make this internal name so we can feed it back, loop it around itself.

400
00:22:49,400 --> 00:23:01,280
And int is defined to be something that starts out at the initial value, and the rest of it is gotten by adding together.

403
00:23:01,280 --> 00:23:06,880
We take our input stream, scale it by dt, and add that to int.

405
00:23:06,880 --> 00:23:10,690
And now we'll return from all that the value of integral is this thing int.

407
00:23:10,690 --> 00:23:15,920
And we use this internal definition syntax so we could write a little internal definition that refers to itself.

411
00:23:21,880 --> 00:23:23,710
Well, there are all sorts of things we can do.

412
00:23:23,710 --> 00:23:25,500
Let's try this one.

413
00:23:25,500 --> 00:23:26,895
how about the Fibonacci numbers.

414
00:23:26,895 --> 00:23:32,625
You can say define fibs.

416
00:23:36,350 --> 00:23:37,985
Well, what are the Fibonacci numbers?

417
00:23:37,985 --> 00:23:50,090
They're something that starts out with 0, and the next one is 1.

420
00:23:56,260 --> 00:24:11,000
And the rest of the Fibonacci numbers are gotten by adding the Fibonacci numbers to their own tail.

423
00:24:17,570 --> 00:24:20,580
There's a definition of the Fibonacci numbers.

424
00:24:20,580 --> 00:24:21,430
How does that work?

425
00:24:21,430 --> 00:24:31,870
Well, we start off, and someone says compute for us the Fibonacci numbers, and we're going to tell you it starts out with 0 and 1.

429
00:24:35,790 --> 00:24:45,830
And everything after the 0 and 1 is gotten by summing two streams. One is the fibs themselves, and the other one is the tail of the fibs.

433
00:24:48,870 --> 00:24:58,360
So if I know that these start out with 0 and 1, I know that the fibs now start out with 0 and 1, and the tail of the fibs start out with 1.

436
00:24:58,360 --> 00:25:06,300
So as soon as I know that, I know that the next one here is 0 plus 1 is 1, and that tells me that the next one here is 1 and the next one here is 1.

439
00:25:06,300 --> 00:25:09,390
And as soon as I know that, I know that the next one is 2.

440
00:25:09,390 --> 00:25:11,700
So the next one here is 2 and the next one here is 2.

441
00:25:11,700 --> 00:25:12,950
And this is 3.

443
00:25:14,720 --> 00:25:18,530
This one goes to 3, and this is 5.

444
00:25:18,530 --> 00:25:21,500
So it's a perfectly sensible definition.

445
00:25:21,500 --> 00:25:22,830
It's a one-line definition.

446
00:25:22,830 --> 00:25:30,150
And again, I could walk over to the computer and type that in, exactly that, and then say print stream the Fibonacci numbers, and they all come flying out.

450
00:25:32,790 --> 00:25:36,810
See, this is a lot like learning about recursion again.

452
00:25:36,810 --> 00:25:45,160
Instead of thinking that recursive procedures, we have recursively defined data objects.

454
00:25:45,160 --> 00:25:53,090
But that shouldn't surprise you at all, because by now, you should be coming to really believe that there's no difference really between procedures and data.

457
00:25:53,090 --> 00:25:58,210
In fact, in some sense, the underlying streams are procedures sitting there, although we don't think of them that way.

460
00:25:58,210 --> 00:26:03,630
So the fact that we have recursive procedures, well, then it should be natural that we have recursive data, too.

463
00:26:07,840 --> 00:26:09,720
OK, well, this is all pretty neat.

464
00:26:09,720 --> 00:26:14,990
Unfortunately, there are problems that streams aren't going to solve.

466
00:26:14,990 --> 00:26:17,580
Let me show you one of them.

467
00:26:17,580 --> 00:26:36,390
See, in the same way, let's imagine that we're building an analog computer to solve some differential equation like, say, we want to solve the equation y prime dy dt is y squared, and I'm going to give you some initial value.

471
00:26:36,390 --> 00:26:38,030
I'll tell you y of 0 equals 1.

473
00:26:41,060 --> 00:26:43,690
Let's say dt is equal to something.

475
00:26:46,770 --> 00:26:51,040
Now, in the old days, people built analog computers to solve these kinds of things.

477
00:26:51,040 --> 00:26:53,020
And the way you do that is really simple.

478
00:26:53,020 --> 00:27:03,055
You get yourself an integrator, like that one, an integrator box.

480
00:27:03,055 --> 00:27:08,530
And we put in the initial value y of 0 is 1.

481
00:27:08,530 --> 00:27:13,890
And now if we feed something in and get something out, we'll say, gee, what we're getting out is the answer.

483
00:27:13,890 --> 00:27:21,490
And what we're going to feed in is the derivative, and the derivative is supposed to be the square of the answer.

485
00:27:21,490 --> 00:27:42,910
So if we take these values and map using square, and if I feed this around, that's how I build a block diagram for an analog computer that solves this differential equation.

488
00:27:42,910 --> 00:27:47,230
Now, what we'd like to do is write a stream program that looks exactly like that.

490
00:27:47,230 --> 00:27:49,390
And what do I mean exactly like that?

491
00:27:49,390 --> 00:28:13,790
Well, I'd say define y to be the integral of dy starting at 1 with 0.001 as a time step.

493
00:28:13,790 --> 00:28:16,805
And I'd like to say that says this.

494
00:28:16,805 --> 00:28:20,850
And then I'd like to say, well, dy is gotten by mapping the square along y.

496
00:28:20,850 --> 00:28:33,510
So define dy to be map square along y.

497
00:28:33,510 --> 00:28:41,410
So there's a stream description of this analog computer, and unfortunately, it doesn't work.

499
00:28:41,410 --> 00:28:51,190
And you can see why it doesn't work because when I come in and say define y to be the integral of dy, it says, oh, the integral of y-- huh?

502
00:28:51,190 --> 00:28:53,710
Oh, that's undefined.

503
00:28:53,710 --> 00:28:58,770
So I can't write this definition before I've written this one.

505
00:28:58,770 --> 00:29:03,580
On the other hand, if I try and write this one first, it says, oh, I define y to be the map of square along y?

507
00:29:03,580 --> 00:29:05,770
Oh, that's not defined yet.

508
00:29:05,770 --> 00:29:11,580
So I can't write this one first, and I can't write that one first. So I can't quite play this game.

511
00:29:17,560 --> 00:29:20,460
Well, is there a way out?

512
00:29:20,460 --> 00:29:22,200
See, we can do that with ones.

513
00:29:22,200 --> 00:29:34,770
See, over here, we did this thing ones, and we were able to define ones in terms of ones because of this delay that was built inside because cons-stream had a delay.

516
00:29:34,770 --> 00:29:36,070
Now, why's it sensible?

517
00:29:36,070 --> 00:29:40,730
Why's it sensible for cons-stream to be built with this delay?

519
00:29:40,730 --> 00:29:45,950
The reason is that cons-stream can do a useful thing without looking at its tail.

521
00:29:45,950 --> 00:29:54,870
See, if I say this is cons-stream of 1 onto something without knowing anything about something, I know that the stream starts off with 1.

524
00:29:54,870 --> 00:29:57,910
That's why it was sensible to build something like cons-stream.

527
00:29:59,960 --> 00:30:06,320
So we put a delay in there, and that allows us to have this sort of self-referential definition.

529
00:30:06,320 --> 00:30:08,190
Well, integral is a little bit the same way.

530
00:30:08,190 --> 00:30:17,580
See, notice for an integral, I can-- let's go back and look at integral for a second.

532
00:30:17,580 --> 00:30:28,970
See, notice integral, it makes sense to say what's the first thing in the integral without knowing the stream that you're integrating.

535
00:30:28,970 --> 00:30:33,140
Because the first thing in the integral is always going to be the initial value that you're handed.

537
00:30:33,140 --> 00:30:37,090
So integral could be a procedure like cons-stream.

538
00:30:37,090 --> 00:30:46,710
You could define it, and then even before it knows what it's supposed to be integrating, it knows enough to say what its initial value is.

541
00:30:46,710 --> 00:30:58,430
So we can make a smarter integral, which is aha, you're going to give me a stream to integrate and an initial value, but I really don't have to look at that stream that I'm supposed to integrate until you ask me to work down the stream.

546
00:30:58,430 --> 00:31:03,710
In other words, integral can be like cons-stream, and you can expect that there's going to be a delay around its integrand.

549
00:31:03,710 --> 00:31:05,610
And we can write that.

550
00:31:05,610 --> 00:31:07,650
Here's a procedure that does that.

551
00:31:07,650 --> 00:31:17,110
Another version of integral, and this is almost like the previous one, except the stream it's going to get in is going to expect to be a delayed object.

554
00:31:17,110 --> 00:31:18,850
And how does this integral work?

555
00:31:18,850 --> 00:31:32,300
Well, the little thing it's going to define inside of itself says on the cons-stream, the initial value is the initial value, but only inside of that cons-stream, and remember, there's going to be a hidden delay inside here.

560
00:31:34,950 --> 00:31:43,180
Only inside of that cons-stream will I start looking at what the actual delayed object is.

562
00:31:43,180 --> 00:31:45,970
So my answer is the first thing's the initial value.

563
00:31:45,970 --> 00:31:59,260
If anybody now asks me for my tail, at that point, I'm going to force that delayed object-- and I'll call that s-- and I do the add streams. So this is an integral which is sort of like cons-stream.

568
00:31:59,260 --> 00:32:07,330
It's not going to actually try and see what you handed it as the thing to integrate until you look past the first element.

572
00:32:10,120 --> 00:32:27,090
And if we do that and we can make this work, all we have to do here is say define y to the integral of delay of y, of delay of dy.

575
00:32:27,090 --> 00:32:35,280
So y is going to be the integral of delay of dy starting at 1, and now this will work.

577
00:32:35,280 --> 00:32:44,600
Because I type in the definition of y, and that says, oh, I'm supposed to use the integral of something I don't care about right now because it's a delay.

580
00:32:44,600 --> 00:32:46,320
And these things, now you define dy.

581
00:32:46,320 --> 00:32:47,550
Now, y is defined.

582
00:32:47,550 --> 00:32:51,700
So when I define dy, it can see that definition for y.

583
00:32:51,700 --> 00:32:52,840
Everything is now started up.

584
00:32:52,840 --> 00:32:54,920
Both streams have their first element.

585
00:32:54,920 --> 00:33:00,590
And then when I start mapping down, looking at successive elements, both y and dy are defined.

587
00:33:00,590 --> 00:33:08,660
So there's a little game you can play that goes a little bit beyond just using the delay that's hidden inside streams. Questions?

591
00:33:13,178 --> 00:33:14,428
OK, let's take a break.

593
00:34:07,300 --> 00:34:14,320
Well, just before the break, I'm not sure if you noticed it, but something nasty started to happen.

595
00:34:14,320 --> 00:34:34,389
We've been going along with the streams and divorcing time in the programs from time in the computers, and all that divorcing got hidden inside the streams. And then at the very end, we saw that sometimes in order to really take advantage of this method, you have to pull out other delays.

601
00:34:34,389 --> 00:34:39,030
You have to write some explicit delays that are not hidden inside that cons-stream.

603
00:34:39,030 --> 00:34:49,929
And I did a very simple example with differential equations, but if you have some very complicated system with all kinds of self-loops, it becomes very, very difficult to see where you need those delays.

607
00:34:49,929 --> 00:34:55,550
And if you leave them out by mistake, it becomes very, very difficult to see why the thing maybe isn't working.

609
00:34:55,550 --> 00:35:08,690
So that's kind of mess, that by getting this power and allowing us to use delay, we end up with some very complicated programming sometimes, because it can't all be hidden inside the streams.

613
00:35:08,690 --> 00:35:11,036
Well, is there a way out of that?

614
00:35:11,036 --> 00:35:13,480
Yeah, there is a way out of that.

615
00:35:13,480 --> 00:35:25,450
We could change the language so that all procedures acted like cons-stream, so that every procedure automatically has an implicit delay around its arguments.

618
00:35:25,450 --> 00:35:27,520
And what would that mean?

619
00:35:27,520 --> 00:35:32,210
That would mean when you call a procedure, the arguments wouldn't get evaluated.

621
00:35:32,210 --> 00:35:39,260
Instead, they'd only be evaluated when you need them, so they might be passed off to some other procedure, which wouldn't evaluate them either.

624
00:35:39,260 --> 00:35:42,150
So all these procedures would be passing promises around.

625
00:35:42,150 --> 00:35:52,380
And then finally maybe when you finally got down to having to look at the value of something that was handed to a primitive operator would you actually start calling in all those promises.

629
00:35:52,380 --> 00:36:02,920
If we did that, since everything would have a uniform delay, then you wouldn't have to write any explicit delays, because it would be automatically built into the way the language works.

633
00:36:02,920 --> 00:36:34,560
Or another way to say that, technically what I'm describing is what's called-- if we did that, our language would be so-called normal-order evaluation language versus what we've actually been working with, which is called applicative order--  versus applicative-order evaluation.

641
00:36:34,560 --> 00:36:36,835
And remember the substitution model for applicative order.

642
00:36:36,835 --> 00:36:43,590
It says when you go and evaluate a combination, you find the values of all the pieces.

644
00:36:43,590 --> 00:36:47,600
You evaluate the arguments and then you substitute them in the body of the procedure.

646
00:36:47,600 --> 00:36:49,890
Normal order says no, don't do that.

647
00:36:49,890 --> 00:36:58,640
What you do is effectively substitute in the body of the procedure, but instead of evaluating the arguments, you just put a promise to compute them there.

650
00:36:58,640 --> 00:37:09,340
Or another way to say that is you take the expressions for the arguments, if you like, and substitute them in the body of the procedure and go on, and never really simplify anything until you get down to a primitive operator.

654
00:37:09,340 --> 00:37:11,840
So that would be a normal-order language.

655
00:37:11,840 --> 00:37:13,490
Well, why don't we do that?

656
00:37:13,490 --> 00:37:18,940
Because if we did, we'd get all the advantages of delayed evaluation with none of the mess.

658
00:37:18,940 --> 00:37:24,710
In fact, if we did that and cons was just a delayed procedure, that would make cons the same as cons-stream.

660
00:37:24,710 --> 00:37:32,350
We wouldn't need streams of all because lists would automatically be streams. That's how lists would behave, and data structures would behave that way.

663
00:37:32,350 --> 00:37:35,270
Everything would behave that way, right?

664
00:37:35,270 --> 00:37:41,020
You'd never really do any computation until you actually needed the answer.

666
00:37:41,020 --> 00:37:44,790
You wouldn't have to worry about all these explicit annoying delays.

668
00:37:44,790 --> 00:37:47,160
Well, why don't we do that?

669
00:37:47,160 --> 00:37:49,230
First of all, I should say people do do that.

670
00:37:49,230 --> 00:37:51,850
There's some very beautiful languages.

671
00:37:51,850 --> 00:38:00,710
One of the very nicest is a language called Miranda, which is developed by David Turner at the University of Kent.

673
00:38:00,710 --> 00:38:01,930
And that's how this language works.

674
00:38:01,930 --> 00:38:14,970
It's a normal-order language and its data structures, which look like lists, are actually streams. And you write ordinary procedures in Miranda, and they do these prime things and eight queens things, just without anything special.

679
00:38:14,970 --> 00:38:17,790
It's all built in there.

680
00:38:17,790 --> 00:38:19,040
But there's a price.

682
00:38:21,190 --> 00:38:23,170
Remember how we got here.

683
00:38:23,170 --> 00:38:27,480
We're decoupling time in the programs from time in the machines.

685
00:38:27,480 --> 00:38:33,140
And if we put delay, that sort of decouples it everywhere, not just in streams. Remember what we're trying to do.

687
00:38:33,140 --> 00:38:39,300
We're trying to think about programming as a way to specify processes.

689
00:38:39,300 --> 00:38:47,030
And if we give up too much time, our language becomes more elegant, but it becomes a little bit less expressive.

691
00:38:47,030 --> 00:38:51,480
There are certain distinctions that we can't draw.

692
00:38:51,480 --> 00:38:53,980
One of them, for instance, is iteration.

693
00:38:53,980 --> 00:39:01,230
Remember this old procedure, iterative factorial, that we looked at quite a long time ago.

695
00:39:01,230 --> 00:39:12,120
Iterative factorial had a thing, and it said there was an internal procedure, and there was a state which was a product and a counter, and we iterate that going around the loop.

699
00:39:12,120 --> 00:39:15,730
And we said that was an iterative procedure because it didn't build up state.

701
00:39:15,730 --> 00:39:23,900
And the reason it didn't build up state is because this iter that's called is just passing these things around to itself.

703
00:39:23,900 --> 00:39:31,660
Or in the substitution model, you could see in the substitution model that Jerry did, that in an iterative procedure, that state doesn't have to grow.

706
00:39:31,660 --> 00:39:34,840
And in fact, we said it doesn't, so this is an iteration.

708
00:39:34,840 --> 00:39:41,150
But now think about this exact same text if we had a normal-order language.

710
00:39:41,150 --> 00:39:45,650
What would happen is this would no longer be an iterative procedure?

712
00:39:45,650 --> 00:39:52,330
And if you really think about the details of the substitution model, which I'm not going to do here, this expression would grow.

715
00:39:52,330 --> 00:39:53,280
Why would it grow?

716
00:39:53,280 --> 00:39:58,080
It's because when iter calls itself, it calls itself with this product.

718
00:39:58,080 --> 00:40:02,510
If it's a normal-order language, that multiplication is not going to get done.

720
00:40:02,510 --> 00:40:06,670
That's going to say I'm to call myself with a promise to compute this product.

722
00:40:06,670 --> 00:40:09,760
And now iter goes around again.

723
00:40:09,760 --> 00:40:18,400
And I'm going to call myself with a promise to compute this product where now one of the one factors is a promise.

725
00:40:18,400 --> 00:40:19,430
And I call myself again.

726
00:40:19,430 --> 00:40:31,790
And if you write out the substitution model for that iterative process, you'll see exactly the same growth in state, all those promises that are getting remembered that have to get called in at the very end.

730
00:40:31,790 --> 00:40:36,980
So one of the disadvantages is that you can't really express iteration.

732
00:40:36,980 --> 00:40:54,610
Maybe that's a little theoretical reason why not, but in fact, people who are trying to write real operating systems in these languages are running into exactly these types of problems. Like it's perfectly possible to implement a text editor in languages like these.

737
00:40:54,610 --> 00:41:10,230
But after you work a while, you suddenly have 3 megabytes of stuff, which is-- I guess they call them the dragging tail problem of people who are looking at these, of promises that sort of haven't been called in because you couldn't quite express an iteration.

743
00:41:10,230 --> 00:41:20,110
And one of the research questions in these kinds of languages are figuring out the right compiler technology to get rid of the so-called dragging tails.

746
00:41:20,110 --> 00:41:23,940
It's not simple.

747
00:41:23,940 --> 00:41:32,056
But there's another kind of more striking issue about why you just don't go ahead and make your language normal order.

750
00:41:32,056 --> 00:41:42,000
And the reason is that normal-order evaluation and side effects just don't mix.

752
00:41:42,000 --> 00:41:45,350
They just don't go together very well.

753
00:41:45,350 --> 00:42:00,400
Somehow, you can't-- it's sort of you can't simultaneously go around trying to model objects with local state and change and at the same time do these normal-order tricks of de-coupling time.

758
00:42:00,400 --> 00:42:03,790
Let me just show you a really simple example, very, very simple.

760
00:42:03,790 --> 00:42:07,520
Suppose we had a normal-order language.

761
00:42:07,520 --> 00:42:09,550
And I'm going to start out in this language.

762
00:42:09,550 --> 00:42:10,520
This is now normal order.

763
00:42:10,520 --> 00:42:13,570
I'm going to define x to be 0.

764
00:42:13,570 --> 00:42:15,750
It's just some variable I'll initialize.

765
00:42:15,750 --> 00:42:22,640
And now I'm going to define this little funny function, which is an identity function.

767
00:42:22,640 --> 00:42:26,770
And what it does, it keeps track of the last time you called it using x.

770
00:42:31,620 --> 00:42:36,760
So the identity of n just returns n, but it sets x to be n.

772
00:42:36,760 --> 00:42:42,580
And now I'll define a little increment function, which is a very little, simple scenario.

774
00:42:42,580 --> 00:42:47,230
Now, imagine I'm interacting with this in the normal-order language, and I type the following.

776
00:42:47,230 --> 00:42:54,190
I say define y to be increment the identity function of 3, so y is going to be 4.

779
00:42:57,410 --> 00:42:59,520
Now, I say what's x?

780
00:42:59,520 --> 00:43:04,710
Well, x should have been the value that was remembered last when I called the identity function.

782
00:43:04,710 --> 00:43:08,530
So you'd expect to say, well, x is 3 at this point, but it's not.

784
00:43:08,530 --> 00:43:17,000
Because when I defined y here, what I really defined y to be increment of a promise to do this thing.

786
00:43:17,000 --> 00:43:21,560
So I didn't look at y, so that identity function didn't get run.

788
00:43:21,560 --> 00:43:25,320
So if I type in this definition and look at x, I'm going to get 0.

791
00:43:28,360 --> 00:43:38,342
Now, if I go look at y and say what's y, say y is 4, looking at y, that very active looking at y caused the identity function to be run.

794
00:43:38,342 --> 00:43:40,740
And now x will get remembered as 3.

795
00:43:40,740 --> 00:43:42,020
So here x will be 0.

796
00:43:42,020 --> 00:43:43,280
Here, x will be 3.

797
00:43:43,280 --> 00:43:57,100
That's a tiny, little, simple scenario, but you can see what kind of a mess that's going to make for debugging interactive programs when you have normal-order evaluation.

800
00:43:57,100 --> 00:43:59,690
It's very confusing.

801
00:43:59,690 --> 00:44:09,780
But it's very confusing for a very deep reason, which is that the whole idea of putting in delays is that you throw away time.

804
00:44:09,780 --> 00:44:11,750
That's why we can have these infinite processes.

805
00:44:11,750 --> 00:44:17,790
Since we've thrown away time, we don't have to wait for them to run, right?

807
00:44:17,790 --> 00:44:28,760
We decouple the order of events in the computer from what we write in our programs. But when we talk about state and set and change, that's exactly what we do want control of.

811
00:44:28,760 --> 00:44:34,570
So it's almost as if there's this fundamental contradiction in what you want.

813
00:44:34,570 --> 00:44:42,410
And that brings us back to these sort of philosophical mutterings about what is it that you're trying to model and how do you look at the world.

816
00:44:42,410 --> 00:44:47,140
Or sometimes this is called the debate over functional programming.

819
00:44:53,570 --> 00:45:00,440
A so-called purely functional language is one that just doesn't have any side effects.

821
00:45:00,440 --> 00:45:06,360
Since you have no side effects, there's no assignment operator, so there are no terrible consequences of it.

823
00:45:06,360 --> 00:45:07,930
You can use a substitution-like thing.

824
00:45:07,930 --> 00:45:15,050
Programs really are like mathematics and not like models in the real world, not like objects in the real world.

827
00:45:15,050 --> 00:45:17,170
There are a lot of wonderful things about functional languages.

829
00:45:17,170 --> 00:45:29,260
Since there's no time, you never have any synchronization problems. And if you want to put something into a parallel algorithm, you can run the pieces of that parallel processing any way you want.

833
00:45:29,260 --> 00:45:33,640
There's just never any synchronization to worry that, and it's a very congenial environment for doing this.

835
00:45:33,640 --> 00:45:35,450
The price is you give up assignment.

837
00:45:39,060 --> 00:45:44,520
So an advocate of a functional language would say, gee, that's just a tiny price to pay.

839
00:45:44,520 --> 00:45:46,510
You probably shouldn't use assignment most of the time anyway.

841
00:45:46,510 --> 00:45:54,190
And if you just give up assignment, you can be in this much, much nicer world than this place with objects.

843
00:45:54,190 --> 00:45:56,300
Well, what's the rejoinder to that?

844
00:45:56,300 --> 00:46:00,300
Remember how we got into this mess.

845
00:46:00,300 --> 00:46:04,440
We started trying to model things that had local state.

846
00:46:04,440 --> 00:46:06,840
So remember Jerry's random number generator.

847
00:46:06,840 --> 00:46:14,080
There was this random number generator that had some little state in it to compute the next random number and the next random number and the next random number.

850
00:46:14,080 --> 00:46:21,050
And we wanted to hide that state away from the Cesaro compute part process, and that's why we needed set.

852
00:46:21,050 --> 00:46:24,070
We wanted to package that stated modularly.

853
00:46:24,070 --> 00:46:27,560
Well, a functional programming person would say, well, you're just all wet.

855
00:46:27,560 --> 00:46:29,840
I mean, you can write a perfectly good modular program.

857
00:46:29,840 --> 00:46:33,250
It's just you're thinking about modularity wrong.

858
00:46:33,250 --> 00:46:36,880
You're hung up in this next random number and the next random number and the next random number.

860
00:46:36,880 --> 00:46:39,880
Why don't you just say let's write a program.

861
00:46:39,880 --> 00:46:44,445
Let's write an enumerator which just generates an infinite stream of random numbers.

864
00:46:49,010 --> 00:46:54,540
We can sort of have that stream all at once, and that's going to be our source of random numbers.

866
00:46:54,540 --> 00:47:06,880
And then if you like, you can put that through some sort of processor, which is-- I don't know-- a Cesaro test, and that can do what it wants.

870
00:47:06,880 --> 00:47:28,140
And what would come out of there would be a stream of successive approximations to pi.

872
00:47:28,140 --> 00:47:35,540
So as we looked further down this stream, we'd tug on this Cesaro thing, and it would pull out more and more random numbers.

875
00:47:35,540 --> 00:47:39,720
And the further and further we look down the stream, the better an approximation we'd get to pi.

877
00:47:39,720 --> 00:47:43,890
And it would do exactly the same as the other computation, except we're thinking about the modularity different.

879
00:47:43,890 --> 00:47:49,400
We're saying imagine we had all those infinite streams of random numbers all at once.

881
00:47:49,400 --> 00:47:53,860
You can see the details of this procedure in the book.

882
00:47:53,860 --> 00:48:03,280
Similarly, there are other things that we tend to get locked into on this one and that one and the next one and the next one, which don't have to be that way.

885
00:48:03,280 --> 00:48:08,900
Like you might think about like a banking system, which is a very simple idea.

887
00:48:08,900 --> 00:48:12,210
Imagine we have a program that sort of represents a bank account.

890
00:48:18,810 --> 00:48:31,510
The bank account might have in it-- if we looked at this in a sort of message-passing view of the world, we'd say a bank account is an object that has some local state in there, which is the balance, say.

895
00:48:34,110 --> 00:48:48,560
And a user using this system comes and sends a transaction request. So the user sends a transaction request, like deposit some money, and the bank account maybe-- let's say the bank account always responds with what the current balance is.

900
00:48:48,560 --> 00:48:54,350
The user says let's deposits some money, and the bank account sends back a message which is the balance.

902
00:48:54,350 --> 00:48:59,150
And the user says deposit some more, and the bank account sends back a message.

904
00:48:59,150 --> 00:49:03,200
And just like the random number generator, you'd say, gee, we would like to use set.

906
00:49:03,200 --> 00:49:09,570
We'd like to have balance be a piece of local state inside this bank account because we want to separate the state of the user from the state of the bank account.

910
00:49:13,280 --> 00:49:16,420
Well, that's the message-processing view.

911
00:49:16,420 --> 00:49:22,740
There's a stream view with that thing, which does the same thing without any set or side effects.

913
00:49:22,740 --> 00:49:31,180
And the idea is again we don't think about anything having local state.

915
00:49:31,180 --> 00:49:38,640
We think about the bank account as something that's going to process a stream of transaction requests.

917
00:49:38,640 --> 00:49:49,490
So think about this bank account not as something that goes message by message, but something that takes in a stream of transaction requests like maybe successive deposit announced.

921
00:49:49,490 --> 00:49:55,940
1, 2, 2, 4, those might be successive amounts to deposit.

922
00:49:55,940 --> 00:50:03,770
And then coming out of it is the successive balances 1, 3, 5, 9.

924
00:50:03,770 --> 00:50:10,820
So we think of the bank account not as something that has state, but something that acts sort of on the infinite stream of requests.

927
00:50:10,820 --> 00:50:12,370
But remember, we've thrown away time.

928
00:50:12,370 --> 00:50:30,010
So what we can do is if the user's here, we can have this infinite stream of requests being generated one at a time coming from the user and this transaction stream coming back on a printer being printed one at a time.

932
00:50:30,010 --> 00:50:39,560
And if we drew a little line here, right there to the user, the user couldn't tell that this system doesn't have state.

935
00:50:39,560 --> 00:50:42,660
It looks just like the other one, but there's no state in there.

938
00:50:45,120 --> 00:50:53,835
And by the way, just to show you, here's an actual implementation of this-- we'll call it make deposit account because you can only deposit.

941
00:50:53,835 --> 00:51:00,020
It takes an initial balance and then a stream of deposits you might make.

943
00:51:00,020 --> 00:51:00,820
And what is it?

944
00:51:00,820 --> 00:51:18,300
Well, it's just cons-stream of the balance onto make a new account stream whose initial balance is the old balance plus the first thing in the deposit stream and make deposit account works on the rest of which is the tail of the deposit stream.

949
00:51:18,300 --> 00:51:28,790
So there's sort of a very typical message-passing, object-oriented thing that's done without side effects at all.

952
00:51:28,790 --> 00:51:32,250
There are very many things you can do this way.

953
00:51:32,250 --> 00:51:36,400
Well, can you do everything without assignment?

954
00:51:36,400 --> 00:51:40,050
Can everybody go over to purely functional languages?

955
00:51:40,050 --> 00:51:48,100
Well, we don't know, but there seem to be places where purely functional programming breaks down.

957
00:51:48,100 --> 00:51:58,850
Where it starts hurting is when you have things like this, but you also mix it up with the other things that we had to worry that, which are objects and sharing and two independent agents being the same.

961
00:51:58,850 --> 00:52:02,960
So under a typical one, suppose you want to extend this bank account.

963
00:52:02,960 --> 00:52:04,210
So here's a bank account.

965
00:52:12,220 --> 00:52:18,780
Bank accounts take in a stream of transaction requests and put out streams of, say, balances or responses to that.

967
00:52:18,780 --> 00:52:26,090
But suppose you want to model the fact that this is a joint bank account between two independent people.

969
00:52:26,090 --> 00:52:33,140
So suppose there are two people, say, Bill and Dave, who have a joint bank account.

972
00:52:35,960 --> 00:52:36,850
How would you model this?

973
00:52:36,850 --> 00:52:45,880
Well, Bill puts out a stream of transaction requests, and Dave puts out a stream of transaction requests, and somehow, they have to merge into this bank account.

976
00:52:45,880 --> 00:53:01,190
So what you might do is write a little stream processing thing called merge, which sort of takes these, merges them together, produces a single stream for the bank account.

979
00:53:01,190 --> 00:53:03,610
Now they're both talking to the same bank account.

980
00:53:03,610 --> 00:53:06,600
That's all great, but how do you write merge?

981
00:53:06,600 --> 00:53:09,730
What's this procedure merge?

982
00:53:09,730 --> 00:53:12,760
You want to do something that's reasonable.

983
00:53:12,760 --> 00:53:24,150
Your first guess might be to say, well, we'll take alternate requests from Bill and Dave. But what happens if suddenly in the middle of this thing, Dave goes away on vacation for two years?

987
00:53:24,150 --> 00:53:27,690
Then Bill's sort of stuck.

988
00:53:27,690 --> 00:53:29,750
So what you want to do is-- well, it's hard to describe.

989
00:53:29,750 --> 00:53:33,380
What you want to do is what people call fair merge.

991
00:53:38,410 --> 00:53:46,010
The idea of fair merge is it sort of should do them alternately, but if there's nothing waiting here, it should take one twice.

994
00:53:46,010 --> 00:53:48,450
Notice I can't even say that without talking about time.

996
00:53:51,300 --> 00:54:18,010
So one of the other active researcher areas in functional languages is inventing little things like fair merge and maybe some others, which will take the places where I used to need side effects and objects and sort of hide them away in some very well-defined modules of the system so that all the problems of assignment don't sort of leak out all over the system but are captured in some fairly well-understood things.

1005
00:54:20,780 --> 00:54:38,360
More generally, I think what you're seeing is that we're running across what I think is a very basic problem in computer science, which is how to define languages that somehow can talk about delayed evaluation, but also be able to reflect this view that there are objects in the world.

1011
00:54:38,360 --> 00:54:41,230
How do we somehow get both?

1012
00:54:41,230 --> 00:54:43,040
And I think that's a very hard problem.

1013
00:54:43,040 --> 00:54:53,840
And it may be that it's a very hard problem that has almost nothing to do with computer science, that it really is a problem having to do with two very incompatible ways of looking at the world.

1017
00:54:53,840 --> 00:54:55,090
OK, questions?

1019
00:55:17,556 --> 00:55:25,890
AUDIENCE: You mentioned earlier that once you introduce assignment, the general rule for using the substitution model is you can't.

1022
00:55:25,890 --> 00:55:27,570
Unless you're very careful, you can't.

1023
00:55:27,570 --> 00:55:28,260
PROFESSOR: Right.

1024
00:55:28,260 --> 00:55:40,300
AUDIENCE: Is there a set of techniques or a set of guidelines for localizing the effects of assignment so that the very careful becomes defined?

1027
00:55:40,300 --> 00:55:42,890
PROFESSOR: I don't know.

1028
00:55:42,890 --> 00:55:45,430
Let me think.

1029
00:55:45,430 --> 00:55:51,480
Well, certainly, there was an assignment inside memo proc, but that was sort of hidden away.

1031
00:55:51,480 --> 00:55:53,480
It ended up not making any difference.

1032
00:55:53,480 --> 00:56:00,390
Part of the reason for that is once this thing triggered that it had run and gotten an answer, that answer will never change.

1035
00:56:00,390 --> 00:56:02,080
So that was sort of a one-time assignment.

1036
00:56:02,080 --> 00:56:11,250
So one very general thing you can do is if you only do what's called a one-time assignment and never change anything, then you can do better.

1039
00:56:11,250 --> 00:56:18,490
One of the problems in this merge thing, people have-- let me see if this is right.

1041
00:56:18,490 --> 00:56:30,820
I think it's true that with fair merge, with just fair merge, you can begin effectively simulating assignment in the rest of the language.

1044
00:56:30,820 --> 00:56:39,520
It seems like anything you do to go outside-- I'm not quite sure that's true for fair merge, but it's true of a little bit more general things that people have been doing.

1048
00:56:39,520 --> 00:56:47,970
So it might be that any little bit you put in, suddenly if they allow you to build arbitrary stuff, it's almost as bad as having assignment altogether.

1051
00:56:47,970 --> 00:56:51,590
But that's an area that people are thinking about now.

1052
00:56:51,590 --> 00:57:04,730
AUDIENCE: I guess I don't see the problem here with merge if I call Bill, if Bill is a procedure, then Bill is going to increment the bank account or build the list that 's going to put in the next element.

1056
00:57:04,730 --> 00:57:07,170
If I call Dave twice in a row, that will do that.

1057
00:57:07,170 --> 00:57:09,350
I'm not sure where fair merge has to be involved.

1058
00:57:09,350 --> 00:57:11,200
PROFESSOR: The problem is imagine these really as people.

1060
00:57:11,200 --> 00:57:14,850
See, here I have the user who's interacting with this bank account.

1062
00:57:14,850 --> 00:57:15,960
Put in a request, get an answer.

1063
00:57:15,960 --> 00:57:17,070
Put in a request, get an answer.

1064
00:57:17,070 --> 00:57:18,200
AUDIENCE: Right.

1065
00:57:18,200 --> 00:57:24,220
PROFESSOR: But if the only way I can process request is to alternate them from two people-- AUDIENCE: Well, why would you alternate them?

1068
00:57:24,220 --> 00:57:25,070
PROFESSOR: Why don't I?

1069
00:57:25,070 --> 00:57:26,140
AUDIENCE: Yes.

1070
00:57:26,140 --> 00:57:26,580
Why do you?

1071
00:57:26,580 --> 00:57:27,640
PROFESSOR: Think of them as real people, right?

1072
00:57:27,640 --> 00:57:29,280
This guy might go away for a year.

1073
00:57:29,280 --> 00:57:35,480
And you're sitting here at the bank account window, and you can't put in two requests because it's waiting for this guy.

1076
00:57:35,480 --> 00:57:37,380
AUDIENCE: Why does it have to be waiting for one?

1077
00:57:37,380 --> 00:57:39,110
PROFESSOR: Because it's trying to compute a function.

1078
00:57:39,110 --> 00:57:41,720
I have to define a function.

1079
00:57:41,720 --> 00:57:51,690
Another way to say that is the answer to what comes out of this merge box is not a function of what goes in.

1081
00:57:51,690 --> 00:57:53,490
Because, see, what would the function be?

1082
00:57:53,490 --> 00:58:03,470
Suppose he puts in 1, 1, 1, 1, and he puts in 2, 2, 2, 2.

1083
00:58:03,470 --> 00:58:05,910
What's the answer supposed to be?

1084
00:58:05,910 --> 00:58:08,740
It's not good enough to say it's 1, 2, 1, 2, 1, 2.

1085
00:58:08,740 --> 00:58:09,390
AUDIENCE: I understand.

1086
00:58:09,390 --> 00:58:11,560
But when Bill puts in 1, 1 goes in.

1087
00:58:11,560 --> 00:58:13,950
When Dave puts in 2 twice, 2 goes in twice.

1088
00:58:13,950 --> 00:58:15,450
When Bill puts in-- PROFESSOR: Right.

1090
00:58:15,450 --> 00:58:23,980
AUDIENCE: Why can't it be hooked to the time of the input-- the actual procedural-- PROFESSOR: Because I don't have time.

1094
00:58:23,980 --> 00:58:26,900
See, all I can say is I'm going to define a function.

1095
00:58:26,900 --> 00:58:28,150
I don't have time.

1097
00:58:32,070 --> 00:58:38,420
There's no concept if it's going to alternate, except if nobody's there, it's going to wait a while for him.

1099
00:58:38,420 --> 00:58:47,810
It's just going to say I have the stream of requests, the timeless infinite streams of all the requests that Dave would have made, right?

1102
00:58:47,810 --> 00:58:51,690
And the timeless infinite stream of all the requests Bill would have made, and I want to operate on them.

1104
00:58:51,690 --> 00:58:53,510
See, that's how this bank account is working.

1106
00:58:56,710 --> 00:59:05,340
And the problem is that these poor people who are sitting at the bank account windows have the misfortune to exist in time.

1109
00:59:05,340 --> 00:59:10,070
They don't see their infinite stream of all the requests they would have ever made.

1111
00:59:10,070 --> 00:59:11,550
They're waiting now, and they want an answer.

1113
00:59:14,290 --> 00:59:25,290
So if you're sitting there-- if this is the screen operation on some time-sharing system and it's working functionally, you want an answer then when you talk the character.

1117
00:59:25,290 --> 00:59:30,910
You don't want it to have to wait for everybody in the whole system to have typed one character before it can get around to service you.

1120
00:59:30,910 --> 00:59:33,890
So that's the problem.

1121
00:59:33,890 --> 00:59:36,850
I mean, the fact that people live in time, apparently.

1122
00:59:36,850 --> 00:59:38,620
If they didn't, it wouldn't be a problem.

1124
00:59:49,100 --> 00:59:54,740
AUDIENCE: I'm afraid I miss the point of having no time in this banking transaction.

1126
00:59:54,740 --> 00:59:56,880
Isn't time very important?

1127
00:59:56,880 --> 01:00:00,790
For instance, the sequence of events.

1128
01:00:00,790 --> 01:00:08,400
If Dave take out $100, then the timing sequence should be important.

1130
01:00:08,400 --> 01:00:11,260
How do you treat transactions as streams?

1131
01:00:11,260 --> 01:00:14,260
PROFESSOR: Well, that's the thing I'm saying.

1132
01:00:14,260 --> 01:00:17,510
This is an example where you can't.

1133
01:00:17,510 --> 01:00:18,610
You can't.

1134
01:00:18,610 --> 01:00:24,170
The point is what comes out of here is simply not a function of the stream going in here and the stream going in here.

1136
01:00:24,170 --> 01:00:32,860
It's a function of the stream going in here and the stream going in here and some kind of information about time, which is precisely what a normal-order language won't let you say.

1141
01:00:34,810 --> 01:00:46,400
AUDIENCE: In order to brings this back into a more functional perspective, could we just explicitly time stamp all the inputs from Bill and Dave and define fair merge to just be the sort on those time stamps?

1146
01:00:49,150 --> 01:00:49,550
PROFESSOR: Yeah, you can do that.

1147
01:00:49,550 --> 01:00:50,600
You can do that sort of thing.

1148
01:00:50,600 --> 01:01:00,970
Another thing you could say is imagine that really what this function is, is that it does a read every microsecond, and then if there's none there, that's considered an empty one.

1152
01:01:00,970 --> 01:01:03,610
That's about equivalent to what you said.

1153
01:01:03,610 --> 01:01:07,110
And yes, you can do that, but that's a clg.

1154
01:01:07,110 --> 01:01:10,170
So it's not quite only implementation we're worried about.

1156
01:01:10,170 --> 01:01:18,824
We're worried about expressive power in the language, and what we're running across is a real mismatch between what we can say easily and what we'd like to say.

1159
01:01:18,824 --> 01:01:26,080
AUDIENCE: It sounds like where we're getting hung up with that is the fact it expects one input from both Bill and Dave at the same time.

1162
01:01:26,080 --> 01:01:28,530
PROFESSOR: It's not quite one, but it's anything you define.

1163
01:01:28,530 --> 01:01:36,110
So you can say Dave can go twice as often, but if anything you predefine, it's not the right thing.

1165
01:01:36,110 --> 01:01:41,930
You can't decide at some particular function of their input requests.

1167
01:01:41,930 --> 01:01:47,290
Worse yet, I mean, worse yet, there are things that even merge can't do.

1169
01:01:47,290 --> 01:01:52,470
One thing you might want to do that's even more general is suddenly you add somebody else to this bank account system.

1171
01:01:52,470 --> 01:01:56,030
You go and you add John to this bank account system.

1172
01:01:56,030 --> 01:02:02,040
And now there's yet another stream that's going to come into the picture at some time which we haven't prespecified.

1174
01:02:02,040 --> 01:02:08,860
So that's something even fair merge can't do, and they're things called-- I forget-- natagers or something.

1178
01:02:08,860 --> 01:02:11,790
That's a generalization of fair merge to allow that.

1179
01:02:11,790 --> 01:02:19,580
There's a whole sort of research discipline saying how far can you push this functional perspective by adding more and more mechanism?

1182
01:02:19,580 --> 01:02:25,610
And how far does that go before the whole thing breaks down and you might as well been using set anyway.

1184
01:02:25,610 --> 01:02:28,960
AUDIENCE: You need to set him up on automatic deposit.

1185
01:02:28,960 --> 01:02:39,630
[LAUGHTER]

1186
01:02:39,630 --> 01:02:40,880
PROFESSOR: OK, thank you.

