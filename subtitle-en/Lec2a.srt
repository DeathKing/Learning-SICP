0
00:00:00,000 --> 00:00:25,680


1
00:00:25,680 --> 00:00:27,960
PROFESSOR: Well, yesterday
was easy.

2
00:00:27,960 --> 00:00:33,020
You learned all of the rules
of programming and lived.

3
00:00:33,020 --> 00:00:34,980
Almost all of them.

4
00:00:34,980 --> 00:00:38,372
And so at this point, you're
now certified programmers--

5
00:00:38,372 --> 00:00:40,200
it says.

6
00:00:40,200 --> 00:00:48,890
However, I suppose what we did
is we, aah, sort of got you a

7
00:00:48,890 --> 00:00:51,700
little bit of into
an easy state.

8
00:00:51,700 --> 00:00:54,770
Here, you still believe it's
possible that this might be

9
00:00:54,770 --> 00:00:59,250
programming in BASIC or Pascal
with just a funny syntax.

10
00:00:59,250 --> 00:01:01,770
Today, that illusion--

11
00:01:01,770 --> 00:01:04,919
or you can no longer support
that belief.

12
00:01:04,919 --> 00:01:06,450
What we're going to do
today is going to

13
00:01:06,450 --> 00:01:08,340
completely smash that.

14
00:01:08,340 --> 00:01:13,590
So let's start out by writing
a few programs on the

15
00:01:13,590 --> 00:01:15,895
blackboard that have a lot in
common with each other.

16
00:01:15,895 --> 00:01:19,540
What we're going to do is try to
make them abstractions that

17
00:01:19,540 --> 00:01:23,880
are not ones that are easy to
make in most languages.

18
00:01:23,880 --> 00:01:26,040
Let's start with some very
simple ones that you can make

19
00:01:26,040 --> 00:01:28,070
in most languages.

20
00:01:28,070 --> 00:01:32,130
Supposing I want to write the
mathematical expression which

21
00:01:32,130 --> 00:01:34,100
adds up a bunch of integers.

22
00:01:34,100 --> 00:01:38,850
So if I wanted to write down
and say the sum from i

23
00:01:38,850 --> 00:01:41,410
equal a to b on i.

24
00:01:41,410 --> 00:01:44,190
Now, you know that that's an
easy thing to compute in a

25
00:01:44,190 --> 00:01:46,180
closed form for it, and I'm
not interested in that.

26
00:01:46,180 --> 00:01:47,140
But I'm going to write
a program that

27
00:01:47,140 --> 00:01:49,045
adds up those integers.

28
00:01:49,045 --> 00:01:57,890
Well, that's rather easy to do
to say I want to define the

29
00:01:57,890 --> 00:02:08,710
sum of the integers from
a to b to be--

30
00:02:08,710 --> 00:02:11,380
well, it's the following
two possibilities.

31
00:02:11,380 --> 00:02:17,430
If a is greater than b, well,
then there's nothing to be

32
00:02:17,430 --> 00:02:19,582
done and the answer is zero.

33
00:02:19,582 --> 00:02:22,530
This is how you're going to
have to think recursively.

34
00:02:22,530 --> 00:02:24,880
You're going to say if I have
an easy case that I know the

35
00:02:24,880 --> 00:02:26,610
answer to, just write it down.

36
00:02:26,610 --> 00:02:29,890
Otherwise, I'm going to try to
reduce this problem to a

37
00:02:29,890 --> 00:02:31,060
simpler problem.

38
00:02:31,060 --> 00:02:33,000
And maybe in this case, I'm
going to make a subproblem of

39
00:02:33,000 --> 00:02:35,340
the simpler problem and then
do something to the result.

40
00:02:35,340 --> 00:02:41,290
So the easiest way to do this
is say that I'm going to add

41
00:02:41,290 --> 00:02:46,530
the index, which in this case is
a, to the result of adding

42
00:02:46,530 --> 00:02:57,960
up the integers from
a plus 1 to b.

43
00:02:57,960 --> 00:03:02,343


44
00:03:02,343 --> 00:03:04,460
Now, at this point, you should
have no trouble looking at

45
00:03:04,460 --> 00:03:06,190
such a definition.

46
00:03:06,190 --> 00:03:09,740
Indeed, coming up with such a
thing might be a little hard

47
00:03:09,740 --> 00:03:12,230
in synthesis, but being able
to read it at this point

48
00:03:12,230 --> 00:03:13,840
should be easy.

49
00:03:13,840 --> 00:03:18,220
And what it says to you is,
well, here is the subproblem

50
00:03:18,220 --> 00:03:19,520
I'm going to solve.

51
00:03:19,520 --> 00:03:24,240
I'm going to try to add up the
integers, one fewer integer

52
00:03:24,240 --> 00:03:26,970
than I added up for the
the whole problem.

53
00:03:26,970 --> 00:03:31,270
I'm adding up the one fewer one,
and that subproblem, once

54
00:03:31,270 --> 00:03:35,150
I've solved it, I'm going to add
a to that, and that will

55
00:03:35,150 --> 00:03:38,550
be the answer to this problem.

56
00:03:38,550 --> 00:03:41,626
And the simplest case, I don't
have to do any work.

57
00:03:41,626 --> 00:03:44,990
Now, I'm also going to write
down another simple one just

58
00:03:44,990 --> 00:03:49,617
like this, which is the
mathematical expression, the

59
00:03:49,617 --> 00:03:55,840
sum of the square from
i equal a to b.

60
00:03:55,840 --> 00:03:58,055
And again, it's a very
simple program.

61
00:03:58,055 --> 00:04:11,220


62
00:04:11,220 --> 00:04:13,510
And indeed, it starts
the same way.

63
00:04:13,510 --> 00:04:16,029


64
00:04:16,029 --> 00:04:21,240
If a is greater than b, then
the answer is zero.

65
00:04:21,240 --> 00:04:24,160
And, of course, we're beginning
to see that there's

66
00:04:24,160 --> 00:04:27,980
something wrong with me writing
this down again.

67
00:04:27,980 --> 00:04:29,820
It's the same program.

68
00:04:29,820 --> 00:04:42,180
It's the sum of the square of a
and the sum of the square of

69
00:04:42,180 --> 00:04:46,134
the increment and b.

70
00:04:46,134 --> 00:04:50,880


71
00:04:50,880 --> 00:04:54,070
Now, if you look at these
things, these programs are

72
00:04:54,070 --> 00:04:56,380
almost identical.

73
00:04:56,380 --> 00:04:59,860
There's not much to
distinguish them.

74
00:04:59,860 --> 00:05:03,140
They have the same first clause
of the conditional and

75
00:05:03,140 --> 00:05:06,250
the same predicate and the
same consequence, and the

76
00:05:06,250 --> 00:05:08,910
alternatives are very
similar, too.

77
00:05:08,910 --> 00:05:15,510
They only differ by the fact
that where here I have a,

78
00:05:15,510 --> 00:05:17,336
here, I have the square of a.

79
00:05:17,336 --> 00:05:22,020
The only other difference, but
this one's sort of unessential

80
00:05:22,020 --> 00:05:25,240
is in the name of this procedure
is sum int, whereas

81
00:05:25,240 --> 00:05:27,560
the name of the procedure
is sum square.

82
00:05:27,560 --> 00:05:29,820
So the things that vary
between these

83
00:05:29,820 --> 00:05:33,250
two are very small.

84
00:05:33,250 --> 00:05:36,080
Now, wherever you see yourself
writing the same thing down

85
00:05:36,080 --> 00:05:38,340
more than once, there's
something wrong, and you

86
00:05:38,340 --> 00:05:40,280
shouldn't be doing it.

87
00:05:40,280 --> 00:05:43,420
And the reason is not because
it's a waste of time to write

88
00:05:43,420 --> 00:05:45,540
something down more than once.

89
00:05:45,540 --> 00:05:50,720
It's because there's some idea
here, a very simple idea,

90
00:05:50,720 --> 00:05:54,620
which has to do with the
sigma notation--

91
00:05:54,620 --> 00:05:57,330
this much--

92
00:05:57,330 --> 00:06:01,255
not depending upon what
it is I'm adding up.

93
00:06:01,255 --> 00:06:03,070
And I would like
to be able to--

94
00:06:03,070 --> 00:06:05,610
always, whenever trying to make
complicated systems and

95
00:06:05,610 --> 00:06:08,575
understand them, it's crucial
to divide the things up into

96
00:06:08,575 --> 00:06:11,030
as many pieces as I can, each
of which I understand

97
00:06:11,030 --> 00:06:13,050
separately.

98
00:06:13,050 --> 00:06:15,030
I would like to understand the
way of adding things up

99
00:06:15,030 --> 00:06:19,540
independently of what it is I'm
adding up so I can do that

100
00:06:19,540 --> 00:06:24,260
having debugged it once and
understood it once and having

101
00:06:24,260 --> 00:06:29,400
been able to share that among
many different uses of it.

102
00:06:29,400 --> 00:06:32,360
Here, we have another example.

103
00:06:32,360 --> 00:06:40,400
This is Leibnitz's formula
for finding pi over 8.

104
00:06:40,400 --> 00:06:43,460
It's a funny, ugly mess.

105
00:06:43,460 --> 00:06:43,930
What is it?

106
00:06:43,930 --> 00:06:50,670
It's something like 1 over 1
times 3 plus 1 over 5 times 7

107
00:06:50,670 --> 00:06:54,340
plus 1 over 9 times 11 plus--

108
00:06:54,340 --> 00:06:59,750
and for some reason, things
like this tend to have

109
00:06:59,750 --> 00:07:02,160
interesting values
like pi over 8.

110
00:07:02,160 --> 00:07:04,460
But what do we see here?

111
00:07:04,460 --> 00:07:07,850
It's the same program or almost
the same program.

112
00:07:07,850 --> 00:07:09,290
It's a sum.

113
00:07:09,290 --> 00:07:12,660
So we're seeing the figure
notation, although over here,

114
00:07:12,660 --> 00:07:17,320
we're dealing with incrementing
by 4, so it's a

115
00:07:17,320 --> 00:07:20,550
slightly different problem,
which means that over here, I

116
00:07:20,550 --> 00:07:25,560
have to change a by 4, as
you see right over here.

117
00:07:25,560 --> 00:07:28,390
It's not by 1.

118
00:07:28,390 --> 00:07:31,150
The other thing, of course,
is that the thing that's

119
00:07:31,150 --> 00:07:34,805
represented by square in the
previous sum of squares, or a

120
00:07:34,805 --> 00:07:36,400
when adding up the integers.

121
00:07:36,400 --> 00:07:38,060
Well, here, I have a different
thing I'm adding up, a

122
00:07:38,060 --> 00:07:44,290
different term, which is 1
over a times a plus 2.

123
00:07:44,290 --> 00:07:45,875
But the rest of this program
is identical.

124
00:07:45,875 --> 00:07:48,530


125
00:07:48,530 --> 00:07:50,640
Well, any time we have a bunch
of things like this that are

126
00:07:50,640 --> 00:07:53,200
identical, we're going to have
to come up with some sort of

127
00:07:53,200 --> 00:07:55,582
abstraction to cover them.

128
00:07:55,582 --> 00:07:59,920
If you think about this, what
you've learned so far is the

129
00:07:59,920 --> 00:08:03,370
rules of some language, some
primitive, some means of

130
00:08:03,370 --> 00:08:06,310
combination, almost all
of them, the means of

131
00:08:06,310 --> 00:08:09,730
abstraction, almost
all of them.

132
00:08:09,730 --> 00:08:13,290
But what you haven't learned is
common patterns of usage.

133
00:08:13,290 --> 00:08:15,150
Now, most of the time, you learn
idioms when learning a

134
00:08:15,150 --> 00:08:18,380
language, which is a common
pattern that mean things that

135
00:08:18,380 --> 00:08:20,760
are useful to know in a flash.

136
00:08:20,760 --> 00:08:22,760
And if you build a great number
of them, if you're a

137
00:08:22,760 --> 00:08:26,180
FORTRAN programmer, of course,
everybody knows how to--

138
00:08:26,180 --> 00:08:29,640
what do you do, for example, to
get an integer which is the

139
00:08:29,640 --> 00:08:31,250
biggest integer in something.

140
00:08:31,250 --> 00:08:32,600
It's a classic thing.

141
00:08:32,600 --> 00:08:34,350
Every FORTRAN programmer
knows how to do that.

142
00:08:34,350 --> 00:08:36,059
And if you don't know that,
you're in real hot water

143
00:08:36,059 --> 00:08:38,150
because it takes a long
time to think it out.

144
00:08:38,150 --> 00:08:41,620
However, one of the things you
can do in this language that

145
00:08:41,620 --> 00:08:43,900
we're showing you is not only
do you know something like

146
00:08:43,900 --> 00:08:48,380
that, but you give the knowledge
of that a name.

147
00:08:48,380 --> 00:08:50,500
And so that's what we're going
to be going after right now.

148
00:08:50,500 --> 00:08:53,530


149
00:08:53,530 --> 00:08:55,860
OK, well, let's see what these
things have in common.

150
00:08:55,860 --> 00:08:58,680


151
00:08:58,680 --> 00:09:02,560
Right over here we have what
appears to be a general

152
00:09:02,560 --> 00:09:06,470
pattern, a general pattern which
covers all of the cases

153
00:09:06,470 --> 00:09:09,700
we've seen so far.

154
00:09:09,700 --> 00:09:15,200
There is a sum procedure,
which is being defined.

155
00:09:15,200 --> 00:09:17,680
It has two arguments, which
are a lower bound

156
00:09:17,680 --> 00:09:19,630
and an upper bound.

157
00:09:19,630 --> 00:09:23,150
The lower bound is tested to
be greater than the upper

158
00:09:23,150 --> 00:09:27,590
bound, and if it is greater,
then the result is zero.

159
00:09:27,590 --> 00:09:31,640
Otherwise, we're going to do
something to the lower bound,

160
00:09:31,640 --> 00:09:35,540
which is the index of the
conversation, and add that

161
00:09:35,540 --> 00:09:40,150
result to the result of
following the procedure

162
00:09:40,150 --> 00:09:45,050
recursively on our lower bound
incremented by some next

163
00:09:45,050 --> 00:09:49,605
operation with the same upper
bound as I had before.

164
00:09:49,605 --> 00:09:53,710


165
00:09:53,710 --> 00:09:59,230
So this is a general pattern,
and what I'd like to do is be

166
00:09:59,230 --> 00:10:03,610
able to name this general
pattern a bit.

167
00:10:03,610 --> 00:10:06,550
Well, that's sort of easy,
because one of the things I'm

168
00:10:06,550 --> 00:10:09,610
going to do right now is--
there's nothing very special

169
00:10:09,610 --> 00:10:11,790
about numbers.

170
00:10:11,790 --> 00:10:14,790
Numbers are just one
kind of data.

171
00:10:14,790 --> 00:10:17,570
It seems to me perfectly
reasonable to give all sorts

172
00:10:17,570 --> 00:10:23,260
of names to all kinds of data,
for example, procedures.

173
00:10:23,260 --> 00:10:26,370
And now many languages allow you
have procedural arguments,

174
00:10:26,370 --> 00:10:27,830
and right now, we're
going to talk

175
00:10:27,830 --> 00:10:29,120
about procedural arguments.

176
00:10:29,120 --> 00:10:31,280
They're very easy
to deal with.

177
00:10:31,280 --> 00:10:33,300
And shortly, we'll do some
remarkable things that are not

178
00:10:33,300 --> 00:10:35,730
like procedural arguments.

179
00:10:35,730 --> 00:10:43,190
So here, we'll define
our sigma notation.

180
00:10:43,190 --> 00:10:55,450
This is called sum and it takes
a term, an A, a next

181
00:10:55,450 --> 00:11:00,190
term, and B as arguments.

182
00:11:00,190 --> 00:11:03,420
So it takes four arguments,
and there was nothing

183
00:11:03,420 --> 00:11:06,580
particularly special about me
writing this in lowercase.

184
00:11:06,580 --> 00:11:08,700
I hope that it doesn't confuse
you, so I'll write it in

185
00:11:08,700 --> 00:11:09,930
uppercase right now.

186
00:11:09,930 --> 00:11:11,180
The machine doesn't care.

187
00:11:11,180 --> 00:11:14,350


188
00:11:14,350 --> 00:11:17,180
But these two arguments
are different.

189
00:11:17,180 --> 00:11:19,360
These are not numbers.

190
00:11:19,360 --> 00:11:21,600
These are going to be procedures
for computing

191
00:11:21,600 --> 00:11:23,690
something given a number.

192
00:11:23,690 --> 00:11:26,590
Term will be a procedure which,
when given an index,

193
00:11:26,590 --> 00:11:29,920
will produce the value of
the term for that index.

194
00:11:29,920 --> 00:11:31,660
Next will be given an
index, which will

195
00:11:31,660 --> 00:11:34,050
produce the next index.

196
00:11:34,050 --> 00:11:36,000
This will be for counting.

197
00:11:36,000 --> 00:11:37,250
And it's very simple.

198
00:11:37,250 --> 00:11:40,590


199
00:11:40,590 --> 00:11:43,400
It's exactly what you see.

200
00:11:43,400 --> 00:11:52,220
If A is greater than B,
then the result is 0.

201
00:11:52,220 --> 00:12:04,970
Otherwise, it's the sum of term
applied to A and the sum

202
00:12:04,970 --> 00:12:10,410
of term, next index.

203
00:12:10,410 --> 00:12:14,990


204
00:12:14,990 --> 00:12:16,480
Let me write it this way.

205
00:12:16,480 --> 00:12:29,370


206
00:12:29,370 --> 00:12:32,160
Now, I'd like you to see
something, first of all.

207
00:12:32,160 --> 00:12:35,210
I was writing here, and
I ran out of space.

208
00:12:35,210 --> 00:12:38,110
What I did is I start indenting
according to the

209
00:12:38,110 --> 00:12:41,080
Pretty-printing rule, which says
that I align all of the

210
00:12:41,080 --> 00:12:44,340
arguments of the procedure
so I can see

211
00:12:44,340 --> 00:12:47,060
which ones go together.

212
00:12:47,060 --> 00:12:49,840
And this is just something I do
automatically, and I want

213
00:12:49,840 --> 00:12:51,530
you to learn how to do that,
too, so your programs can be

214
00:12:51,530 --> 00:12:52,780
read and understood.

215
00:12:52,780 --> 00:12:54,750


216
00:12:54,750 --> 00:12:57,610
However, what do we have here?

217
00:12:57,610 --> 00:13:01,730
We have four arguments: the
procedure, the lower index--

218
00:13:01,730 --> 00:13:03,670
lower bound index--

219
00:13:03,670 --> 00:13:09,010
the way to get the next index,
and the upper bound.

220
00:13:09,010 --> 00:13:13,890
What's passed along on the
recursive call is indeed the

221
00:13:13,890 --> 00:13:18,110
same procedure because I'm going
to need it again, the

222
00:13:18,110 --> 00:13:21,260
next index, which is using the
next procedure to compute it,

223
00:13:21,260 --> 00:13:23,332
the procedure for computing
next, which I also have to

224
00:13:23,332 --> 00:13:25,250
have separately, and
that's different.

225
00:13:25,250 --> 00:13:27,940
The procedure for computing
next is different from the

226
00:13:27,940 --> 00:13:30,680
next index, which is the result
of using next on the

227
00:13:30,680 --> 00:13:32,510
last index.

228
00:13:32,510 --> 00:13:34,210
And I also have to pass
along the upper bound.

229
00:13:34,210 --> 00:13:37,090


230
00:13:37,090 --> 00:13:44,850
So this captures both of these
and the other nice program

231
00:13:44,850 --> 00:13:47,810
that we are playing with.

232
00:13:47,810 --> 00:13:52,740
So using this, we can write down
the original program as

233
00:13:52,740 --> 00:13:56,260
instances of sum very simply.

234
00:13:56,260 --> 00:14:08,880


235
00:14:08,880 --> 00:14:17,620
A and B. Well, I'm going to
need an identity procedure

236
00:14:17,620 --> 00:14:29,440
here because ,ahh, the sum of
the integers requires me to in

237
00:14:29,440 --> 00:14:33,020
this case compute a term for
every integer, but the term

238
00:14:33,020 --> 00:14:35,560
procedure doesn't want to do
anything to that integer.

239
00:14:35,560 --> 00:14:41,460
So the identity procedure on A
is A or X or whatever, and I

240
00:14:41,460 --> 00:14:52,420
want to say the sum of using
identity of the term procedure

241
00:14:52,420 --> 00:14:58,400
and using A as the initial
index and the incrementer

242
00:14:58,400 --> 00:15:05,552
being the way to get the next
index and B being the high

243
00:15:05,552 --> 00:15:07,870
bound, the upper bound.

244
00:15:07,870 --> 00:15:12,010
This procedure does exactly
the same as the sum of the

245
00:15:12,010 --> 00:15:14,140
integers over here, computes
the same answer.

246
00:15:14,140 --> 00:15:17,690


247
00:15:17,690 --> 00:15:21,520
Now, one thing you should see,
of course, is that there's

248
00:15:21,520 --> 00:15:25,220
nothing very special over here
about what I used as the

249
00:15:25,220 --> 00:15:25,990
formal parameter.

250
00:15:25,990 --> 00:15:27,230
I could have, for example,
written this

251
00:15:27,230 --> 00:15:29,690
X. It doesn't matter.

252
00:15:29,690 --> 00:15:33,760
I just wanted you to see that
this name does not conflict

253
00:15:33,760 --> 00:15:35,140
with this one at all.

254
00:15:35,140 --> 00:15:37,850
It's an internal name.

255
00:15:37,850 --> 00:15:40,500
For the second procedure here,
the sum of the squares, it's

256
00:15:40,500 --> 00:15:41,750
even a little bit easier.

257
00:15:41,750 --> 00:15:53,760


258
00:15:53,760 --> 00:15:54,850
And what do we have to do?

259
00:15:54,850 --> 00:16:02,560
Nothing more than add up the
squares, this is the procedure

260
00:16:02,560 --> 00:16:05,620
that each index will be given,
will be given each--

261
00:16:05,620 --> 00:16:06,780
yes.

262
00:16:06,780 --> 00:16:10,410
Each index will have this done
to it to get the term.

263
00:16:10,410 --> 00:16:13,570
That's the thing that maps
against term over here.

264
00:16:13,570 --> 00:16:18,810
Then I have A as the lower
bound, the incrementer as the

265
00:16:18,810 --> 00:16:21,520
next term method, and B
as the upper bound.

266
00:16:21,520 --> 00:16:26,780


267
00:16:26,780 --> 00:16:29,030
And finally, just for the thing
that we did about pi

268
00:16:29,030 --> 00:16:33,270
sums, pi sums are sort of--

269
00:16:33,270 --> 00:16:35,840
well, it's even easier to think
about them this way

270
00:16:35,840 --> 00:16:36,610
because I don't have to think.

271
00:16:36,610 --> 00:16:41,110
What I'm doing is separating the
thing I'm adding up from

272
00:16:41,110 --> 00:16:43,340
the method of doing
the addition.

273
00:16:43,340 --> 00:16:57,200
And so we have here, for
example, pi sum A B

274
00:16:57,200 --> 00:16:59,890
of the sum of things.

275
00:16:59,890 --> 00:17:03,350
I'm going to write the terms
procedure here explicitly

276
00:17:03,350 --> 00:17:05,670
without giving it a name.

277
00:17:05,670 --> 00:17:07,119
This is done anonymously.

278
00:17:07,119 --> 00:17:10,960
I don't necessarily have to give
a name to something if I

279
00:17:10,960 --> 00:17:12,310
just want to use it once.

280
00:17:12,310 --> 00:17:18,050
And, of course, I can write
sort of a expression that

281
00:17:18,050 --> 00:17:19,579
produces a procedure.

282
00:17:19,579 --> 00:17:22,740
I'm going to write the Greek
lambda letter here instead of

283
00:17:22,740 --> 00:17:26,220
L-A-M-B-D-A in general to avoid
taking up a lot of space

284
00:17:26,220 --> 00:17:27,240
on blackboards.

285
00:17:27,240 --> 00:17:28,270
But unfortunately,
we don't have

286
00:17:28,270 --> 00:17:29,960
lambda keys on our keyboards.

287
00:17:29,960 --> 00:17:32,170
Maybe we can convince our
friends in the computer

288
00:17:32,170 --> 00:17:34,040
industry that this
is an important.

289
00:17:34,040 --> 00:17:43,480
Lambda of i is the quotient of 1
and the product of i and the

290
00:17:43,480 --> 00:17:58,020
sum of i 2, starting at a with
the way of incrementing being

291
00:17:58,020 --> 00:18:08,666
that procedure of an index i,
which adds i to 4, and b being

292
00:18:08,666 --> 00:18:09,916
the upper bound.

293
00:18:09,916 --> 00:18:12,270


294
00:18:12,270 --> 00:18:17,490
So you can see that this
notation, the invention of the

295
00:18:17,490 --> 00:18:21,370
procedure that takes a
procedural argument, allows us

296
00:18:21,370 --> 00:18:26,066
to compress a lot of these
procedures into one thing.

297
00:18:26,066 --> 00:18:32,780
This procedure, sums, covers
a whole bunch of ideas.

298
00:18:32,780 --> 00:18:34,740
Now, just why is
this important?

299
00:18:34,740 --> 00:18:37,370
I tried to say before that it
helps us divide a problem into

300
00:18:37,370 --> 00:18:42,760
two pieces, and indeed, it does,
for example, if someone

301
00:18:42,760 --> 00:18:46,570
came up with a different way of
implementing this, which,

302
00:18:46,570 --> 00:18:50,010
of course, one might.

303
00:18:50,010 --> 00:18:51,230
Here, for example, an iterative

304
00:18:51,230 --> 00:18:52,480
implementation of sum.

305
00:18:52,480 --> 00:18:55,900


306
00:18:55,900 --> 00:18:59,470
Iterative implementation for
some reason might be better

307
00:18:59,470 --> 00:19:00,840
than the recursive
implementation.

308
00:19:00,840 --> 00:19:03,670


309
00:19:03,670 --> 00:19:06,460
But the important thing is
that it's different.

310
00:19:06,460 --> 00:19:09,460
Now, supposing I had written my
program this way that you

311
00:19:09,460 --> 00:19:14,310
see on the blackboard
on the left.

312
00:19:14,310 --> 00:19:17,810
That's correct, the left.

313
00:19:17,810 --> 00:19:22,280
Well, then if I want to change
the method of addition, then

314
00:19:22,280 --> 00:19:25,200
I'd have to change
each of these.

315
00:19:25,200 --> 00:19:30,210
Whereas if I write them like
this that you see here, then

316
00:19:30,210 --> 00:19:32,430
the method by which I did the
addition is encapsulated in

317
00:19:32,430 --> 00:19:34,850
the procedure sum.

318
00:19:34,850 --> 00:19:37,780
That decomposition allows me
to independently change one

319
00:19:37,780 --> 00:19:43,210
part of the program and prove
it perhaps without changing

320
00:19:43,210 --> 00:19:45,052
the other part that was
written for some

321
00:19:45,052 --> 00:19:46,630
of the other cases.

322
00:19:46,630 --> 00:19:50,366


323
00:19:50,366 --> 00:19:51,010
Thank you.

324
00:19:51,010 --> 00:19:52,420
Are there any questions?

325
00:19:52,420 --> 00:19:53,190
Yes, sir.

326
00:19:53,190 --> 00:19:55,150
AUDIENCE: Would you go over
next A and next again on--

327
00:19:55,150 --> 00:19:55,640
PROFESSOR: Yes.

328
00:19:55,640 --> 00:19:56,680
It's the same problem.

329
00:19:56,680 --> 00:19:57,900
I'm sure you're going to--

330
00:19:57,900 --> 00:19:59,160
you're going to have
to work on this.

331
00:19:59,160 --> 00:20:01,280
This is hard the first
time you've ever seen

332
00:20:01,280 --> 00:20:02,460
something like this.

333
00:20:02,460 --> 00:20:06,300
What I have here is
a-- procedures

334
00:20:06,300 --> 00:20:07,550
can be named by variables.

335
00:20:07,550 --> 00:20:10,020


336
00:20:10,020 --> 00:20:12,710
Procedures are not special.

337
00:20:12,710 --> 00:20:15,230
Actually, sum square is a
variable, which has gotten a

338
00:20:15,230 --> 00:20:18,640
value, which is a procedure.

339
00:20:18,640 --> 00:20:20,030
This is define sum square to be

340
00:20:20,030 --> 00:20:23,310
lambda of A and B something.

341
00:20:23,310 --> 00:20:24,700
So the procedure can be named.

342
00:20:24,700 --> 00:20:27,900
Therefore, they can be passed
from one to another, one

343
00:20:27,900 --> 00:20:31,430
procedure to another,
as arguments.

344
00:20:31,430 --> 00:20:33,630
Well, what we're doing here is
we're passing the procedure

345
00:20:33,630 --> 00:20:38,190
term as an argument to sum just
when we get it around in

346
00:20:38,190 --> 00:20:41,060
the next recursive.

347
00:20:41,060 --> 00:20:45,350
Here, we're passing
the procedure next

348
00:20:45,350 --> 00:20:47,630
as an argument also.

349
00:20:47,630 --> 00:20:50,120
However, here we're using
the procedure next.

350
00:20:50,120 --> 00:20:51,690
That's what the parentheses
mean.

351
00:20:51,690 --> 00:20:56,750
We're applying next to A to get
the next value of A. If

352
00:20:56,750 --> 00:20:59,390
you look at what next is mapped
against, remember that

353
00:20:59,390 --> 00:21:02,390
the way you think about this
is that you substitute the

354
00:21:02,390 --> 00:21:06,800
arguments for the formal
parameters in the body.

355
00:21:06,800 --> 00:21:10,590
If you're ever confused, think
of the thing that way.

356
00:21:10,590 --> 00:21:14,730
Well, over here, with
sum of the integers.

357
00:21:14,730 --> 00:21:21,150
I substitute identity for
a term and 1 plus the

358
00:21:21,150 --> 00:21:26,070
incrementer for next
in the body.

359
00:21:26,070 --> 00:21:30,600
Well, the identity procedure
on A is what I get here.

360
00:21:30,600 --> 00:21:35,170
Identity is being passed
along, and here, I have

361
00:21:35,170 --> 00:21:41,040
increment 1 plus being applied
to A and 1 plus is being

362
00:21:41,040 --> 00:21:42,980
passed along.

363
00:21:42,980 --> 00:21:46,340
Does that clarify
the situation?

364
00:21:46,340 --> 00:21:49,355
AUDIENCE: We could also define
explicitly those two

365
00:21:49,355 --> 00:21:51,300
functions, then pass them.

366
00:21:51,300 --> 00:21:52,360
PROFESSOR: Sure.

367
00:21:52,360 --> 00:21:54,950
What we can do is we could have
given names to them, just

368
00:21:54,950 --> 00:21:55,770
like I did here.

369
00:21:55,770 --> 00:21:57,530
In fact, I gave you various
ways so you

370
00:21:57,530 --> 00:21:59,390
could see it, a variety.

371
00:21:59,390 --> 00:22:05,130
Here, I define the thing which
I passed the name of.

372
00:22:05,130 --> 00:22:07,850
I referenced it by its name.

373
00:22:07,850 --> 00:22:10,400
But the thing is, in fact, that
procedure, one argument

374
00:22:10,400 --> 00:22:14,300
X, which is X. And the identity
procedure is just

375
00:22:14,300 --> 00:22:20,870
lambda of X X. And that's
what you're seeing here.

376
00:22:20,870 --> 00:22:26,190
Here, I happened to just write
its canonical name there for

377
00:22:26,190 --> 00:22:27,440
you to see.

378
00:22:27,440 --> 00:22:31,730


379
00:22:31,730 --> 00:22:33,020
Is it OK if we take our
five-minute break?

380
00:22:33,020 --> 00:23:15,850


381
00:23:15,850 --> 00:23:19,780
As I said, computers to make
people happy, not people to

382
00:23:19,780 --> 00:23:21,070
make computers happy.

383
00:23:21,070 --> 00:23:23,080
And for the most part, the
reason why we introduce all

384
00:23:23,080 --> 00:23:26,440
this abstraction stuff is to
make it so that programs can

385
00:23:26,440 --> 00:23:29,940
be more easily written
and more easily read.

386
00:23:29,940 --> 00:23:32,930
Let's try to understand what's
the most complicated program

387
00:23:32,930 --> 00:23:36,280
we've seen so far using
a little bit of

388
00:23:36,280 --> 00:23:38,120
this abstraction stuff.

389
00:23:38,120 --> 00:23:44,560
If you look at the slide, this
is the Heron of Alexandria's

390
00:23:44,560 --> 00:23:51,590
method of computing square roots
that we saw yesterday.

391
00:23:51,590 --> 00:23:56,460
And let's see.

392
00:23:56,460 --> 00:24:00,780
Well, in any case, this
program is a little

393
00:24:00,780 --> 00:24:01,805
complicated.

394
00:24:01,805 --> 00:24:04,800
And at the current state of your
thinking, you just can't

395
00:24:04,800 --> 00:24:07,320
look at that and say, oh,
this obviously means

396
00:24:07,320 --> 00:24:10,380
something very clear.

397
00:24:10,380 --> 00:24:12,930
It's not obvious from
looking at the

398
00:24:12,930 --> 00:24:17,060
program what it's computing.

399
00:24:17,060 --> 00:24:21,890
There's some loop here inside
try, and a loop does something

400
00:24:21,890 --> 00:24:26,030
about trying the improvement
of y.

401
00:24:26,030 --> 00:24:30,170
There's something called
improve, which does some

402
00:24:30,170 --> 00:24:33,270
averaging and quotienting
and things like that.

403
00:24:33,270 --> 00:24:34,840
But what's the real idea?

404
00:24:34,840 --> 00:24:38,930
Can we make it clear
what the idea is?

405
00:24:38,930 --> 00:24:41,610
Well, I think we can.

406
00:24:41,610 --> 00:24:45,070
I think we can use abstraction
that we have learned about so

407
00:24:45,070 --> 00:24:48,990
far to clarify what's
going on.

408
00:24:48,990 --> 00:24:54,720
Now, what we have mathematically
is a procedure

409
00:24:54,720 --> 00:24:58,411
for improving a guess
for square roots.

410
00:24:58,411 --> 00:25:02,610
And if y is a guess for a square
root, then what we want

411
00:25:02,610 --> 00:25:04,570
to get we'll call
a function f.

412
00:25:04,570 --> 00:25:07,660
This is the means
of improvement.

413
00:25:07,660 --> 00:25:17,510
I want to get y plus x/y over
2, so the average of y and x

414
00:25:17,510 --> 00:25:24,080
divided by y as the improved
value for the square root of x

415
00:25:24,080 --> 00:25:27,920
such that-- one thing you can
notice about this function f

416
00:25:27,920 --> 00:25:36,310
is that f of the square root
of f is in fact the

417
00:25:36,310 --> 00:25:38,460
square root of x.

418
00:25:38,460 --> 00:25:41,670
In other words, if I take
the square root of x and

419
00:25:41,670 --> 00:25:44,930
substitute it for y here, I see
the square root of x plus

420
00:25:44,930 --> 00:25:47,560
x divided by the square of x,
which is the square root of x.

421
00:25:47,560 --> 00:25:49,890
That's 2 times the square root
of x divided by 2, is the

422
00:25:49,890 --> 00:25:51,640
square root of x.

423
00:25:51,640 --> 00:25:55,630
So, in fact, what we're really
looking for is we're looking

424
00:25:55,630 --> 00:26:12,850
for a fixed point, a fixed
point of the function f.

425
00:26:12,850 --> 00:26:17,570


426
00:26:17,570 --> 00:26:22,650
A fixed point is a place which
has the property that if you

427
00:26:22,650 --> 00:26:24,850
put it into the function, you
get the same value out.

428
00:26:24,850 --> 00:26:27,620


429
00:26:27,620 --> 00:26:29,700
Now, I suppose if I were giving
some nice, boring

430
00:26:29,700 --> 00:26:34,480
lecture, and you happened to
have in front of you an HP-35

431
00:26:34,480 --> 00:26:36,380
desk calculator like I
used to have when I

432
00:26:36,380 --> 00:26:38,170
went to boring lectures.

433
00:26:38,170 --> 00:26:41,120
And if you think it was really
boring, you put it into

434
00:26:41,120 --> 00:26:44,720
radians mode, and you hit
cosine, and you hit cosine,

435
00:26:44,720 --> 00:26:45,780
and you hit cosine.

436
00:26:45,780 --> 00:26:48,770
And eventually, you end
up with 0.734 or

437
00:26:48,770 --> 00:26:50,090
something like that.

438
00:26:50,090 --> 00:26:53,250
0.743, I don't remember what
exactly, and it gets closer

439
00:26:53,250 --> 00:26:54,810
and closer to that.

440
00:26:54,810 --> 00:26:57,980
Some functions have the property
that you can find

441
00:26:57,980 --> 00:27:03,420
their fixed point by iterating
the function, and that's

442
00:27:03,420 --> 00:27:07,170
essentially what's happening in
the square root program by

443
00:27:07,170 --> 00:27:08,420
Heron's method.

444
00:27:08,420 --> 00:27:11,550


445
00:27:11,550 --> 00:27:14,732
So let's see if we can write
that down, that idea.

446
00:27:14,732 --> 00:27:17,670
Now, I'm not going to say how
I compute fixed points yet.

447
00:27:17,670 --> 00:27:19,240
There might be more
than one way.

448
00:27:19,240 --> 00:27:22,750
But the first thing to
do is I'm going to

449
00:27:22,750 --> 00:27:24,310
say what I just said.

450
00:27:24,310 --> 00:27:27,460
I'm going to say it
specifically, the square root.

451
00:27:27,460 --> 00:27:32,440


452
00:27:32,440 --> 00:27:48,210
The square root of x is the
fixed point of that procedure

453
00:27:48,210 --> 00:27:59,180
which takes an argument
y and averages of x

454
00:27:59,180 --> 00:28:02,330
divided by y with y.

455
00:28:02,330 --> 00:28:05,620


456
00:28:05,620 --> 00:28:08,120
And we're going to start up with
the initial guess for the

457
00:28:08,120 --> 00:28:09,630
fixed point of 1.

458
00:28:09,630 --> 00:28:11,860
It doesn't matter
where it starts.

459
00:28:11,860 --> 00:28:13,940
A theorem having to do
with square roots.

460
00:28:13,940 --> 00:28:18,610


461
00:28:18,610 --> 00:28:21,410
So what you're seeing here is
I'm just trying to write out

462
00:28:21,410 --> 00:28:22,560
by wishful thinking.

463
00:28:22,560 --> 00:28:24,380
I don't know how I'm going to
make fixed point happen.

464
00:28:24,380 --> 00:28:26,290
We'll worry about that later.

465
00:28:26,290 --> 00:28:29,570
But if somehow I had a way of
finding the fixed point of the

466
00:28:29,570 --> 00:28:33,590
function computed by this
procedure, then I would have--

467
00:28:33,590 --> 00:28:36,120
that would be the square root
that I'm looking for.

468
00:28:36,120 --> 00:28:39,770


469
00:28:39,770 --> 00:28:41,500
OK, well, now let's see how
we're going to write--

470
00:28:41,500 --> 00:28:43,470
how we're going to come
up with fixed points.

471
00:28:43,470 --> 00:28:44,890
Well, it's very simple,
actually.

472
00:28:44,890 --> 00:28:47,180
I'm going to write an
abbreviated version here just

473
00:28:47,180 --> 00:28:48,430
so we understand it.

474
00:28:48,430 --> 00:29:00,450


475
00:29:00,450 --> 00:29:03,310
I'm going to find the fixed
point of a function f--

476
00:29:03,310 --> 00:29:06,140
actually, the fixed point of the
function computed by the

477
00:29:06,140 --> 00:29:09,990
procedure whose name will
be f in this procedure.

478
00:29:09,990 --> 00:29:11,025
How's that?

479
00:29:11,025 --> 00:29:13,230
A long sentence--

480
00:29:13,230 --> 00:29:14,820
starting with a particular
starting value.

481
00:29:14,820 --> 00:29:19,920


482
00:29:19,920 --> 00:29:22,660
Well, I'm going to have a little
loop inside here, which

483
00:29:22,660 --> 00:29:25,800
is going to push the button on
the calculator repeatedly,

484
00:29:25,800 --> 00:29:28,940
hoping that it will eventually
converge.

485
00:29:28,940 --> 00:29:35,290
And we will say here internal
loops are written by defining

486
00:29:35,290 --> 00:29:36,540
internal procedures.

487
00:29:36,540 --> 00:29:39,340


488
00:29:39,340 --> 00:29:41,860
Well, one thing I'm going to
have to do is I'm going to

489
00:29:41,860 --> 00:29:43,690
have to say whether I'm done.

490
00:29:43,690 --> 00:29:45,410
And the way I'm going to decide
when I'm done is when

491
00:29:45,410 --> 00:29:47,760
the old value and the new value
are close enough so I

492
00:29:47,760 --> 00:29:50,820
can't distinguish
them anymore.

493
00:29:50,820 --> 00:29:53,510
That's the standard thing you
do on the calculator unless

494
00:29:53,510 --> 00:29:54,970
you look at more precision,
and eventually,

495
00:29:54,970 --> 00:29:57,820
you run out of precision.

496
00:29:57,820 --> 00:30:06,530
So the old value and new value,
and I'm going to stay

497
00:30:06,530 --> 00:30:14,758
here if I can't distinguish them
if they're close enough,

498
00:30:14,758 --> 00:30:16,830
and we'll have to worry about
what that is soon.

499
00:30:16,830 --> 00:30:20,780


500
00:30:20,780 --> 00:30:22,580
The old value and the new value
are close enough to each

501
00:30:22,580 --> 00:30:25,880
other and let's pick the new
value as the answer.

502
00:30:25,880 --> 00:30:33,520
Otherwise, I'm going to iterate
around again with the

503
00:30:33,520 --> 00:30:39,020
next value of old being the
current value of new and the

504
00:30:39,020 --> 00:30:43,160
next value of new being the
result of calling f on new.

505
00:30:43,160 --> 00:30:54,810


506
00:30:54,810 --> 00:30:57,680
And so this is my iteration loop
that pushes the button on

507
00:30:57,680 --> 00:30:58,600
the calculator.

508
00:30:58,600 --> 00:31:00,760
I basically think of it as
having two registers on the

509
00:31:00,760 --> 00:31:02,495
calculator: old and new.

510
00:31:02,495 --> 00:31:09,070
And in each step, new becomes
old, and new gets F of new.

511
00:31:09,070 --> 00:31:13,080
So this is the thing where I'm
getting the next value.

512
00:31:13,080 --> 00:31:20,970
And now, I'm going to
start this thing up

513
00:31:20,970 --> 00:31:22,220
by giving two values.

514
00:31:22,220 --> 00:31:28,470


515
00:31:28,470 --> 00:31:30,570
I wrote down on the blackboard
to be slow

516
00:31:30,570 --> 00:31:31,640
so you can see this.

517
00:31:31,640 --> 00:31:34,650
This is the first time you've
seen something quite this

518
00:31:34,650 --> 00:31:37,700
complicated, I think.

519
00:31:37,700 --> 00:31:44,710
However, we might want to see
the whole thing over here in

520
00:31:44,710 --> 00:31:50,720
this transparency or
slide or whatever.

521
00:31:50,720 --> 00:31:57,200
What we have is all of the
details that are required to

522
00:31:57,200 --> 00:31:58,500
make this thing work.

523
00:31:58,500 --> 00:32:01,660
I have a way of getting a
tolerance for a close enough

524
00:32:01,660 --> 00:32:03,080
procedure, which we see here.

525
00:32:03,080 --> 00:32:06,030
The close enough procedure, it
tests whether u and v are

526
00:32:06,030 --> 00:32:09,170
close enough by seeing if the
absolute value of the

527
00:32:09,170 --> 00:32:12,460
difference in u and v is less
than the given tolerance, OK?

528
00:32:12,460 --> 00:32:14,440
And here is the iteration loop
that I just wrote on the

529
00:32:14,440 --> 00:32:17,930
blackboard and the
initialization for it, which

530
00:32:17,930 --> 00:32:19,180
is right there.

531
00:32:19,180 --> 00:32:21,680


532
00:32:21,680 --> 00:32:22,930
It's very simple.

533
00:32:22,930 --> 00:32:34,210


534
00:32:34,210 --> 00:32:34,880
But let's see.

535
00:32:34,880 --> 00:32:36,630
I haven't told you enough.

536
00:32:36,630 --> 00:32:39,500
It's actually easier
than this.

537
00:32:39,500 --> 00:32:42,120
There is more structure to
this problem than I've

538
00:32:42,120 --> 00:32:43,310
already told you.

539
00:32:43,310 --> 00:32:45,700
Like why should this work?

540
00:32:45,700 --> 00:32:48,070
Why should it converge?

541
00:32:48,070 --> 00:32:50,930
There's a hairy theorem in
mathematics tied up in what

542
00:32:50,930 --> 00:32:52,760
I've written here.

543
00:32:52,760 --> 00:32:55,890
Why is it that I should assume
that by iterating averaging

544
00:32:55,890 --> 00:32:57,780
the quotient of x and y
and y that I should

545
00:32:57,780 --> 00:33:00,110
get the right answer?

546
00:33:00,110 --> 00:33:01,360
It isn't so obvious.

547
00:33:01,360 --> 00:33:03,710


548
00:33:03,710 --> 00:33:07,280
Surely there are other things,
other procedures, which

549
00:33:07,280 --> 00:33:09,870
compute functions whose fixed
points would also be the

550
00:33:09,870 --> 00:33:12,040
square root.

551
00:33:12,040 --> 00:33:20,480
For example, the obvious one
will be a new function g,

552
00:33:20,480 --> 00:33:25,330
which maps y to x/y.

553
00:33:25,330 --> 00:33:27,950


554
00:33:27,950 --> 00:33:30,870
That's even simpler.

555
00:33:30,870 --> 00:33:34,540
The fixed point of g is surely
the square root also, and it's

556
00:33:34,540 --> 00:33:37,400
a simpler procedure.

557
00:33:37,400 --> 00:33:39,020
Why am I not using it?

558
00:33:39,020 --> 00:33:40,470
Well, I suppose you know.

559
00:33:40,470 --> 00:33:44,970
Supposing x is 2 and I start out
with 1, and if I divide 1

560
00:33:44,970 --> 00:33:47,700
into 2, I get 2.

561
00:33:47,700 --> 00:33:49,610
And then if I divide
2 into 2, I get 1.

562
00:33:49,610 --> 00:33:52,740
If I divide 1 into 2, I get 2,
and 2 into 2, I get 1, and I

563
00:33:52,740 --> 00:33:55,480
never get any closer
to the square root.

564
00:33:55,480 --> 00:33:56,730
It just oscillates.

565
00:33:56,730 --> 00:33:59,080


566
00:33:59,080 --> 00:34:03,110
So what we have is a signal
processing system, an

567
00:34:03,110 --> 00:34:06,230
electrical circuit which is
oscillating, and I want to

568
00:34:06,230 --> 00:34:07,480
damp out these oscillations.

569
00:34:07,480 --> 00:34:10,530


570
00:34:10,530 --> 00:34:11,840
Well, I can do that.

571
00:34:11,840 --> 00:34:14,190
See, what I'm really doing
here when I'm taking my

572
00:34:14,190 --> 00:34:17,290
average, the average is
averaging the last two values

573
00:34:17,290 --> 00:34:21,350
of something which oscillates,
getting something in between.

574
00:34:21,350 --> 00:34:24,480
The classic way is damping out
oscillations in a signal

575
00:34:24,480 --> 00:34:25,730
processing system.

576
00:34:25,730 --> 00:34:28,460


577
00:34:28,460 --> 00:34:31,719
So why don't we write down the
strategy that I just said in a

578
00:34:31,719 --> 00:34:33,872
more clear way?

579
00:34:33,872 --> 00:34:35,520
Well, that's easy enough.

580
00:34:35,520 --> 00:34:38,639


581
00:34:38,639 --> 00:34:53,790
I'm going to define the square
root of x to be a fixed point

582
00:34:53,790 --> 00:34:58,510
of the procedure resulting
from average damping.

583
00:34:58,510 --> 00:35:10,780
So I have a procedure resulting
from average damp of

584
00:35:10,780 --> 00:35:24,820
the procedure, that procedure
of y, which divides x by y

585
00:35:24,820 --> 00:35:26,070
starting out at 1.

586
00:35:26,070 --> 00:35:29,840


587
00:35:29,840 --> 00:35:33,520
Ah, but average damp is a
special procedure that's going

588
00:35:33,520 --> 00:35:35,720
to take a procedure as its
argument and return a

589
00:35:35,720 --> 00:35:38,080
procedure as its value.

590
00:35:38,080 --> 00:35:42,090
It's a generalization that says
given a procedure, it's

591
00:35:42,090 --> 00:35:45,090
the thing which produces a
procedure which averages the

592
00:35:45,090 --> 00:35:47,980
last value and the
value before and

593
00:35:47,980 --> 00:35:51,320
after running the procedure.

594
00:35:51,320 --> 00:35:53,260
You can use it for anything
if you want to damp out

595
00:35:53,260 --> 00:35:54,880
oscillations.

596
00:35:54,880 --> 00:35:56,495
So let's write that down.

597
00:35:56,495 --> 00:35:57,745
It's very easy.

598
00:35:57,745 --> 00:36:00,624


599
00:36:00,624 --> 00:36:04,590
And stylistically here, I'm
going to use lambda notation

600
00:36:04,590 --> 00:36:06,950
because it's much easier to
think when you're dealing with

601
00:36:06,950 --> 00:36:08,845
procedure, the mid-line
procedures, to understand that

602
00:36:08,845 --> 00:36:11,552
the procedures are the objects
I'm dealing with, so I'm going

603
00:36:11,552 --> 00:36:13,830
to use lambda notation here.

604
00:36:13,830 --> 00:36:14,490
Not always.

605
00:36:14,490 --> 00:36:18,110
I don't always use it, but
very specifically here to

606
00:36:18,110 --> 00:36:22,040
expand on that idea,
to elucidate it.

607
00:36:22,040 --> 00:36:28,590


608
00:36:28,590 --> 00:36:33,810
Well, average damp is a
procedure, which takes a

609
00:36:33,810 --> 00:36:37,560
procedure as its argument,
which we will call f.

610
00:36:37,560 --> 00:36:38,710
And what does it produce?

611
00:36:38,710 --> 00:36:40,340
It produces as its value--

612
00:36:40,340 --> 00:36:43,890
the body of this procedure is
a thing which produces a

613
00:36:43,890 --> 00:36:47,260
procedure, the construct of the
procedures right here, of

614
00:36:47,260 --> 00:37:00,440
one argument x, which averages
f of x with x.

615
00:37:00,440 --> 00:37:10,420


616
00:37:10,420 --> 00:37:14,070
This is a very special thing.

617
00:37:14,070 --> 00:37:17,730
I think for the first time
you're seeing a procedure

618
00:37:17,730 --> 00:37:21,730
which produces a procedure
as its value.

619
00:37:21,730 --> 00:37:25,690
This procedure takes the
procedure f and does something

620
00:37:25,690 --> 00:37:29,360
to it to produce a new procedure
of one argument x,

621
00:37:29,360 --> 00:37:31,050
which averages f--

622
00:37:31,050 --> 00:37:31,950
this f--

623
00:37:31,950 --> 00:37:36,040
applied to x and x itself.

624
00:37:36,040 --> 00:37:40,280
Using the context here, I apply
average damping to the

625
00:37:40,280 --> 00:37:44,670
procedure, which just
divides x by y.

626
00:37:44,670 --> 00:37:45,920
It's a division.

627
00:37:45,920 --> 00:37:48,122


628
00:37:48,122 --> 00:37:51,980
And I'm finding to fixed point
of that, and that's a clearer

629
00:37:51,980 --> 00:37:54,460
way of writing down what
I wrote down over

630
00:37:54,460 --> 00:37:57,796
here, wherever it was.

631
00:37:57,796 --> 00:38:01,110
Here, because it tells why
I am writing this down.

632
00:38:01,110 --> 00:38:07,910


633
00:38:07,910 --> 00:38:11,110
I suppose this to some extent
really clarifies what Heron of

634
00:38:11,110 --> 00:38:14,260
Alexandria was up to.

635
00:38:14,260 --> 00:38:15,130
I suppose I'll stop now.

636
00:38:15,130 --> 00:38:16,380
Are there any questions?

637
00:38:16,380 --> 00:38:18,190


638
00:38:18,190 --> 00:38:21,282
AUDIENCE: So when you define
average damp, don't you need

639
00:38:21,282 --> 00:38:25,210
to have a variable on f?

640
00:38:25,210 --> 00:38:28,150
PROFESSOR: Ah, the question was,
and here we're having--

641
00:38:28,150 --> 00:38:29,900
again, you've got to learn
about the syntax.

642
00:38:29,900 --> 00:38:33,840
The question was when defining
average damp, don't you have

643
00:38:33,840 --> 00:38:38,070
to have a variable
defined with f?

644
00:38:38,070 --> 00:38:40,310
What you are asking about is
the formal parameter of f?

645
00:38:40,310 --> 00:38:41,290
AUDIENCE: Yeah.

646
00:38:41,290 --> 00:38:42,810
PROFESSOR: OK.

647
00:38:42,810 --> 00:38:45,580
The formal parameter
of f is here.

648
00:38:45,580 --> 00:38:47,318
The formal parameter of f--

649
00:38:47,318 --> 00:38:50,190
AUDIENCE: The formal parameter
of average damp.

650
00:38:50,190 --> 00:38:51,890
PROFESSOR: F is being
used to apply it to

651
00:38:51,890 --> 00:38:54,400
an argument, right?

652
00:38:54,400 --> 00:38:57,780
It's indeed true that f must
have a formal parameter.

653
00:38:57,780 --> 00:39:00,380
Let's find out what f's
formal parameter is.

654
00:39:00,380 --> 00:39:02,440
AUDIENCE: The formal parameter
of average damp.

655
00:39:02,440 --> 00:39:04,700
PROFESSOR: Oh, f is the formal
parameter of average damp.

656
00:39:04,700 --> 00:39:05,500
I'm sorry.

657
00:39:05,500 --> 00:39:07,910
You're just confusing
a syntactic thing.

658
00:39:07,910 --> 00:39:10,470
I could have written
this the other way.

659
00:39:10,470 --> 00:39:12,520
Actually, I didn't understand
your question.

660
00:39:12,520 --> 00:39:13,910
Of course, I could have written
it this other way.

661
00:39:13,910 --> 00:39:19,340


662
00:39:19,340 --> 00:39:21,540
Those are identical notations.

663
00:39:21,540 --> 00:39:25,607
This is a different way
of writing this.

664
00:39:25,607 --> 00:39:31,710


665
00:39:31,710 --> 00:39:33,280
You're going to have to get
used to lambda notation

666
00:39:33,280 --> 00:39:35,520
because I'm going to use it.

667
00:39:35,520 --> 00:39:40,460
What it says here, I'm defining
the name average damp

668
00:39:40,460 --> 00:39:44,600
to name the procedure whose
of one argument f.

669
00:39:44,600 --> 00:39:49,250
That's the formal parameter of
the procedure average damp.

670
00:39:49,250 --> 00:39:56,550
What define does is it says
give this name a value.

671
00:39:56,550 --> 00:39:57,860
Here is the value of for it.

672
00:39:57,860 --> 00:40:01,310


673
00:40:01,310 --> 00:40:05,100
That there happens to be a
funny syntax to make that

674
00:40:05,100 --> 00:40:08,085
easier in some cases is
purely convenience.

675
00:40:08,085 --> 00:40:10,900


676
00:40:10,900 --> 00:40:14,540
But the reason why I wrote it
this way here is to emphasize

677
00:40:14,540 --> 00:40:16,530
that I'm dealing with a
procedure that takes a

678
00:40:16,530 --> 00:40:18,100
procedure as its argument
and produces a

679
00:40:18,100 --> 00:40:19,350
procedure as its value.

680
00:40:19,350 --> 00:40:23,640


681
00:40:23,640 --> 00:40:25,800
AUDIENCE: I don't understand
why you use lambda twice.

682
00:40:25,800 --> 00:40:27,760
Can you just use one
lambda and take two

683
00:40:27,760 --> 00:40:29,230
arguments f and x?

684
00:40:29,230 --> 00:40:29,520
PROFESSOR: No.

685
00:40:29,520 --> 00:40:30,330
AUDIENCE: You can't?

686
00:40:30,330 --> 00:40:32,500
PROFESSOR: No, that would
be a different thing.

687
00:40:32,500 --> 00:40:36,190
If I were to write the procedure
lambda of f and x,

688
00:40:36,190 --> 00:40:40,090
the average of f of x and x,
that would not be something

689
00:40:40,090 --> 00:40:42,810
which would be allowed to take a
procedure as an argument and

690
00:40:42,810 --> 00:40:44,580
produce a procedure
as its value.

691
00:40:44,580 --> 00:40:46,330
That would be a thing that
takes a procedure as its

692
00:40:46,330 --> 00:40:48,700
argument and numbers
its argument and

693
00:40:48,700 --> 00:40:50,620
produces a new number.

694
00:40:50,620 --> 00:40:53,650
But what I'm producing here is
a procedure to fit in the

695
00:40:53,650 --> 00:40:56,090
procedure slot over here,
which is going to

696
00:40:56,090 --> 00:40:58,860
be used over here.

697
00:40:58,860 --> 00:41:01,450
So the number has to
come from here.

698
00:41:01,450 --> 00:41:04,440
This is the thing that's going
to eventually end up in the x.

699
00:41:04,440 --> 00:41:07,810
And if you're confused, you
should do some substitution

700
00:41:07,810 --> 00:41:09,060
and see for yourself.

701
00:41:09,060 --> 00:41:12,010


702
00:41:12,010 --> 00:41:12,746
Yes?

703
00:41:12,746 --> 00:41:15,870
AUDIENCE: Will you please show
the definition for average

704
00:41:15,870 --> 00:41:19,320
damp without using lambda
notation in both cases.

705
00:41:19,320 --> 00:41:21,490
PROFESSOR: I can't make a very
simple one like that.

706
00:41:21,490 --> 00:41:22,990
Let me do it for you, though.

707
00:41:22,990 --> 00:41:26,530
I can get rid of this
lambda easily.

708
00:41:26,530 --> 00:41:27,780
I don't want to be--

709
00:41:27,780 --> 00:41:32,760


710
00:41:32,760 --> 00:41:33,810
actually, I'm lying to you.

711
00:41:33,810 --> 00:41:37,170
I don't want to do what you want
because I think it's more

712
00:41:37,170 --> 00:41:39,310
confusing than you think.

713
00:41:39,310 --> 00:41:40,560
I'm not going to write
what you want.

714
00:41:40,560 --> 00:41:55,450


715
00:41:55,450 --> 00:41:56,500
So we'll have to get a name.

716
00:41:56,500 --> 00:42:13,370
FOO of x to be of F of x and x
and return as a value FOO.

717
00:42:13,370 --> 00:42:17,140


718
00:42:17,140 --> 00:42:20,406
This is equivalent, but
I've had to make an

719
00:42:20,406 --> 00:42:21,700
arbitrary name up.

720
00:42:21,700 --> 00:42:26,290
This is equivalent to this
without any lambdas.

721
00:42:26,290 --> 00:42:31,240
Lambda is very convenient for
naming anonymous procedures.

722
00:42:31,240 --> 00:42:34,080
It's the anonymous name
of something.

723
00:42:34,080 --> 00:42:39,780
Now, if you really want to know
a cute way of doing this,

724
00:42:39,780 --> 00:42:41,820
we'll talk about it later.

725
00:42:41,820 --> 00:42:44,680
We're going to have to define
the anonymous procedure.

726
00:42:44,680 --> 00:42:45,930
Any other questions?

727
00:42:45,930 --> 00:42:49,116


728
00:42:49,116 --> 00:42:50,880
And so we go for our
break again.

729
00:42:50,880 --> 00:43:31,740


730
00:43:31,740 --> 00:43:35,380
So now we've seen how
to use high-order

731
00:43:35,380 --> 00:43:36,490
procedures, they're called.

732
00:43:36,490 --> 00:43:38,570
That's procedures that take
procedural arguments and

733
00:43:38,570 --> 00:43:43,310
produce procedural values to
help us clarify and abstract

734
00:43:43,310 --> 00:43:46,470
some otherwise complicated
processes.

735
00:43:46,470 --> 00:43:48,500
I suppose what I'd like to do
now is have a bit of fun with

736
00:43:48,500 --> 00:43:54,080
that and sort of a little
practice as well.

737
00:43:54,080 --> 00:43:56,290
So let's play with this square
root thing even more.

738
00:43:56,290 --> 00:43:59,800
Let's elaborate it and
understand what's going on and

739
00:43:59,800 --> 00:44:04,270
make use of this kind of
programming style.

740
00:44:04,270 --> 00:44:08,680
One thing that you might know
is that there is a general

741
00:44:08,680 --> 00:44:12,990
method called Newton's method
the purpose of which is to

742
00:44:12,990 --> 00:44:15,180
find the roots--

743
00:44:15,180 --> 00:44:17,280
that's the zeroes--

744
00:44:17,280 --> 00:44:19,130
of functions.

745
00:44:19,130 --> 00:44:38,420
So, for example, to find a y
such that f of y equals 0, we

746
00:44:38,420 --> 00:44:40,280
start with some guess.

747
00:44:40,280 --> 00:44:41,530
This is Newton's method.

748
00:44:41,530 --> 00:44:51,260


749
00:44:51,260 --> 00:44:55,860
And the guess we start with
we'll call y0, and then we

750
00:44:55,860 --> 00:45:01,100
will iterate the following
expression.

751
00:45:01,100 --> 00:45:04,880
y n plus 1-- this is a
difference equation--

752
00:45:04,880 --> 00:45:17,366
is yn minus f of yn over the
derivative with respect to y

753
00:45:17,366 --> 00:45:23,270
of f evaluated at y equal yn.

754
00:45:23,270 --> 00:45:26,430
Very strange notation.

755
00:45:26,430 --> 00:45:31,700
I must say ugh.

756
00:45:31,700 --> 00:45:35,990
The derivative of f with respect
to y is a function.

757
00:45:35,990 --> 00:45:38,420
I'm having a little bit of
unhappiness with that, but

758
00:45:38,420 --> 00:45:39,120
that's all right.

759
00:45:39,120 --> 00:45:41,050
It turns out in the programming
language world,

760
00:45:41,050 --> 00:45:43,930
the notation is much clearer.

761
00:45:43,930 --> 00:45:45,950
Now, what is this?

762
00:45:45,950 --> 00:45:47,330
People call it Newton's
method.

763
00:45:47,330 --> 00:45:54,250
It's a method for finding the
roots of the function f.

764
00:45:54,250 --> 00:45:56,410
And it, of course, sometimes
converges, and when it does,

765
00:45:56,410 --> 00:45:59,310
it does so very fast. And
sometimes, it doesn't

766
00:45:59,310 --> 00:46:03,230
converge, and, oh well, we have
to do something else.

767
00:46:03,230 --> 00:46:07,190
But let's talk about square
root by Newton's method.

768
00:46:07,190 --> 00:46:08,680
Well, that's rather
interesting.

769
00:46:08,680 --> 00:46:11,340
Let's do exactly the same thing
we did last time: a bit

770
00:46:11,340 --> 00:46:13,490
of wishful thinking.

771
00:46:13,490 --> 00:46:18,210
We will apply Newton's method,
assuming we knew how to do it.

772
00:46:18,210 --> 00:46:20,620
You don't know how
to do it yet.

773
00:46:20,620 --> 00:46:21,870
Well, let's go.

774
00:46:21,870 --> 00:46:25,090


775
00:46:25,090 --> 00:46:26,070
What do I have here?

776
00:46:26,070 --> 00:46:27,320
The square root of x.

777
00:46:27,320 --> 00:46:31,410


778
00:46:31,410 --> 00:46:37,480
It's Newton's method applied
to a procedure which will

779
00:46:37,480 --> 00:46:39,990
represent that function
of y, which computes

780
00:46:39,990 --> 00:46:42,480
that function of y.

781
00:46:42,480 --> 00:46:48,820
Well, that procedure is that
procedure of y, which is the

782
00:46:48,820 --> 00:46:51,810
difference between x and
the square of y.

783
00:46:51,810 --> 00:47:00,080


784
00:47:00,080 --> 00:47:07,570
Indeed, if I had a value of y
for which this was zero, then

785
00:47:07,570 --> 00:47:10,020
y would be the square
root of x.

786
00:47:10,020 --> 00:47:13,730


787
00:47:13,730 --> 00:47:15,550
See that?

788
00:47:15,550 --> 00:47:19,250
OK, I'm going to start this
out searching at 1.

789
00:47:19,250 --> 00:47:23,570
Again, completely arbitrary
property of square roots that

790
00:47:23,570 --> 00:47:24,820
I can do that.

791
00:47:24,820 --> 00:47:27,950


792
00:47:27,950 --> 00:47:31,480
Now, how am I going to compute
Newton's method?

793
00:47:31,480 --> 00:47:32,170
Well, this is the method.

794
00:47:32,170 --> 00:47:34,310
I have it right here.

795
00:47:34,310 --> 00:47:37,740
In fact, what I'm doing is
looking for a fixed point of

796
00:47:37,740 --> 00:47:41,240
some procedure.

797
00:47:41,240 --> 00:47:45,190
This procedure involves some
complicated expressions in

798
00:47:45,190 --> 00:47:47,150
terms of other complicated
things.

799
00:47:47,150 --> 00:47:48,800
Well, I'm trying to find the
fixed point of this.

800
00:47:48,800 --> 00:47:54,620
I want to find the values of y,
which if I put y in here, I

801
00:47:54,620 --> 00:48:00,130
get the same value out here up
to some degree of accuracy.

802
00:48:00,130 --> 00:48:02,710
Well, I already have a
fixed point process

803
00:48:02,710 --> 00:48:05,040
around to do that.

804
00:48:05,040 --> 00:48:07,350
And so, let's just define
Newton's method over here.

805
00:48:07,350 --> 00:48:19,430


806
00:48:19,430 --> 00:48:21,680
A procedure which computes
a function and a

807
00:48:21,680 --> 00:48:26,640
guess, initial guess.

808
00:48:26,640 --> 00:48:28,920
Now, I'm going to have
to do something here.

809
00:48:28,920 --> 00:48:33,280
I'm going to need the derivative
of the function.

810
00:48:33,280 --> 00:48:36,550
I'm going to need a procedure
which computes the derivative

811
00:48:36,550 --> 00:48:39,490
of the function computed by
the given a procedure f.

812
00:48:39,490 --> 00:48:42,140


813
00:48:42,140 --> 00:48:44,440
I'm trying to be very careful
about what I'm saying.

814
00:48:44,440 --> 00:48:46,270
I don't want to mix up the word
procedure and function.

815
00:48:46,270 --> 00:48:47,875
Function is a mathematical
word.

816
00:48:47,875 --> 00:48:52,950
It says I'm mapping from values
to other values, a set

817
00:48:52,950 --> 00:48:55,430
of ordered pairs.

818
00:48:55,430 --> 00:49:00,380
But sometimes, I'll accidentally
mix those up.

819
00:49:00,380 --> 00:49:01,655
Procedures compute functions.

820
00:49:01,655 --> 00:49:07,400


821
00:49:07,400 --> 00:49:12,100
So I'm going to define the
derivative of f to be by

822
00:49:12,100 --> 00:49:12,930
wishful thinking again.

823
00:49:12,930 --> 00:49:14,720
I don't know how I'm
going to do it.

824
00:49:14,720 --> 00:49:15,970
Let's worry about that later--

825
00:49:15,970 --> 00:49:18,612


826
00:49:18,612 --> 00:49:25,340
of F. So if F is a procedure,
which happens to be this one

827
00:49:25,340 --> 00:49:31,800
over here for a square root,
then DF will be the derivative

828
00:49:31,800 --> 00:49:34,890
of it, which is also the
derivative of the function

829
00:49:34,890 --> 00:49:36,080
computed by that procedure.

830
00:49:36,080 --> 00:49:38,760
DF will be a procedure that
computes the derivative of the

831
00:49:38,760 --> 00:49:42,920
function computed by the
procedure F. And then given

832
00:49:42,920 --> 00:49:44,850
that, I will just go looking
for a fixed point.

833
00:49:44,850 --> 00:49:51,910


834
00:49:51,910 --> 00:49:53,710
What is the fixed point
I'm looking for?

835
00:49:53,710 --> 00:49:57,580
It's the one for that procedure
of one argument x,

836
00:49:57,580 --> 00:50:00,500
which I compute by
subtracting x.

837
00:50:00,500 --> 00:50:04,870
That's the old-- that's
the yn here.

838
00:50:04,870 --> 00:50:21,110
The quotient of f of x and df
of x, starting out with the

839
00:50:21,110 --> 00:50:22,360
original guess.

840
00:50:22,360 --> 00:50:29,450


841
00:50:29,450 --> 00:50:32,640
That's all very simple.

842
00:50:32,640 --> 00:50:35,130
Now, I have one part left that
I haven't written, and I want

843
00:50:35,130 --> 00:50:37,720
you to see the process by which
I write these things,

844
00:50:37,720 --> 00:50:40,150
because this is really true.

845
00:50:40,150 --> 00:50:43,810
I start out with some
mathematical idea, perhaps.

846
00:50:43,810 --> 00:50:48,440
By wishful thinking, I assume
that by some magic I can do

847
00:50:48,440 --> 00:50:50,980
something that I have
a name for.

848
00:50:50,980 --> 00:50:54,850
I'm not going to worry about
how I do it yet.

849
00:50:54,850 --> 00:50:57,970
Then I go walking down here and
say, well, by some magic,

850
00:50:57,970 --> 00:51:01,142
I'm somehow going to figure how
to do that, but I'm going

851
00:51:01,142 --> 00:51:04,330
to write my program anyway.

852
00:51:04,330 --> 00:51:07,990
Wishful thinking, essential
to good engineering, and

853
00:51:07,990 --> 00:51:10,060
certainly essential to a
good computer science.

854
00:51:10,060 --> 00:51:12,770


855
00:51:12,770 --> 00:51:15,900
So anyway, how many of
you wished that your

856
00:51:15,900 --> 00:51:17,150
computer ran faster?

857
00:51:17,150 --> 00:51:21,120


858
00:51:21,120 --> 00:51:23,390
Well, the derivative isn't
so bad either.

859
00:51:23,390 --> 00:51:24,640
Sort of like average damping.

860
00:51:24,640 --> 00:51:28,922


861
00:51:28,922 --> 00:51:34,010
The derivative is a procedure
that takes a procedure that

862
00:51:34,010 --> 00:51:38,560
computes a function as its
argument, and it produces a

863
00:51:38,560 --> 00:51:42,230
procedure that computes a
function, which needs one

864
00:51:42,230 --> 00:51:43,930
argument x.

865
00:51:43,930 --> 00:51:46,270
Well, you all know
this definition.

866
00:51:46,270 --> 00:51:49,040
It's f of x plus delta x minus
f of x over delta x, right?

867
00:51:49,040 --> 00:51:50,800
For some small delta x.

868
00:51:50,800 --> 00:51:59,850
So that's the quotient of the
difference of f of the sum of

869
00:51:59,850 --> 00:52:10,345
x and dx minus f point
x divided by dx.

870
00:52:10,345 --> 00:52:18,530


871
00:52:18,530 --> 00:52:21,360
I think the thing was lining up
correctly when I balanced

872
00:52:21,360 --> 00:52:22,610
the parentheses.

873
00:52:22,610 --> 00:52:25,120


874
00:52:25,120 --> 00:52:27,070
Now, I want you to
look at this.

875
00:52:27,070 --> 00:52:28,320
Just look.

876
00:52:28,320 --> 00:52:31,330


877
00:52:31,330 --> 00:52:33,220
I suppose I haven't told
you what dx is.

878
00:52:33,220 --> 00:52:44,880
Somewhere in the world I'm going
to have to write down

879
00:52:44,880 --> 00:52:45,770
something like that.

880
00:52:45,770 --> 00:52:48,150
I'm not interested.

881
00:52:48,150 --> 00:52:52,970
This is a procedure which takes
a procedure and produces

882
00:52:52,970 --> 00:52:55,950
an approximation, a procedure
that computes an approximation

883
00:52:55,950 --> 00:52:58,010
of the derivative of the
function computed by the

884
00:52:58,010 --> 00:53:02,740
procedure given by the standard
methods that you all

885
00:53:02,740 --> 00:53:04,800
know and love.

886
00:53:04,800 --> 00:53:08,920
Now, it may not be the case that
doing this operation is

887
00:53:08,920 --> 00:53:11,390
such a good way of approximating
a derivative.

888
00:53:11,390 --> 00:53:14,800
Numerical analysts here
should jump on me and

889
00:53:14,800 --> 00:53:16,690
say don't do that.

890
00:53:16,690 --> 00:53:20,150
Computing derivatives produces
noisy answers, which is true.

891
00:53:20,150 --> 00:53:24,850
However, this again is for the
sake of understanding.

892
00:53:24,850 --> 00:53:26,620
Look what we've got.

893
00:53:26,620 --> 00:53:29,040
We started out with what is
apparently a mathematically

894
00:53:29,040 --> 00:53:31,210
complex thing.

895
00:53:31,210 --> 00:53:31,610
and.

896
00:53:31,610 --> 00:53:35,370
In a few blackboards full, we
managed to decompose the

897
00:53:35,370 --> 00:53:37,900
problem of computing square
roots by the way you were

898
00:53:37,900 --> 00:53:41,770
taught in your college
calculus class--

899
00:53:41,770 --> 00:53:43,720
Newton's method--

900
00:53:43,720 --> 00:53:45,830
so that it can be understood.

901
00:53:45,830 --> 00:53:47,840
It's clear.

902
00:53:47,840 --> 00:53:51,231
Let's look at the structure
of what it is we've got.

903
00:53:51,231 --> 00:53:54,660
Let's look at this slide.

904
00:53:54,660 --> 00:54:03,110
This is a diagram of the machine
described by the

905
00:54:03,110 --> 00:54:05,520
program on the blackboard.

906
00:54:05,520 --> 00:54:08,940
There's a machine
described here.

907
00:54:08,940 --> 00:54:10,700
And what have I got?

908
00:54:10,700 --> 00:54:17,690
Over here is the Newton's method
function f that we have

909
00:54:17,690 --> 00:54:21,040
on the left-most blackboard.

910
00:54:21,040 --> 00:54:24,990
It's the thing that takes an
argument called y and puts out

911
00:54:24,990 --> 00:54:32,500
the difference between x and
the square of y, where x is

912
00:54:32,500 --> 00:54:35,400
some sort of free variable that
comes in from the outside

913
00:54:35,400 --> 00:54:38,050
by some magic.

914
00:54:38,050 --> 00:54:43,430
So the square root routine picks
up an x, and builds this

915
00:54:43,430 --> 00:54:47,750
procedure, which I have the
x rolled up in it by

916
00:54:47,750 --> 00:54:50,170
substitution.

917
00:54:50,170 --> 00:54:58,930
Now, this procedure in the cloud
is fed in as the f into

918
00:54:58,930 --> 00:55:01,630
the Newton's method which
is here, this box.

919
00:55:01,630 --> 00:55:04,650


920
00:55:04,650 --> 00:55:08,790
The f is fanned out.

921
00:55:08,790 --> 00:55:12,130
Part of it goes into something
else, and the other part of it

922
00:55:12,130 --> 00:55:15,670
goes through a derivative
process into something else to

923
00:55:15,670 --> 00:55:20,570
produce a procedure, which
computes the function which is

924
00:55:20,570 --> 00:55:24,090
the iteration function of
Newton's method when we use

925
00:55:24,090 --> 00:55:27,450
the fixed point method.

926
00:55:27,450 --> 00:55:33,030
So this procedure, which
contains it by substitution--

927
00:55:33,030 --> 00:55:37,730
remember, Newton's method over
here, Newton's method builds

928
00:55:37,730 --> 00:55:43,010
this procedure, and Newton's
method has in it defined f and

929
00:55:43,010 --> 00:55:48,900
df, so those are captured
over here: f and df.

930
00:55:48,900 --> 00:55:51,930
Starting with this procedure,
I can now feed this to the

931
00:55:51,930 --> 00:55:55,260
fixed point process within an
initial guess coming out from

932
00:55:55,260 --> 00:55:59,135
the outside from square
root to produce the

933
00:55:59,135 --> 00:56:00,385
square root of x.

934
00:56:00,385 --> 00:56:03,680


935
00:56:03,680 --> 00:56:07,680
So what we've built is a very
powerful engine, which allows

936
00:56:07,680 --> 00:56:11,256
us to make nice things
like this.

937
00:56:11,256 --> 00:56:19,000
Now, I want to end this with
basically an idea of Chris

938
00:56:19,000 --> 00:56:21,520
Strachey, one of the

939
00:56:21,520 --> 00:56:23,230
grandfathers of computer science.

940
00:56:23,230 --> 00:56:27,440
He's a logician who
lived in the--

941
00:56:27,440 --> 00:56:30,320
I suppose about 10 years ago
or 15 years ago, he died.

942
00:56:30,320 --> 00:56:31,840
I don't remember exactly when.

943
00:56:31,840 --> 00:56:33,250
He's one of the inventors
of something called

944
00:56:33,250 --> 00:56:34,820
denotational semantics.

945
00:56:34,820 --> 00:56:40,560
He was a great advocate of
making procedures or functions

946
00:56:40,560 --> 00:56:43,950
first-class citizens in a
programming language.

947
00:56:43,950 --> 00:56:46,910
So here's the rights and
privileges of first-class

948
00:56:46,910 --> 00:56:50,690
citizens in a programming
language.

949
00:56:50,690 --> 00:56:53,070
It allows you to make any
abstraction you like if you

950
00:56:53,070 --> 00:56:57,710
have functions as first-class
citizens.

951
00:56:57,710 --> 00:56:59,030
The first-class citizens
must be able

952
00:56:59,030 --> 00:57:02,270
to be named by variables.

953
00:57:02,270 --> 00:57:04,600
And you're seeing me doing
that all the time.

954
00:57:04,600 --> 00:57:07,700
Here's a nice variable which
names a procedure which

955
00:57:07,700 --> 00:57:08,950
computes something.

956
00:57:08,950 --> 00:57:13,270


957
00:57:13,270 --> 00:57:15,370
They have to be passed as
arguments to procedures.

958
00:57:15,370 --> 00:57:18,540
We've certainly seen that.

959
00:57:18,540 --> 00:57:20,640
We have to be able to return
them as values from

960
00:57:20,640 --> 00:57:23,340
procedures.

961
00:57:23,340 --> 00:57:25,300
And I suppose we've seen that.

962
00:57:25,300 --> 00:57:27,970
We haven't yet seen anything
about data structures.

963
00:57:27,970 --> 00:57:31,490
We will soon, but it's also the
case that in order to have

964
00:57:31,490 --> 00:57:33,940
a first-class citizen in a
programming language, the

965
00:57:33,940 --> 00:57:37,200
object has to be allowed to be
part of a data structure.

966
00:57:37,200 --> 00:57:39,110
We're going to see that soon.

967
00:57:39,110 --> 00:57:43,530
So I just want to close with
this and say having things

968
00:57:43,530 --> 00:57:46,180
like procedures as first-class
data structures, first-class

969
00:57:46,180 --> 00:57:50,780
data, allows one to make
powerful abstractions, which

970
00:57:50,780 --> 00:57:53,110
encode general methods
like Newton's method

971
00:57:53,110 --> 00:57:54,780
in very clear way.

972
00:57:54,780 --> 00:57:57,430
Are there any questions?

973
00:57:57,430 --> 00:57:57,780
Yes.

974
00:57:57,780 --> 00:58:00,040
AUDIENCE: Could you put
derivative instead of df

975
00:58:00,040 --> 00:58:02,570
directly in the fixed point?

976
00:58:02,570 --> 00:58:03,810
PROFESSOR: Oh, sure.

977
00:58:03,810 --> 00:58:09,220
Yes, I could have put deriv of
f right here, no question.

978
00:58:09,220 --> 00:58:11,810


979
00:58:11,810 --> 00:58:16,190
Any time you see something
defined, you can put the thing

980
00:58:16,190 --> 00:58:18,950
that the definition is
there because you

981
00:58:18,950 --> 00:58:21,060
get the same result.

982
00:58:21,060 --> 00:58:22,800
In fact, what that would look
like, it's interesting.

983
00:58:22,800 --> 00:58:23,750
AUDIENCE: Lambda.

984
00:58:23,750 --> 00:58:24,085
PROFESSOR: Huh?

985
00:58:24,085 --> 00:58:25,970
AUDIENCE: You could put the
lambda expression in there.

986
00:58:25,970 --> 00:58:29,990
PROFESSOR: I could also put
derivative of f here.

987
00:58:29,990 --> 00:58:32,640
It would look interesting
because of the open paren,

988
00:58:32,640 --> 00:58:38,610
open paren, deriv of f,
closed paren on an x.

989
00:58:38,610 --> 00:58:40,900
Now, that would have the bad
property of computing the

990
00:58:40,900 --> 00:58:43,980
derivative many times, because
every time I would run this

991
00:58:43,980 --> 00:58:45,490
procedure, I would compute
the derivative again.

992
00:58:45,490 --> 00:58:48,030


993
00:58:48,030 --> 00:58:52,510
However, the two open parens
here both would be meaningful.

994
00:58:52,510 --> 00:58:54,600
I want you to understand
syntactically that that's a

995
00:58:54,600 --> 00:58:55,350
sensible thing.

996
00:58:55,350 --> 00:58:58,190
Because if was to rewrite this
program-- and I should do it

997
00:58:58,190 --> 00:59:00,210
right here just so
you see because

998
00:59:00,210 --> 00:59:01,460
that's a good question--

999
00:59:01,460 --> 00:59:11,490


1000
00:59:11,490 --> 00:59:25,430
of F and guess to be fixed point
of that procedure of one

1001
00:59:25,430 --> 00:59:34,920
argument x, which subtracts
from x the quotient of F

1002
00:59:34,920 --> 00:59:45,045
applied to x and the deriv
of F applied to x.

1003
00:59:45,045 --> 00:59:53,459


1004
00:59:53,459 --> 00:59:54,709
This is guess.

1005
00:59:54,709 --> 00:59:59,960


1006
00:59:59,960 --> 01:00:02,680
This is a perfectly legitimate
program,

1007
01:00:02,680 --> 01:00:04,250
because what I have here--

1008
01:00:04,250 --> 01:00:05,910
remember the evaluation rule.

1009
01:00:05,910 --> 01:00:08,760
The evaluation rule is evaluate
all of the parts of

1010
01:00:08,760 --> 01:00:12,070
the combination: the operator
and the operands.

1011
01:00:12,070 --> 01:00:14,575
This is the operator of
this combination.

1012
01:00:14,575 --> 01:00:17,080


1013
01:00:17,080 --> 01:00:21,080
Evaluating this operator will,
of course, produce the

1014
01:00:21,080 --> 01:00:28,250
derivative of F.

1015
01:00:28,250 --> 01:00:30,300
AUDIENCE: To get it one step
further, you could put the

1016
01:00:30,300 --> 01:00:31,200
lambda expression there, too.

1017
01:00:31,200 --> 01:00:33,180
PROFESSOR: Oh, of course.

1018
01:00:33,180 --> 01:00:37,620
Any time I take something which
is define, I can put the

1019
01:00:37,620 --> 01:00:40,420
thing it's defined to be in
the place where the thing

1020
01:00:40,420 --> 01:00:42,420
defined is.

1021
01:00:42,420 --> 01:00:44,430
I can't remember which is
definiens and which is

1022
01:00:44,430 --> 01:00:45,680
definiendum.

1023
01:00:45,680 --> 01:00:47,490


1024
01:00:47,490 --> 01:00:50,230
When I'm trying to figure out
how to do a lecture about this

1025
01:00:50,230 --> 01:00:54,160
in a freshman class, I use such
words and tell everybody

1026
01:00:54,160 --> 01:00:55,440
it's fun to tell
their friends.

1027
01:00:55,440 --> 01:00:59,470


1028
01:00:59,470 --> 01:01:01,460
OK, I think that's it.

1029
01:01:01,460 --> 01:01:18,506

