0
00:00:00,000 --> 00:00:21,170


1
00:00:21,170 --> 00:00:24,550
PROFESSOR: Well, now that we've
given you some power to

2
00:00:24,550 --> 00:00:28,340
make independent local state
and to model objects, I

3
00:00:28,340 --> 00:00:31,610
thought we'd do a bit of
programming of a very

4
00:00:31,610 --> 00:00:35,380
complicated kind, just to
illustrate what you can do

5
00:00:35,380 --> 00:00:36,630
with this sort of thing.

6
00:00:36,630 --> 00:00:40,430


7
00:00:40,430 --> 00:00:44,080
I suppose, as I said, we were
motivated by physical systems

8
00:00:44,080 --> 00:00:47,200
and the ways we like to think
about physical systems, which

9
00:00:47,200 --> 00:00:52,060
is that there are these things
that the world is made out of.

10
00:00:52,060 --> 00:00:55,570
And each of these things has
particular independent local

11
00:00:55,570 --> 00:00:58,830
state, and therefore
it is a thing.

12
00:00:58,830 --> 00:01:01,280
That's what makes it a thing.

13
00:01:01,280 --> 00:01:04,410
And then we're going to say
that in the model in the

14
00:01:04,410 --> 00:01:07,900
world--we have a world and a
model in our minds and in the

15
00:01:07,900 --> 00:01:10,940
computer of that world.

16
00:01:10,940 --> 00:01:13,230
And what I want to make is a
correspondence between the

17
00:01:13,230 --> 00:01:15,980
objects in the world and the
objects in the computer, the

18
00:01:15,980 --> 00:01:18,140
relationships between the
objects in the world and the

19
00:01:18,140 --> 00:01:21,200
relationships between those same
obj...--the model objects

20
00:01:21,200 --> 00:01:24,890
in the computer, and the
functions that relate things

21
00:01:24,890 --> 00:01:27,320
in the world to the functions
that relate

22
00:01:27,320 --> 00:01:28,570
things in the computer.

23
00:01:28,570 --> 00:01:30,840


24
00:01:30,840 --> 00:01:34,740
This buys us modularity.

25
00:01:34,740 --> 00:01:37,786
If we really believe the world
is like that, that it's made

26
00:01:37,786 --> 00:01:40,120
out of these little pieces, and
of course we could arrange

27
00:01:40,120 --> 00:01:43,085
our world to be like that, we
could only model those things

28
00:01:43,085 --> 00:01:47,030
that are like that, then we can
inherit the modularity in

29
00:01:47,030 --> 00:01:50,450
the world into our
programming.

30
00:01:50,450 --> 00:01:53,150
That's why we would invent some
of this object-oriented

31
00:01:53,150 --> 00:01:55,420
programming.

32
00:01:55,420 --> 00:01:58,890
Well, let's take the best
kind of objects I know.

33
00:01:58,890 --> 00:02:03,160
They're completely--they're
completely wonderful:

34
00:02:03,160 --> 00:02:10,270
electrical systems. Electrical
systems really are the

35
00:02:10,270 --> 00:02:14,220
physicist's best,
best objects.

36
00:02:14,220 --> 00:02:16,760
You see over here I have some
piece of machinery.

37
00:02:16,760 --> 00:02:20,040
Right here's a piece
of machinery.

38
00:02:20,040 --> 00:02:24,270
And it's got an electrical wire
connecting one part of

39
00:02:24,270 --> 00:02:27,190
the machinery with another
part of the machinery.

40
00:02:27,190 --> 00:02:30,450
And one of the wonderful
properties of the electrical

41
00:02:30,450 --> 00:02:34,610
world is that I can say this is
an object, and this is an

42
00:02:34,610 --> 00:02:36,040
object, and they're--

43
00:02:36,040 --> 00:02:38,310
the connection between
them is clear.

44
00:02:38,310 --> 00:02:41,190
In principle, there is no
connection that I didn't

45
00:02:41,190 --> 00:02:44,740
describe with these wires.

46
00:02:44,740 --> 00:02:48,000
Let's say if I have light bulbs,
a light bulb and a

47
00:02:48,000 --> 00:02:51,370
power supply that's plugged
into the outlet.

48
00:02:51,370 --> 00:02:53,620
Then the connection is
perfectly clear.

49
00:02:53,620 --> 00:02:56,220
There's no other connections
that we know of.

50
00:02:56,220 --> 00:02:59,250
If I were to tie a knot in the
wire that connects the light

51
00:02:59,250 --> 00:03:04,040
bulb to the power supply, the
light remains lit up.

52
00:03:04,040 --> 00:03:05,290
It doesn't care.

53
00:03:05,290 --> 00:03:08,300


54
00:03:08,300 --> 00:03:11,120
That the way the physics is
arranged is such that the

55
00:03:11,120 --> 00:03:13,790
connection can be made abstract,
at least for low

56
00:03:13,790 --> 00:03:15,270
frequencies and things
like that.

57
00:03:15,270 --> 00:03:17,840


58
00:03:17,840 --> 00:03:20,360
So in fact, we have captured all
of the connections there

59
00:03:20,360 --> 00:03:22,350
really are.

60
00:03:22,350 --> 00:03:24,310
Well, as you can go one step
further and talk about the

61
00:03:24,310 --> 00:03:27,830
most abstract types of
electrical systems we have,

62
00:03:27,830 --> 00:03:30,951
digital to dual circuits.

63
00:03:30,951 --> 00:03:34,610
And here there are certain
kinds of objects.

64
00:03:34,610 --> 00:03:38,240
For example, in digital
circuits we

65
00:03:38,240 --> 00:03:41,092
have things like inverters.

66
00:03:41,092 --> 00:03:43,990
We have things like and-gates.

67
00:03:43,990 --> 00:03:47,210
We have things like or-gates.

68
00:03:47,210 --> 00:03:53,980
We connect them together by
sort-of wires which represent

69
00:03:53,980 --> 00:03:55,610
abstract signals.

70
00:03:55,610 --> 00:03:57,390
We don't really care as physical
variables whether

71
00:03:57,390 --> 00:04:00,190
these are voltages or currents
or some combination or

72
00:04:00,190 --> 00:04:05,160
anything like that, or water,
water pressure.

73
00:04:05,160 --> 00:04:09,420
These abstract variables
represent certain signals.

74
00:04:09,420 --> 00:04:11,950
And we build systems by
wiring these things

75
00:04:11,950 --> 00:04:14,070
together with wires.

76
00:04:14,070 --> 00:04:17,730
So today what I'm going to show
you, right now, we're

77
00:04:17,730 --> 00:04:22,650
going to build up an invented
language in Lisp, embedded in

78
00:04:22,650 --> 00:04:24,590
the same sense that Henderson's
picture language

79
00:04:24,590 --> 00:04:29,780
was embedded, which is not the
same sense as the language of

80
00:04:29,780 --> 00:04:32,700
pattern match and substitution
was done yesterday.

81
00:04:32,700 --> 00:04:35,725
The pattern match/substitution
language was interpreted by a

82
00:04:35,725 --> 00:04:38,160
Lisp program.

83
00:04:38,160 --> 00:04:40,920
But the embedding of Henderson's
program is that we

84
00:04:40,920 --> 00:04:43,370
just build up more and more
procedures that encapsulate

85
00:04:43,370 --> 00:04:45,480
the structure we want.

86
00:04:45,480 --> 00:04:49,280
So for example here, I'm going
to have some various primitive

87
00:04:49,280 --> 00:04:53,026
kinds of objects, as you see,
that one and that one.

88
00:04:53,026 --> 00:04:55,810
I'm going to use wires
to combine them.

89
00:04:55,810 --> 00:04:58,420
The way I represent
attaching--

90
00:04:58,420 --> 00:04:59,870
I can make wires.

91
00:04:59,870 --> 00:05:01,740
So let's say A is a wire.

92
00:05:01,740 --> 00:05:02,690
And B is a wire.

93
00:05:02,690 --> 00:05:03,460
And C is a wire.

94
00:05:03,460 --> 00:05:04,230
And D is a wire.

95
00:05:04,230 --> 00:05:04,830
And E is wire.

96
00:05:04,830 --> 00:05:06,880
And S is a wire.

97
00:05:06,880 --> 00:05:12,380
Well, an or-gate that has both
inputs, the inputs being A and

98
00:05:12,380 --> 00:05:17,940
B, and the output being Y or
D, you notate like this.

99
00:05:17,940 --> 00:05:22,390
An and-gate, which has inputs
A and B and output C, we

100
00:05:22,390 --> 00:05:24,820
notate like that.

101
00:05:24,820 --> 00:05:29,690
By making such a sequence of
declarations, like this, I can

102
00:05:29,690 --> 00:05:32,750
wire together an arbitrary
circuit.

103
00:05:32,750 --> 00:05:35,940
So I've just told you a set
of primitives and means of

104
00:05:35,940 --> 00:05:40,930
combination for building digital
circuits, when I need

105
00:05:40,930 --> 00:05:43,690
more in a real language
than abstraction.

106
00:05:43,690 --> 00:05:46,766
And so for example,
here I have--here

107
00:05:46,766 --> 00:05:52,240
I have a half adder.

108
00:05:52,240 --> 00:05:54,270
It's something you all
know if you've

109
00:05:54,270 --> 00:05:56,930
done any digital design.

110
00:05:56,930 --> 00:06:00,830
It's used for adding numbers
together on A and B and

111
00:06:00,830 --> 00:06:03,956
putting out a sum and a carry.

112
00:06:03,956 --> 00:06:05,710
And in fact, the wiring
diagram is

113
00:06:05,710 --> 00:06:07,450
exactly what I told you.

114
00:06:07,450 --> 00:06:11,410
A half adder with things that
come out of the box-- you see

115
00:06:11,410 --> 00:06:14,790
the box, the boundary, the
abstraction is always a box.

116
00:06:14,790 --> 00:06:19,700
And there are things that come
out of it, A, B, S, and C.

117
00:06:19,700 --> 00:06:24,950
Those are the declared
variables--declared variables

118
00:06:24,950 --> 00:06:27,020
of a lambda expression,
which is the one that

119
00:06:27,020 --> 00:06:28,270
defines half adder.

120
00:06:28,270 --> 00:06:31,400


121
00:06:31,400 --> 00:06:36,080
And internal to that, I make up
some more wires, D and E,

122
00:06:36,080 --> 00:06:37,760
which I'm going to use for
the interconnect--

123
00:06:37,760 --> 00:06:41,860
here E is this one and D is this
wire, the interconnect

124
00:06:41,860 --> 00:06:45,100
that doesn't come through
the walls of the box--

125
00:06:45,100 --> 00:06:48,790
and wire things together
as you just saw.

126
00:06:48,790 --> 00:06:51,180
And the nice thing about this
that I've just shown you is

127
00:06:51,180 --> 00:06:53,890
this language is hierarchical
in the right way.

128
00:06:53,890 --> 00:06:55,950
If a language isn't hierarchical
in the right way,

129
00:06:55,950 --> 00:06:58,850
if it turns out that a compound
object doesn't look

130
00:06:58,850 --> 00:07:00,820
like a primitive, there's
something

131
00:07:00,820 --> 00:07:02,180
wrong with the language--

132
00:07:02,180 --> 00:07:06,300
at least the way I
feel about that.

133
00:07:06,300 --> 00:07:09,220
So here we have--here, instead
of starting with mathematical

134
00:07:09,220 --> 00:07:10,900
functions, or things that
compute mathematical

135
00:07:10,900 --> 00:07:13,870
functions, which is what we've
been doing up until now,

136
00:07:13,870 --> 00:07:15,770
instead of starting with
things that look like

137
00:07:15,770 --> 00:07:18,080
mathematical functions, or
compute such things, we are

138
00:07:18,080 --> 00:07:21,330
starting with things that are
electrical objects and we

139
00:07:21,330 --> 00:07:23,350
build up more electrical
objects.

140
00:07:23,350 --> 00:07:26,590
And the glue we're using
is basically the

141
00:07:26,590 --> 00:07:30,500
Lisp structure: lambdas.

142
00:07:30,500 --> 00:07:32,930
Lambda is the ultimate
glue, if you will.

143
00:07:32,930 --> 00:07:39,000
And of course, half adder itself
can be used in a more

144
00:07:39,000 --> 00:07:42,250
complicated abstraction called
a full adder, which in fact

145
00:07:42,250 --> 00:07:46,670
involves two half adders, as you
see here, hooked together

146
00:07:46,670 --> 00:07:50,600
with some extra wires, that you
see here, S, C1, and C2,

147
00:07:50,600 --> 00:07:57,340
and an or-gate, to manufacture
a full adder, which takes a

148
00:07:57,340 --> 00:08:01,570
input number, another input
number, a carry in, and

149
00:08:01,570 --> 00:08:05,900
produces output, a sum
and a carry out.

150
00:08:05,900 --> 00:08:09,820
And out of full adders, you can
make real adder chains and

151
00:08:09,820 --> 00:08:12,990
big adders.

152
00:08:12,990 --> 00:08:18,870
So we have here a language so
far that has primitives, means

153
00:08:18,870 --> 00:08:22,270
of combination, and means of
abstraction to real language.

154
00:08:22,270 --> 00:08:25,000
Now, how are we going
to implement this?

155
00:08:25,000 --> 00:08:27,070
Well, let's do it easily.

156
00:08:27,070 --> 00:08:28,610
Let's look at the primitives.

157
00:08:28,610 --> 00:08:31,160
The only problem is we have to
implement the primitives.

158
00:08:31,160 --> 00:08:34,270
Nothing else has to be
implemented, because we're

159
00:08:34,270 --> 00:08:37,640
picking up the means of
combination and abstraction

160
00:08:37,640 --> 00:08:43,417
from Lisp, inheriting them
in the embedding.

161
00:08:43,417 --> 00:08:45,860
OK, so let's look at a
particular primitive.

162
00:08:45,860 --> 00:08:47,400
An inverter is a nice one.

163
00:08:47,400 --> 00:08:51,540


164
00:08:51,540 --> 00:08:54,900
Now, inverter has two wires
coming in, an in and an out.

165
00:08:54,900 --> 00:08:57,440


166
00:08:57,440 --> 00:09:01,570
And somehow, it's going to have
to know what to do when a

167
00:09:01,570 --> 00:09:04,300
signal comes in.

168
00:09:04,300 --> 00:09:07,710
So somehow it's going to have
to tell its input wire--

169
00:09:07,710 --> 00:09:10,756
and now we're going to talk
about objects and we're going

170
00:09:10,756 --> 00:09:13,260
to see this in a little
more detail soon--

171
00:09:13,260 --> 00:09:16,660
but it's going to have to tell
its input wire that when you

172
00:09:16,660 --> 00:09:20,120
change, tell me.

173
00:09:20,120 --> 00:09:22,720
So this object, the object which
is the inverter has to

174
00:09:22,720 --> 00:09:25,070
tell the object which
is the input wire,

175
00:09:25,070 --> 00:09:26,870
hi, my name is George.

176
00:09:26,870 --> 00:09:30,480
And my, my job is to do
something with results when

177
00:09:30,480 --> 00:09:31,720
you change.

178
00:09:31,720 --> 00:09:34,730
So when you change, you get a
change, tell me about it.

179
00:09:34,730 --> 00:09:37,010
Because I've got to do
something with that.

180
00:09:37,010 --> 00:09:42,200
Well, that's done down here by
adding an action on the input

181
00:09:42,200 --> 00:09:47,020
wire called invert-in, where
invert-in is defined over here

182
00:09:47,020 --> 00:09:51,660
to be a procedure of no
arguments, which gets the

183
00:09:51,660 --> 00:09:56,130
logical not of the signal
on the input wire.

184
00:09:56,130 --> 00:09:59,720
And after some delay, which is
the inverter delay, all these

185
00:09:59,720 --> 00:10:04,110
electrical objects have delays,
we'll do the following

186
00:10:04,110 --> 00:10:07,140
thing-- set the signal on the
output wire to the new value.

187
00:10:07,140 --> 00:10:10,160


188
00:10:10,160 --> 00:10:12,400
A very simple program.

189
00:10:12,400 --> 00:10:14,820
Now, you have to imagine that
the output wire has to be

190
00:10:14,820 --> 00:10:19,650
sensitive and know that when
its signal changes, it may

191
00:10:19,650 --> 00:10:23,840
have to tell other guys,
hey, wake up.

192
00:10:23,840 --> 00:10:26,050
My value has changed.

193
00:10:26,050 --> 00:10:29,350
So when you hook together
inverter with an and-gate or

194
00:10:29,350 --> 00:10:31,680
something like that, there has
to be a lot of communication

195
00:10:31,680 --> 00:10:34,040
going on in order to
make sure that the

196
00:10:34,040 --> 00:10:36,810
signal propagates right.

197
00:10:36,810 --> 00:10:38,620
And down here is nothing
very exciting.

198
00:10:38,620 --> 00:10:41,100
This is just the definition
of logical not for some

199
00:10:41,100 --> 00:10:44,170
particular representations
of the logical values--

200
00:10:44,170 --> 00:10:46,240
1, 0 in this case.

201
00:10:46,240 --> 00:10:49,780
And we can look at things more
complicated like and-gates.

202
00:10:49,780 --> 00:10:55,000
And-gates take two inputs, A1
and A2, we'll call them, and

203
00:10:55,000 --> 00:10:56,950
produce an output.

204
00:10:56,950 --> 00:10:59,840
But the structure of the
and-gate is identical to the

205
00:10:59,840 --> 00:11:00,860
one we just saw.

206
00:11:00,860 --> 00:11:03,000
There's one called an and-action
procedure that's

207
00:11:03,000 --> 00:11:08,570
defined, which is the thing that
gets called when an input

208
00:11:08,570 --> 00:11:10,910
is changed.

209
00:11:10,910 --> 00:11:13,230
And what it does, of course, is
nothing more than compute

210
00:11:13,230 --> 00:11:15,900
the logical and of the signals
on the inputs.

211
00:11:15,900 --> 00:11:20,890
And after some delay, called the
and-gate delay, calls this

212
00:11:20,890 --> 00:11:25,470
procedure, which sets a signal
on the output to a new value.

213
00:11:25,470 --> 00:11:27,320
Now, how I implement
these things

214
00:11:27,320 --> 00:11:28,350
is all wishful thinking.

215
00:11:28,350 --> 00:11:32,020
As you see here, I have an
assignment operation.

216
00:11:32,020 --> 00:11:34,570
It's not set.

217
00:11:34,570 --> 00:11:36,820
It's a derived assignment
operation in the same way we

218
00:11:36,820 --> 00:11:41,140
had functions that were derived
from CAR and CDR. So

219
00:11:41,140 --> 00:11:46,340
I, by convention, label that
with an exclamation point.

220
00:11:46,340 --> 00:11:50,730
And over here, you see there's
an action, which is to inform

221
00:11:50,730 --> 00:11:57,190
the wire, called A1 locally in
this and-gate, to call the

222
00:11:57,190 --> 00:12:00,960
and-action procedure when it
gets changed, and the wire A2

223
00:12:00,960 --> 00:12:02,100
to call the and-action
procedure

224
00:12:02,100 --> 00:12:03,350
when it gets changed.

225
00:12:03,350 --> 00:12:06,310


226
00:12:06,310 --> 00:12:09,510
All very simple.

227
00:12:09,510 --> 00:12:12,870
Well, let's talk a little bit
about this communication that

228
00:12:12,870 --> 00:12:18,310
must occur between these
various parts.

229
00:12:18,310 --> 00:12:24,560
Suppose, for example, I have
a very simple circuit which

230
00:12:24,560 --> 00:12:34,230
contains an and with wires A
and B. And that connects

231
00:12:34,230 --> 00:12:40,580
through a wire called C to an
inverter which has a wire

232
00:12:40,580 --> 00:12:46,310
output called D. What are
the comput...--here's

233
00:12:46,310 --> 00:12:47,360
the physical world.

234
00:12:47,360 --> 00:12:49,860
It's an abstraction of
the physical world.

235
00:12:49,860 --> 00:12:52,010
Now I can buy these out of
little pieces that you get at

236
00:12:52,010 --> 00:12:54,880
Radio Shack for a few cents.

237
00:12:54,880 --> 00:12:57,680
And there are boxes that act
like this, which have little

238
00:12:57,680 --> 00:13:01,530
numbers on them like
LS04 or something.

239
00:13:01,530 --> 00:13:06,980
Now supposing I were to
try to say what's the

240
00:13:06,980 --> 00:13:09,010
computational model.

241
00:13:09,010 --> 00:13:11,610
What is the thing that
corresponds to that, that part

242
00:13:11,610 --> 00:13:15,850
of reality in the mind of
us and in the computer?

243
00:13:15,850 --> 00:13:18,200
Well, I have to assign for every
object in the world an

244
00:13:18,200 --> 00:13:22,160
object in the computer, and for
every relationship in the

245
00:13:22,160 --> 00:13:25,750
world between them a
relationship in the computer.

246
00:13:25,750 --> 00:13:28,560
That's my goal.

247
00:13:28,560 --> 00:13:30,900
So let's do that.

248
00:13:30,900 --> 00:13:35,401
Well, I have some sort of thing
called the signal, A.

249
00:13:35,401 --> 00:13:37,940
This is A. It's a signal.

250
00:13:37,940 --> 00:13:39,900
It's a cloudy thing like that.

251
00:13:39,900 --> 00:13:42,390
And I have another one down here
which I'm going to call

252
00:13:42,390 --> 00:13:49,140
B. It's another signal.

253
00:13:49,140 --> 00:13:52,070
Now this signal--these two
signals are somehow going to

254
00:13:52,070 --> 00:13:56,180
have to hook together into a
box, let's call it this, which

255
00:13:56,180 --> 00:14:00,320
is the and-gate, action
procedure.

256
00:14:00,320 --> 00:14:02,040
That's the and-gate's
action procedure.

257
00:14:02,040 --> 00:14:07,660


258
00:14:07,660 --> 00:14:09,750
And it's going to produce--well,
it's going to

259
00:14:09,750 --> 00:14:18,360
interact with a signal object,
which we call C--a wire

260
00:14:18,360 --> 00:14:21,330
object, excuse me, we call
C. And then the--

261
00:14:21,330 --> 00:14:25,630
this is going to put out again,
or connect to, another

262
00:14:25,630 --> 00:14:28,240
action procedure which is one
associated with the inverter

263
00:14:28,240 --> 00:14:30,195
in the world, not.

264
00:14:30,195 --> 00:14:32,860


265
00:14:32,860 --> 00:14:39,980
And I'm going to have
another--another wire, which

266
00:14:39,980 --> 00:14:42,970
we'll call D.

267
00:14:42,970 --> 00:14:45,770
So here's my layout of stuff.

268
00:14:45,770 --> 00:14:47,650
Now we have to say what's inside
them and what they have

269
00:14:47,650 --> 00:14:51,500
to know to compute.

270
00:14:51,500 --> 00:14:53,900
Well, every--every one of these
wires has to know what

271
00:14:53,900 --> 00:14:57,340
the value of the signal that's
on that wire is.

272
00:14:57,340 --> 00:14:59,430
So there's going to be some
variable inside here, we'll

273
00:14:59,430 --> 00:15:00,680
call it signal.

274
00:15:00,680 --> 00:15:02,670


275
00:15:02,670 --> 00:15:05,840
And he owns a value.

276
00:15:05,840 --> 00:15:06,870
So there must be some
environment

277
00:15:06,870 --> 00:15:08,656
associated with this.

278
00:15:08,656 --> 00:15:10,550
And for each one of these, there
must be an environment

279
00:15:10,550 --> 00:15:11,800
that binds signal.

280
00:15:11,800 --> 00:15:15,400


281
00:15:15,400 --> 00:15:16,880
And there must be a signal
here, therefore.

282
00:15:16,880 --> 00:15:19,400


283
00:15:19,400 --> 00:15:22,920
And presumably, signal's a value
that's either 1 or 0,

284
00:15:22,920 --> 00:15:24,170
and signal.

285
00:15:24,170 --> 00:15:28,000


286
00:15:28,000 --> 00:15:33,140
Now, we also have to have some
list of people to inform if

287
00:15:33,140 --> 00:15:34,390
the signal here changes.

288
00:15:34,390 --> 00:15:36,660


289
00:15:36,660 --> 00:15:39,300
We're going to have
to inform this.

290
00:15:39,300 --> 00:15:41,470
So I've got that list.
We'll call it the

291
00:15:41,470 --> 00:15:44,500
Action Procedures, AP.

292
00:15:44,500 --> 00:15:47,590
And it's presumably a list.
But the first thing on the

293
00:15:47,590 --> 00:15:50,500
list, in this case,
is this guy.

294
00:15:50,500 --> 00:15:53,730
And the action procedures of
this one happens to have some

295
00:15:53,730 --> 00:15:54,810
list of stuff.

296
00:15:54,810 --> 00:15:57,510
There might be other people
who are sharing A, who are

297
00:15:57,510 --> 00:15:59,020
looking at it.

298
00:15:59,020 --> 00:16:02,060
So there might be other guys
on this list, like somebody

299
00:16:02,060 --> 00:16:03,630
over there that we
don't know about.

300
00:16:03,630 --> 00:16:07,200
It's the other guy
attached to A.

301
00:16:07,200 --> 00:16:11,230
And the action procedure here
also has to point to that, the

302
00:16:11,230 --> 00:16:13,070
list of action procedures.

303
00:16:13,070 --> 00:16:17,060
And of course, that means this
one, its action procedures has

304
00:16:17,060 --> 00:16:18,530
to point up to here.

305
00:16:18,530 --> 00:16:18,770
This is the things--

306
00:16:18,770 --> 00:16:21,770
the people it has to inform.

307
00:16:21,770 --> 00:16:24,280
And this guy has some too.

308
00:16:24,280 --> 00:16:25,660
But I don't know what they
are because I didn't

309
00:16:25,660 --> 00:16:27,190
draw it in my diagram.

310
00:16:27,190 --> 00:16:30,320
It's the things connected
to D.

311
00:16:30,320 --> 00:16:36,240
Now, it's also the case that
when the and-action procedure

312
00:16:36,240 --> 00:16:41,951
is awakened, saying one of the
people who know that you've

313
00:16:41,951 --> 00:16:44,010
told--one of the people you've
told to wake you up if their

314
00:16:44,010 --> 00:16:48,430
signal changes, you have to go
look and ask them what's their

315
00:16:48,430 --> 00:16:51,540
signal so you can do the
and, and produce a

316
00:16:51,540 --> 00:16:52,790
signal for this one.

317
00:16:52,790 --> 00:16:57,090


318
00:16:57,090 --> 00:16:59,760
So there has to be, for example,
information here

319
00:16:59,760 --> 00:17:06,400
saying A1, my A1 is this guy,
and my A2 is this guy.

320
00:17:06,400 --> 00:17:08,930


321
00:17:08,930 --> 00:17:14,170
And not only that, when I do my
and, I'm going to have to

322
00:17:14,170 --> 00:17:16,170
tell this guy something.

323
00:17:16,170 --> 00:17:17,420
So I need an output--

324
00:17:17,420 --> 00:17:19,904


325
00:17:19,904 --> 00:17:21,160
being this guy.

326
00:17:21,160 --> 00:17:25,800


327
00:17:25,800 --> 00:17:29,550
And similarly, this guy's going
to have a thing called

328
00:17:29,550 --> 00:17:37,540
the input that he interrogates
to find out what the value of

329
00:17:37,540 --> 00:17:39,430
the signal on the input is, when
the signal wakes up and

330
00:17:39,430 --> 00:17:42,980
says, I've changed, and sends
a message this way saying,

331
00:17:42,980 --> 00:17:43,520
I've changed.

332
00:17:43,520 --> 00:17:46,900
This guy says, OK, what's
your value now?

333
00:17:46,900 --> 00:17:50,840
When he gets that value, then
he's going to have to say, OK,

334
00:17:50,840 --> 00:17:55,860
output changes this guy,
changes this guy.

335
00:17:55,860 --> 00:18:00,600


336
00:18:00,600 --> 00:18:02,481
And so on.

337
00:18:02,481 --> 00:18:06,240
And so I have to have at least
that much connected-ness.

338
00:18:06,240 --> 00:18:10,260
Now, let's go back and look, for
example, at the and-gate.

339
00:18:10,260 --> 00:18:13,670
Here we are back
on this slide.

340
00:18:13,670 --> 00:18:16,040
And we can see some
of these parts.

341
00:18:16,040 --> 00:18:18,470
For any particular and-gate,
there is an A1, there is an

342
00:18:18,470 --> 00:18:21,030
A2, and the output.

343
00:18:21,030 --> 00:18:21,483
And those are, those are an
environment that was created

344
00:18:21,483 --> 00:18:30,720
at the--those produce a frame
at the time and-gate was

345
00:18:30,720 --> 00:18:37,200
called, a frame where A1, A2,
and output are--have as their

346
00:18:37,200 --> 00:18:41,940
values, they're bound to the
wires which, they are--which

347
00:18:41,940 --> 00:18:46,240
were passed in.

348
00:18:46,240 --> 00:18:50,890
In that environment, I
constructed a procedure--

349
00:18:50,890 --> 00:18:54,590
this one right there.

350
00:18:54,590 --> 00:18:56,810
And-action procedure was
constructed in that

351
00:18:56,810 --> 00:18:57,780
environment.

352
00:18:57,780 --> 00:19:00,190
That was the result of
evaluating a lambda

353
00:19:00,190 --> 00:19:01,620
expression.

354
00:19:01,620 --> 00:19:07,620
So it hangs onto the frame
where these were defined.

355
00:19:07,620 --> 00:19:11,700
Local--part of its local
state is that.

356
00:19:11,700 --> 00:19:15,000
The and-action procedure,
therefore, has access to A1,

357
00:19:15,000 --> 00:19:17,310
A2, and output as we see here.

358
00:19:17,310 --> 00:19:19,645
A1, A2, and output.

359
00:19:19,645 --> 00:19:22,360


360
00:19:22,360 --> 00:19:26,030
Now, we haven't looked
inside of a wire yet.

361
00:19:26,030 --> 00:19:29,030
That's all that remains.

362
00:19:29,030 --> 00:19:30,280
Let's look at a wire.

363
00:19:30,280 --> 00:19:33,520


364
00:19:33,520 --> 00:19:36,160
Like the overhead, very good.

365
00:19:36,160 --> 00:19:39,500


366
00:19:39,500 --> 00:19:40,940
Well, the wire, again,
is a, is a

367
00:19:40,940 --> 00:19:43,090
somewhat complicated mess.

368
00:19:43,090 --> 00:19:46,840
Ooh, wrong one.

369
00:19:46,840 --> 00:19:49,780
It's a big complicated
mess, like that.

370
00:19:49,780 --> 00:19:54,720
But let's look at it in detail
and see what's going on.

371
00:19:54,720 --> 00:19:57,760
Well, the wire is
one of these.

372
00:19:57,760 --> 00:20:02,320
And it has to have two things
that are part of

373
00:20:02,320 --> 00:20:05,010
it, that it's state.

374
00:20:05,010 --> 00:20:07,390
One of them is the signal
we see here.

375
00:20:07,390 --> 00:20:10,670
In other words, when we call
make-wire to make a wire, then

376
00:20:10,670 --> 00:20:15,300
the first thing we do is we
create some variables which

377
00:20:15,300 --> 00:20:19,270
are the signal and the action
procedures for this wire.

378
00:20:19,270 --> 00:20:22,042


379
00:20:22,042 --> 00:20:26,540
And in that context, we define
various functions--or

380
00:20:26,540 --> 00:20:27,840
procedures, excuse
me, procedures.

381
00:20:27,840 --> 00:20:32,850
One of them is called
set-my-signal to a new value.

382
00:20:32,850 --> 00:20:37,930
And what that does is takes
a new value in.

383
00:20:37,930 --> 00:20:40,360
If that's equal to my current
value of my signal, I'm done.

384
00:20:40,360 --> 00:20:43,460
Otherwise, I set the signal to
the new value and call each of

385
00:20:43,460 --> 00:20:47,081
the action procedures that
I've been, that I've

386
00:20:47,081 --> 00:20:48,331
been--what's the right word?--

387
00:20:48,331 --> 00:20:51,700


388
00:20:51,700 --> 00:20:54,630
introduced to.

389
00:20:54,630 --> 00:21:01,530
I get introduced when the
and-gate was applied to me.

390
00:21:01,530 --> 00:21:04,130


391
00:21:04,130 --> 00:21:07,410
I add action procedure
at the bottom.

392
00:21:07,410 --> 00:21:10,440
Also, I have to define a way
of accepting an action

393
00:21:10,440 --> 00:21:12,780
procedure-- which is what
you see here---

394
00:21:12,780 --> 00:21:18,530
which increments my action
procedures using set to the

395
00:21:18,530 --> 00:21:22,060
result of CONSing up a new
process--a procedure, which is

396
00:21:22,060 --> 00:21:25,760
passed to me, on to my actions
procedures list. And for

397
00:21:25,760 --> 00:21:27,780
technical reasons, I have to
call that procedure one.

398
00:21:27,780 --> 00:21:29,660
So I'm not going to tell you
anything about that, that has

399
00:21:29,660 --> 00:21:32,610
to do with event-driven
simulations and getting them

400
00:21:32,610 --> 00:21:36,950
started, which takes a little
bit of thinking.

401
00:21:36,950 --> 00:21:38,690
And finally, I'm going to define
a thing called the

402
00:21:38,690 --> 00:21:45,390
dispatcher, which is a way of
passing a message to a wire,

403
00:21:45,390 --> 00:21:48,030
which is going to be used to
extract from it various

404
00:21:48,030 --> 00:21:53,820
information, like what is the
current signal value?

405
00:21:53,820 --> 00:21:57,180
What is the method of
setting your signal?

406
00:21:57,180 --> 00:22:00,100
I want to get that out of it.

407
00:22:00,100 --> 00:22:02,600
How do I--how do I add another
action procedure?

408
00:22:02,600 --> 00:22:05,510


409
00:22:05,510 --> 00:22:08,280
And I'm going to return
that dispatch, that

410
00:22:08,280 --> 00:22:09,940
procedure as a value.

411
00:22:09,940 --> 00:22:12,610
So the wire that I've
constructed is a message

412
00:22:12,610 --> 00:22:16,710
accepting object which accepts
a message like, like what's

413
00:22:16,710 --> 00:22:19,790
your method of adding
action procedures?

414
00:22:19,790 --> 00:22:22,270
In fact, it'll give me a
procedure, which is the add

415
00:22:22,270 --> 00:22:26,020
action procedure, which I can
then apply to an action

416
00:22:26,020 --> 00:22:29,010
procedure to create another
action procedure in the wire.

417
00:22:29,010 --> 00:22:31,620


418
00:22:31,620 --> 00:22:32,820
So that's a permission.

419
00:22:32,820 --> 00:22:37,450
So it's given me permission to
change your action procedures.

420
00:22:37,450 --> 00:22:41,710
And in fact, you can
see that over here.

421
00:22:41,710 --> 00:22:43,278
Next slide.

422
00:22:43,278 --> 00:22:44,528
Ah.

423
00:22:44,528 --> 00:22:47,760


424
00:22:47,760 --> 00:22:49,120
This is nothing very
interesting.

425
00:22:49,120 --> 00:22:52,040
The call each of the action
procedures is just a CDRing

426
00:22:52,040 --> 00:22:53,500
down a list. And I'm
not going to even

427
00:22:53,500 --> 00:22:54,990
talk about that anymore.

428
00:22:54,990 --> 00:22:57,560
We're too advanced for that.

429
00:22:57,560 --> 00:23:00,280
However, if I want to
get a signal from a

430
00:23:00,280 --> 00:23:02,250
wire, I ask the wire--

431
00:23:02,250 --> 00:23:03,090
which is, what is the wire?

432
00:23:03,090 --> 00:23:05,860
The wire is the dispatch
returned by creating the wire.

433
00:23:05,860 --> 00:23:06,830
It's a procedure.

434
00:23:06,830 --> 00:23:12,590
I call that dispatch on the
message get-signal.

435
00:23:12,590 --> 00:23:14,770
And what I should expect
to get is a method

436
00:23:14,770 --> 00:23:16,900
of getting a signal.

437
00:23:16,900 --> 00:23:19,220
Or actually, I get the signal.

438
00:23:19,220 --> 00:23:25,800
If I want to set a signal, I
want to change a signal, then

439
00:23:25,800 --> 00:23:28,810
what I'm going to do is take a
wire as an argument and a new

440
00:23:28,810 --> 00:23:31,120
value for the signal, I'm going
to ask the wire for

441
00:23:31,120 --> 00:23:35,660
permission to set its signal and
use that permission, which

442
00:23:35,660 --> 00:23:38,700
is a procedure, on
the new value.

443
00:23:38,700 --> 00:23:44,156
And if we go back to the
overhead here, thank you, if

444
00:23:44,156 --> 00:23:46,880
we go back to the overhead here,
we see that the method--

445
00:23:46,880 --> 00:23:49,720
if I ask for the method of
setting the signal, that's

446
00:23:49,720 --> 00:23:54,620
over here, it's set-my-signal,
a procedure that's defined

447
00:23:54,620 --> 00:23:59,270
inside the wire, which if we
look over here is the thing

448
00:23:59,270 --> 00:24:02,930
that says set my internal value
called the signal, my

449
00:24:02,930 --> 00:24:08,640
internal variable, which is the
signal, to the new value,

450
00:24:08,640 --> 00:24:11,630
which is passed to me as an
argument, and then call each

451
00:24:11,630 --> 00:24:13,010
of the action procedures
waking them up.

452
00:24:13,010 --> 00:24:16,340


453
00:24:16,340 --> 00:24:19,400
Very simple.

454
00:24:19,400 --> 00:24:24,310
Going back to that slide, we
also have the one last thing--

455
00:24:24,310 --> 00:24:27,810
which I suppose now you can
easily work out for yourself--

456
00:24:27,810 --> 00:24:30,100
is the way you add an action.

457
00:24:30,100 --> 00:24:36,470
You take a wire--a wire and
an action procedure.

458
00:24:36,470 --> 00:24:40,050
And I ask the wire for
permission to add an action.

459
00:24:40,050 --> 00:24:43,210
Getting that permission, I use
that permission to give it an

460
00:24:43,210 --> 00:24:45,020
action procedure.

461
00:24:45,020 --> 00:24:48,570
So that's a real object.

462
00:24:48,570 --> 00:24:52,460
There's a few more details
about this.

463
00:24:52,460 --> 00:24:58,390
For example, how am I going
to control this thing?

464
00:24:58,390 --> 00:25:01,290
How do I do these delays?

465
00:25:01,290 --> 00:25:02,540
Let's look at that
for a second.

466
00:25:02,540 --> 00:25:05,275


467
00:25:05,275 --> 00:25:08,360
The next one here.

468
00:25:08,360 --> 00:25:09,570
Let's see.

469
00:25:09,570 --> 00:25:15,450
We know when we looked at the
and-gate or the not-gate that

470
00:25:15,450 --> 00:25:18,770
when a signal changed on the
input, there was a delay.

471
00:25:18,770 --> 00:25:22,060
And then it was going to call
the procedure, which was going

472
00:25:22,060 --> 00:25:23,310
to change the output.

473
00:25:23,310 --> 00:25:26,040


474
00:25:26,040 --> 00:25:28,120
Well, how are we going
to do this?

475
00:25:28,120 --> 00:25:30,600
We're going to make up some
mechanism, a fairly

476
00:25:30,600 --> 00:25:32,840
complicated mechanism at that,
which we're going to have to

477
00:25:32,840 --> 00:25:34,720
be very careful about.

478
00:25:34,720 --> 00:25:37,390
But after a delay, we're
going to do an action.

479
00:25:37,390 --> 00:25:40,590
A delay is a number, and an
action is a procedure.

480
00:25:40,590 --> 00:25:41,970
What that's going to be is
they're going to have a

481
00:25:41,970 --> 00:25:47,120
special structure called an
agenda, which is a thing that

482
00:25:47,120 --> 00:25:49,510
organizes time and actions.

483
00:25:49,510 --> 00:25:50,880
And we're going to see
that in a while.

484
00:25:50,880 --> 00:25:53,070
I don't want to get into
that right now.

485
00:25:53,070 --> 00:25:55,745
But the agenda has a
moment at which--at

486
00:25:55,745 --> 00:25:59,130
which something happens.

487
00:25:59,130 --> 00:26:03,120
We're setting up for later at
some moment, which is the sum

488
00:26:03,120 --> 00:26:05,400
of the time, which is the delay
time plus the current

489
00:26:05,400 --> 00:26:08,460
time, which the agenda
thinks is now.

490
00:26:08,460 --> 00:26:11,840
We're going to set up to do this
action, and add that to

491
00:26:11,840 --> 00:26:13,090
the agenda.

492
00:26:13,090 --> 00:26:15,280


493
00:26:15,280 --> 00:26:18,660
And the way this machine will
now run is very simple.

494
00:26:18,660 --> 00:26:20,800
We have a thing called
propagate, which is the way

495
00:26:20,800 --> 00:26:22,710
things run.

496
00:26:22,710 --> 00:26:25,290
If the agenda is empty, we're
done--if there's nothing more

497
00:26:25,290 --> 00:26:27,440
to be done.

498
00:26:27,440 --> 00:26:31,690
Otherwise, we're going to take
the first item off the agenda,

499
00:26:31,690 --> 00:26:34,200
and that's a procedure
of no arguments.

500
00:26:34,200 --> 00:26:36,030
So that we're going to see
extra parentheses here.

501
00:26:36,030 --> 00:26:39,190
We call that on no arguments.

502
00:26:39,190 --> 00:26:42,200
That takes the action.

503
00:26:42,200 --> 00:26:45,050
Then we remove that first item
from the agenda, and we go

504
00:26:45,050 --> 00:26:48,395
around the propagation loop.

505
00:26:48,395 --> 00:26:50,750
So that's the overall structure
of this thing.

506
00:26:50,750 --> 00:26:53,380


507
00:26:53,380 --> 00:26:57,430
Now, there's a, a few other
things we can look at.

508
00:26:57,430 --> 00:26:59,160
And then we're going to
look into the agenda a

509
00:26:59,160 --> 00:27:00,410
little while from now.

510
00:27:00,410 --> 00:27:02,800
Now the overhead again.

511
00:27:02,800 --> 00:27:04,980
Well, in order to set this thing
going, I just want to

512
00:27:04,980 --> 00:27:07,410
show you some behavior out
of this simulator.

513
00:27:07,410 --> 00:27:10,610
By the way, you may think this
simulator is very simple, and

514
00:27:10,610 --> 00:27:12,370
probably too simple
to be useful.

515
00:27:12,370 --> 00:27:15,730
The fact of the matter is that
this simulator has been used

516
00:27:15,730 --> 00:27:18,680
to manufacture a fairly
large computer.

517
00:27:18,680 --> 00:27:22,360
So this is a real
live example.

518
00:27:22,360 --> 00:27:24,790
Actually, not exactly this
simulator, because I'll tell

519
00:27:24,790 --> 00:27:25,560
you the difference.

520
00:27:25,560 --> 00:27:28,180
The difference is that there
were many more different kinds

521
00:27:28,180 --> 00:27:29,820
of primitives.

522
00:27:29,820 --> 00:27:33,200
There's not just the word
inverter or and-gate.

523
00:27:33,200 --> 00:27:37,590
There were things like
edge-triggered, flip-flops,

524
00:27:37,590 --> 00:27:43,780
and latches, transparent
latches, and adders, and

525
00:27:43,780 --> 00:27:45,170
things like that.

526
00:27:45,170 --> 00:27:48,510
And the difficulty with that
is that there's pages and

527
00:27:48,510 --> 00:27:51,410
pages of the definitions of
all these primitives with

528
00:27:51,410 --> 00:27:54,690
numbers like LS04.

529
00:27:54,690 --> 00:27:56,740
And then there's many more
parameters for them.

530
00:27:56,740 --> 00:27:58,480
It's not just one delay.

531
00:27:58,480 --> 00:28:00,020
There's things like set
up times and hold

532
00:28:00,020 --> 00:28:01,220
times and all that.

533
00:28:01,220 --> 00:28:03,990
But with the exception of that
part of the complexity, the

534
00:28:03,990 --> 00:28:07,580
structure of the simulator that
we use for building a

535
00:28:07,580 --> 00:28:12,290
real computer, that works
is exactly what

536
00:28:12,290 --> 00:28:15,110
you're seeing here.

537
00:28:15,110 --> 00:28:19,270
Well in any case, what we have
here is a few simple things.

538
00:28:19,270 --> 00:28:21,580
Like, there's inverter delays
being set up and

539
00:28:21,580 --> 00:28:23,030
making a new agenda.

540
00:28:23,030 --> 00:28:26,470
And then we can make
some inputs.

541
00:28:26,470 --> 00:28:28,220
There's input-1, input-2,
a sum and a

542
00:28:28,220 --> 00:28:29,460
carry, which are wires.

543
00:28:29,460 --> 00:28:32,560
I'm going to put a special kind
of object called a probe

544
00:28:32,560 --> 00:28:37,810
onto, onto some of the wires,
onto sum and onto carry.

545
00:28:37,810 --> 00:28:41,590
A probe is a, can object that
has the property that when you

546
00:28:41,590 --> 00:28:46,120
change a wire it's attached to,
it types out a message.

547
00:28:46,120 --> 00:28:47,970
It's an easy thing to do.

548
00:28:47,970 --> 00:28:50,790
And then once we have that, of
course, the way you put the

549
00:28:50,790 --> 00:28:53,040
probe on, the first thing it
does, it says, the current

550
00:28:53,040 --> 00:28:59,400
value of the sum at time 0 is
0 because I just noticed it.

551
00:28:59,400 --> 00:29:02,640
And the value of the carry
at time 0, this is

552
00:29:02,640 --> 00:29:05,556
the time, is 0.

553
00:29:05,556 --> 00:29:09,620
And then we go off and we
build some structure.

554
00:29:09,620 --> 00:29:14,440
Like, we can build a structure
here that says you have a

555
00:29:14,440 --> 00:29:18,420
half-adder on input-1, input-2,
sum, and carry.

556
00:29:18,420 --> 00:29:20,420
And we're going to set the
signal on input-1 to 1.

557
00:29:20,420 --> 00:29:21,880
We do some propagation.

558
00:29:21,880 --> 00:29:25,380
At time 8, which you could see
going through this thing if

559
00:29:25,380 --> 00:29:29,520
you wanted to, the new value
of sum became 1.

560
00:29:29,520 --> 00:29:31,150
And the thing says I'm done.

561
00:29:31,150 --> 00:29:32,630
That wasn't very interesting.

562
00:29:32,630 --> 00:29:34,150
But we can send it some
more signals.

563
00:29:34,150 --> 00:29:36,590
Like, we set-signal on
input-2 to be one.

564
00:29:36,590 --> 00:29:39,430
And at that time if we
propagate, then it carried at

565
00:29:39,430 --> 00:29:43,280
11, the carry becomes 1, and
at 16, the sum's new

566
00:29:43,280 --> 00:29:45,040
value becomes 0.

567
00:29:45,040 --> 00:29:48,060
And you might want to work out
that, if you like, about the

568
00:29:48,060 --> 00:29:48,990
digital circuitry.

569
00:29:48,990 --> 00:29:50,620
It's true, and it works.

570
00:29:50,620 --> 00:29:51,535
And it's not very interesting.

571
00:29:51,535 --> 00:29:53,330
But that's the kind
of behavior we

572
00:29:53,330 --> 00:29:54,580
get out of this thing.

573
00:29:54,580 --> 00:30:01,830


574
00:30:01,830 --> 00:30:06,550
So what I've shown you right now
is a large-scale picture,

575
00:30:06,550 --> 00:30:10,360
how you, at a bigger, big
scale, you implement an

576
00:30:10,360 --> 00:30:12,952
event-driven simulation
of some sort.

577
00:30:12,952 --> 00:30:16,010
And how you might organize it
to have nice hierarchical

578
00:30:16,010 --> 00:30:20,220
structure allowing you to build
abstract boxes that you

579
00:30:20,220 --> 00:30:21,225
can instantiate.

580
00:30:21,225 --> 00:30:23,630
But I haven't told you any of
the details about how this

581
00:30:23,630 --> 00:30:25,780
agenda and things
like that work.

582
00:30:25,780 --> 00:30:28,630
That we'll do next.

583
00:30:28,630 --> 00:30:32,040
And that's going to involve
change and mutation of data

584
00:30:32,040 --> 00:30:34,310
and things like that.

585
00:30:34,310 --> 00:30:35,860
Are there any questions
now, before I go on?

586
00:30:35,860 --> 00:30:47,160


587
00:30:47,160 --> 00:30:47,550
Thank you.

588
00:30:47,550 --> 00:30:48,800
Let's take a break.

589
00:30:48,800 --> 00:31:28,940


590
00:31:28,940 --> 00:31:35,060
Well, we've been making
a simulation.

591
00:31:35,060 --> 00:31:39,360
And the simulation is an
event-driven simulation where

592
00:31:39,360 --> 00:31:43,920
the objects in the world are the
objects in the computer.

593
00:31:43,920 --> 00:31:46,700
And the changes of state that
are happening in the world in

594
00:31:46,700 --> 00:31:53,520
time are organized to be time
in the computer, so that if

595
00:31:53,520 --> 00:31:56,430
something happens after
something else in the world,

596
00:31:56,430 --> 00:32:00,910
then we have it happen after,
after the corresponding events

597
00:32:00,910 --> 00:32:04,420
happen in the same order
in the computer.

598
00:32:04,420 --> 00:32:06,070
That's where we have
assignments, when

599
00:32:06,070 --> 00:32:08,220
we make that alignment.

600
00:32:08,220 --> 00:32:11,860
Right now I want to show you a
way of organizing time, which

601
00:32:11,860 --> 00:32:16,040
is an agenda or priority queue,
it's sometimes called.

602
00:32:16,040 --> 00:32:17,990
We'll do some--we'll do
a little bit of just

603
00:32:17,990 --> 00:32:19,980
understanding what are the
things we need to be able to

604
00:32:19,980 --> 00:32:21,230
do to make agendas.

605
00:32:21,230 --> 00:32:28,330


606
00:32:28,330 --> 00:32:30,310
And so we're going to have--and
so right now over

607
00:32:30,310 --> 00:32:31,750
here, I'm going to write down
a bunch of primitive

608
00:32:31,750 --> 00:32:35,960
operations for manipulating
agendas.

609
00:32:35,960 --> 00:32:38,650
I'm not going to show you the
code for them because they're

610
00:32:38,650 --> 00:32:41,300
all very simple, and you've got

611
00:32:41,300 --> 00:32:43,680
listings of all that anyway.

612
00:32:43,680 --> 00:32:44,380
So what do we have?

613
00:32:44,380 --> 00:32:52,880
We have things like make-agenda
which produces a

614
00:32:52,880 --> 00:32:54,130
new agenda.

615
00:32:54,130 --> 00:32:59,860


616
00:32:59,860 --> 00:33:10,950
We can ask--we get the
current-time of an agenda,

617
00:33:10,950 --> 00:33:12,625
which gives me a
number, a time.

618
00:33:12,625 --> 00:33:16,990


619
00:33:16,990 --> 00:33:20,650
We can get--we can ask whether
an agenda is empty,

620
00:33:20,650 --> 00:33:21,900
empty-agenda.

621
00:33:21,900 --> 00:33:30,200


622
00:33:30,200 --> 00:33:32,570
And that produces either
a true or a false.

623
00:33:32,570 --> 00:33:42,590


624
00:33:42,590 --> 00:33:44,720
We can add an object
to an agenda.

625
00:33:44,720 --> 00:33:52,710


626
00:33:52,710 --> 00:33:55,230
Actually, what we add to an
agenda is an operation--an

627
00:33:55,230 --> 00:33:56,910
action to be done.

628
00:33:56,910 --> 00:34:03,560
And that takes a time, the
action itself, and the agenda

629
00:34:03,560 --> 00:34:04,810
I want to add it to.

630
00:34:04,810 --> 00:34:07,850


631
00:34:07,850 --> 00:34:09,280
That inserts it in
the appropriate

632
00:34:09,280 --> 00:34:10,719
place in the agenda.

633
00:34:10,719 --> 00:34:14,850
I can get the first item off an
agenda, the first thing I

634
00:34:14,850 --> 00:34:23,259
have to do, which is going
to give me an action.

635
00:34:23,259 --> 00:34:26,085


636
00:34:26,085 --> 00:34:29,540
And I can remove the first
item from an agenda.

637
00:34:29,540 --> 00:34:31,409
That's what I have to be able
to do with agendas.

638
00:34:31,409 --> 00:34:33,020
That is a big complicated
mess.

639
00:34:33,020 --> 00:34:42,530


640
00:34:42,530 --> 00:34:43,780
From an agenda.

641
00:34:43,780 --> 00:34:45,530


642
00:34:45,530 --> 00:34:48,040
Well, let's see how we can
organize this thing as a data

643
00:34:48,040 --> 00:34:52,528
structure a bit.

644
00:34:52,528 --> 00:34:58,720
Well, an agenda is going to be
some kind of list. And it's

645
00:34:58,720 --> 00:35:00,190
going to be a list that
I'm going to have

646
00:35:00,190 --> 00:35:01,570
to be able to modify.

647
00:35:01,570 --> 00:35:05,820
So we have to talk about
modifying of lists, because

648
00:35:05,820 --> 00:35:09,590
I'm going to add things to it,
and delete things from it, and

649
00:35:09,590 --> 00:35:11,070
things like that.

650
00:35:11,070 --> 00:35:13,820
It's organized by time.

651
00:35:13,820 --> 00:35:15,570
It's probably good to keep
it in sorted order.

652
00:35:15,570 --> 00:35:18,330


653
00:35:18,330 --> 00:35:22,170
But sometimes there are lots of
things that happen at the

654
00:35:22,170 --> 00:35:23,420
same time--approximate
same time.

655
00:35:23,420 --> 00:35:26,440
What I have to do is say, group
things by the time at

656
00:35:26,440 --> 00:35:29,040
which they're supposed
to happen.

657
00:35:29,040 --> 00:35:32,780
So I'm going to make an agenda
as a list of segments.

658
00:35:32,780 --> 00:35:36,780
And so I'm going to draw you a
data structure for an agenda,

659
00:35:36,780 --> 00:35:39,620
a perfectly reasonable one.

660
00:35:39,620 --> 00:35:41,110
Here's an agenda.

661
00:35:41,110 --> 00:35:42,870
It's a thing that begins
with a name.

662
00:35:42,870 --> 00:35:47,630


663
00:35:47,630 --> 00:35:49,940
I'm going to do it right now
out of list structure.

664
00:35:49,940 --> 00:35:52,620


665
00:35:52,620 --> 00:35:53,980
It's got a header.

666
00:35:53,980 --> 00:35:55,840
There's a reason
for the header.

667
00:35:55,840 --> 00:35:57,630
We're going to see
the reason soon.

668
00:35:57,630 --> 00:36:00,680


669
00:36:00,680 --> 00:36:03,750
And it will have a segment.

670
00:36:03,750 --> 00:36:05,620
It will have--it will be
a list of segments.

671
00:36:05,620 --> 00:36:08,310


672
00:36:08,310 --> 00:36:13,580
Supposing this agenda has two
segments, they're the car's--

673
00:36:13,580 --> 00:36:18,260
successive car's of this
list. Each segment is

674
00:36:18,260 --> 00:36:20,250
going to have a time--

675
00:36:20,250 --> 00:36:24,160


676
00:36:24,160 --> 00:36:26,900
say for example, 10--

677
00:36:26,900 --> 00:36:29,060
that says that the things
that happen in this

678
00:36:29,060 --> 00:36:33,320
segment are at time 10.

679
00:36:33,320 --> 00:36:36,670
And what I'm going to have in
here is another data structure

680
00:36:36,670 --> 00:36:39,490
which I'm not going to describe,
which is a queue of

681
00:36:39,490 --> 00:36:42,240
things to do at time 10.

682
00:36:42,240 --> 00:36:43,330
It's a queue.

683
00:36:43,330 --> 00:36:45,130
And we'll talk about
that in a second.

684
00:36:45,130 --> 00:36:49,530
But abstractly, the queue is
just a list of things to do at

685
00:36:49,530 --> 00:36:50,200
a particular time.

686
00:36:50,200 --> 00:36:53,100
And I can add things
to a queue.

687
00:36:53,100 --> 00:36:56,140
This is a queue.

688
00:36:56,140 --> 00:36:59,115
There's a time, there's
a segment.

689
00:36:59,115 --> 00:37:02,889


690
00:37:02,889 --> 00:37:06,035
Now, I may have another segment
in this agenda.

691
00:37:06,035 --> 00:37:08,940


692
00:37:08,940 --> 00:37:13,410
Supposing this is stuff that
happens at time 30.

693
00:37:13,410 --> 00:37:18,020
It has, of course, another
queue of things that are

694
00:37:18,020 --> 00:37:23,210
queued up to be done
at time 30.

695
00:37:23,210 --> 00:37:24,705
Well, there are various
things I have to be

696
00:37:24,705 --> 00:37:27,090
able to do to an agenda.

697
00:37:27,090 --> 00:37:30,410
Supposing I want to add to an
agenda another thing to be

698
00:37:30,410 --> 00:37:33,030
done at time 10.

699
00:37:33,030 --> 00:37:34,700
Well, that's not very hard.

700
00:37:34,700 --> 00:37:37,480
I'm going to walk down
here, looking for the

701
00:37:37,480 --> 00:37:39,730
segment of time 10.

702
00:37:39,730 --> 00:37:42,930
It is possible that there is
no segment of time 10.

703
00:37:42,930 --> 00:37:45,420
We'll cover that case
in a second.

704
00:37:45,420 --> 00:37:48,590
But if I find a segment of time
10, then if I want to add

705
00:37:48,590 --> 00:37:51,070
another thing to be done
at time 10, I just

706
00:37:51,070 --> 00:37:53,860
increase that queue--

707
00:37:53,860 --> 00:37:56,290
"just increase" isn't such
an obvious idea.

708
00:37:56,290 --> 00:38:01,430
But I increase the things
to be done at that time.

709
00:38:01,430 --> 00:38:02,900
Now, supposing I want to
add something to be

710
00:38:02,900 --> 00:38:05,140
done at time 20.

711
00:38:05,140 --> 00:38:08,680
There is no segment
for time 20.

712
00:38:08,680 --> 00:38:11,340
I'm going to have to create
a new segment.

713
00:38:11,340 --> 00:38:13,960
I want my time 20 segment
to exist between

714
00:38:13,960 --> 00:38:17,610
time 10 and time 30.

715
00:38:17,610 --> 00:38:20,170
Well, that takes
a little work.

716
00:38:20,170 --> 00:38:21,525
I'm going to have
to do a CONS.

717
00:38:21,525 --> 00:38:24,260


718
00:38:24,260 --> 00:38:28,690
I'm going to have to make a
new element of the agenda

719
00:38:28,690 --> 00:38:29,940
list--list of segments.

720
00:38:29,940 --> 00:38:33,600


721
00:38:33,600 --> 00:38:35,400
I'm going to have to change.

722
00:38:35,400 --> 00:38:37,540
Here's change.

723
00:38:37,540 --> 00:38:42,290
I'm going to have to change
the CDR of the CDR of the

724
00:38:42,290 --> 00:38:50,620
agenda to point that a new CONS
of the new segment and

725
00:38:50,620 --> 00:38:56,657
the CDR of the CDR of the CDR of
the agenda, the CD-D-D-DR.

726
00:38:56,657 --> 00:39:02,470
And this is going to have a
new segment now of time 20

727
00:39:02,470 --> 00:39:06,290
with its own queue, which now
has one element in it.

728
00:39:06,290 --> 00:39:10,730


729
00:39:10,730 --> 00:39:13,080
If I wanted to add something at
the end, I'm going to have

730
00:39:13,080 --> 00:39:20,770
to replace the CDR of this, of
this list with something.

731
00:39:20,770 --> 00:39:24,040
We're going to have to change
that piece of data structure.

732
00:39:24,040 --> 00:39:27,210
So I'm going to need new
primitives for doing this.

733
00:39:27,210 --> 00:39:29,550
But I'm just showing you
why I need them.

734
00:39:29,550 --> 00:39:33,390
And finally, if I wanted to add
a thing to be done at time

735
00:39:33,390 --> 00:39:41,240
5, I'm going to have to change
this one, because I'm going to

736
00:39:41,240 --> 00:39:44,770
have to add it in over here,
which is why I planned ahead

737
00:39:44,770 --> 00:39:49,400
and had a header cell,
which has a place.

738
00:39:49,400 --> 00:39:50,580
If I'm going to change things,
I have to have

739
00:39:50,580 --> 00:39:53,420
places for the change.

740
00:39:53,420 --> 00:39:58,600
I have to have a place
to make the change.

741
00:39:58,600 --> 00:40:02,540
If I remove things from the
agenda, that's not so hard.

742
00:40:02,540 --> 00:40:04,990
Removing them from the beginning
is pretty easy,

743
00:40:04,990 --> 00:40:07,740
which is the only case I have.
I can go looking for the

744
00:40:07,740 --> 00:40:11,220
first, the first segment.

745
00:40:11,220 --> 00:40:14,510
I see if it has a
non-empty queue.

746
00:40:14,510 --> 00:40:17,610
If it has a non-empty queue,
well, I'm going to delete one

747
00:40:17,610 --> 00:40:20,100
element from the queue,
like that.

748
00:40:20,100 --> 00:40:23,460
If the queue ever becomes empty,
then I have to delete

749
00:40:23,460 --> 00:40:24,220
the whole segment.

750
00:40:24,220 --> 00:40:28,220
And then this, this changes
to point to here.

751
00:40:28,220 --> 00:40:30,540
So it's quite a complicated data
structure manipulation

752
00:40:30,540 --> 00:40:36,440
going on, the details of which
are not really very exciting.

753
00:40:36,440 --> 00:40:38,920
Now, let's talk about queues.

754
00:40:38,920 --> 00:40:41,160
They're similar.

755
00:40:41,160 --> 00:40:44,340
Because each of these agendas
has a queue in it.

756
00:40:44,340 --> 00:40:45,590
What's a queue?

757
00:40:45,590 --> 00:40:49,079


758
00:40:49,079 --> 00:40:51,110
A queue is going to have
the following primitive

759
00:40:51,110 --> 00:40:52,350
operations.

760
00:40:52,350 --> 00:41:02,170
To make a queue, this gives
me a new queue.

761
00:41:02,170 --> 00:41:07,274


762
00:41:07,274 --> 00:41:12,610
I'm going to have to be
able to insert into

763
00:41:12,610 --> 00:41:16,850
a queue a new item.

764
00:41:16,850 --> 00:41:24,510


765
00:41:24,510 --> 00:41:27,490
I'm going to have to be able
to delete from a queue the

766
00:41:27,490 --> 00:41:28,740
first item in the queue.

767
00:41:28,740 --> 00:41:39,988


768
00:41:39,988 --> 00:41:51,320
And I want to be able to get the
first thing in the queue

769
00:41:51,320 --> 00:41:52,890
from some queue.

770
00:41:52,890 --> 00:41:55,140
I also have to be able to test
whether a queue is empty.

771
00:41:55,140 --> 00:42:07,110


772
00:42:07,110 --> 00:42:09,710
And when you invent things like
this, I want you to be

773
00:42:09,710 --> 00:42:13,220
very careful to use the kinds
of conventions I use for

774
00:42:13,220 --> 00:42:15,120
naming things.

775
00:42:15,120 --> 00:42:18,450
Notice that I'm careful to say
these change something and

776
00:42:18,450 --> 00:42:19,870
that tests it.

777
00:42:19,870 --> 00:42:24,335
And presumably, I did the
same thing over here.

778
00:42:24,335 --> 00:42:29,240
OK, and there should be an
empty test over here.

779
00:42:29,240 --> 00:42:31,720
OK, well, how would
I make a queue?

780
00:42:31,720 --> 00:42:35,210
A queue wants to be something
I can add to at the end of,

781
00:42:35,210 --> 00:42:37,840
and pick up the thing
at the beginning of.

782
00:42:37,840 --> 00:42:39,290
I should be able to delete
from the beginning

783
00:42:39,290 --> 00:42:41,230
and add to the end.

784
00:42:41,230 --> 00:42:42,400
Well, I'm going to show
you a very simple

785
00:42:42,400 --> 00:42:43,740
structure for that.

786
00:42:43,740 --> 00:42:47,080
We can make this out
of CONSes as well.

787
00:42:47,080 --> 00:42:49,910
Here's a queue.

788
00:42:49,910 --> 00:42:55,310
It has--it has a queue header,
which contains two parts--

789
00:42:55,310 --> 00:42:59,610
a front pointer and
a rear pointer.

790
00:42:59,610 --> 00:43:02,930


791
00:43:02,930 --> 00:43:09,000
And here I have a queue
with two items in it.

792
00:43:09,000 --> 00:43:12,095
The first item, I don't know,
it's perhaps a 1.

793
00:43:12,095 --> 00:43:16,530
And the second item, I don't
know, let's give it a 2.

794
00:43:16,530 --> 00:43:21,160


795
00:43:21,160 --> 00:43:24,550
The reason why I want two
pointers in here, a front

796
00:43:24,550 --> 00:43:27,570
pointer and a rear pointer,
is so I can add to the end

797
00:43:27,570 --> 00:43:31,850
without having to chase down
from the beginning.

798
00:43:31,850 --> 00:43:34,380
So for example, if I wanted to
add one more item to this

799
00:43:34,380 --> 00:43:40,380
queue, if I want to add on
another item to be worried

800
00:43:40,380 --> 00:43:44,060
about later, all I have to do is
make a CONS, which contains

801
00:43:44,060 --> 00:43:47,530
that item, say a 3.

802
00:43:47,530 --> 00:43:51,340
That's for inserting
3 into the queue.

803
00:43:51,340 --> 00:44:00,100
Then I have to change this
pointer here to here.

804
00:44:00,100 --> 00:44:04,320
And I have to change this one
to point to the new rear.

805
00:44:04,320 --> 00:44:09,120


806
00:44:09,120 --> 00:44:11,990
If I wish to take the first
element of the queue, the

807
00:44:11,990 --> 00:44:15,130
first item, I just go chasing
down the front pointer until I

808
00:44:15,130 --> 00:44:18,890
find the first one
and pick it up.

809
00:44:18,890 --> 00:44:22,560
If I wish to delete the first
item from the queue,

810
00:44:22,560 --> 00:44:25,240
delete-queue, all I do
is move the front

811
00:44:25,240 --> 00:44:27,450
pointer along this way.

812
00:44:27,450 --> 00:44:31,700
The new front of the
queue is now this.

813
00:44:31,700 --> 00:44:34,390
So queues are very simple too.

814
00:44:34,390 --> 00:44:39,690
So what you see now is that I
need a certain number of new

815
00:44:39,690 --> 00:44:41,350
primitive operations.

816
00:44:41,350 --> 00:44:42,560
And I'm going to give
them some names.

817
00:44:42,560 --> 00:44:45,310
And then we're going to look
into how they work, and how

818
00:44:45,310 --> 00:44:47,350
they're used.

819
00:44:47,350 --> 00:44:56,970
We have set the CAR of some
pair, or a thing produced by

820
00:44:56,970 --> 00:44:58,940
CONSing, to a new value.

821
00:44:58,940 --> 00:45:02,370


822
00:45:02,370 --> 00:45:09,920
And set the CDR of a pair
to a new value.

823
00:45:09,920 --> 00:45:12,680


824
00:45:12,680 --> 00:45:16,030
And then we're going to look
into how they work.

825
00:45:16,030 --> 00:45:19,720
I needed setting CAR over
here to delete the first

826
00:45:19,720 --> 00:45:20,960
element of the queue.

827
00:45:20,960 --> 00:45:23,470
This is the CAR, and
I had to set it.

828
00:45:23,470 --> 00:45:26,300
I had to be able to set the
CDR to be able to move the

829
00:45:26,300 --> 00:45:30,160
rear pointer, or to be able to
increment the queue here.

830
00:45:30,160 --> 00:45:33,170
All of the operations I did were
made out of those that I

831
00:45:33,170 --> 00:45:35,515
just showed you on the, on
the last blackboard.

832
00:45:35,515 --> 00:45:38,230


833
00:45:38,230 --> 00:45:38,430
Good.

834
00:45:38,430 --> 00:45:40,357
Let's pause the time, and take
a little break then.

835
00:45:40,357 --> 00:46:38,346


836
00:46:38,346 --> 00:46:42,910
When we originally introduced
pairs made out of CONS, made

837
00:46:42,910 --> 00:46:48,640
by CONS, we only said a few
axioms about them, which were

838
00:46:48,640 --> 00:46:50,040
of the form--

839
00:46:50,040 --> 00:46:52,010
what were they--

840
00:46:52,010 --> 00:47:06,040
for all X and Y, the CAR of the
CONS of X and Y is X and

841
00:47:06,040 --> 00:47:15,650
the CDR of the CONS of X and Y
is Y. Now, these say nothing

842
00:47:15,650 --> 00:47:21,850
about whether a CONS has an
identity like a person.

843
00:47:21,850 --> 00:47:25,730
In fact, all they say is
something sort of abstract,

844
00:47:25,730 --> 00:47:29,740
that a CONS is the parts
it's made out of.

845
00:47:29,740 --> 00:47:32,320
And of course, two things are
made out of the same parts,

846
00:47:32,320 --> 00:47:34,990
they're the same, at least
from the point of view of

847
00:47:34,990 --> 00:47:37,390
these axioms.

848
00:47:37,390 --> 00:47:39,920
But by introducing
assignment--

849
00:47:39,920 --> 00:47:43,360
in fact, mutable data is a kind
of assignment, we have a

850
00:47:43,360 --> 00:47:45,590
set CAR and a set CDR--

851
00:47:45,590 --> 00:47:48,300
by introducing those, these
axioms no longer tell the

852
00:47:48,300 --> 00:47:49,830
whole story.

853
00:47:49,830 --> 00:47:53,250
And they're still true if
written exactly like this.

854
00:47:53,250 --> 00:47:56,070
But they don't tell
the whole story.

855
00:47:56,070 --> 00:48:01,150
Because if I'm going to set a
particular CAR in a particular

856
00:48:01,150 --> 00:48:05,810
CONS, the questions are, well,
is that setting all CARs and

857
00:48:05,810 --> 00:48:10,090
all CONSes of the same
two things or not?

858
00:48:10,090 --> 00:48:12,610
If I--if we use CONSes to make
up things like rational

859
00:48:12,610 --> 00:48:19,540
numbers, or things like 3 over
4, supposing I had two

860
00:48:19,540 --> 00:48:21,570
three-fourths.

861
00:48:21,570 --> 00:48:24,110
Are they the same one--

862
00:48:24,110 --> 00:48:25,340
or are they different?

863
00:48:25,340 --> 00:48:27,860
Well, in the case of numbers,
it doesn't matter.

864
00:48:27,860 --> 00:48:29,410
Because there's no meaning
to changing the

865
00:48:29,410 --> 00:48:33,020
denominator of a number.

866
00:48:33,020 --> 00:48:34,670
What you could do is make a
number which has a different

867
00:48:34,670 --> 00:48:36,840
denominator.

868
00:48:36,840 --> 00:48:38,980
But the concept of changing a
number which has to have a

869
00:48:38,980 --> 00:48:41,570
different denominator is sort
of a very weird, and sort of

870
00:48:41,570 --> 00:48:44,770
not supported by what you
think of as mathematics.

871
00:48:44,770 --> 00:48:46,570
However, when these CONSes
represent things in the

872
00:48:46,570 --> 00:48:50,940
physical world, then changing
something like the CAR is like

873
00:48:50,940 --> 00:48:53,690
removing a piece of
the fingernail.

874
00:48:53,690 --> 00:48:57,770
And so CONSes have
an identity.

875
00:48:57,770 --> 00:49:01,280
Let me show you what I mean
about identity, first of all.

876
00:49:01,280 --> 00:49:04,320
Let's do some little
example here.

877
00:49:04,320 --> 00:49:15,200
Supposing I define A to
the CONS of 1 and 2.

878
00:49:15,200 --> 00:49:18,040


879
00:49:18,040 --> 00:49:22,510
Well, what that means, first of
all, is that somewhere in

880
00:49:22,510 --> 00:49:27,590
some environment I've made a
symbol A to have a value which

881
00:49:27,590 --> 00:49:33,300
is a pair consisting of pointers
to a 1 and a pointer

882
00:49:33,300 --> 00:49:38,120
to a 2, just like that.

883
00:49:38,120 --> 00:49:47,220
Now, supposing I also say define
B to be the CONS--

884
00:49:47,220 --> 00:49:53,320


885
00:49:53,320 --> 00:49:58,240
it doesn't matter, but I like
it better, it's prettier--

886
00:49:58,240 --> 00:50:03,970
of A and A.

887
00:50:03,970 --> 00:50:07,840
Well, first of all, I'm using
the name A twice.

888
00:50:07,840 --> 00:50:09,100
At this moment, I'm
going to think of

889
00:50:09,100 --> 00:50:11,300
CONSes as having identity.

890
00:50:11,300 --> 00:50:13,690
This is the same one.

891
00:50:13,690 --> 00:50:19,200
And so what that means is I make
another pair, which I'm

892
00:50:19,200 --> 00:50:29,120
going to call B. And it contains
two pointers to A. At

893
00:50:29,120 --> 00:50:33,260
this point, I have three
names for this object.

894
00:50:33,260 --> 00:50:34,790
A is its name.

895
00:50:34,790 --> 00:50:37,230
The CAR of B is its name.

896
00:50:37,230 --> 00:50:39,360
And the CDR of B is its name.

897
00:50:39,360 --> 00:50:41,150
It has several aliases,
they're called.

898
00:50:41,150 --> 00:50:44,230


899
00:50:44,230 --> 00:51:01,860
Now, supposing I do something
like set-the-CAR, the CAR of

900
00:51:01,860 --> 00:51:07,880
the CAR of B to 3.

901
00:51:07,880 --> 00:51:12,750


902
00:51:12,750 --> 00:51:17,830
What that means is I find the
CAR of B, that's this.

903
00:51:17,830 --> 00:51:20,935
I set the CAR of that to
be 3, changing this.

904
00:51:20,935 --> 00:51:24,760


905
00:51:24,760 --> 00:51:29,940
I've changed A. If I were
to ask what's the

906
00:51:29,940 --> 00:51:35,340
CAR of A--of A now?

907
00:51:35,340 --> 00:51:42,250
I would get out 3, even though
here we see that A was the

908
00:51:42,250 --> 00:51:45,290
CONS of 1 and 2.

909
00:51:45,290 --> 00:51:48,400
I caused A to change
by changing B.

910
00:51:48,400 --> 00:51:52,010
There is sharing here.

911
00:51:52,010 --> 00:51:54,240
That's sometimes what we want.

912
00:51:54,240 --> 00:51:56,400
Surely in the queues and things
like that, that's

913
00:51:56,400 --> 00:51:59,560
exactly what we defined
our--organized our data

914
00:51:59,560 --> 00:52:01,790
structures to facilitate--

915
00:52:01,790 --> 00:52:04,350
sharing.

916
00:52:04,350 --> 00:52:08,950
But inadvertent sharing,
unanticipated interactions

917
00:52:08,950 --> 00:52:12,925
between objects, is the source
of most of the bugs that occur

918
00:52:12,925 --> 00:52:17,820
in complicated programs. So by
introducing this possibility

919
00:52:17,820 --> 00:52:22,570
of things having identity and
sharing and having multiple

920
00:52:22,570 --> 00:52:25,190
names for the same thing,
we get a lot of power.

921
00:52:25,190 --> 00:52:27,390
But we're going to pay
for it with lots of

922
00:52:27,390 --> 00:52:28,640
complexity and bugs.

923
00:52:28,640 --> 00:52:32,190


924
00:52:32,190 --> 00:52:35,430
So also, for example, if I just
looked at this just to

925
00:52:35,430 --> 00:52:43,370
drive that home, the CADR of
B, which has nothing to do

926
00:52:43,370 --> 00:52:46,560
with even the CAR of
B, apparently.

927
00:52:46,560 --> 00:52:49,350
The CADR of B, what's that?

928
00:52:49,350 --> 00:52:53,560
Take that CDR of B and now
take the CAR of that.

929
00:52:53,560 --> 00:52:56,480
Oh, that's 3 also.

930
00:52:56,480 --> 00:53:01,120
So I can have non-local
interactions by sharing.

931
00:53:01,120 --> 00:53:02,480
And I have to be very
careful of that.

932
00:53:02,480 --> 00:53:06,640


933
00:53:06,640 --> 00:53:10,530
Well, so far, of course, it
seems I've introduced several

934
00:53:10,530 --> 00:53:13,030
different assignment
operators--

935
00:53:13,030 --> 00:53:19,480
set, set CAR, set CDR. Well,
maybe I should just get rid of

936
00:53:19,480 --> 00:53:22,820
set CAR and set CDR. Maybe
they're not worthwhile.

937
00:53:22,820 --> 00:53:25,680
Well, the answer is that once
you let the camel's nose into

938
00:53:25,680 --> 00:53:27,170
the tent, the rest
of him follows.

939
00:53:27,170 --> 00:53:30,160


940
00:53:30,160 --> 00:53:34,600
All I have to have is set, and
I can make all of the--all of

941
00:53:34,600 --> 00:53:35,850
the bad things that
can happen.

942
00:53:35,850 --> 00:53:38,550


943
00:53:38,550 --> 00:53:40,690
Let's play with that
a little bit.

944
00:53:40,690 --> 00:53:45,330
A couple of days ago, when we
introduced compound data, you

945
00:53:45,330 --> 00:53:49,980
saw Hal show you a definition
of CONS in terms

946
00:53:49,980 --> 00:53:52,480
of a message acceptor.

947
00:53:52,480 --> 00:53:57,280
I'm going to show you even
a more horrible thing, a

948
00:53:57,280 --> 00:54:04,440
definition of CONS in terms of
nothing but air, hot air.

949
00:54:04,440 --> 00:54:07,640
What is the definition of CONS,
of the old functional

950
00:54:07,640 --> 00:54:13,330
kind, in terms of purely
lambdic expressions,

951
00:54:13,330 --> 00:54:14,580
procedures?

952
00:54:14,580 --> 00:54:17,190


953
00:54:17,190 --> 00:54:20,630
Because I'm going to then modify
this definition to get

954
00:54:20,630 --> 00:54:25,020
assignment to be only one kind
of assignment, to get rid of

955
00:54:25,020 --> 00:54:28,580
the set CAR and set CDR
in terms of set.

956
00:54:28,580 --> 00:54:41,020
So what if I define CONS of X
and Y to be a procedure of one

957
00:54:41,020 --> 00:54:44,310
argument called a message
M, which calls that

958
00:54:44,310 --> 00:54:46,320
message on X and Y?

959
00:54:46,320 --> 00:54:51,120


960
00:54:51,120 --> 00:54:54,080
This [? idea ?] was invented by
Alonzo Church, who was the

961
00:54:54,080 --> 00:54:56,180
greatest programmer of the
20th century, although he

962
00:54:56,180 --> 00:54:57,870
never saw a computer.

963
00:54:57,870 --> 00:54:59,130
It was done in the 1930s.

964
00:54:59,130 --> 00:55:02,220
He was a logician, I suppose
at Princeton at the time.

965
00:55:02,220 --> 00:55:08,660


966
00:55:08,660 --> 00:55:15,690
Define CAR of X to be the result
of applying X to that

967
00:55:15,690 --> 00:55:24,000
procedure of two arguments, A
and D, which selects A. I will

968
00:55:24,000 --> 00:55:36,410
define CDR of X to be that
procedure, to be the result of

969
00:55:36,410 --> 00:55:46,670
applying X to that procedure of
A and D, which selects D.

970
00:55:46,670 --> 00:55:50,510
Now, you may not recognize this
as CAR, CDR, and CONS.

971
00:55:50,510 --> 00:55:52,690
But I'm going to demonstrate to
you that it satisfies the

972
00:55:52,690 --> 00:55:55,210
original axioms, just once.

973
00:55:55,210 --> 00:55:58,290
And then we're going to do
some playing of games.

974
00:55:58,290 --> 00:56:09,695
Consider the problem CAR of
CONS of, say, 35 and 47.

975
00:56:09,695 --> 00:56:11,120
Well, what is that?

976
00:56:11,120 --> 00:56:14,080
It is the result of taking car
of the result of substituting

977
00:56:14,080 --> 00:56:19,710
35 and 47 for X and Y
in the body of this.

978
00:56:19,710 --> 00:56:20,690
Well, that's easy enough.

979
00:56:20,690 --> 00:56:27,780
That's CAR of the result of
substituting into lambda of M,

980
00:56:27,780 --> 00:56:35,750
M of 35 and 47.

981
00:56:35,750 --> 00:56:38,680
Well, what this is, is the
result of substituting this

982
00:56:38,680 --> 00:56:42,830
object for X in the
body of that.

983
00:56:42,830 --> 00:56:48,930
So that's just lambda of M--

984
00:56:48,930 --> 00:56:51,090
that's substituted, because
this object is being

985
00:56:51,090 --> 00:56:54,980
substituted for X, which is
the beginning of a list,

986
00:56:54,980 --> 00:56:57,260
lambda of M--

987
00:56:57,260 --> 00:57:07,570
M of 35 and 47, applied to that
procedure of A and D,

988
00:57:07,570 --> 00:57:12,280
which gives me A. Well, that's
the result of substituting

989
00:57:12,280 --> 00:57:15,840
this for M here.

990
00:57:15,840 --> 00:57:22,320
So that's the same thing
as lambda of A, D, A,

991
00:57:22,320 --> 00:57:26,026
applied to 35 and 47.

992
00:57:26,026 --> 00:57:27,560
Oh, well that's 35.

993
00:57:27,560 --> 00:57:36,000
That's substituting 35 for A
and for 47 for D in A. So I

994
00:57:36,000 --> 00:57:40,720
don't need any data at all,
not even numbers.

995
00:57:40,720 --> 00:57:42,640
This is Alonso Church's hack.

996
00:57:42,640 --> 00:57:52,420


997
00:57:52,420 --> 00:57:56,760
Well, now we're going to do
something nasty to him.

998
00:57:56,760 --> 00:57:58,860
Being a logician, he
wouldn't like this.

999
00:57:58,860 --> 00:58:03,260
But as programmers, let's
look at the overhead.

1000
00:58:03,260 --> 00:58:05,390
And here we go.

1001
00:58:05,390 --> 00:58:09,570
I'm going to change the
definition of CONS.

1002
00:58:09,570 --> 00:58:14,520
It's almost the same as Alonzo
Church's, but not quite.

1003
00:58:14,520 --> 00:58:16,070
What do we have here?

1004
00:58:16,070 --> 00:58:20,880
The CONS of two arguments, X
and Y, is going to be that

1005
00:58:20,880 --> 00:58:25,020
procedure of one argument M,
which supplies M to X and Y as

1006
00:58:25,020 --> 00:58:30,900
before, but also to two
permissions, the permission to

1007
00:58:30,900 --> 00:58:35,030
set X to N and the permission
to set Y to N, given that I

1008
00:58:35,030 --> 00:58:40,940
have an N.

1009
00:58:40,940 --> 00:58:44,040
So besides the things that
I had here in Church's

1010
00:58:44,040 --> 00:58:50,990
definition, what I have is
that the thing that CONS

1011
00:58:50,990 --> 00:58:55,900
returns will apply its argument
to not just the

1012
00:58:55,900 --> 00:59:00,210
values of the X and Y that the
CONS is made of, but also

1013
00:59:00,210 --> 00:59:03,365
permissions to set X and
Y to new values.

1014
00:59:03,365 --> 00:59:06,540


1015
00:59:06,540 --> 00:59:09,220
Now, of course, just
as before, CAR

1016
00:59:09,220 --> 00:59:11,690
is exactly the same.

1017
00:59:11,690 --> 00:59:14,980
The CAR of X is nothing more
than applying X, as in

1018
00:59:14,980 --> 00:59:18,110
Church's definition, to a
procedure, in this case, of

1019
00:59:18,110 --> 00:59:22,550
four arguments, which selects
out the first one.

1020
00:59:22,550 --> 00:59:28,750
And just as we did before, that
will be the value of X

1021
00:59:28,750 --> 00:59:33,470
that was contained in the
procedure which is the result

1022
00:59:33,470 --> 00:59:36,260
of evaluating this lambda
expression in the environment

1023
00:59:36,260 --> 00:59:37,920
where X and Y are defined
over here.

1024
00:59:37,920 --> 00:59:41,940


1025
00:59:41,940 --> 00:59:45,640
That's the value of CONS.

1026
00:59:45,640 --> 00:59:47,730
Now, however, the
exciting part.

1027
00:59:47,730 --> 00:59:48,960
CDR, of course, is the same.

1028
00:59:48,960 --> 00:59:54,270
The exciting part, set CAR and
set CDR. Well, they're nothing

1029
00:59:54,270 --> 00:59:55,800
very complicated anymore.

1030
00:59:55,800 --> 01:00:02,700
Set CAR of a CONS X to a new
value Y is nothing more than

1031
01:00:02,700 --> 01:00:06,097
applying that CONS, which is
the procedure of four--the

1032
01:00:06,097 --> 01:00:09,160
procedure of one argument which
applies its argument to

1033
01:00:09,160 --> 01:00:15,950
four things, to a procedure
which is of four arguments--

1034
01:00:15,950 --> 01:00:19,450
the value of X, the value of
Y, permission to set X, the

1035
01:00:19,450 --> 01:00:21,390
permission to set Y--

1036
01:00:21,390 --> 01:00:23,610
and using it--using that
permission to set

1037
01:00:23,610 --> 01:00:26,150
X to the new value.

1038
01:00:26,150 --> 01:00:31,650


1039
01:00:31,650 --> 01:00:33,540
And similarly, set-cdr
is the same thing.

1040
01:00:33,540 --> 01:00:36,120


1041
01:00:36,120 --> 01:00:38,470
So what you've just seen is that
I didn't introduce any

1042
01:00:38,470 --> 01:00:40,470
new primitives at all.

1043
01:00:40,470 --> 01:00:43,340
Whether or not I want to
implement it this way is a

1044
01:00:43,340 --> 01:00:45,340
matter of engineering.

1045
01:00:45,340 --> 01:00:48,080
And the answer is of course I
don't implement it this way

1046
01:00:48,080 --> 01:00:51,680
for reasons that have to
do with engineering.

1047
01:00:51,680 --> 01:00:55,170
However in principle, logically,
once I introduced

1048
01:00:55,170 --> 01:00:57,515
one assignment operator,
I've assigned--I've

1049
01:00:57,515 --> 01:00:58,765
introduced them all.

1050
01:00:58,765 --> 01:01:05,420


1051
01:01:05,420 --> 01:01:06,670
Are there any questions?

1052
01:01:06,670 --> 01:01:09,200


1053
01:01:09,200 --> 01:01:12,040
Yes, David.

1054
01:01:12,040 --> 01:01:14,860
AUDIENCE: I can follow you up
until you get--I can follow

1055
01:01:14,860 --> 01:01:15,740
all of that.

1056
01:01:15,740 --> 01:01:19,760
But when we bring in the
permissions, defining CONS in

1057
01:01:19,760 --> 01:01:24,210
terms of the lambda N, I don't
follow where N gets passed.

1058
01:01:24,210 --> 01:01:25,100
PROFESSOR: Oh, I'm sorry.

1059
01:01:25,100 --> 01:01:26,340
I'll show you.

1060
01:01:26,340 --> 01:01:27,360
Let's follow it.

1061
01:01:27,360 --> 01:01:29,180
Of course, we could do
it on the blackboard.

1062
01:01:29,180 --> 01:01:30,170
It's not so hard.

1063
01:01:30,170 --> 01:01:32,450
But it's also easy here.

1064
01:01:32,450 --> 01:01:38,520
Supposing I wish to set-cdr of
X to Y. See that right there.

1065
01:01:38,520 --> 01:01:43,680
set-cdr of X to Y. X is
presumably a CONS, a thing

1066
01:01:43,680 --> 01:01:46,890
resulting from evaluating
CONS.

1067
01:01:46,890 --> 01:01:54,030
Therefore X comes from a place
over here, that that X is of

1068
01:01:54,030 --> 01:01:58,110
the result of evaluating
this lambda expression.

1069
01:01:58,110 --> 01:01:59,380
Right?

1070
01:01:59,380 --> 01:02:04,475
That when I evaluated that
lambda expression, I evaluated

1071
01:02:04,475 --> 01:02:07,700
it in an environment
where the arguments

1072
01:02:07,700 --> 01:02:08,950
to CONS were defined.

1073
01:02:08,950 --> 01:02:11,750


1074
01:02:11,750 --> 01:02:14,530
That means that as free
variables in this lambda

1075
01:02:14,530 --> 01:02:18,670
expression, there is the--there
are in the frame,

1076
01:02:18,670 --> 01:02:23,860
which is the parent frame of
this lambda expression, the

1077
01:02:23,860 --> 01:02:27,470
procedure resulting from this
lambda expression, X and Y

1078
01:02:27,470 --> 01:02:29,250
have places.

1079
01:02:29,250 --> 01:02:31,910
And it's possible to set them.

1080
01:02:31,910 --> 01:02:35,380
I set them to an N, which
is the argument of the

1081
01:02:35,380 --> 01:02:37,010
permission.

1082
01:02:37,010 --> 01:02:43,650
The permission is a procedure
which is passed to M, which is

1083
01:02:43,650 --> 01:02:47,940
the argument that the CONS
object gets passed.

1084
01:02:47,940 --> 01:02:54,020
Now, let's go back here in the
set-cdr The CONS object, which

1085
01:02:54,020 --> 01:02:56,230
is the first argument
of set-cdr

1086
01:02:56,230 --> 01:02:57,480
gets passed an argument.

1087
01:02:57,480 --> 01:03:00,260


1088
01:03:00,260 --> 01:03:02,910
That--there's a procedure of
four things, indeed, because

1089
01:03:02,910 --> 01:03:05,780
that's the same thing as this M
over here, which is applied

1090
01:03:05,780 --> 01:03:07,920
to four objects.

1091
01:03:07,920 --> 01:03:12,970
The object over here, SD, is,
in fact, this permission.

1092
01:03:12,970 --> 01:03:15,470


1093
01:03:15,470 --> 01:03:19,930
When I use SD, I apply
it to Y, right there.

1094
01:03:19,930 --> 01:03:22,910


1095
01:03:22,910 --> 01:03:25,740
So that comes from this.

1096
01:03:25,740 --> 01:03:27,410
AUDIENCE: So what do you--

1097
01:03:27,410 --> 01:03:31,420
PROFESSOR: So to finish that,
the N that was here is the Y

1098
01:03:31,420 --> 01:03:34,160
which is here.

1099
01:03:34,160 --> 01:03:34,810
How's that?

1100
01:03:34,810 --> 01:03:35,750
AUDIENCE: Right, OK.

1101
01:03:35,750 --> 01:03:40,240
Now, when you do a set-cdr,
X is the value the

1102
01:03:40,240 --> 01:03:41,970
CDR is going to become.

1103
01:03:41,970 --> 01:03:44,742
PROFESSOR: The X over here.

1104
01:03:44,742 --> 01:03:46,200
I'm sorry, that's not true.

1105
01:03:46,200 --> 01:03:48,720
The X is--set-cdr has
two arguments--

1106
01:03:48,720 --> 01:03:56,150
The CONS I'm changing and the
value I'm changing it to.

1107
01:03:56,150 --> 01:03:58,320
So you have them backwards,
that's all.

1108
01:03:58,320 --> 01:04:01,750


1109
01:04:01,750 --> 01:04:03,000
Are there any other questions?

1110
01:04:03,000 --> 01:04:07,880


1111
01:04:07,880 --> 01:04:08,640
Well, thank you.

1112
01:04:08,640 --> 01:04:09,890
It's time for lunch.

1113
01:04:09,890 --> 01:04:28,970

