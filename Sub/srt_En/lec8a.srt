1
00:00:00,000 --> 00:00:00,000

2
00:00:00,000 --> 00:00:17,814
[MUSIC PLAYING BY J.S. BACH]

3
00:00:17,814 --> 00:00:20,040
PROFESSOR: The last time we
began having a look at how

4
00:00:20,040 --> 00:00:22,132
languages are constructed.

5
00:00:22,132 --> 00:00:26,050
Remember the main point that an
evaluator for, LISP, say,

6
00:00:26,050 --> 00:00:27,580
has two main elements.

7
00:00:27,580 --> 00:00:36,350
There is EVAL, and EVAL's job
is to take in an expression

8
00:00:36,350 --> 00:00:43,820
and an environment and turn that
into a procedure and some

9
00:00:43,820 --> 00:00:46,635
arguments and pass that
off to APPLY.

10
00:00:46,635 --> 00:00:49,410

11
00:00:49,410 --> 00:00:52,250
And APPLY takes the procedure
in the arguments, turns that

12
00:00:52,250 --> 00:00:55,680
back into, in a general case,
another expression to be

13
00:00:55,680 --> 00:00:58,280
evaluated in another environment
and passes that

14
00:00:58,280 --> 00:01:00,770
off to EVAL, which passes it
to APPLY, and there's this

15
00:01:00,770 --> 00:01:02,750
whole big circle where things
go around and around and

16
00:01:02,750 --> 00:01:05,519
around until you get either to
some very primitive data or to

17
00:01:05,519 --> 00:01:07,740
a primitive procedure.

18
00:01:07,740 --> 00:01:12,080
See, what this cycle has to do
with is unwinding the means of

19
00:01:12,080 --> 00:01:15,020
combination and the means of
abstraction in the language.

20
00:01:15,020 --> 00:01:17,870
So for instance, you have
a procedure in LISP-- a

21
00:01:17,870 --> 00:01:21,320
procedure is a general way of
saying, I want to be able to

22
00:01:21,320 --> 00:01:25,392
evaluate this expression for
any value of the arguments,

23
00:01:25,392 --> 00:01:27,670
and that's sort of what's
going on here.

24
00:01:27,670 --> 00:01:28,510
That's what APPLY does.

25
00:01:28,510 --> 00:01:30,770
It says the general thing coming
in with the arguments

26
00:01:30,770 --> 00:01:33,380
reduces to the expression that's
the body, and then if

27
00:01:33,380 --> 00:01:35,790
that's a compound expression
or another procedure

28
00:01:35,790 --> 00:01:40,440
application, the thing will go
around and around the circle.

29
00:01:40,440 --> 00:01:43,040
Anyway, that's sort of the basic
structure of gee, pretty

30
00:01:43,040 --> 00:01:45,120
much any interpreter.

31
00:01:45,120 --> 00:01:46,720
The other thing that you saw
is once you have the

32
00:01:46,720 --> 00:01:49,080
interpreter in your hands, you
have all this power to start

33
00:01:49,080 --> 00:01:49,870
playing with the language.

34
00:01:49,870 --> 00:01:53,390
So you can make it dynamically
scoped, or you can put in

35
00:01:53,390 --> 00:01:55,960
normal order evaluation, or you
can add new forms to the

36
00:01:55,960 --> 00:01:57,680
language, whatever you like.

37
00:01:57,680 --> 00:02:00,570
Or more generally, there's this
notion of metalinguistic

38
00:02:00,570 --> 00:02:07,930
abstraction, which says that
part of your perspective as an

39
00:02:07,930 --> 00:02:09,970
engineer, as a software
engineer, but as an engineer

40
00:02:09,970 --> 00:02:15,270
in general is that you can gain
control of complexity by

41
00:02:15,270 --> 00:02:18,010
inventing new languages
sometimes.

42
00:02:18,010 --> 00:02:22,830
See, one way to think about
computer programming is that

43
00:02:22,830 --> 00:02:25,170
it only incidentally has
to do with getting a

44
00:02:25,170 --> 00:02:26,440
computer to do something.

45
00:02:26,440 --> 00:02:29,220
Primarily what a computer
program has to do with, it's a

46
00:02:29,220 --> 00:02:33,270
way of expressing ideas with
communicating ideas.

47
00:02:33,270 --> 00:02:36,300
And sometimes when you want to
communicate new kinds of

48
00:02:36,300 --> 00:02:39,770
ideas, you'd like to invent new
modes of expressing that.

49
00:02:39,770 --> 00:02:44,300
Well, today we're going to apply
this framework to build

50
00:02:44,300 --> 00:02:45,730
a new language.

51
00:02:45,730 --> 00:02:48,140
See, once we have the basic idea
of the interpreter, you

52
00:02:48,140 --> 00:02:50,830
can pretty much go build any
language that you like.

53
00:02:50,830 --> 00:02:54,370
So for example, we can go
off and build Pascal.

54
00:02:54,370 --> 00:02:58,820
And gee, we would worry about
syntax and parsing and various

55
00:02:58,820 --> 00:03:01,450
kinds of compiler optimizations,
and there are

56
00:03:01,450 --> 00:03:05,580
people who make honest livings
doing that, but at the level

57
00:03:05,580 --> 00:03:09,100
of abstraction that we're
talking, a Pascal interpreter

58
00:03:09,100 --> 00:03:13,020
would not look very different at
all from what you saw Gerry

59
00:03:13,020 --> 00:03:15,350
do last time.

60
00:03:15,350 --> 00:03:18,190
Instead of that, we'll spend
today building a really

61
00:03:18,190 --> 00:03:23,400
different language, a language
that encourages you to think

62
00:03:23,400 --> 00:03:26,980
about programming not in terms
of procedures, but in a really

63
00:03:26,980 --> 00:03:29,090
different way.

64
00:03:29,090 --> 00:03:33,650
And the lecture today is going
to be at two levels

65
00:03:33,650 --> 00:03:34,810
simultaneously.

66
00:03:34,810 --> 00:03:37,210
On the one hand, I'm going to
show you what this language

67
00:03:37,210 --> 00:03:40,410
looks like, and on the other
hand, I'll show you how it's

68
00:03:40,410 --> 00:03:41,010
implemented.

69
00:03:41,010 --> 00:03:43,250
And we'll build an
implementation in LISP and see

70
00:03:43,250 --> 00:03:44,220
how that works.

71
00:03:44,220 --> 00:03:48,730
And you should be drawing
lessons on two levels.

72
00:03:48,730 --> 00:03:52,190
The first is to realize
just how different a

73
00:03:52,190 --> 00:03:53,790
language can be.

74
00:03:53,790 --> 00:03:57,830
So if you think that the jump
from Fortran to LISP is a big

75
00:03:57,830 --> 00:04:01,560
deal, you haven't seen
anything yet.

76
00:04:01,560 --> 00:04:05,660
And secondly, you'll see that
even with such a very

77
00:04:05,660 --> 00:04:08,590
different language, which will
turn out to not have

78
00:04:08,590 --> 00:04:12,260
procedures at all and not talk
about functions at all, there

79
00:04:12,260 --> 00:04:16,570
will still be this basic cycle
of eval and apply that's

80
00:04:16,570 --> 00:04:19,170
unwinds the means of combination
and the means an

81
00:04:19,170 --> 00:04:20,950
abstraction.

82
00:04:20,950 --> 00:04:24,430
And then thirdly, as kind of a
minor but elegant technical

83
00:04:24,430 --> 00:04:27,720
point, you'll see a nice
use of streams to avoid

84
00:04:27,720 --> 00:04:28,970
backtracking.

85
00:04:28,970 --> 00:04:32,330

86
00:04:32,330 --> 00:04:35,860
OK, well, I said that this
language is very different.

87
00:04:35,860 --> 00:04:41,620
To explain that, let's go back
to the very first idea that we

88
00:04:41,620 --> 00:04:44,710
talked about in this course, and
that was the idea of the

89
00:04:44,710 --> 00:04:48,780
distinction between the
declarative knowledge of

90
00:04:48,780 --> 00:04:50,240
mathematics--

91
00:04:50,240 --> 00:04:55,470
the definition of a square root
as a mathematical truth--

92
00:04:55,470 --> 00:04:59,080
and the idea that computer
science talks about the how to

93
00:04:59,080 --> 00:04:59,810
knowledge--

94
00:04:59,810 --> 00:05:03,700
contrast that definition of
square root with a program to

95
00:05:03,700 --> 00:05:05,970
compute a square root.

96
00:05:05,970 --> 00:05:08,042
That's where we started off.

97
00:05:08,042 --> 00:05:11,830
Well, wouldn't it be great if
you could somehow bridge this

98
00:05:11,830 --> 00:05:16,030
gap and make a programming
language which sort of did

99
00:05:16,030 --> 00:05:20,510
things, but you talked about
it in terms of truth, in

100
00:05:20,510 --> 00:05:22,380
declarative terms?

101
00:05:22,380 --> 00:05:24,110
So that would be a programming
language in

102
00:05:24,110 --> 00:05:27,690
which you specify facts.

103
00:05:27,690 --> 00:05:28,880
You tell it what is.

104
00:05:28,880 --> 00:05:30,950
You say what is true.

105
00:05:30,950 --> 00:05:34,220
And then when you want an
answer, somehow the language

106
00:05:34,220 --> 00:05:38,560
has built into it automatically
general kinds of

107
00:05:38,560 --> 00:05:41,200
how to knowledge so it can just
take your facts and it

108
00:05:41,200 --> 00:05:44,180
can evolve these methods on
its on using the facts you

109
00:05:44,180 --> 00:05:46,200
gave it and maybe some general
rules of logic.

110
00:05:46,200 --> 00:05:49,330

111
00:05:49,330 --> 00:05:53,920
So for instance, I might go up
to this program and start

112
00:05:53,920 --> 00:05:55,645
telling it some things.

113
00:05:55,645 --> 00:06:08,920
So I might tell it that the
son of Adam is Abel.

114
00:06:08,920 --> 00:06:17,660
And I might tell it that the
son of Adam is Cain.

115
00:06:17,660 --> 00:06:24,670
And I might tell it that the
son of Cain is Enoch.

116
00:06:24,670 --> 00:06:27,502

117
00:06:27,502 --> 00:06:37,550
And I might tell it that the son
of Enoch is Irad, and all

118
00:06:37,550 --> 00:06:41,190
through the rest of our chapter
whatever of Genesis,

119
00:06:41,190 --> 00:06:45,010
which ends up ending in Adah, by
the way, and this shows the

120
00:06:45,010 --> 00:06:48,760
genealogy of Adah from Cain.

121
00:06:48,760 --> 00:06:52,520
Anyway, once you tell
it these facts, you

122
00:06:52,520 --> 00:06:53,510
might ask it things.

123
00:06:53,510 --> 00:06:58,560
You might go up to your language
and say, who's the

124
00:06:58,560 --> 00:07:00,420
son of Adam?

125
00:07:00,420 --> 00:07:03,480
And you can very easily imagine
having a little

126
00:07:03,480 --> 00:07:06,460
general purpose search program
which would be able to go

127
00:07:06,460 --> 00:07:08,800
through and in response to that
say, oh yeah, there are

128
00:07:08,800 --> 00:07:10,930
two answers: the son of
Adam is Abel and the

129
00:07:10,930 --> 00:07:14,140
son of Adam is Cain.

130
00:07:14,140 --> 00:07:19,350
Or you might say, based on the
very same facts, who is Cain

131
00:07:19,350 --> 00:07:21,950
the son of?

132
00:07:21,950 --> 00:07:25,520
And then you can imagine
generating another slightly

133
00:07:25,520 --> 00:07:29,510
different search program which
would be able to go through

134
00:07:29,510 --> 00:07:33,760
and checked for who is
Cain, and son of, and

135
00:07:33,760 --> 00:07:35,890
come up with Adam.

136
00:07:35,890 --> 00:07:40,300
Or you might say, what's
the relationship

137
00:07:40,300 --> 00:07:42,070
between Cain and Enoch?

138
00:07:42,070 --> 00:07:46,340
And again, a minor variant
on that search program.

139
00:07:46,340 --> 00:07:48,160
You could figure out that
it said son of.

140
00:07:48,160 --> 00:07:52,880

141
00:07:52,880 --> 00:07:56,960
But even here in this very
simple example, what you see

142
00:07:56,960 --> 00:08:00,460
is that a single fact, see, a
single fact like the son of

143
00:08:00,460 --> 00:08:04,230
Adam is Cain can be
used to answer

144
00:08:04,230 --> 00:08:06,520
different kinds of questions.

145
00:08:06,520 --> 00:08:10,540
You can say, who's the son of,
or you can say who's the son

146
00:08:10,540 --> 00:08:12,220
of Adam, or you can say
what's the relation

147
00:08:12,220 --> 00:08:12,970
between Adam and Cain?

148
00:08:12,970 --> 00:08:17,370
Those are different questions
being run by different

149
00:08:17,370 --> 00:08:22,474
traditional procedures all
based on the same fact.

150
00:08:22,474 --> 00:08:24,960
And that's going to be the
essence of the power of this

151
00:08:24,960 --> 00:08:30,050
programming style, that one
piece of declarative knowledge

152
00:08:30,050 --> 00:08:33,150
can be used as the basis for
a lot of different kinds of

153
00:08:33,150 --> 00:08:36,440
how-to knowledge, as opposed
to the kinds of procedures

154
00:08:36,440 --> 00:08:39,010
we're writing where you sort of
tell it what input you're

155
00:08:39,010 --> 00:08:41,490
giving it and what
answer you want.

156
00:08:41,490 --> 00:08:43,710
So for instance, our square
root program can perfectly

157
00:08:43,710 --> 00:08:48,900
well answer the question, what's
the square root of 144?

158
00:08:48,900 --> 00:08:51,290
But in principle, the
mathematical definition of

159
00:08:51,290 --> 00:08:52,830
square root tells you
other things.

160
00:08:52,830 --> 00:08:57,590
Like it could say, what is
17 the square root of?

161
00:08:57,590 --> 00:08:58,590
And that would be have
to be answered

162
00:08:58,590 --> 00:09:01,920
by a different program.

163
00:09:01,920 --> 00:09:05,700
So the mathematical definition,
or in general, the

164
00:09:05,700 --> 00:09:09,540
facts that you give it are
somehow unbiased as to what

165
00:09:09,540 --> 00:09:10,900
the question is.

166
00:09:10,900 --> 00:09:13,240
Whereas the programs we tend to
write specifically because

167
00:09:13,240 --> 00:09:15,230
they are how-to knowledge
tend to be looking

168
00:09:15,230 --> 00:09:17,700
for a specific answer.

169
00:09:17,700 --> 00:09:19,530
So that's going to be one
characteristic of what we're

170
00:09:19,530 --> 00:09:21,810
talking about.

171
00:09:21,810 --> 00:09:23,480
We can go on.

172
00:09:23,480 --> 00:09:26,420
We can imagine that we've
given our language

173
00:09:26,420 --> 00:09:27,710
some sort of facts.

174
00:09:27,710 --> 00:09:30,020
Now let's give it some
rules of inference.

175
00:09:30,020 --> 00:09:35,100
We can say, for instance,
if the--

176
00:09:35,100 --> 00:09:36,510
make up some syntax here--

177
00:09:36,510 --> 00:09:41,580
if the son of x is y--

178
00:09:41,580 --> 00:09:45,650
I'll put question marks to
indicate variables here--

179
00:09:45,650 --> 00:10:01,800
if the son of x is y and the
son of y is z, then the

180
00:10:01,800 --> 00:10:09,320
grandson of x is z.

181
00:10:09,320 --> 00:10:15,370
So I can imagine telling my
machine that rule and then

182
00:10:15,370 --> 00:10:17,680
being able to say, for
instance, who's

183
00:10:17,680 --> 00:10:20,610
the grandson of Adam?

184
00:10:20,610 --> 00:10:24,790
Or who is Irad the
grandson of?

185
00:10:24,790 --> 00:10:28,080
Or deduce all grandson
relationships you possibly can

186
00:10:28,080 --> 00:10:29,330
from this information.

187
00:10:29,330 --> 00:10:31,220

188
00:10:31,220 --> 00:10:34,580
We can imagine somehow the
language knowing how to do

189
00:10:34,580 --> 00:10:35,830
that automatically.

190
00:10:35,830 --> 00:10:42,640

191
00:10:42,640 --> 00:10:45,200
Let me give you maybe a little
bit more concrete example.

192
00:10:45,200 --> 00:10:49,610

193
00:10:49,610 --> 00:10:53,700
Here's a procedure that merges
two sorted lists.

194
00:10:53,700 --> 00:11:01,370
So x and y are two, say, lists
of numbers, lists of distinct

195
00:11:01,370 --> 00:11:04,780
numbers, if you like, that
are in increasing order.

196
00:11:04,780 --> 00:11:08,560
And what merge does is take
two such lists and combine

197
00:11:08,560 --> 00:11:10,040
them into a list where
everything's in increasing

198
00:11:10,040 --> 00:11:15,330
order, and this is a pretty easy
programs that you ought

199
00:11:15,330 --> 00:11:16,390
to be able to write.

200
00:11:16,390 --> 00:11:18,860
It says, if x is empty,
the answer is y.

201
00:11:18,860 --> 00:11:21,180
If y is empty, the
answer is x.

202
00:11:21,180 --> 00:11:22,990
Otherwise, you compare the
first two elements.

203
00:11:22,990 --> 00:11:25,540
So you pick out the first thing
in x and the first thing

204
00:11:25,540 --> 00:11:31,060
in y, and then depending on
which of those first elements

205
00:11:31,060 --> 00:11:35,500
is less, you stick the lower
one on to the result a

206
00:11:35,500 --> 00:11:40,150
recursively merging, either
chopping the first one off x

207
00:11:40,150 --> 00:11:42,400
or chopping the first
one off y.

208
00:11:42,400 --> 00:11:43,960
That's a standard
kind of program.

209
00:11:43,960 --> 00:11:46,470

210
00:11:46,470 --> 00:11:48,620
Let's look at the logic.

211
00:11:48,620 --> 00:11:51,660
Let's forget about the program
and look at the logic on which

212
00:11:51,660 --> 00:11:53,820
that procedure is based.

213
00:11:53,820 --> 00:11:56,860
See, there's some logic which
says, gee, if the first one is

214
00:11:56,860 --> 00:12:00,240
less, then we get the answer by
sticking something onto the

215
00:12:00,240 --> 00:12:03,350
result of recursively merging
the rest. So let's try and be

216
00:12:03,350 --> 00:12:05,420
explicit about what that
logic is that's

217
00:12:05,420 --> 00:12:08,430
making the program work.

218
00:12:08,430 --> 00:12:10,130
So here's one piece.

219
00:12:10,130 --> 00:12:13,820
Here's the piece of the program
which recursively

220
00:12:13,820 --> 00:12:19,980
chops down x if the first
thing in x is smaller.

221
00:12:19,980 --> 00:12:22,030
And if you want to be very
explicit about what the logic

222
00:12:22,030 --> 00:12:27,120
is there, what's really going on
is a deduction, which says,

223
00:12:27,120 --> 00:12:31,790
if you know that some list, that
we'll call cdr of x, and

224
00:12:31,790 --> 00:12:40,480
y merged to form z, and you know
that a is less than the

225
00:12:40,480 --> 00:12:47,570
first thing in y, then you know
that if you put a onto

226
00:12:47,570 --> 00:12:55,820
the cdr of x, then that result
and y merge to form a onto z.

227
00:12:55,820 --> 00:12:58,720
And what that is, that's the
underlying piece of logic--

228
00:12:58,720 --> 00:13:01,620
I haven't written it as a
program, I wrote it a sort of

229
00:13:01,620 --> 00:13:05,480
deduction that's underneath this
particular clause that

230
00:13:05,480 --> 00:13:09,410
says we can use the
recursion there.

231
00:13:09,410 --> 00:13:11,910
And then similar, here's
the other clause

232
00:13:11,910 --> 00:13:14,000
just to complete it.

233
00:13:14,000 --> 00:13:16,880
The other clause is based on
this piece of logic, which is

234
00:13:16,880 --> 00:13:19,460
almost the same and I won't go
through it, and then there's

235
00:13:19,460 --> 00:13:22,730
the n cases where we tested for
null, and that's based on

236
00:13:22,730 --> 00:13:26,920
the idea that for any x, x and
the empty list merge to form

237
00:13:26,920 --> 00:13:30,740
an x, or for any y, the empty
list and y merge to form y.

238
00:13:30,740 --> 00:13:33,360

239
00:13:33,360 --> 00:13:39,340
OK, so there's a piece of
procedure and the logic on

240
00:13:39,340 --> 00:13:41,740
which it's based.

241
00:13:41,740 --> 00:13:44,750
And notice a big difference.

242
00:13:44,750 --> 00:13:51,050
The procedure looked
like this: it

243
00:13:51,050 --> 00:13:52,900
said there was a box--

244
00:13:52,900 --> 00:13:55,410
and all the things we've been
doing have the characteristic

245
00:13:55,410 --> 00:13:57,890
we have boxes and things going
in and things going out--

246
00:13:57,890 --> 00:14:04,480
there was this box called merge,
and in came an x and y,

247
00:14:04,480 --> 00:14:07,550
and out came an answer.

248
00:14:07,550 --> 00:14:09,340
That's the character of the
procedure that we wrote.

249
00:14:09,340 --> 00:14:13,160

250
00:14:13,160 --> 00:14:14,660
These rules don't
look like that.

251
00:14:14,660 --> 00:14:17,620
These rules talk about
a relation.

252
00:14:17,620 --> 00:14:23,030
There's some sort of relation
that in those slides I called

253
00:14:23,030 --> 00:14:25,370
mrege-to-form.

254
00:14:25,370 --> 00:14:29,200
So I said x and y merge
to form z, and

255
00:14:29,200 --> 00:14:32,610
somehow this is a function.

256
00:14:32,610 --> 00:14:32,850
Right?

257
00:14:32,850 --> 00:14:36,070
The answer is a function of x
and y, and here what I have is

258
00:14:36,070 --> 00:14:39,720
a relation between
three things.

259
00:14:39,720 --> 00:14:43,120
And I'm not going to specify
which is the input and which

260
00:14:43,120 --> 00:14:44,200
is the output.

261
00:14:44,200 --> 00:14:48,690
And the reason I want to say
that is because in principle,

262
00:14:48,690 --> 00:14:51,300
we could use exactly those same
logic rules to answer a

263
00:14:51,300 --> 00:14:54,570
lot of different questions.

264
00:14:54,570 --> 00:14:56,750
So we can say, for instance--

265
00:14:56,750 --> 00:14:59,050
imagine giving our machine
those rules of logic.

266
00:14:59,050 --> 00:15:01,400
Not the program, the underlying
rules of logic.

267
00:15:01,400 --> 00:15:04,750
Then it ought to be
able to say--

268
00:15:04,750 --> 00:15:06,770
we could ask it--

269
00:15:06,770 --> 00:15:20,910
1, 3, 7 and 2, 4, 8 merge
to form what?

270
00:15:20,910 --> 00:15:23,880
And that's a question it ought
to be able to answer.

271
00:15:23,880 --> 00:15:26,480
That's exactly the same
question that our list

272
00:15:26,480 --> 00:15:28,180
procedure answered.

273
00:15:28,180 --> 00:15:33,750
But the exact same rules should
also be able to answer

274
00:15:33,750 --> 00:15:41,760
a question like this: 1, 3, 7
and what merged to form 1, 2,

275
00:15:41,760 --> 00:15:45,560
3, 4, 7, 8?

276
00:15:45,560 --> 00:15:48,120
The same rules of logic can
answer this, although the

277
00:15:48,120 --> 00:15:50,880
procedure we wrote can't
answer that question.

278
00:15:50,880 --> 00:15:56,070
Or we might be able to
say what and what

279
00:15:56,070 --> 00:16:07,900
else merge to form--

280
00:16:07,900 --> 00:16:13,780
what and what else merge to
form 1, 2, 3, 4, 7, 8?

281
00:16:13,780 --> 00:16:16,320
And the thing should be able
to go through, if it really

282
00:16:16,320 --> 00:16:20,470
can apply that logic, and deduce
all, whatever is, 2 to

283
00:16:20,470 --> 00:16:22,540
the sixth answers to
that question.

284
00:16:22,540 --> 00:16:25,600

285
00:16:25,600 --> 00:16:28,790
It could be 1 and the rest, or
it could be 1, 2 and the rest.

286
00:16:28,790 --> 00:16:32,490
Or it could be 1 and 3 and 7 and
the rest. There's a whole

287
00:16:32,490 --> 00:16:33,410
bunch of answers.

288
00:16:33,410 --> 00:16:36,830
And in principle, the
logic should be

289
00:16:36,830 --> 00:16:38,550
enough to deduce that.

290
00:16:38,550 --> 00:16:44,540
So there are going to be two big
differences in the kind of

291
00:16:44,540 --> 00:16:48,370
program we're going to look
at and not only list, but

292
00:16:48,370 --> 00:16:49,850
essentially all the programming
you've probably

293
00:16:49,850 --> 00:16:54,150
done so far in pretty much any
language you can think of.

294
00:16:54,150 --> 00:16:57,620
The first is, we're not going
to be computing functions.

295
00:16:57,620 --> 00:17:00,800

296
00:17:00,800 --> 00:17:03,770
We're not going to be talking
about things that take input

297
00:17:03,770 --> 00:17:04,410
and output.

298
00:17:04,410 --> 00:17:06,890
We're going to be talking
about relations.

299
00:17:06,890 --> 00:17:09,180
And that means in principle,
these relations don't have

300
00:17:09,180 --> 00:17:11,089
directionality.

301
00:17:11,089 --> 00:17:14,569
So the knowledge that you
specify to answer this

302
00:17:14,569 --> 00:17:19,220
question, that same knowledge
should also allow you to

303
00:17:19,220 --> 00:17:21,345
answer these other questions
and conversely.

304
00:17:21,345 --> 00:17:26,310

305
00:17:26,310 --> 00:17:30,590
And the second issue is that
since we're talking about

306
00:17:30,590 --> 00:17:33,150
relations, these
relations don't

307
00:17:33,150 --> 00:17:35,610
necessarily have one answer.

308
00:17:35,610 --> 00:17:37,480
So that third question down
there doesn't have a

309
00:17:37,480 --> 00:17:39,415
particular answer, it has a
whole bunch of answers.

310
00:17:39,415 --> 00:17:42,270

311
00:17:42,270 --> 00:17:44,640
Well, that's where
we're going.

312
00:17:44,640 --> 00:17:48,620
This style of programming, by
the way, is called logic

313
00:17:48,620 --> 00:17:51,310
programming, for kind
of obvious reasons.

314
00:17:51,310 --> 00:17:56,160

315
00:17:56,160 --> 00:18:02,440
And people who do logic
programming say that-- they

316
00:18:02,440 --> 00:18:04,150
have this little phrase-- they
say the point of logic

317
00:18:04,150 --> 00:18:10,190
programming is that you use
logic to express what is true,

318
00:18:10,190 --> 00:18:15,190
you use logic to check whether
something is true, and you use

319
00:18:15,190 --> 00:18:19,200
logic to find out
what is true.

320
00:18:19,200 --> 00:18:23,300
The best known logic programming
language, as you

321
00:18:23,300 --> 00:18:25,780
probably know, is
called Prolog.

322
00:18:25,780 --> 00:18:31,010
The language that we're going
to implement this morning is

323
00:18:31,010 --> 00:18:33,110
something we call the query
language, and it essentially

324
00:18:33,110 --> 00:18:35,320
has the essence of prologue.

325
00:18:35,320 --> 00:18:38,340
It can do about the same stuff,
although it's a lot

326
00:18:38,340 --> 00:18:42,390
slower because we're going to
implement it in LISP rather

327
00:18:42,390 --> 00:18:44,210
than building a particular
compiler.

328
00:18:44,210 --> 00:18:47,510
We're going to interpret it on
top of the LISP interpreter.

329
00:18:47,510 --> 00:18:48,950
But other than that,
it can do about the

330
00:18:48,950 --> 00:18:49,750
same stuff as prolog.

331
00:18:49,750 --> 00:18:52,160
It has about the same power
and about the same

332
00:18:52,160 --> 00:18:54,696
limitations.

333
00:18:54,696 --> 00:18:56,120
All right, let's break
for question.

334
00:18:56,120 --> 00:19:00,040

335
00:19:00,040 --> 00:19:04,010
STUDENT: Yes, could you please
repeat what the three things

336
00:19:04,010 --> 00:19:06,720
you use logic programming
to find?

337
00:19:06,720 --> 00:19:09,120
In other words, to find what is
true, learn what is true--

338
00:19:09,120 --> 00:19:09,840
what is the?

339
00:19:09,840 --> 00:19:10,520
PROFESSOR: Right.

340
00:19:10,520 --> 00:19:15,850
Sort of a logic programmer's
little catechism.

341
00:19:15,850 --> 00:19:22,610
You use logic to express what
is true, like these rules.

342
00:19:22,610 --> 00:19:26,120
You use logic to check whether
something is true, and that's

343
00:19:26,120 --> 00:19:28,550
the kind of question I
didn't answer here.

344
00:19:28,550 --> 00:19:29,720
I might say--

345
00:19:29,720 --> 00:19:33,620
another question I could put
down here is to say, is it

346
00:19:33,620 --> 00:19:41,400
true that 1, 3, 7 and 2, 4, 8
merge to form 1, 2, 6, 10 And

347
00:19:41,400 --> 00:19:45,690
that same logic should
be enough to say no.

348
00:19:45,690 --> 00:19:49,190
So I use logic to check what is
true, and then you also use

349
00:19:49,190 --> 00:19:50,480
logic to find out what's true.

350
00:19:50,480 --> 00:20:04,060

351
00:20:04,060 --> 00:20:04,570
All right.

352
00:20:04,570 --> 00:20:06,138
Let's break.

353
00:20:06,138 --> 00:20:22,106
[MUSIC PLAYING BY J.S. BACH]

354
00:20:22,106 --> 00:20:47,590
[MUSIC ENDS]

355
00:20:47,590 --> 00:21:02,901
[MUSIC PLAYING BY J.S. BACH]

356
00:21:02,901 --> 00:21:06,810
PROFESSOR: OK, let's go ahead
and take a look at this query

357
00:21:06,810 --> 00:21:10,520
language and operation.

358
00:21:10,520 --> 00:21:12,890
The first thing you might
notice, when I put up that

359
00:21:12,890 --> 00:21:15,390
little biblical database, is
that it's nice to be able to

360
00:21:15,390 --> 00:21:18,900
ask this language questions
in relation to some

361
00:21:18,900 --> 00:21:21,330
collection of facts.

362
00:21:21,330 --> 00:21:26,060
So let's start off and make a
little collection of facts.

363
00:21:26,060 --> 00:21:31,700
This is a tiny fragment of
personnel records for a Boston

364
00:21:31,700 --> 00:21:34,440
high tech company, and here's
a piece of the personnel

365
00:21:34,440 --> 00:21:37,500
records of Ben Bitdiddle.

366
00:21:37,500 --> 00:21:41,470
And Ben Bitdiddle is the
computer wizard in this

367
00:21:41,470 --> 00:21:44,660
company, he's the underpaid
computer

368
00:21:44,660 --> 00:21:46,420
wizard in this company.

369
00:21:46,420 --> 00:21:49,330
His supervisor is all
Oliver Warbucks,

370
00:21:49,330 --> 00:21:52,150
and here's his address.

371
00:21:52,150 --> 00:21:55,220
So the format is we're giving
this information: job, salary,

372
00:21:55,220 --> 00:21:57,300
supervisor, address.

373
00:21:57,300 --> 00:21:59,250
And there are some other
conventions.

374
00:21:59,250 --> 00:22:01,570
Computer here means that Ben
works in the computer

375
00:22:01,570 --> 00:22:03,590
division, and his
position in the

376
00:22:03,590 --> 00:22:06,440
computer division is wizard.

377
00:22:06,440 --> 00:22:07,580
Here's somebody else.

378
00:22:07,580 --> 00:22:13,860
Alyssa, Alyssa P. Hacker is a
computer programmer, and she

379
00:22:13,860 --> 00:22:17,550
works for Ben, and she
lives in Cambridge.

380
00:22:17,550 --> 00:22:19,990
And there's another programmer
who works for Ben

381
00:22:19,990 --> 00:22:22,820
who's Lem E. Tweakit.

382
00:22:22,820 --> 00:22:26,330
And there's a programmer
trainee, who is Louis

383
00:22:26,330 --> 00:22:30,100
Reasoner, and he works
for Alyssa.

384
00:22:30,100 --> 00:22:34,830
And the big wheel of the company
doesn't work for

385
00:22:34,830 --> 00:22:37,010
anybody, right?

386
00:22:37,010 --> 00:22:38,110
That's Oliver Warbucks.

387
00:22:38,110 --> 00:22:43,080
Anyway, what we're going to do
is ask questions about that

388
00:22:43,080 --> 00:22:44,971
little world.

389
00:22:44,971 --> 00:22:47,410
And that'll be a sample
world that we're

390
00:22:47,410 --> 00:22:48,660
going to do logic in.

391
00:22:48,660 --> 00:22:51,420

392
00:22:51,420 --> 00:22:55,810
Let me just write up here, for
probably the last time, what I

393
00:22:55,810 --> 00:22:57,600
said is the very most important
thing you should get

394
00:22:57,600 --> 00:23:00,760
out of this course, and that
is, when somebody tells you

395
00:23:00,760 --> 00:23:03,440
about a language,
you say, fine--

396
00:23:03,440 --> 00:23:15,050
what are the primitives, what
are the means of combination,

397
00:23:15,050 --> 00:23:18,480
how do you put the primitives
together, and then how do you

398
00:23:18,480 --> 00:23:24,690
abstract them, how do you
abstract the compound pieces

399
00:23:24,690 --> 00:23:26,740
so you can use them as pieces
to make something more

400
00:23:26,740 --> 00:23:28,500
complicated?

401
00:23:28,500 --> 00:23:31,440
And we've said this a whole
bunch of times already, but

402
00:23:31,440 --> 00:23:32,690
it's worth saying again.

403
00:23:32,690 --> 00:23:36,210

404
00:23:36,210 --> 00:23:36,670
Let's start.

405
00:23:36,670 --> 00:23:38,040
The primitives.

406
00:23:38,040 --> 00:23:41,660
Well, there's really only one
primitive, and the primitive

407
00:23:41,660 --> 00:23:44,400
in this language is
called a query.

408
00:23:44,400 --> 00:23:46,810
A primitive query.

409
00:23:46,810 --> 00:23:48,060
Let's look at some primitive
queries.

410
00:23:48,060 --> 00:23:52,160

411
00:23:52,160 --> 00:23:53,100
Job x.

412
00:23:53,100 --> 00:23:55,550
Who is a computer programmer?

413
00:23:55,550 --> 00:24:04,700
Or find every fact in the
database that matches job of

414
00:24:04,700 --> 00:24:06,640
the x is computer programmer.

415
00:24:06,640 --> 00:24:08,470
And you see a little
syntax here.

416
00:24:08,470 --> 00:24:11,330
Things without question marks
are meant to be literal,

417
00:24:11,330 --> 00:24:13,940
question mark x means that's a
variable, and this thing will

418
00:24:13,940 --> 00:24:18,110
match, for example, the fact
that Alyssa P. Hacker is a

419
00:24:18,110 --> 00:24:21,930
computer programmer, or
x is Alyssa P. Hacker.

420
00:24:21,930 --> 00:24:26,820

421
00:24:26,820 --> 00:24:29,170
Or more generally, I could
have something with two

422
00:24:29,170 --> 00:24:30,750
variables in it.

423
00:24:30,750 --> 00:24:39,530
I could say, the job of x is
computer something, and

424
00:24:39,530 --> 00:24:42,140
that'll match computer wizard.

425
00:24:42,140 --> 00:24:44,865
So there's something here: type
will match wizard, or

426
00:24:44,865 --> 00:24:49,390
type will match programmer,
or x might match

427
00:24:49,390 --> 00:24:50,370
various certain things.

428
00:24:50,370 --> 00:24:53,270
So there are, in our little
example, only three facts in

429
00:24:53,270 --> 00:24:55,150
that database that
match that query.

430
00:24:55,150 --> 00:24:59,210

431
00:24:59,210 --> 00:25:04,910
Let's see, just to show you some
syntax, the same query,

432
00:25:04,910 --> 00:25:11,490
this query doesn't match the job
of x, doesn't match Lewis

433
00:25:11,490 --> 00:25:13,200
Reasoner, the reason for that
is when I write something

434
00:25:13,200 --> 00:25:17,160
here, what I mean is that this
is going to be a list of two

435
00:25:17,160 --> 00:25:22,730
symbols, of which the first is
the word computer, and the

436
00:25:22,730 --> 00:25:24,810
second can be anything.

437
00:25:24,810 --> 00:25:28,130
And Lewis's job description here
has three symbols, so it

438
00:25:28,130 --> 00:25:30,340
doesn't match.

439
00:25:30,340 --> 00:25:35,360
And just to show you a little
bit of syntax, the more

440
00:25:35,360 --> 00:25:37,920
general thing I might want to
type is a thing with a dot

441
00:25:37,920 --> 00:25:42,550
here, and this is just standard
this notation for

442
00:25:42,550 --> 00:25:46,560
saying, this is a list, of which
the first element is the

443
00:25:46,560 --> 00:25:49,350
word computers, and THE
REST, is something

444
00:25:49,350 --> 00:25:50,600
that I'll call type.

445
00:25:50,600 --> 00:25:53,730

446
00:25:53,730 --> 00:25:56,930
So this one would match.

447
00:25:56,930 --> 00:26:00,000
Lewis's job is computer
programmer trainee, and type

448
00:26:00,000 --> 00:26:04,690
here would be the cdr of this
list. It would be the list

449
00:26:04,690 --> 00:26:06,960
programmer trainee.

450
00:26:06,960 --> 00:26:08,410
And that kind of dot
processing is done

451
00:26:08,410 --> 00:26:10,460
automatically by the
LISP reader.

452
00:26:10,460 --> 00:26:15,900

453
00:26:15,900 --> 00:26:17,760
Well, let's actually try this.

454
00:26:17,760 --> 00:26:20,810
The idea is I'm going to type
in queries in this language,

455
00:26:20,810 --> 00:26:23,630
and answers will come out.

456
00:26:23,630 --> 00:26:25,180
Let's look at this.

457
00:26:25,180 --> 00:26:30,000
I can go up and say, who works
in the computer division?

458
00:26:30,000 --> 00:26:39,730
Job of x is computer dot y.

459
00:26:39,730 --> 00:26:42,562
Doesn't matter what I call
the dummy variables.

460
00:26:42,562 --> 00:26:45,690
It says the answers to that, and
it's found four answers.

461
00:26:45,690 --> 00:26:48,650

462
00:26:48,650 --> 00:26:51,380
Or I can go off and say, tell
me about everybody's

463
00:26:51,380 --> 00:26:52,505
supervisor.

464
00:26:52,505 --> 00:26:56,610
So I'll put in the query,
the primitive query, the

465
00:26:56,610 --> 00:26:59,390
supervisor of x is y.

466
00:26:59,390 --> 00:27:02,860

467
00:27:02,860 --> 00:27:05,540
There are all the supervisor
relationships I know.

468
00:27:05,540 --> 00:27:08,830
Or I could go type in, who
lives in Cambridge?

469
00:27:08,830 --> 00:27:20,670
So I can say, the address of x
is Cambridge dot anything.

470
00:27:20,670 --> 00:27:25,090

471
00:27:25,090 --> 00:27:26,585
And only one person lives
in Cambridge.

472
00:27:26,585 --> 00:27:30,820

473
00:27:30,820 --> 00:27:32,170
OK, so those are primitive
queries.

474
00:27:32,170 --> 00:27:34,460
And you see what happens to
basic interaction with the

475
00:27:34,460 --> 00:27:38,140
system is you type in a query,
and it types out

476
00:27:38,140 --> 00:27:39,620
all possible answers.

477
00:27:39,620 --> 00:27:43,100
Or another way to say that: it
finds out all the possible

478
00:27:43,100 --> 00:27:45,330
values of those variables x and
y or t or whatever I've

479
00:27:45,330 --> 00:27:50,380
called them, and it types out
all ways of taking that query

480
00:27:50,380 --> 00:27:53,080
and instantiating it--

481
00:27:53,080 --> 00:27:56,250
remember that from the rule
system lecture-- instantiates

482
00:27:56,250 --> 00:27:59,150
the query with all possible
values for those variables and

483
00:27:59,150 --> 00:28:01,000
then types out all of them.

484
00:28:01,000 --> 00:28:02,370
And there are a lot
of ways you can

485
00:28:02,370 --> 00:28:03,350
arrange a logic language.

486
00:28:03,350 --> 00:28:06,010
Prolog, for instance, does
something slightly different.

487
00:28:06,010 --> 00:28:08,980
Rather than typing back your
query, prolog would type out,

488
00:28:08,980 --> 00:28:12,230
x equals this and y equals that,
or x sequels this and y

489
00:28:12,230 --> 00:28:12,650
equals that.

490
00:28:12,650 --> 00:28:16,430
And that's a very surface level
thing, you can decide

491
00:28:16,430 --> 00:28:19,070
what you like.

492
00:28:19,070 --> 00:28:20,760
OK.

493
00:28:20,760 --> 00:28:21,340
All right.

494
00:28:21,340 --> 00:28:23,390
So the primitives in
this language?

495
00:28:23,390 --> 00:28:24,570
Only one, right?

496
00:28:24,570 --> 00:28:27,230
Primitive query.

497
00:28:27,230 --> 00:28:31,360

498
00:28:31,360 --> 00:28:31,650
OK.

499
00:28:31,650 --> 00:28:34,330
Means of combination.

500
00:28:34,330 --> 00:28:39,770
Let's look at some compound
queries in this language.

501
00:28:39,770 --> 00:28:41,790
Here's one.

502
00:28:41,790 --> 00:28:47,250
This one says, tell me all the
people who work in the

503
00:28:47,250 --> 00:28:49,810
computer division.

504
00:28:49,810 --> 00:28:52,610
Tell me all the people who work
in the computer division

505
00:28:52,610 --> 00:28:53,860
together with their
supervisors.

506
00:28:53,860 --> 00:28:56,800

507
00:28:56,800 --> 00:29:00,220
The way I write that is
the query is and.

508
00:29:00,220 --> 00:29:04,920
And the job of the x is computer
something or other.

509
00:29:04,920 --> 00:29:07,560
And job of x is computer
dot y.

510
00:29:07,560 --> 00:29:11,650
And the supervisor of x is z.

511
00:29:11,650 --> 00:29:13,570
Tell me all the people in
the computer division--

512
00:29:13,570 --> 00:29:16,460
that's this-- together with
their supervisors.

513
00:29:16,460 --> 00:29:20,290
And notice in this query I
have three variables--

514
00:29:20,290 --> 00:29:23,660
x, y, and z.

515
00:29:23,660 --> 00:29:29,450
And this x is supposed to
be the same as that x.

516
00:29:29,450 --> 00:29:31,560
So x works in the computer
division, and the

517
00:29:31,560 --> 00:29:34,810
supervisor of x is z.

518
00:29:34,810 --> 00:29:37,250
Let's try another one.

519
00:29:37,250 --> 00:29:39,005
So one means of combination
is and.

520
00:29:39,005 --> 00:29:41,540

521
00:29:41,540 --> 00:29:45,790
Who are all the people who
make more than $30,000?

522
00:29:45,790 --> 00:29:51,640
And the salary of some person
p is some amount a.

523
00:29:51,640 --> 00:29:54,590

524
00:29:54,590 --> 00:30:00,600
And when I go and look at a,
a is greater than $30,000.

525
00:30:00,600 --> 00:30:06,300
And LISP value here is a little
piece of interface that

526
00:30:06,300 --> 00:30:10,600
interfaces the query language
to the underlying LISP.

527
00:30:10,600 --> 00:30:13,540
And what the LISP value allows
you to do is call any LISP

528
00:30:13,540 --> 00:30:17,180
predicate inside a query.

529
00:30:17,180 --> 00:30:19,110
So here I'm using the LISP
predicate greater than, so I

530
00:30:19,110 --> 00:30:21,020
say LISP value.

531
00:30:21,020 --> 00:30:21,750
This I say and.

532
00:30:21,750 --> 00:30:28,190
So all the people whose salary
is greater than $30,000.

533
00:30:28,190 --> 00:30:31,270
Or here's a more complicated
one.

534
00:30:31,270 --> 00:30:36,150
Tell me all the people who work
in the computer division

535
00:30:36,150 --> 00:30:38,560
who do not have a supervisor
who works in

536
00:30:38,560 --> 00:30:39,810
the computer division.

537
00:30:39,810 --> 00:30:42,790

538
00:30:42,790 --> 00:30:45,510
and x works in the computer
division.

539
00:30:45,510 --> 00:30:47,780
The job of x is computer
dot y.

540
00:30:47,780 --> 00:30:55,570
And it's not the case that both
x has a supervisor z and

541
00:30:55,570 --> 00:30:59,620
the job of z is computer
something or other.

542
00:30:59,620 --> 00:31:04,050
All right, so again, this x has
got to be that x, and this

543
00:31:04,050 --> 00:31:05,710
z is going to be that z.

544
00:31:05,710 --> 00:31:09,390

545
00:31:09,390 --> 00:31:11,380
And then you see another means
a combination, not.

546
00:31:11,380 --> 00:31:17,272

547
00:31:17,272 --> 00:31:20,880
All right, well, let's
look at that.

548
00:31:20,880 --> 00:31:22,400
It works the same way.

549
00:31:22,400 --> 00:31:33,110
I can go up to the machine and
say and the job of the x is

550
00:31:33,110 --> 00:31:35,400
computer dot y.

551
00:31:35,400 --> 00:31:38,480

552
00:31:38,480 --> 00:31:46,600
And the supervisor of x is z.

553
00:31:46,600 --> 00:31:50,794
And I typed that in
like a query.

554
00:31:50,794 --> 00:31:55,680
And what it types back, what
you see are the queries I

555
00:31:55,680 --> 00:31:58,930
typed in instantiated by
all possible answers.

556
00:31:58,930 --> 00:32:02,000
And then you see there
are a lot of answers.

557
00:32:02,000 --> 00:32:02,190
All right.

558
00:32:02,190 --> 00:32:05,230
So the means of combination
in this language--

559
00:32:05,230 --> 00:32:07,550
and this is why it's called
a logic language--

560
00:32:07,550 --> 00:32:09,800
are logical operations.

561
00:32:09,800 --> 00:32:16,120
Means of combinations are things
like AND and NOT and

562
00:32:16,120 --> 00:32:18,490
there's one I didn't show
you, which is OR.

563
00:32:18,490 --> 00:32:24,310
And then I showed you LISP
value, which is not logic, of

564
00:32:24,310 --> 00:32:26,365
course, but is a little special
hack to interface that

565
00:32:26,365 --> 00:32:29,250
to LISP so you can
get more power.

566
00:32:29,250 --> 00:32:32,690
Those are the means
of combination.

567
00:32:32,690 --> 00:32:34,160
OK, the means of abstraction.

568
00:32:34,160 --> 00:32:35,410
What we'd like to do--

569
00:32:35,410 --> 00:32:38,330

570
00:32:38,330 --> 00:32:42,260
let's go back for second and
look at that last slide.

571
00:32:42,260 --> 00:32:45,010
We might like to take very
complicated thing, the idea

572
00:32:45,010 --> 00:32:48,800
that someone works in a division
but does not have a

573
00:32:48,800 --> 00:32:52,400
supervisor in the division.

574
00:32:52,400 --> 00:32:56,090
And as before, name that.

575
00:32:56,090 --> 00:32:58,800
Well, if someone works in a
division and does not have a

576
00:32:58,800 --> 00:33:00,950
supervisor who works in that
division, that means that

577
00:33:00,950 --> 00:33:02,750
person is a big shot.

578
00:33:02,750 --> 00:33:08,370
So let's make a rule that
somebody x is a big shot in

579
00:33:08,370 --> 00:33:16,760
some department if x works in
the department and it's not

580
00:33:16,760 --> 00:33:19,610
the case that x has a supervisor
who works in the

581
00:33:19,610 --> 00:33:21,510
department.

582
00:33:21,510 --> 00:33:22,940
So this is our means
of abstraction.

583
00:33:22,940 --> 00:33:24,190
This is a rule.

584
00:33:24,190 --> 00:33:26,220

585
00:33:26,220 --> 00:33:27,580
And a rule has three parts.

586
00:33:27,580 --> 00:33:30,970

587
00:33:30,970 --> 00:33:33,450
The thing that says
it's a rule.

588
00:33:33,450 --> 00:33:37,530
And then there's the conclusion
of the rule.

589
00:33:37,530 --> 00:33:40,000
And then there's the
body of the rule.

590
00:33:40,000 --> 00:33:42,150
And you can read this as a piece
of logic which says, if

591
00:33:42,150 --> 00:33:46,940
you know that the body of the
rule is true, then you can

592
00:33:46,940 --> 00:33:49,470
conclude that the conclusion
is true.

593
00:33:49,470 --> 00:33:52,640
Or in order to deduce that
x is a big shot in some

594
00:33:52,640 --> 00:33:57,480
department, it's enough
to verify that.

595
00:33:57,480 --> 00:33:58,820
So that's what rules
look like.

596
00:33:58,820 --> 00:34:03,280

597
00:34:03,280 --> 00:34:07,180
Let's go back and look at that
merge example that I did

598
00:34:07,180 --> 00:34:08,110
before the break.

599
00:34:08,110 --> 00:34:11,610
Let's look at how that would
look in terms of rules.

600
00:34:11,610 --> 00:34:14,030
I'm going to take the logic I
put up and just change it into

601
00:34:14,030 --> 00:34:15,500
a bunch of rules
in this format.

602
00:34:15,500 --> 00:34:18,739

603
00:34:18,739 --> 00:34:19,350
We have a rule.

604
00:34:19,350 --> 00:34:21,710
Remember, there was this
thing merge-to-form.

605
00:34:21,710 --> 00:34:28,489
There is a rule that says,
the empty list and y

606
00:34:28,489 --> 00:34:29,620
merge to form y.

607
00:34:29,620 --> 00:34:30,870
This is the rule conclusion.

608
00:34:30,870 --> 00:34:33,210

609
00:34:33,210 --> 00:34:36,650
And notice this particular
rule has no body.

610
00:34:36,650 --> 00:34:40,010
And in this language, a rule
with no body is something that

611
00:34:40,010 --> 00:34:41,239
is always true.

612
00:34:41,239 --> 00:34:42,510
You can always assume
that's true.

613
00:34:42,510 --> 00:34:45,190

614
00:34:45,190 --> 00:34:47,530
And there was another piece of
logic that said anything in

615
00:34:47,530 --> 00:34:49,460
the empty list merged to
form the anything.

616
00:34:49,460 --> 00:34:50,900
That's this.

617
00:34:50,900 --> 00:34:55,510
A rule y and the empty
list merge to form y.

618
00:34:55,510 --> 00:34:58,060
Those corresponded to the two
end cases in our merge

619
00:34:58,060 --> 00:35:00,890
procedure, but now we're talking
about logic, not about

620
00:35:00,890 --> 00:35:03,490
procedures.

621
00:35:03,490 --> 00:35:07,560
Then we had another rule, which
said if you know how

622
00:35:07,560 --> 00:35:09,830
shorter things merge, you
can put them together.

623
00:35:09,830 --> 00:35:15,340
So this says, if you have a list
x and y and z, and if you

624
00:35:15,340 --> 00:35:19,530
want to deduce that a dot x--
this means constant a onto x,

625
00:35:19,530 --> 00:35:23,160
or a list whose first thing
is a and whose rest is x--

626
00:35:23,160 --> 00:35:26,230
so if you want to deduce that
a dot x and b dot y merge to

627
00:35:26,230 --> 00:35:27,480
form b dot c--

628
00:35:27,480 --> 00:35:30,570

629
00:35:30,570 --> 00:35:34,070
that would say you merge these
two lists a x and b y and

630
00:35:34,070 --> 00:35:37,680
you're going to get something
that starts with b--

631
00:35:37,680 --> 00:35:41,880
you can deduce that if you know
that it's the case both

632
00:35:41,880 --> 00:35:48,690
that a dot x and y merge to form
z and a is larger than b.

633
00:35:48,690 --> 00:35:52,610
So when I merge them, b will
come first in the list. That's

634
00:35:52,610 --> 00:35:56,050
a little translation of the
logic rule that I wrote in

635
00:35:56,050 --> 00:35:57,960
pseudo-English before.

636
00:35:57,960 --> 00:35:59,870
And then just for completeness,

637
00:35:59,870 --> 00:36:03,130
here's the other case.

638
00:36:03,130 --> 00:36:08,170
a dot x and b dot y merge to
form a dot z if x and b dot y

639
00:36:08,170 --> 00:36:12,190
merged to form z and
b is larger than a.

640
00:36:12,190 --> 00:36:15,610
So that's a little program that
I've typed in in this

641
00:36:15,610 --> 00:36:17,416
language, and now let's
look at it run.

642
00:36:17,416 --> 00:36:21,900

643
00:36:21,900 --> 00:36:27,740
So I typed in the merge rules
before, and I could use this

644
00:36:27,740 --> 00:36:28,510
like a procedure.

645
00:36:28,510 --> 00:36:39,590
I could say merge to form
1 and 3 and 2 and 7.

646
00:36:39,590 --> 00:36:43,330
So here I'm using it like
the LISP procedure.

647
00:36:43,330 --> 00:36:46,940
Now it's going to think about
that for a while and apply

648
00:36:46,940 --> 00:36:48,190
these rules.

649
00:36:48,190 --> 00:36:50,780

650
00:36:50,780 --> 00:36:52,800
So it found an answer.

651
00:36:52,800 --> 00:36:55,370
Now it's going to see if there
are any other answers but it

652
00:36:55,370 --> 00:36:57,810
doesn't know a priori there's
only one answer.

653
00:36:57,810 --> 00:37:00,790
So it's sitting here checking
all possibilities, and it

654
00:37:00,790 --> 00:37:01,970
says, no more.

655
00:37:01,970 --> 00:37:02,775
Done.

656
00:37:02,775 --> 00:37:05,210
So there I've used those
rules like a procedure.

657
00:37:05,210 --> 00:37:08,340
Or remember the whole point is
that I can ask different kinds

658
00:37:08,340 --> 00:37:10,220
of questions.

659
00:37:10,220 --> 00:37:24,590
I could say merge to form, let's
see, how about 2 and a.

660
00:37:24,590 --> 00:37:29,440
Some list of two elements which
I know starts with 2,

661
00:37:29,440 --> 00:37:34,600
and the other thing I don't
know, and x and some other

662
00:37:34,600 --> 00:37:39,510
list merge to form
a 1, 2, 3 and 4.

663
00:37:39,510 --> 00:37:42,760

664
00:37:42,760 --> 00:37:44,590
So now it's going to
think about that.

665
00:37:44,590 --> 00:37:45,840
It's got to find--

666
00:37:45,840 --> 00:37:48,070

667
00:37:48,070 --> 00:37:49,095
so it found one possibility.

668
00:37:49,095 --> 00:37:53,830
It said a could be 3, and x
could be the list 1, 4.

669
00:37:53,830 --> 00:37:57,220
And now, again, it's got to
check because it doesn't a

670
00:37:57,220 --> 00:37:59,050
priori know that there
aren't any other

671
00:37:59,050 --> 00:38:00,300
possibilities going on.

672
00:38:00,300 --> 00:38:03,680

673
00:38:03,680 --> 00:38:10,660
Or like I said, I could say
something like merge to form,

674
00:38:10,660 --> 00:38:17,275
like, what and what else merge
to form 1, 2, 3, 4, 5?

675
00:38:17,275 --> 00:38:24,340

676
00:38:24,340 --> 00:38:25,590
Now it's going to think
about that.

677
00:38:25,590 --> 00:38:28,490

678
00:38:28,490 --> 00:38:30,310
And there are a lot of answers
that it might get.

679
00:38:30,310 --> 00:38:35,180

680
00:38:35,180 --> 00:38:37,920
And what you see is here you're
really paying the price

681
00:38:37,920 --> 00:38:39,170
of slowness.

682
00:38:39,170 --> 00:38:42,210

683
00:38:42,210 --> 00:38:43,880
And kind of for three reasons.

684
00:38:43,880 --> 00:38:47,630
One is that this language
is doubly interpreted.

685
00:38:47,630 --> 00:38:50,100
Whereas in a real
implementation, you would go

686
00:38:50,100 --> 00:38:52,190
compile this down to primitive
operations.

687
00:38:52,190 --> 00:38:56,410
The other reason is that this
particular algorithm for

688
00:38:56,410 --> 00:38:58,380
merges is doubly recursive.

689
00:38:58,380 --> 00:39:01,020
So it's going to take
a very long time.

690
00:39:01,020 --> 00:39:06,710
And eventually, this is going
to go through and find--

691
00:39:06,710 --> 00:39:07,130
find what?

692
00:39:07,130 --> 00:39:08,730
Two to the fifth possible
answers.

693
00:39:08,730 --> 00:39:12,140

694
00:39:12,140 --> 00:39:14,830
And you see they come out in
some fairly arbitrary order,

695
00:39:14,830 --> 00:39:17,100
depending on which order
it's going to be

696
00:39:17,100 --> 00:39:20,160
trying these rules.

697
00:39:20,160 --> 00:39:21,530
In fact, what we're going
to do when they edit the

698
00:39:21,530 --> 00:39:24,310
videotape is speed
all this up.

699
00:39:24,310 --> 00:39:26,600
Don't you like taking
out these weights?

700
00:39:26,600 --> 00:39:28,250
And don't you wish you could
do that in your demos?

701
00:39:28,250 --> 00:39:32,840

702
00:39:32,840 --> 00:39:34,260
Anyway, it's still
grinding there.

703
00:39:34,260 --> 00:39:39,220

704
00:39:39,220 --> 00:39:41,170
Anyway, there are 32
possibilities--

705
00:39:41,170 --> 00:39:42,630
we won't wait for it to
print out all of them.

706
00:39:42,630 --> 00:39:47,850

707
00:39:47,850 --> 00:39:49,410
OK, so the needs of abstraction
in this

708
00:39:49,410 --> 00:39:50,660
language are rules.

709
00:39:50,660 --> 00:39:53,630

710
00:39:53,630 --> 00:39:57,410
So we take some bunch of things
that are put together

711
00:39:57,410 --> 00:40:00,350
with logic and we name them.

712
00:40:00,350 --> 00:40:02,080
And you can think of
that as naming a

713
00:40:02,080 --> 00:40:03,410
particular pattern of logic.

714
00:40:03,410 --> 00:40:05,810
Or you can think of that as
saying, if you want to deduce

715
00:40:05,810 --> 00:40:10,660
some conclusion, you can apply
those rules of logic.

716
00:40:10,660 --> 00:40:13,420
And those are three elements
of this language.

717
00:40:13,420 --> 00:40:15,670
Let's break now, and then we'll
talk about how it's

718
00:40:15,670 --> 00:40:16,920
actually implemented.

719
00:40:16,920 --> 00:40:22,747

720
00:40:22,747 --> 00:40:27,380
STUDENT: Does using LISP value
primitive or whatever

721
00:40:27,380 --> 00:40:31,770
interfere with your means to go
both directions on a query?

722
00:40:31,770 --> 00:40:33,530
PROFESSOR: OK, that's a--

723
00:40:33,530 --> 00:40:37,840
the question is, does using LISP
value interfere with the

724
00:40:37,840 --> 00:40:40,090
ability to go both directions
on the query?

725
00:40:40,090 --> 00:40:43,850
We haven't really talked about
the implementation yet, but

726
00:40:43,850 --> 00:40:46,890
the answer is, yes, it can.

727
00:40:46,890 --> 00:40:50,510
In general, as we'll
see at the end--

728
00:40:50,510 --> 00:40:53,330
although I really won't
to go into details--

729
00:40:53,330 --> 00:40:58,140
it's fairly complicated,
especially when you use either

730
00:40:58,140 --> 00:40:59,780
not or LISP value--

731
00:40:59,780 --> 00:41:04,310
or actually, if you use anything
besides only and, it

732
00:41:04,310 --> 00:41:07,350
becomes very complicated
to say when

733
00:41:07,350 --> 00:41:08,700
these things will work.

734
00:41:08,700 --> 00:41:10,360
They won't work quite
in all situations.

735
00:41:10,360 --> 00:41:14,300
I'll talk about that at the end
of the second half today.

736
00:41:14,300 --> 00:41:17,180
But the answer to your question
is, yes, by dragging

737
00:41:17,180 --> 00:41:22,000
in a lot more power from LISP
value, you lose some of the

738
00:41:22,000 --> 00:41:24,170
principal power of logic
programming.

739
00:41:24,170 --> 00:41:28,090
That's a trade-off that
you have to make.

740
00:41:28,090 --> 00:41:30,390
OK, let's take a break.

741
00:41:30,390 --> 00:41:49,844