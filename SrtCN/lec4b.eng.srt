1
00:00:03,936 --> 00:00:05,529
[MUSIC -- "JESU, JOY OF MAN'S DESIRING" BY JOHANN SEBASTIAN BACH]

2
00:00:20,180 --> 00:00:23,780
PROFESSOR: So far in this course we've been talking a lot about data abstraction.

3
00:00:23,780 --> 00:00:41,180
And remember the idea is that we build systems that have these horizontal barriers in them, these abstraction barriers that separate use, the way you might use some data object, from the way you might represent it.

4
00:00:48,985 --> 00:00:57,110
Or another way to think of that is up here you have the boss who's going to be using some sort of data object.

5
00:00:57,110 --> 00:01:02,310
And down here is George who's implemented it.

6
00:01:02,310 --> 00:01:15,930
Now this notion of separating use from representation so you can think about these two problems separately is a very, very powerful programming methodology, data abstraction.

7
00:01:15,930 --> 00:01:28,640
On the other hand, it's not really sufficient for really complex systems. And the problem with this is George.

8
00:01:28,640 --> 00:01:34,630
Or actually, the problem is that there are a lot of Georges.

9
00:01:34,630 --> 00:01:35,390
Let's be concrete.

10
00:01:35,390 --> 00:01:41,192
Let's suppose there is George, and there's also Martha.

11
00:01:41,192 --> 00:01:51,750
OK, now George and Martha are both working on this system, both designing representations, and absolutely are incompatible.

12
00:01:51,750 --> 00:01:57,250
They wouldn't cooperate on a representation under any circumstances.

13
00:01:57,250 --> 00:02:14,180
And the problem is you would like to have some system where both George and Martha are designing representations, and yet, if you're above this abstraction barrier you don't want to have to worry about that, whether something is done by George or by Martha.

14
00:02:14,180 --> 00:02:16,630
And you don't want George and Martha to interfere with each other.

15
00:02:16,630 --> 00:02:32,980
Somehow in designing a system, you not only want these horizontal barriers, but you also want some kind of vertical barrier to keep George and Martha separate.

16
00:02:32,980 --> 00:02:36,560
Let me be a little bit more concrete.

17
00:02:36,560 --> 00:02:50,430
Imagine that you're thinking about personnel records for a large company with a lot of loosely linked divisions that don't cooperate very well either.

18
00:02:50,430 --> 00:03:00,700
And imagine even that this company is formed by merging a whole bunch of companies that already have their personnel record system set up.

19
00:03:03,250 --> 00:03:12,240
And imagine that once these divisions are all linked in some kind of very sophisticated satellite network, and all these databases are put together.

20
00:03:12,240 --> 00:03:26,400
And what you'd like to do is, from any place in the company, to be able to say things like, oh, what's the name in a personnel record?

21
00:03:26,400 --> 00:03:30,540
Or, what's the job description in a personnel record?

22
00:03:30,540 --> 00:03:41,580
And not have to worry about the fact that each division obviously is going to have completely separate conventions for how you might implement these records.

23
00:03:41,580 --> 00:03:44,960
From this point you don't want to know about that.

24
00:03:44,960 --> 00:03:48,430
Well how could you possibly do that?

25
00:03:48,430 --> 00:03:58,070
One way, of course, is to send down an edict from somewhere that everybody has to change their format to some fixed compatible thing.

26
00:03:58,070 --> 00:04:01,820
That's what people often try, and of course it never works.

27
00:04:01,820 --> 00:04:11,250
Another thing that you might want to do is somehow arrange it so you can have these vertical barriers.

28
00:04:11,250 --> 00:04:19,470
So that when you ask for the name of a personnel record, somehow, whatever format it happens to be, name will figure out how to do the right thing.

29
00:04:22,730 --> 00:04:26,260
We want name to be, so-called, a generic operator.

30
00:04:26,260 --> 00:04:33,650
Generic operator means what it sort of precisely does depends on the kind of data that it's looking at.

31
00:04:33,650 --> 00:04:55,520
More than that, you'd like to design the system so that the next time a new division comes into the company they don't have to make any big changes in what they're already doing to link into this system, and the rest of the company doesn't have to make any big changes to admit their stuff to the system.

32
00:04:55,520 --> 00:04:58,700
So that's the problem you should be thinking about.

33
00:04:58,700 --> 00:05:00,770
Like it's sort of just your work.

34
00:05:00,770 --> 00:05:03,640
You want to be able to include new things by making minimal changes.

35
00:05:05,980 --> 00:05:09,440
OK, well that's the problem that we'll be talking about today.

36
00:05:09,440 --> 00:05:14,240
And you should have this sort of distributed personnel record system in your mind.

37
00:05:14,240 --> 00:05:18,900
But actually the one I'll be talking about is a problem that's a little bit more self-contained than that.

38
00:05:18,900 --> 00:05:21,870
that'll bring up the issues, I think, more clearly.

39
00:05:21,870 --> 00:05:27,770
That's the problem of doing a system that does arithmetic on complex numbers.

40
00:05:27,770 --> 00:05:30,690
So let's take a look here.

41
00:05:30,690 --> 00:05:35,250
Just as a little review, there are things called complex numbers.

42
00:05:35,250 --> 00:05:39,370
Complex number you can think of as a point in the plane, or z.

43
00:05:39,370 --> 00:05:47,190
And you can represent a point either by its real-part and its imaginary-part.

44
00:05:47,190 --> 00:05:56,130
So if this is z and its real-part is this much, and its imaginary-part is that much, and you write z equals x plus iy.

45
00:05:59,110 --> 00:06:10,900
Or another way to represent a complex number is by saying, what's the distance from the origin, and what's the angle?

46
00:06:10,900 --> 00:06:16,670
So that represents a complex number as its radius times an angle.

47
00:06:19,520 --> 00:06:28,640
This one's called-- the original one's called rectangular form, rectangular representation, real- and imaginary-part, or polar representation.

48
00:06:28,640 --> 00:06:33,720
Magnitude and angle-- and if you know the real- and imaginary-part, you can figure out the magnitude and angle.

49
00:06:33,720 --> 00:06:37,190
If you know x and y, you can get r by this formula.

50
00:06:37,190 --> 00:06:41,420
Square root of sum of the squares, and you can get the angle as an arctangent.

51
00:06:41,420 --> 00:06:45,800
Or conversely, if you knew r and A you could figure out x and y.

52
00:06:45,800 --> 00:06:52,490
x is r times the cosine of A, and y is r times the sine of A. All right, so there's these two.

53
00:06:52,490 --> 00:06:54,130
They're complex numbers.

54
00:06:54,130 --> 00:06:57,150
You can think of them either in polar form or rectangular form.

55
00:06:57,150 --> 00:07:03,850
What we would like to do is make a system that does arithmetic on complex numbers.

56
00:07:03,850 --> 00:07:16,910
In other words, what we'd like-- just like the rational number example-- is to have some operations plus c, which is going to take two complex numbers and add them, subtract them, and multiply them, and divide them.

57
00:07:20,730 --> 00:07:25,280
OK, well there's little bit of mathematics behind it.

58
00:07:25,280 --> 00:07:29,800
What are the actual formulas for manipulating such things?

59
00:07:29,800 --> 00:07:42,660
And it's sort of not important where they come from, but just as an implementer let's see-- if you want to add two complex numbers it's pretty easy to get its real-part and its imaginary-part.

60
00:07:42,660 --> 00:07:54,970
The real-part of the sum of two complex numbers, the real-part of the z1 plus z2 is the real-part of z1 plus the real-part of z2.

61
00:07:57,820 --> 00:08:07,410
And the imaginary-part of z1 plus z2 is the imaginary part of z1 plus the imaginary part of z2.

62
00:08:07,410 --> 00:08:09,480
So it's pretty easy to add complex numbers.

63
00:08:09,480 --> 00:08:13,400
You just add the corresponding parts and make a new complex number with those parts.

64
00:08:13,400 --> 00:08:17,840
If you want to multiply them, it's kind of nice to do it in polar form.

65
00:08:17,840 --> 00:08:26,285
Because if you have two complex numbers, the magnitude of their product is here, the product of the magnitudes.

66
00:08:28,850 --> 00:08:35,809
And the angle of the product is the sum of the angles.

67
00:08:35,809 --> 00:08:40,549
So that's sort of mathematics that allows you to do arithmetic on complex numbers.

68
00:08:40,549 --> 00:08:43,720
Let's actually think about the implementation.

69
00:08:43,720 --> 00:08:49,330
Well we do it just like rational numbers.

70
00:08:49,330 --> 00:08:53,840
We come down, we assume we have some constructors and selectors.

71
00:08:53,840 --> 00:08:55,330
What would we like?

72
00:08:55,330 --> 00:09:12,150
Well let's assume that we make a data object cloud, which is a complex number that has some stuff in it, and that we can get out from a complex number the real-part, or the imaginary-part, or the magnitude, or the angle.

73
00:09:12,150 --> 00:09:16,800
We want some ways of making complex numbers-- not only selectors, but constructors.

74
00:09:16,800 --> 00:09:20,160
So we'll assume we have a thing called make-rectangular.

75
00:09:20,160 --> 00:09:31,920
What make-rectangular is going to do is take a real-part and an imaginary-part and construct a complex number with those parts.

76
00:09:31,920 --> 00:09:44,680
Similarly, we can have make-polar which will take a magnitude and an angle, and construct a complex number which has that magnitude and angle.

77
00:09:44,680 --> 00:09:45,460
So here's a system.

78
00:09:45,460 --> 00:09:48,910
We'll have two constructors and four selectors.

79
00:09:48,910 --> 00:09:59,220
And now, just like before, in terms of that abstract data we'll go ahead and implement our complex number operations.

80
00:09:59,220 --> 00:10:08,330
And here you can see translated into Lisp code just the arithmetic formulas I put down before.

81
00:10:08,330 --> 00:10:16,630
If I want to add two complex numbers I will make a complex number out of its real- and imaginary-parts.

82
00:10:16,630 --> 00:10:23,310
The real part of the complex number I'm going to make is the sum of the real-parts.

83
00:10:23,310 --> 00:10:27,005
The imaginary part of the complex number I'm going to make is the sum of the imaginary-parts.

84
00:10:30,310 --> 00:10:31,990
I put those together, make a complex number.

85
00:10:31,990 --> 00:10:35,780
That's how I implement complex number addition.

86
00:10:35,780 --> 00:10:39,650
Subtraction is essentially the same.

87
00:10:39,650 --> 00:10:45,140
All I do is subtract the parts rather than add them.

88
00:10:45,140 --> 00:10:49,270
To multiply two complex numbers, I use the other formula.

89
00:10:49,270 --> 00:10:55,350
I'll make a complex number out of a magnitude and angle.

90
00:10:55,350 --> 00:11:00,465
The magnitude is going to be the product of the magnitudes of the two complex numbers I'm multiplying.

91
00:11:03,710 --> 00:11:09,620
And the angle is going to be the sum of the angles of the two complex numbers I'm multiplying.

92
00:11:09,620 --> 00:11:11,230
So there's multiplication.

93
00:11:11,230 --> 00:11:17,370
And then division, division is almost the same.

94
00:11:17,370 --> 00:11:19,660
Here I divide the magnitudes and subtract the angles.

95
00:11:28,640 --> 00:11:31,870
Now I've implemented the operations.

96
00:11:31,870 --> 00:11:33,640
And what do we do?

97
00:11:33,640 --> 00:11:36,060
We call on George.

98
00:11:36,060 --> 00:11:38,800
We've done the use, let's worry about the representation.

99
00:11:38,800 --> 00:11:45,250
We'll call on George and say to George, go ahead and build us a complex number representation.

100
00:11:45,250 --> 00:11:47,770
Well that's fine.

101
00:11:47,770 --> 00:11:57,200
George can say, we'll implement a complex number simply as a pair that has the real-part and the imaginary-part.

102
00:11:57,200 --> 00:12:09,780
So if I want to make a complex number with a certain real-part and an imaginary-part, I'll just use cons to form a pair, and that will-- that's George's representation of a complex number.

103
00:12:09,780 --> 00:12:14,350
So if I want to get out the real-part of something, I just extract the car, the first part.

104
00:12:14,350 --> 00:12:22,220
If I want to get the imaginary-part, I extract the cdr. How do I deal with the magnitude and angle?

105
00:12:22,220 --> 00:12:39,530
Well if I want to extract the magnitude of one of these things, I get the square root of the sum of the square of the car plus the square of the cdr. If I want to get the angle, I compute the arctangent of the cdr in the car.

106
00:12:39,530 --> 00:12:42,300
This is a list procedure for computing arctangent.

107
00:12:44,970 --> 00:13:01,460
And if somebody hands me a magnitude and an angle and says, make me a complex number, well I compute the real-part and the imaginary-part, or our cosine of a and our sine of a, and stick them together into a pair.

108
00:13:01,460 --> 00:13:02,260
OK so we're done.

109
00:13:02,260 --> 00:13:12,510
In fact, what I just did, conceptually, is absolutely no different from the rational number representation that we looked at last time.

110
00:13:12,510 --> 00:13:13,910
It's the same sort of idea.

111
00:13:13,910 --> 00:13:18,070
You implement the operators, you pick a representation.

112
00:13:18,070 --> 00:13:20,070
Nothing different.

113
00:13:20,070 --> 00:13:23,210
Now let's worry about Martha.

114
00:13:23,210 --> 00:13:26,670
See, Martha has a different idea.

115
00:13:26,670 --> 00:13:30,900
She doesn't want to represent a complex number as a pair of a real-part and an imaginary-part.

116
00:13:30,900 --> 00:13:39,550
What she would like to do is represent a complex number as a pair of a magnitude and an angle.

117
00:13:39,550 --> 00:13:44,570
So if instead of calling up George we ask Martha to design our representation, we get something like this.

118
00:13:44,570 --> 00:13:47,160
We get make-polar.

119
00:13:47,160 --> 00:13:55,430
Sure, if I give you a magnitude and an angle we're just going to form a pair that has magnitude and angle.

120
00:13:55,430 --> 00:13:57,680
If you want to extract the magnitude, that's easy.

121
00:13:57,680 --> 00:13:59,780
You just pull out the car or the pair.

122
00:13:59,780 --> 00:14:02,670
If you want to extract the angle, sure, that's easy.

123
00:14:02,670 --> 00:14:08,590
You just pull out the cdr. If you want to look for real-parts and imaginary-parts, well then you have to do some work.

124
00:14:08,590 --> 00:14:14,580
If you want the real-part, you have to get r cosine a.

125
00:14:14,580 --> 00:14:20,910
In other words, r, the car of the pair, times the cosine of the cdr of the pair.

126
00:14:20,910 --> 00:14:28,330
So this is r times the cosine of a, and that's the real-part.

127
00:14:28,330 --> 00:14:32,660
If you want to get the imaginary-part, it's r times the sine of a.

128
00:14:32,660 --> 00:14:45,540
And if I hand you a real-part and an imaginary-part and say, make me a complex number with that real-part and imaginary-part, well I figure out what the magnitude and angle should be.

129
00:14:45,540 --> 00:14:49,230
The magnitude's the square root of the sum of the squares and the angle's the arctangent.

130
00:14:49,230 --> 00:14:52,090
I put those together to make a pair.

131
00:14:52,090 --> 00:14:54,170
So there's Martha's idea.

132
00:14:56,690 --> 00:14:59,680
Well which is better?

133
00:14:59,680 --> 00:15:05,850
Well if you're doing a lot of additions, probably George's is better, because you're doing a lot of real-parts and imaginary-parts.

134
00:15:05,850 --> 00:15:11,140
If mostly you're going to be doing multiplications and divisions, then maybe Martha's idea is better.

135
00:15:11,140 --> 00:15:16,590
Or maybe, and this is the real point, you can't decide.

136
00:15:16,590 --> 00:15:23,480
Or maybe you just have to let them both hang around, for personality reasons.

137
00:15:23,480 --> 00:15:28,560
Maybe you just really can't ever decide what you would like.

138
00:15:28,560 --> 00:15:32,320
And again, what we would really like is a system that looks like this.

139
00:15:32,320 --> 00:15:41,470
That somehow there's George over here, who has built rectangular complex numbers.

140
00:15:41,470 --> 00:15:46,120
And Martha, who has polar complex numbers.

141
00:15:46,120 --> 00:16:04,410
And somehow we have operations that can add, and subtract, and multiply, and divide, and it shouldn't matter that there are two incompatible representations of complex numbers floating around this system.

142
00:16:04,410 --> 00:16:23,830
In other words, not only like an abstraction barrier here that has things in it like a real-part, and an imaginary-part, and magnitude, and angle.

143
00:16:23,830 --> 00:16:38,570
So not only is there an abstraction barrier that hides the actual representation from us, but also there's some kind of vertical barrier here that allows both of these representations to exist without interfering with each other.

144
00:16:38,570 --> 00:16:47,310
The idea is that the things in here-- real-part, imaginary-part, magnitude, and angle-- will be generic operators.

145
00:16:47,310 --> 00:16:53,880
If you ask for the real-part, it will worry about what representation it's looking at.

146
00:16:53,880 --> 00:16:56,840
OK, well how can we do that?

147
00:16:56,840 --> 00:17:02,770
There's actually a really obvious idea, if you're used to thinking about complex numbers.

148
00:17:02,770 --> 00:17:06,390
If you're used to thinking about compound data.

149
00:17:06,390 --> 00:17:15,790
See, suppose you could just tell by looking at a complex number whether it was constructed by George or Martha.

150
00:17:15,790 --> 00:17:20,910
In other words, so it's not that what's floating around here are ordinary, just complex numbers, right?

151
00:17:20,910 --> 00:17:24,390
They're fancy, designer complex numbers.

152
00:17:24,390 --> 00:17:31,450
So you look at a complex numbers as it's not just a complex number, it's got a label on it that says, this one is by Martha.

153
00:17:31,450 --> 00:17:34,480
Or this is a complex number by George.

154
00:17:34,480 --> 00:17:34,700
Right?

155
00:17:34,700 --> 00:17:36,860
They're signed.

156
00:17:36,860 --> 00:17:48,030
See, and then whenever we looked at a complex number we could just read the label, and then we'd know how you expect to operate on that.

157
00:17:48,030 --> 00:17:51,190
In other words, what we want is not just ordinary data objects.

158
00:17:51,190 --> 00:17:54,370
We want to introduce the notion of what's called typed data.

159
00:17:59,760 --> 00:18:03,940
Typed data means, again, there's some sort of cloud.

160
00:18:03,940 --> 00:18:10,180
And what it's got in it is an ordinary data object like we've been thinking about.

161
00:18:13,180 --> 00:18:16,540
Pulled out the contents, sort of the actual data.

162
00:18:19,320 --> 00:18:25,850
But also a thing called a type, but it's signed by either George or Martha.

163
00:18:25,850 --> 00:18:28,340
So we're going to go from regular data to type data.

164
00:18:31,950 --> 00:18:32,710
How do we build that?

165
00:18:32,710 --> 00:18:33,990
Well that's easy.

166
00:18:33,990 --> 00:18:34,980
We know how to build clouds.

167
00:18:34,980 --> 00:18:37,920
We build them out of pairs.

168
00:18:37,920 --> 00:18:43,510
So here's a little representation that supports typed data.

169
00:18:43,510 --> 00:18:51,530
There's a thing called take a type and attach it to a piece of contents, and we just use cons.

170
00:18:51,530 --> 00:18:56,290
And if we have a piece of typed data, we can look at the type, which is the car.

171
00:18:56,290 --> 00:19:07,520
We can look at the contents, which is the cdr. Now along with that, the way we use our type data will test, when we're given a piece of data, what type it is.

172
00:19:07,520 --> 00:19:10,510
So we have some type predicates with us.

173
00:19:10,510 --> 00:19:23,850
For example, to see whether a complex number is one of George's, whether it's rectangular, we just check to see if the type of that is the symbol rectangular, right?

174
00:19:23,850 --> 00:19:25,100
The symbol rectangular.

175
00:19:27,200 --> 00:19:33,430
And to check whether a complex number is one of Martha's, we check to see whether the type is the symbol polar.

176
00:19:36,460 --> 00:19:40,350
So that's a way to test what kind of number we're looking at.

177
00:19:40,350 --> 00:19:43,870
Now let's think about how we can use that to build the system.

178
00:19:43,870 --> 00:19:52,640
So let's suppose that George and Martha were off working separately, and each of them had designed their complex number representation packages.

179
00:19:52,640 --> 00:20:00,140
What do they have to do to become part of the system, to exist compatibly?

180
00:20:00,140 --> 00:20:02,860
Well it's really pretty easy.

181
00:20:02,860 --> 00:20:05,970
Remember, George had this package.

182
00:20:05,970 --> 00:20:08,980
Here's George's original package, or half of it.

183
00:20:08,980 --> 00:20:12,090
And underlined in red are the changes he has to make.

184
00:20:12,090 --> 00:20:20,930
So before, when George made a complex number out of an x and y, he just put them together to make a pair.

185
00:20:20,930 --> 00:20:24,090
And the only difference is that now he signs them.

186
00:20:24,090 --> 00:20:30,600
He attaches the type, which is the symbol rectangular to that pair.

187
00:20:30,600 --> 00:20:38,700
Everything else George does is the same, except that-- see, George and Martha both have procedures named real-part and imaginary-part.

188
00:20:38,700 --> 00:20:45,920
So to allow them both to exist in the same Lisp environment, George had changed the names of his procedures.

189
00:20:45,920 --> 00:20:49,045
So we'll say, this is George's real-part procedure.

190
00:20:49,045 --> 00:20:55,170
It's the real-part rectangular procedure, the imaginary-part rectangular procedure.

191
00:20:55,170 --> 00:20:59,130
And then here's the rest of George's package.

192
00:20:59,130 --> 00:21:05,702
He'd had magnitude and angle, just renames them magnitude rectangular and angle rectangular.

193
00:21:05,702 --> 00:21:09,860
And Martha has to do basically the same thing.

194
00:21:09,860 --> 00:21:19,270
Martha previously, when she made a complex number out of a magnitude and angle, she just cons them.

195
00:21:19,270 --> 00:21:30,710
Now she attaches the type polar, and she changes the name so her real-part procedure won't conflict in name with George's.

196
00:21:30,710 --> 00:21:38,060
It's a real-part-polar, imaginary-part-polar, magnitude polar, and angle polar.

197
00:21:45,000 --> 00:21:46,130
Now we have the system.

198
00:21:46,130 --> 00:21:49,160
Right there's George and Martha.

199
00:21:49,160 --> 00:21:52,300
And now we've got to get some kind of manager to look at these types.

200
00:21:55,050 --> 00:22:00,530
How are these things actually going to work now that George and Martha have supplied us with typed data?

201
00:22:00,530 --> 00:22:05,260
Well what we have are a bunch of generic selectors.

202
00:22:05,260 --> 00:22:10,630
Generic selectors for complex numbers real-part, imaginary-part, magnitude, and angle.

203
00:22:14,140 --> 00:22:15,410
Let's look at them more closely.

204
00:22:17,930 --> 00:22:19,310
What does a real-part do?

205
00:22:19,310 --> 00:22:25,800
If I ask for the real part of a complex number, well I look at it.

206
00:22:25,800 --> 00:22:26,690
I look at its type.

207
00:22:26,690 --> 00:22:27,940
I say, is it rectangular?

208
00:22:31,020 --> 00:22:38,220
If so, I apply George's real part procedure to the contents of that complex number.

209
00:22:41,230 --> 00:22:43,720
This is a number that has a type on it.

210
00:22:43,720 --> 00:22:47,590
I strip off the type using contents and apply George's procedure.

211
00:22:50,700 --> 00:22:53,950
Or is this a polar complex number?

212
00:22:53,950 --> 00:22:59,850
If I want the real part, I apply Martha's real part procedure to the contents of that number.

213
00:22:59,850 --> 00:23:02,260
So that's how real part works.

214
00:23:02,260 --> 00:23:06,770
And then similarly there's imaginary-part, which is almost the same.

215
00:23:06,770 --> 00:23:11,130
It looks at the number and if it's rectangular, uses George's imaginary-part procedure.

216
00:23:11,130 --> 00:23:13,380
If it's polar, uses Martha's.

217
00:23:13,380 --> 00:23:17,240
And then there's a magnitude and an angle.

218
00:23:19,880 --> 00:23:21,130
So there's a system.

219
00:23:23,460 --> 00:23:24,260
Has three parts.

220
00:23:24,260 --> 00:23:26,760
There's sort of George, and Martha, and the manager.

221
00:23:26,760 --> 00:23:28,970
And that's how you get generic operators implemented.

222
00:23:28,970 --> 00:23:33,500
Let's look at just a simple example, just to pin it down.

223
00:23:33,500 --> 00:23:46,090
But exactly how this is going to work, suppose you're going to be looking at the complex number who's real-part is one, and who's imaginary-part is two.

224
00:23:46,090 --> 00:23:50,310
So that would be one plus 2i.

225
00:23:50,310 --> 00:24:10,320
What would happen is up here, up here above where the operations have to happen, that number would be represented as a pair of 1 and 2 together with typed data.

226
00:24:10,320 --> 00:24:11,870
That would be the contents.

227
00:24:11,870 --> 00:24:17,960
And the whole data would be that thing with the symbol rectangular added onto that.

228
00:24:17,960 --> 00:24:22,330
And that's the way that complex number would exist in the system.

229
00:24:22,330 --> 00:24:30,270
When you went to take the real-part, the manager would look at this and say, oh it's one of George's.

230
00:24:30,270 --> 00:24:37,532
He'll strip off the type and hand down to George the pair 1, 2.

231
00:24:37,532 --> 00:24:42,670
And that's the kind of data that George developed his system to use.

232
00:24:44,950 --> 00:24:46,680
So it gets stripped down.

233
00:24:46,680 --> 00:25:00,880
Later on, if you ask George to construct a complex number, George would construct some complex number as a pair, and before he passes it back up through the manager would attach the type rectangular.

234
00:25:03,920 --> 00:25:04,650
So you see what happens.

235
00:25:04,650 --> 00:25:05,850
There's no confusion in this system.

236
00:25:05,850 --> 00:25:15,750
It doesn't matter in the least that the pair 1, 2 means something completely different in Martha's world.

237
00:25:15,750 --> 00:25:21,190
In Martha's world this pair means the complex number whose magnitude is 1 and whose angle is 2.

238
00:25:21,190 --> 00:25:31,210
And there's no confusion, because by the time any pair like this gets handed back through the manager to the main system it's going to have the type polar attached.

239
00:25:31,210 --> 00:25:33,670
Whereas this one would have the type rectangular attached.

240
00:25:36,930 --> 00:25:38,180
OK, let's take a break.

241
00:25:40,770 --> 00:25:42,307
[MUSIC-- "JESU, JOY OF MAN'S DESIRING" BY JOHANN SEBASTIAN BACH]

242
00:26:20,210 --> 00:26:24,150
We just looked at a strategy for implementing generic operators.

243
00:26:24,150 --> 00:26:31,400
That strategy has a name: it's called dispatch type.

244
00:26:34,310 --> 00:26:39,360
And the idea is that you break your system into a bunch of pieces.

245
00:26:39,360 --> 00:26:46,320
There's George and Martha, who are making representations, and then there's the manager.

246
00:26:46,320 --> 00:26:51,990
Looks at the types on the data and then dispatches them to the right person.

247
00:26:51,990 --> 00:26:56,570
Well what criticisms can we make of that as a system organization?

248
00:26:58,150 --> 00:27:04,220
Well first of all there was this little, annoying problem that George and Martha had to change the names of their procedures.

249
00:27:04,220 --> 00:27:17,310
George originally had a real-part procedure, and he had to go name it real-part rectangular so it wouldn't interfere with Martha's real-part procedure, which is now named real-part-polar, so it wouldn't interfere with the manager's real-part procedure, who's now named real-part.

250
00:27:17,310 --> 00:27:19,460
That's kind of an annoying problem.

251
00:27:19,460 --> 00:27:21,270
But I'm not going to talk about that one now.

252
00:27:21,270 --> 00:27:32,500
We'll see later on when we think about the structure of Lisp names and environments that there really are ways to package all those so-called name spaces separately so they don't interfere with each other.

253
00:27:32,500 --> 00:27:35,720
Not going to think about that problem now.

254
00:27:35,720 --> 00:27:44,510
The problem that I actually want to focus on is what happens when you bring somebody new into the system.

255
00:27:44,510 --> 00:27:45,320
What has to happen?

256
00:27:45,320 --> 00:27:47,690
Well George and Martha don't care.

257
00:27:47,690 --> 00:27:54,090
George is sitting there in his rectangular world, has his procedures and his types.

258
00:27:54,090 --> 00:27:56,260
Martha sits in her polar world.

259
00:27:56,260 --> 00:27:59,380
She doesn't care.

260
00:27:59,380 --> 00:28:01,540
But let's look at the manager.

261
00:28:01,540 --> 00:28:03,180
What's the manager have to do?

262
00:28:03,180 --> 00:28:07,360
The manager comes through and had these operations.

263
00:28:07,360 --> 00:28:10,140
There was a test for rectangular and a test for polar.

264
00:28:10,140 --> 00:28:25,240
If Harry comes in with some new kind of complex number, and Harry has a new type, Harry type complex number, the manager has to go in and change all those procedures.

265
00:28:25,240 --> 00:28:34,890
So the inflexibility in the system, the place where work has to happen to accommodate change, is in the manager.

266
00:28:34,890 --> 00:28:35,990
That's pretty annoying.

267
00:28:35,990 --> 00:28:42,590
It's even more annoying when you realize the manager's not doing anything.

268
00:28:42,590 --> 00:28:46,690
The manager is just being a paper pusher.

269
00:28:46,690 --> 00:28:51,760
Let's look again at these programs. What are they doing?

270
00:28:51,760 --> 00:28:52,880
What does real-part do?

271
00:28:52,880 --> 00:28:57,000
Real-part says, oh, is it the kind of complex number that George can handle?

272
00:28:57,000 --> 00:28:59,410
If so, send it off to George.

273
00:28:59,410 --> 00:29:01,910
Is it the kind of complex number that Martha can handle?

274
00:29:01,910 --> 00:29:05,040
If so, send it off to Martha.

275
00:29:05,040 --> 00:29:15,000
So it's really annoying that the bottleneck in this system, the thing that's preventing flexibility and change, is completely in the bureaucracy.

276
00:29:15,000 --> 00:29:19,700
It's not in anybody who's doing any of the work.

277
00:29:19,700 --> 00:29:23,300
Not an uncommon situation, unfortunately.

278
00:29:23,300 --> 00:29:28,100
See, what's really going on-- abstractly in the system, there's a table.

279
00:29:28,100 --> 00:29:30,150
So what's really happening is somewhere there's a table.

280
00:29:32,780 --> 00:29:34,400
There're types.

281
00:29:34,400 --> 00:29:38,565
There's polar and rectangular.

282
00:29:41,550 --> 00:29:44,380
And Harry's may be over here.

283
00:29:44,380 --> 00:29:48,050
And there are operators.

284
00:29:48,050 --> 00:29:50,340
There's an operator like real-part.

285
00:29:55,600 --> 00:30:00,010
Or imaginary-part.

286
00:30:00,010 --> 00:30:05,830
Or a magnitude and angle.

287
00:30:05,830 --> 00:30:19,280
And sitting in this table are the right procedures.

288
00:30:19,280 --> 00:30:24,730
So sitting here for the type polar and real-part is Martha's procedure real-part-polar.

289
00:30:30,570 --> 00:30:34,990
And over here in the table is George's procedure real-part-rectangular.

290
00:30:37,740 --> 00:30:49,760
And over here would be, say, Martha's procedure magnitude-polar, and George's procedure magnitude-rectangular, right, and so on.

291
00:30:49,760 --> 00:30:52,390
The rest of this table's filled in.

292
00:30:52,390 --> 00:30:54,260
And that's really what's going on.

293
00:30:57,630 --> 00:31:04,630
So in some sense, all the manager is doing is acting as this table.

294
00:31:06,860 --> 00:31:08,610
Well how do we fix our system?

295
00:31:12,110 --> 00:31:13,770
How do you fix bureaucracies a lot of the time?

296
00:31:13,770 --> 00:31:16,240
What you do is you get rid of the manager.

297
00:31:16,240 --> 00:31:20,170
We just take the manager and replace him by a computer.

298
00:31:20,170 --> 00:31:23,320
We're going to automate him out of existence.

299
00:31:23,320 --> 00:31:31,020
Namely, instead of having the manager who basically consults this table, we'll have our system use the table directly.

300
00:31:31,020 --> 00:31:32,110
What do I mean by that?

301
00:31:32,110 --> 00:31:40,880
Let's assume, again using data abstraction, that we have some kind of data structure that's a table.

302
00:31:40,880 --> 00:31:44,356
And we have ways of sticking things in and ways of getting things out.

303
00:31:44,356 --> 00:32:00,130
And to be explicit, let me assume that there's an operation called "put." And put is going to take, in this case two things I'll call "keys." Key1 and key2.

304
00:32:00,130 --> 00:32:01,380
And a value.

305
00:32:06,200 --> 00:32:11,490
And that stores the value in the table under key1 and key2.

306
00:32:11,490 --> 00:32:26,730
And then we'll assume there's a thing called "get," such that if later on I say, get me what's in the table stored under key1 and key2, it'll retrieve whatever value was stored there.

307
00:32:26,730 --> 00:32:30,000
And let's not worry about how tables are implemented.

308
00:32:30,000 --> 00:32:33,060
That's yet another data abstraction, George's problem.

309
00:32:33,060 --> 00:32:36,970
And maybe we'll see later-- talk about how you might actually build tables in Lisp.

310
00:32:40,710 --> 00:32:47,380
Well given this organization, what did George and Martha have to do?

311
00:32:47,380 --> 00:32:55,210
Well when they build their system, they each have the responsibility to set up their appropriate column in the table.

312
00:32:55,210 --> 00:33:06,990
So what George does, for example, when he defines his procedures, all he has to do is go off and put into the table under the type-rectangular.

313
00:33:09,820 --> 00:33:16,250
And the name of the operation is real-part, his procedure real-part-rectangular.

314
00:33:16,250 --> 00:33:17,780
So notice what's going into this table.

315
00:33:17,780 --> 00:33:22,100
The two keys here are symbols, rectangular and real-part.

316
00:33:22,100 --> 00:33:24,400
That's the quote.

317
00:33:24,400 --> 00:33:28,870
And what's going into the table is the actual procedure that he wrote, real-part rectangular.

318
00:33:32,040 --> 00:33:45,270
And then puts an imaginary part into the table, filed under the keys rectangular- and imaginary-part, and magnitude under the keys rectangular magnitude, angle under rectangular-angle.

319
00:33:47,350 --> 00:33:50,840
So that's what George has to do to be part of this system.

320
00:33:54,420 --> 00:33:59,430
Martha similarly sets up the column and the table under polar.

321
00:33:59,430 --> 00:34:02,160
Polar and real-part.

322
00:34:02,160 --> 00:34:04,340
Is the procedure real-part-polar?

323
00:34:04,340 --> 00:34:09,030
And imaginary-part, and magnitude, and angle.

324
00:34:09,030 --> 00:34:11,409
So this is what Martha has to do to be part of the system.

325
00:34:11,409 --> 00:34:17,840
Everyone who makes a representation has the responsibility for setting up a column in the table.

326
00:34:17,840 --> 00:34:21,800
And what does Harry do when Harry comes in with his brilliant idea for implementing complex numbers?

327
00:34:21,800 --> 00:34:28,550
Well he makes whatever procedure he wants and builds a new column in this table.

328
00:34:28,550 --> 00:34:31,330
OK, well what happened to the manager?

329
00:34:31,330 --> 00:34:37,110
The manager has been automated out of existence and is replaced by a procedure called operate.

330
00:34:37,110 --> 00:34:40,380
And this is the key procedure in the whole system.

331
00:34:40,380 --> 00:34:45,920
Let's say define operate.

332
00:34:51,060 --> 00:35:04,210
Operate is going to take an operation that you want to do, the name of an operation, and an object that you would like to apply that operation to.

333
00:35:04,210 --> 00:35:09,890
So for example, the real-part of some particular complex number, what does it do?

334
00:35:09,890 --> 00:35:12,650
Well the first thing it does, it looks in the table.

335
00:35:12,650 --> 00:35:23,320
Goes into the table and tries to find a procedure that's stored in the table.

336
00:35:23,320 --> 00:35:44,440
So it gets from the table, using as keys the type of the object and the operator, but looks on the table and sees what's stored under the type of the object and the operator, sees if anything's stored.

337
00:35:44,440 --> 00:35:45,930
Let's assume that get is implemented.

338
00:35:45,930 --> 00:35:52,560
So if nothing is stored there, it'll return the empty list.

339
00:35:52,560 --> 00:36:15,120
So it says, if there's actually something stored there, if the procedure here is not no, then it'll take the procedure that it found in the table and apply it to the contents of the object.

340
00:36:18,042 --> 00:36:22,435
And otherwise if there was nothing stored there, it'll-- well we can decide.

341
00:36:22,435 --> 00:36:28,650
In this case let's have it put out an error message saying, undefined operator.

342
00:36:28,650 --> 00:36:30,230
No operator for this type.

343
00:36:32,770 --> 00:36:34,285
Or some appropriate error message.

344
00:36:39,150 --> 00:36:39,300
OK?

345
00:36:39,300 --> 00:36:41,890
And that replaces the manager.

346
00:36:41,890 --> 00:36:43,960
How do we really use it?

347
00:36:43,960 --> 00:36:50,040
Well what we say is we'll go off and define our generic selectors using operate.

348
00:36:50,040 --> 00:37:06,260
We'll say that the real-part of an object is found by operating on the object with the name of the operation being real-part.

349
00:37:08,070 --> 00:37:16,080
And then similarly, imaginary-part is operate using the name imaginary-part and magnitude and angle.

350
00:37:16,080 --> 00:37:17,430
That's our implementation.

351
00:37:17,430 --> 00:37:21,330
That plus the tape plus the operate procedure.

352
00:37:21,330 --> 00:37:24,150
And the table effectively replaces what the manager used to do.

353
00:37:24,150 --> 00:37:27,900
Let's just go through that slowly to show you what's going on.

354
00:37:27,900 --> 00:37:33,000
Suppose I have one of Martha's complex numbers.

355
00:37:35,520 --> 00:37:39,100
It's got magnitude 1 and angle 2.

356
00:37:39,100 --> 00:37:40,220
And it's one of Martha's.

357
00:37:40,220 --> 00:37:47,120
So it's labeled here, polar.

358
00:37:47,120 --> 00:37:48,000
Let's call that z.

359
00:37:48,000 --> 00:37:49,250
Suppose that's z.

360
00:37:51,770 --> 00:37:57,110
And suppose with this implementation someone comes up and asks for the real-part of z.

361
00:38:04,870 --> 00:38:08,920
Well real-part now is defined in terms of operate.

362
00:38:08,920 --> 00:38:27,060
So that's equivalent to saying operate with the name of the operator being real-part, the symbol real-part on z.

363
00:38:27,060 --> 00:38:28,090
And now operate comes.

364
00:38:28,090 --> 00:38:46,225
It's going to look in the table, and it's going to try and find something stored under--  the operation is going to apply by looking in the table under the type of the object.

365
00:38:46,225 --> 00:38:48,790
And the type of z is polar.

366
00:38:48,790 --> 00:38:52,990
So it's going to look and say, can I get using polar?

367
00:38:52,990 --> 00:38:58,250
And the operation name, which was real-part.

368
00:39:05,960 --> 00:39:14,930
It's going to look in there and apply that to the contents of z.

369
00:39:14,930 --> 00:39:15,650
And that?

370
00:39:15,650 --> 00:39:21,700
If everything was set up correctly, this thing is the procedure that Martha put there.

371
00:39:21,700 --> 00:39:22,950
This is real-part-polar.

372
00:39:30,790 --> 00:39:35,130
And this is z without its type.

373
00:39:35,130 --> 00:39:40,340
The thing that Martha originally designed those procedures to work on, which is 1, 2.

374
00:39:43,790 --> 00:39:49,450
And so operate sort of does uniformly what the manager used to do sort of all over the system.

375
00:39:49,450 --> 00:39:59,160
It finds the right thing, looks in the table, strips off the type, and passes it down into the person who handles it.

376
00:39:59,160 --> 00:40:07,990
This is another, and, you can see, more flexible for most purposes, way of implementing generic operators.

377
00:40:07,990 --> 00:40:15,505
And it's called data-directed programming.

378
00:40:20,350 --> 00:40:35,390
And the idea of that is in some sense the data objects themselves, those little complex numbers that are floating around the system, are carrying with them the information about how you should operate on them.

379
00:40:35,390 --> 00:40:36,640
Let's break for questions.

380
00:40:41,000 --> 00:40:41,240
Yes.

381
00:40:41,240 --> 00:40:43,390
AUDIENCE: What do you have stored in that data object?

382
00:40:43,390 --> 00:40:49,690
You have the data itself, you have its type, and you have the operations for that type?

383
00:40:49,690 --> 00:40:53,600
Or where are the operations that you found?

384
00:40:53,600 --> 00:40:56,500
PROFESSOR: OK, let me-- yeah, that's a good question.

385
00:40:56,500 --> 00:41:00,750
Because it raises other possibilities of how you might do it.

386
00:41:00,750 --> 00:41:04,200
And of course there are a lot of possibilities.

387
00:41:04,200 --> 00:41:16,550
In this particular implementation, what's sitting in this data object, for example, is the data itself-- which in this case is a pair of 1 and 2-- and also a symbol.

388
00:41:16,550 --> 00:41:22,390
This is the symbol, the word P-O-L-A-R, and that's what's sitting in this data object.

389
00:41:24,870 --> 00:41:26,690
Where are the operations themselves?

390
00:41:26,690 --> 00:41:29,850
The operations are sitting in the table.

391
00:41:29,850 --> 00:41:38,230
So in this table, the rows and columns of the table are labeled by symbols.

392
00:41:38,230 --> 00:41:48,240
So when I store something in this table, the key might be the symbol polar and the symbol magnitude.

393
00:41:48,240 --> 00:41:51,310
And I think by writing it this way I've been very confusing.

394
00:41:51,310 --> 00:41:59,850
Because what's really sitting here isn't-- when I wrote magnitude polar, what I mean is the procedure magnitude polar.

395
00:41:59,850 --> 00:42:14,710
And probably what I really should have written-- except it's too small for me to write in this little space-- is something like lambda of z, the thing that Martha wrote to implement.

396
00:42:14,710 --> 00:42:23,150
And then you can see from that, there's another way that I alluded to of solving this name conflict problem, which is that George and Martha never have to name their procedures at all.

397
00:42:23,150 --> 00:42:28,660
They can just stick the anonymous things generated by lambda directly into the table.

398
00:42:28,660 --> 00:42:43,520
There's also another thing that your question raises, is the possibility that maybe what I would like somehow is to store in this data object not the symbol P-O-L-A-R but maybe actually all the operations themselves.

399
00:42:43,520 --> 00:42:48,650
And that's another way to organize the system, called message passing.

400
00:42:48,650 --> 00:42:49,970
So there are a lot of ways you can do it.

401
00:42:54,640 --> 00:43:02,560
AUDIENCE: Therefore if Martha and George had used the same procedure names, it would be OK because it wouldn't look [UNINTELLIGIBLE].

402
00:43:02,560 --> 00:43:03,010
PROFESSOR: That's right.

403
00:43:03,010 --> 00:43:04,890
That's right.

404
00:43:04,890 --> 00:43:09,470
See, they wouldn't even have to name their procedures at all.

405
00:43:09,470 --> 00:43:24,540
What George could have written instead of saying put in the table under rectangular- and real-part, the procedure real-part rectangular, George could have written put under rectangular real-part, lambda of z, such and such, and such and such.

406
00:43:24,540 --> 00:43:27,330
And the system would work completely the same.

407
00:43:27,330 --> 00:43:41,290
AUDIENCE: My question is, Martha could have put key1 key2 real-part, and George could have put key1 key2 real-part, and as long as they defined them differently they wouldn't have had any conflicts, right?

408
00:43:41,290 --> 00:43:52,800
PROFESSOR: Yes, that would all be OK except for the fact that if you imagine George and Martha typing at the same console with the same meanings for all their names, and it would get confused by real-part, but there are ways to arrange that, too.

409
00:43:52,800 --> 00:43:54,980
And in principle you're absolutely right.

410
00:43:54,980 --> 00:43:58,190
If their names didn't conflict-- it's the objects that go in the table, not the names.

411
00:44:08,200 --> 00:44:09,450
OK, let's take a break.

412
00:44:12,493 --> 00:44:14,086
[MUSIC-- "JESU, JOY OF MAN'S DESIRING" BY JOHANN SEBASTIAN BACH]

413
00:45:12,880 --> 00:45:22,840
All right, well we just looked at data-directed programming as a way of implementing a system that does arithmetic on complex numbers.

414
00:45:27,420 --> 00:45:38,230
So I had these operations in it called plus C and minus C, and multiply, and divide, and maybe some others.

415
00:45:38,230 --> 00:45:50,340
And that sat on top of-- and this is the key point-- sat on top of two different representations.

416
00:45:50,340 --> 00:45:55,110
A rectangular package here, and a polar package.

417
00:45:58,240 --> 00:45:59,150
And maybe some more.

418
00:45:59,150 --> 00:46:04,670
And we saw that the whole idea is that maybe some more are now very easy to add.

419
00:46:04,670 --> 00:46:08,900
But that doesn't really show the power of this methodology.

420
00:46:08,900 --> 00:46:10,150
Shows you what's going on.

421
00:46:10,150 --> 00:46:17,080
The power of the methodology only becomes apparent when you start embedding this in some more complex system.

422
00:46:17,080 --> 00:46:20,250
What I'm going to do now is embed this in some more complex system.

423
00:46:20,250 --> 00:46:25,280
Let's assume that what we really have is a general kind of arithmetic system.

424
00:46:25,280 --> 00:46:27,240
So called generic arithmetic system.

425
00:46:27,240 --> 00:46:41,180
And at the top level here, somebody can say add two things, or subtract two things, or multiply two things, or divide two things.

426
00:46:44,140 --> 00:46:47,930
And underneath that there's an abstraction barrier.

427
00:46:47,930 --> 00:46:52,850
And underneath this barrier, is, say, a complex arithmetic package.

428
00:46:52,850 --> 00:46:55,110
And you can say, add two complex numbers.

429
00:46:55,110 --> 00:47:00,190
Or you might also have-- remember we did a rational number package-- you might have that sitting there.

430
00:47:00,190 --> 00:47:03,950
And there might be a rational thing.

431
00:47:03,950 --> 00:47:08,320
And the rational number package, well, has the things we implemented.

432
00:47:08,320 --> 00:47:15,490
Plus rat, and times rat, and so on.

433
00:47:15,490 --> 00:47:17,010
Or you might have ordinary Lisp numbers.

434
00:47:17,010 --> 00:47:19,310
You might say add three and four.

435
00:47:19,310 --> 00:47:36,670
So we might have ordinary numbers, in which case we have the Lisp supplied plus, and minus, and times, and slash.

436
00:47:36,670 --> 00:47:44,910
OK, so we might imagine this complex number system sitting in a more complicated generic operator structure at the next level up.

437
00:47:47,730 --> 00:47:49,050
Well how can we make that?

438
00:47:49,050 --> 00:47:52,780
We already have the idea, we're just going to do it again.

439
00:47:52,780 --> 00:47:54,720
We've implemented a rational number package.

440
00:47:54,720 --> 00:47:56,650
Let's look at how it has to be changed.

441
00:48:01,590 --> 00:48:03,730
In fact, at this level it doesn't have to be changed at all.

442
00:48:03,730 --> 00:48:07,180
This is exactly the code that we wrote last time.

443
00:48:07,180 --> 00:48:11,140
To add two rational numbers, remember there was this formula.

444
00:48:11,140 --> 00:48:21,520
You make a rational number whose numerator-- the numerator of the first times the denominator of the second, plus the denominator of the first times the numerator of the second.

445
00:48:21,520 --> 00:48:25,760
And who's denominator is the product of the denominators.

446
00:48:25,760 --> 00:48:30,580
And minus rat, and star rat, and slash rat.

447
00:48:30,580 --> 00:48:36,310
And this is exactly the rational number package that we made before.

448
00:48:36,310 --> 00:48:40,240
We're ignoring the GCD problem, but let's not worry about that.

449
00:48:40,240 --> 00:48:45,570
As implementers of this rational number package, how do we install it in the generic arithmetic system?

450
00:48:45,570 --> 00:48:46,820
Well that's easy.

451
00:48:48,980 --> 00:48:51,840
There's only one thing we have to do differently.

452
00:48:51,840 --> 00:49:03,300
Whereas previously we said that to make a rational number you built a pair of the numerator and denominator, here we'll not only build the pair, but we'll sign it.

453
00:49:03,300 --> 00:49:06,120
We'll attach the type rational.

454
00:49:06,120 --> 00:49:12,380
That's the only thing we have to do different, make it a typed data object.

455
00:49:12,380 --> 00:49:14,500
And now we'll stick our operations in the table.

456
00:49:14,500 --> 00:49:21,820
We'll put under the symbol rational and the operation add our procedure, plus rat.

457
00:49:21,820 --> 00:49:23,580
And, again, note this is a symbol.

458
00:49:23,580 --> 00:49:23,930
Right?

459
00:49:23,930 --> 00:49:30,060
Quote, unquote, but the actual thing we're putting in the table is the procedure.

460
00:49:30,060 --> 00:49:38,270
And for how to subtract, well you subtract rationals with minus rat.

461
00:49:38,270 --> 00:49:41,090
And multiply, and divide.

462
00:49:41,090 --> 00:49:48,510
And that is exactly and precisely what we have to do to fit inside this generic arithmetic system.

463
00:49:48,510 --> 00:49:51,560
Well how does the whole thing work?

464
00:49:51,560 --> 00:50:00,170
See, what we want to do is have some generic operators.

465
00:50:00,170 --> 00:50:01,720
Have add and sub and [UNINTELLIGIBLE]

466
00:50:01,720 --> 00:50:03,990
be generic operators.

467
00:50:03,990 --> 00:50:27,490
So we're going to define add and say, to add x and y, that will be operate--  we were going to call it operate-2.

468
00:50:27,490 --> 00:50:37,261
This is our operator procedure, but set up for two arguments using add on x and y.

469
00:50:37,261 --> 00:50:40,420
And so this is the analog to operate.

470
00:50:40,420 --> 00:50:41,680
Let's look at the code for second.

471
00:50:41,680 --> 00:50:42,930
It's almost like operate.

472
00:50:46,040 --> 00:51:01,900
To operate with some operator on an argument 1 and an argument 2, well the first thing we're going to do is check and see if the two arguments have the same type.

473
00:51:01,900 --> 00:51:07,860
So we'll say, is the type of the first argument the same as the type of the second argument?

474
00:51:10,350 --> 00:51:15,670
And if they're not, we'll go off and complain, and say, that's an error.

475
00:51:15,670 --> 00:51:19,140
We don't know how to do that.

476
00:51:19,140 --> 00:51:22,080
If they do have the same type, we'll do exactly what we did before.

477
00:51:22,080 --> 00:51:30,420
We'll go look and filed under the type of the argument-- arg 1 and arg 2 have the same type, so it doesn't matter.

478
00:51:30,420 --> 00:51:33,640
So we'll look in the table, find the procedure.

479
00:51:33,640 --> 00:51:43,030
If there is a procedure there, then we'll apply it to the contents of the argument 1 and the contents of arg 2.

480
00:51:43,030 --> 00:51:44,760
And otherwise we'll say, error.

481
00:51:44,760 --> 00:51:46,890
Undefined operator.

482
00:51:46,890 --> 00:51:48,140
And so there's operate-2.

483
00:51:51,326 --> 00:51:55,160
And that's all we have to do.

484
00:51:55,160 --> 00:51:57,640
We just built the complex number package before.

485
00:51:57,640 --> 00:52:02,140
How do we embed that complex number package in this generic system?

486
00:52:02,140 --> 00:52:03,390
Almost the same.

487
00:52:06,410 --> 00:52:15,350
We make a procedure called make-complex that takes whatever George and Martha hand to us and add the type-complex.

488
00:52:18,170 --> 00:52:33,490
And then we say, to add complex numbers, plus complex, we use our internal procedure, plus c, and attach a type, make that a complex number.

489
00:52:37,560 --> 00:52:45,250
So our original package had names plus c and minus c that we're using to communicate with George and Martha.

490
00:52:45,250 --> 00:52:52,380
And then to communicate with the outside world, we have a thing called plus-complex and minus-complex.

491
00:52:55,920 --> 00:52:56,530
And so on.

492
00:52:56,530 --> 00:53:01,120
And the only difference is that these return values that are tight.

493
00:53:01,120 --> 00:53:02,850
So they can be looked at up here.

494
00:53:02,850 --> 00:53:04,690
And these are internal operations.

495
00:53:09,250 --> 00:53:10,680
Let's go look at that slide again.

496
00:53:10,680 --> 00:53:13,740
There's one more thing we do.

497
00:53:13,740 --> 00:53:23,200
After defining plus-complex, we put under the type complex and the symbol add, that procedure plus complex.

498
00:53:23,200 --> 00:53:29,130
And then similarly for subtracting complex numbers, and multiplying them, and dividing them.

499
00:53:31,700 --> 00:53:35,250
OK, how do we install ordinary numbers?

500
00:53:35,250 --> 00:53:38,160
Exactly the same way.

501
00:53:38,160 --> 00:53:41,750
Come off and say, well we'll make a thing called make-number.

502
00:53:44,340 --> 00:53:50,260
Make-number takes a number and attaches a type, which is the symbol number.

503
00:53:50,260 --> 00:54:04,510
We build a procedure called plus-number, which is simply, add the two things using the ordinary addition, because in this case we're talking about ordinary numbers, and attach a type to it and make that a number.

504
00:54:04,510 --> 00:54:16,610
And then we put into the table under the symbol number and the operation add, this procedure plus-number, and then the same thing for subtracting, and multiplying, and dividing.

505
00:54:22,750 --> 00:54:26,060
Let's look at an example, just to make it clear.

506
00:54:26,060 --> 00:54:34,150
Suppose, for instance, I'm going to perform the operation.

507
00:54:34,150 --> 00:54:40,930
So I sit up here and I'm going to perform the operation, which looks like multiplying two complex numbers.

508
00:54:40,930 --> 00:54:49,786
So I would multiply, say, 3 plus 4i and 2 plus 6i.

509
00:54:49,786 --> 00:54:52,840
And that's something that I might want to take hand that to mul.

510
00:54:52,840 --> 00:54:57,170
I'll write mul as my generic operator here.

511
00:54:57,170 --> 00:54:58,280
How's that going to work?

512
00:54:58,280 --> 00:55:06,250
Well 3 plus 4i, say, sits in the system at this level as something that looks like this.

513
00:55:06,250 --> 00:55:08,280
Let's say it was one of George's.

514
00:55:08,280 --> 00:55:14,695
So it would have a 3 and a 4.

515
00:55:18,490 --> 00:55:29,510
And attached to that would be George's type, which would say rectangular, it came from George.

516
00:55:29,510 --> 00:55:42,280
And attached to that-- and this itself would be the data view from the next level up, which it is-- so that itself would be a type-data object which would say complex.

517
00:55:44,820 --> 00:55:55,560
So that's what this object would look like up here at the very highest level, where the really super-generic operations are looking at it.

518
00:55:55,560 --> 00:56:00,400
Now what happens, mul eventually's going to come along and say, oh, what's it's type?

519
00:56:00,400 --> 00:56:01,650
It's type is complex.

520
00:56:04,270 --> 00:56:17,950
Go through to operate-2 and say, oh, what I want to do is apply what's in the table, which is going to be the procedure star complex, on this thing with the type stripped off.

521
00:56:17,950 --> 00:56:26,288
So it's going to strip off the type, take that much, and send that down into the complex world.

522
00:56:26,288 --> 00:56:31,280
The complex world looks at its operations and says, oh, I have to apply star c.

523
00:56:31,280 --> 00:56:39,420
Star c might say, oh, at some point I want to look at the magnitude of this object that it's in, that it's got.

524
00:56:39,420 --> 00:56:41,870
And they'll say, oh, it's rectangular, it's one of George's.

525
00:56:41,870 --> 00:56:52,160
So it'll then strip off the next version of type, and hand that down to George to take the magnitude of.

526
00:56:52,160 --> 00:56:59,320
So you see what's going on is that there are these chains of types.

527
00:56:59,320 --> 00:57:05,090
And the length of the chain is sort of the number of levels that you're going to be going up in this table.

528
00:57:05,090 --> 00:57:17,440
And what a type tells you, every time you have a vertical barrier in this table, where there's some ambiguity about where you should go down to the next level, the type is telling you where to go.

529
00:57:17,440 --> 00:57:22,810
And then everybody at the bottom, as they construct data and filter it up, they stick their type back on.

530
00:57:25,350 --> 00:57:30,750
So that's the general structure of the system.

531
00:57:33,410 --> 00:57:34,820
OK.

532
00:57:34,820 --> 00:57:39,910
Now that we've got this, let's go and make this thing even more complex.

533
00:57:41,890 --> 00:57:51,510
Let's talk about adding to the system not only these kinds of numbers, but it's also meaningful to start talking about adding polynomials.

534
00:57:51,510 --> 00:57:53,360
Might do arithmetic on polynomials.

535
00:57:53,360 --> 00:58:04,480
Like we could have x to the fifteenth plus 2x to the seventh plus 5.

536
00:58:04,480 --> 00:58:06,380
That might be some polynomial.

537
00:58:06,380 --> 00:58:10,530
And if we have two such gadgets we can add them or multiply them.

538
00:58:10,530 --> 00:58:12,140
Let's not worry about dividing them.

539
00:58:12,140 --> 00:58:15,870
Just add them, multiply them, then we'll subtract them.

540
00:58:15,870 --> 00:58:16,660
What do we have to do?

541
00:58:16,660 --> 00:58:21,830
Well let's think about how we might represent a polynomial.

542
00:58:21,830 --> 00:58:24,950
It's going to be some typed data object.

543
00:58:24,950 --> 00:58:32,000
So let's say a polynomial to this system might look like a thing that starts with the type polynomial.

544
00:58:32,000 --> 00:58:34,550
And then maybe it says the next thing is what variable its in.

545
00:58:34,550 --> 00:58:38,960
So I might say I'm a polynomial in the variable x.

546
00:58:38,960 --> 00:58:42,250
And then it'll have some information about what the terms are.

547
00:58:42,250 --> 00:58:56,360
And there're just tons of ways to do this, but one way is to say we're going to have a thing called a term-list. And a term-list-- well, in our case we'll use something that looks like this.

548
00:58:56,360 --> 00:58:59,690
We'll make it a bunch of pairs which have an order in a coefficient.

549
00:58:59,690 --> 00:59:09,070
So this polynomial would be represented by this term-list.

550
00:59:09,070 --> 00:59:19,710
And what that means is that this polynomial starts off with a term of order 15 and coefficient 1.

551
00:59:23,820 --> 00:59:31,450
And the next thing in it is a term of order 7 and coefficient 2, a term of order 0, which is constant in coefficient 5.

552
00:59:31,450 --> 00:59:41,730
And there are lots and lots of ways, and lots and lots of trade-offs when you really think about making algebraic manipulation packages about exactly how you should represent these things.

553
00:59:41,730 --> 00:59:44,180
But this is a fairly standard one.

554
00:59:44,180 --> 00:59:47,770
It's useful in a lot of contexts.

555
00:59:47,770 --> 00:59:50,815
OK, well how do we implement our polynomial arithmetic?

556
00:59:54,270 --> 00:59:55,520
Let's start out.

557
00:59:57,950 --> 01:00:05,690
What we'll do to make a polynomial-- we'll first have a way to make polynomials.

558
01:00:05,690 --> 01:00:14,290
We're going to make a polynomial out of variable like x and term-list. And all that does is we'll package them together someway.

559
01:00:14,290 --> 01:00:21,380
We'll put the variable together with the term list using cons, and then attached to that the type polynomial.

560
01:00:26,270 --> 01:00:29,280
OK, how do we add two polynomials?

561
01:00:29,280 --> 01:00:37,380
To add a polynomial, p1 and p2, and then just for simplicity let's say we will only add things in the same variable.

562
01:00:37,380 --> 01:00:45,150
So if they have the same variable, and same variable here is going to be some selector we write, whose details we don't care about.

563
01:00:45,150 --> 01:00:48,810
If the two polynomials have the same variable, then we'll do something.

564
01:00:48,810 --> 01:00:55,480
If they don't have the same variable, we'll give an error, polynomials not in the same variable.

565
01:00:55,480 --> 01:01:10,170
And if they do have the same variable, what we'll do is we'll make a polynomial whose variable is whatever that variable is, and whose term-list is something we'll call sum-terms. Plus terms will add the two term lists.

566
01:01:10,170 --> 01:01:13,500
So we'll add the two term lists to the polynomial.

567
01:01:13,500 --> 01:01:22,550
That'll give us a term-list. We'll add on, we'll say it's a polynomial in the variable with that term-list. That's plus poly.

568
01:01:22,550 --> 01:01:30,520
And then we're going to put in our table under the type polynomial, add them using plus poly.

569
01:01:30,520 --> 01:01:31,750
And of course we really haven't done much.

570
01:01:31,750 --> 01:01:38,480
What we've really done is pushed all the work onto this thing, plus-terms, which is supposed to add term-lists.

571
01:01:38,480 --> 01:01:40,920
Let's look at that.

572
01:01:40,920 --> 01:01:48,900
Here's an overview of how we might add two term-lists.

573
01:01:48,900 --> 01:01:51,860
So L1 and L2 were going to be two term-lists.

574
01:01:51,860 --> 01:01:55,700
And a term-list is a bunch of pairs, coefficient in order.

575
01:01:55,700 --> 01:01:56,950
And it's a big case analysis.

576
01:01:59,860 --> 01:02:12,270
And the first thing we'll check for and see if there are any terms. We're going to recursively work down these term-lists, so eventually we'll get to a place where either L1 or L2 might be empty.

577
01:02:12,270 --> 01:02:15,850
And if either one is empty, our answer will be the other one.

578
01:02:15,850 --> 01:02:23,470
So if L1 is empty we'll return L2, and if L2 is empty we'll return L1.

579
01:02:23,470 --> 01:02:27,220
Otherwise there are sort of three interesting cases.

580
01:02:27,220 --> 01:02:37,660
What we're going to do is grab the first term in each of those lists, called t1 and t2.

581
01:02:37,660 --> 01:02:50,470
And we're going to look at three cases, depending on whether the order of t1 is greater than the order of t2, or less than t2, or the same.

582
01:02:53,290 --> 01:02:54,910
Those are the three cases we're going to look at.

583
01:02:54,910 --> 01:02:56,160
Let's look at this case.

584
01:02:58,640 --> 01:03:11,480
If the order of t1 is greater than the order of t2, then what that means is that our answer is going to start with this term of the order of t1.

585
01:03:11,480 --> 01:03:26,880
Because it won't combine with any lower order terms. So what we do is add the lower order terms. We recursively add together all the terms in the rest of the term-list in L1 and L2.

586
01:03:26,880 --> 01:03:30,120
That's going to be the lower order terms of the answer.

587
01:03:30,120 --> 01:03:33,180
And then we're going to adjoin to that the highest order term.

588
01:03:33,180 --> 01:03:41,410
And I'm using here a whole bunch of procedures I haven't defined, like a adjoin-term, and rest-terms, and selectors that get order.

589
01:03:41,410 --> 01:03:44,730
But you can imagine what those are.

590
01:03:44,730 --> 01:03:55,540
So if the first term-list has a higher order than the second, we recursively add all the lower terms and then stick on that last term.

591
01:03:55,540 --> 01:03:56,890
The other case, the same way.

592
01:03:56,890 --> 01:04:11,430
If the first term has a smaller order, well then we add the first term-list and the rest of the terms in the second one, and adjoin on this highest order term.

593
01:04:14,570 --> 01:04:27,240
So so far nothing's much happened, we've just sort of pushed this thing off into adding lower order terms. The last case where you actually get to a coefficients that you have to add, this will be the case where the orders are equal.

594
01:04:27,240 --> 01:04:33,460
What we do is, well again recursively add the lower order terms. But now we have to really combine something.

595
01:04:33,460 --> 01:04:40,820
What we do is we make a term whose order is the order of the term we're looking at.

596
01:04:40,820 --> 01:04:44,320
By now t1 and t2 have the same order.

597
01:04:44,320 --> 01:04:45,090
That's its order.

598
01:04:45,090 --> 01:04:52,230
And its coefficient is gotten by adding the coefficient of t1 and the coefficient of t2.

599
01:04:56,360 --> 01:05:05,900
This is a big recursive working down of terms, but really there's only one interesting symbol in this procedure, only one interesting idea.

600
01:05:05,900 --> 01:05:08,500
The interesting idea is this add.

601
01:05:12,390 --> 01:05:18,220
And the reason that's interesting is because something completely wonderful just happened.

602
01:05:18,220 --> 01:05:28,820
We reduced adding polynomials, not to sort of plus, but to the generic add.

603
01:05:28,820 --> 01:05:43,340
In other words, by implementing it that way, not only do we have our system where we can have rational numbers, or complex numbers, or ordinary numbers, we've just added on polynomials.

604
01:05:48,520 --> 01:05:53,590
But the coefficients of the polynomials can be anything that the system can add.

605
01:05:53,590 --> 01:06:11,250
So these could be polynomials whose coefficients are rational numbers or complex numbers, which in turn could be either rectangular, or polar, or ordinary numbers.

606
01:06:19,860 --> 01:06:40,940
So what I mean precisely is our system right now automatically can handle things like adding together polynomials that have this one: 2/3 of x squared plus 5/17 x plus 11/4.

607
01:06:40,940 --> 01:06:54,160
Or automatically handle polynomials that look like 3 plus 2i times x to the fifth plus 4 plus 7i, or something.

608
01:06:54,160 --> 01:06:56,210
You can automatically handle those things.

609
01:06:56,210 --> 01:06:57,820
Why is that?

610
01:06:57,820 --> 01:07:06,790
That's merely because, or profoundly because we reduced adding polynomials to adding their coefficients.

611
01:07:06,790 --> 01:07:15,170
And adding coefficients was done by the generic add operator, which said, I don't care what your types are as long as I know how to add you.

612
01:07:15,170 --> 01:07:20,880
So automatically for free we get the ability to handle that.

613
01:07:20,880 --> 01:07:34,660
What's even better than that, because remember one of the things we did is we put into the table that the way you add polynomials is using plus poly.

614
01:07:34,660 --> 01:07:39,370
That means that polynomials themselves are things that can be added.

615
01:07:39,370 --> 01:07:42,110
So for instance let me write one here.

616
01:07:45,260 --> 01:07:46,510
Here's a polynomial.

617
01:07:50,560 --> 01:08:04,690
So this gadget here I'm writing up, this is a polynomial in y whose coefficients are polynomials in x.

618
01:08:08,610 --> 01:08:43,670
So you see, simply by saying, polynomials are themselves things that can be added, we can go off and say, well not only can we deal with rationals, or complex, or ordinary numbers, but we can deal with polynomials whose coefficients are rationals, or complex, or ordinary numbers, or polynomials whose coefficients are rationals, or complex, rectangular, polar, or ordinary numbers, or polynomials whose coefficients are rationals, complex, or ordinary numbers.

619
01:08:43,670 --> 01:08:45,950
And so on, and so on, and so on.

620
01:08:45,950 --> 01:08:53,880
So this is sort of an infinite or maybe a recursive tower of types that we've built up.

621
01:08:53,880 --> 01:08:56,420
And it's all exactly from that one little symbol.

622
01:08:56,420 --> 01:09:02,270
A-D-D. Writing "add" instead of "plus" in the polynomial thing.

623
01:09:02,270 --> 01:09:08,740
Slightly different way to think about it is that polynomials are a constructor for types.

624
01:09:08,740 --> 01:09:16,279
Namely you give it a type, like integer, and it returns for you polynomials in x whose coefficients are integers.

625
01:09:16,279 --> 01:09:23,500
And the important thing about that is that the operations on polynomials reduce to the operations on the coefficients.

626
01:09:23,500 --> 01:09:25,840
And there are a lot of things like that.

627
01:09:25,840 --> 01:09:28,870
So for example, let's go back and rational numbers.

628
01:09:28,870 --> 01:09:36,240
We thought about rational numbers as an integer over an integer, but there's the general notion of a rational object.

629
01:09:36,240 --> 01:09:43,010
Like we might think about 3x plus 7 over x squared plus 1.

630
01:09:43,010 --> 01:09:50,310
That's general rational object whose numerator and denominator are polynomials.

631
01:09:50,310 --> 01:09:57,290
And to add two of them we use the same formula, numerator times denominator plus denominator times numerator over product of denominators.

632
01:09:57,290 --> 01:09:59,430
How could we install that in our system?

633
01:09:59,430 --> 01:10:04,250
Well here's our original rational number arithmetic package.

634
01:10:04,250 --> 01:10:16,480
And all we have to do in order to make the entire system continue working with general rational objects, is replace these particular pluses and stars by the generic operator.

635
01:10:16,480 --> 01:10:34,000
So if we simply change that procedure to this one, here we've changed plus and star to add a mul, those are absolutely the only change, then suddenly our entire system can start talking about objects that look like this.

636
01:10:34,000 --> 01:10:47,350
So for example, here is a rational object whose numerator is a polynomial in x whose coefficients are rational numbers.

637
01:10:47,350 --> 01:11:03,390
Or here is a rational object whose numerator is polynomials in x whose coefficients are rational objects constructed out of complex numbers.

638
01:11:03,390 --> 01:11:04,850
And then there are a lot of other things like that.

639
01:11:04,850 --> 01:11:12,310
See, whenever you have a thing where the operations reduce to operations on the pieces, another example would be two by two matrices.

640
01:11:12,310 --> 01:11:18,650
I have the idea, there might be a matrix here of general things that I don't care about.

641
01:11:18,650 --> 01:11:29,030
But if I add two of them, the answer over here is gotten by adding this one and that one, however they like to add.

642
01:11:29,030 --> 01:11:31,110
So I can implement that the same way.

643
01:11:31,110 --> 01:11:35,480
And if I do that, then again suddenly my system can start handling things like this.

644
01:11:35,480 --> 01:11:47,230
So here's a matrix whose elements happen to be-- we'll say this element here is a rational object whose numerator and denominators are polynomials.

645
01:11:47,230 --> 01:11:49,510
And all that comes for free.

646
01:11:52,580 --> 01:11:53,920
What's really going on here?

647
01:11:53,920 --> 01:12:03,120
What's really going on is getting rid of this manager who's sitting there poking his nose into who everybody's business is.

648
01:12:03,120 --> 01:12:05,900
We built a system that has decentralized control.

649
01:12:14,350 --> 01:12:22,440
So when you come into and no one's poking around saying, gee, are you in the official list of people who can be added?

650
01:12:22,440 --> 01:12:27,810
Rather you say, well go off and add yourself how your parts like to be added.

651
01:12:27,810 --> 01:12:36,482
And the result of that is you can get this very, very, very complex hierarchy where a lot of things just get done and rooted to the right place automatically.

652
01:12:36,482 --> 01:12:37,732
Let's stop for questions.

653
01:12:40,380 --> 01:12:43,020
AUDIENCE: You say you get this for free.

654
01:12:43,020 --> 01:12:50,910
One thing that strikes me is that now you've lost kind of the cleanness of the break between what's on top and what's underneath.

655
01:12:50,910 --> 01:12:56,610
In other words, now you're defining some of the lower-level procedures in terms of things above their own line.

656
01:12:56,610 --> 01:13:00,350
Isn't that dangerous?

657
01:13:00,350 --> 01:13:05,440
Or, if nothing more, a little less structured?

658
01:13:05,440 --> 01:13:07,770
PROFESSOR: No, I-- the question is whether that's less structured.

659
01:13:07,770 --> 01:13:08,690
Depends on what you mean by structure.

660
01:13:08,690 --> 01:13:11,050
All this is doing is recursion.

661
01:13:11,050 --> 01:13:18,640
See, it's saying that the way you add these guys is to use that.

662
01:13:18,640 --> 01:13:22,610
And that's not less structured, it's just a recursive structure.

663
01:13:22,610 --> 01:13:24,730
So I don't think it's particularly any less clean.

664
01:13:24,730 --> 01:13:34,480
AUDIENCE: Now when you want to change the multiplier or the add operator, suddenly you've got tremendous consequences underneath that you're not even sure the extent of.

665
01:13:34,480 --> 01:13:37,080
PROFESSOR: That's right, but it depends what you mean.

666
01:13:37,080 --> 01:13:38,470
See, this goes both ways.

667
01:13:41,790 --> 01:13:44,690
What would be a good example?

668
01:13:44,690 --> 01:13:47,500
I ignored greatest common divisor, for instance.

669
01:13:47,500 --> 01:13:50,280
I ignored that problem just to keep the example simple.

670
01:13:50,280 --> 01:14:11,560
But if I suddenly decided that plus rat here should do a GCD computation and install that, then that immediately becomes available to all of these, to that guy, and that guy, and that guy, and all the way down.

671
01:14:11,560 --> 01:14:13,890
So it depends what you mean by the coherence of your system.

672
01:14:13,890 --> 01:14:25,440
It's certainly true that you might want to have a special different one that didn't filter down through the coefficients, but the nice thing about this particular example is that mostly you do.

673
01:14:25,440 --> 01:14:41,590
AUDIENCE: Isn't that the problem, I think, that you're getting to tied in with the fact that the structuring, the recursiveness of that structuring there is actually in execution as opposed to just definition of the actual types themselves?

674
01:14:44,680 --> 01:14:46,120
PROFESSOR: I think I understand the question.

675
01:14:46,120 --> 01:14:50,400
The point is that these types evolve and get more and more complex as the thing's actually running.

676
01:14:50,400 --> 01:14:50,990
Is that what-- AUDIENCE: Yes.

677
01:14:50,990 --> 01:14:51,790
As it's running.

678
01:14:51,790 --> 01:14:51,956
PROFESSOR: --what you're saying?

679
01:14:51,956 --> 01:14:54,180
Yes, the point is-- AUDIENCE: As opposed to the basic definitions.

680
01:14:54,180 --> 01:14:54,830
PROFESSOR: Right.

681
01:14:54,830 --> 01:14:57,210
The type structure is sort of recursive.

682
01:14:57,210 --> 01:15:04,850
It's not that you can make this finite list of the actual things they might look like before the system runs.

683
01:15:04,850 --> 01:15:06,780
It's something that evolves.

684
01:15:06,780 --> 01:15:13,670
So if you want to specify that system, you have to do in some other way than by this finite list. You have to do it by a recursive structure.

685
01:15:13,670 --> 01:15:17,900
AUDIENCE: Because the basic structure of the types is pretty clean and simple.

686
01:15:17,900 --> 01:15:20,125
PROFESSOR: Right.

687
01:15:20,125 --> 01:15:21,460
Yes?

688
01:15:21,460 --> 01:15:22,870
AUDIENCE: I have a question.

689
01:15:22,870 --> 01:15:30,640
I understand once you have your data structure set up, how it pulls off complex and passes that down, and then pulls off rect, passes that down.

690
01:15:30,640 --> 01:15:38,390
But if you're just a user and you don't know anything about rect or polar or whatever, how do you initially set up that data structure so that everything goes to the right spot?

691
01:15:38,390 --> 01:15:43,640
If I just have the equation over there on the left and I just want to add, multiply complex numbers-- PROFESSOR: Well that's the wonderful thing.

692
01:15:43,640 --> 01:15:50,280
If you're just a user you say "mul." AUDIENCE: And it figures out that I mean complex numbers?

693
01:15:50,280 --> 01:15:53,050
Or how do I tell it that I want-- PROFESSOR: Well you're going to have in your hands complex numbers.

694
01:15:53,050 --> 01:15:58,370
See what you would have at some level, as a real user, is a constructor for complex numbers.

695
01:15:58,370 --> 01:15:59,470
AUDIENCE: So then I have to make complex numbers?

696
01:15:59,470 --> 01:16:00,350
PROFESSOR: So you have to make them.

697
01:16:00,350 --> 01:16:11,590
What you would probably have as a user is some little thing in the reader loop, which would give you some plausible way to type in a complex number, in whatever format you like.

698
01:16:11,590 --> 01:16:14,360
Or it might be that you're never typing them in.

699
01:16:14,360 --> 01:16:16,170
Someone's just handing you a complex number.

700
01:16:16,170 --> 01:16:21,960
AUDIENCE: OK, so if I had a complex number that had a polynomial in it, I'd have to make my polynomial and then make my complex number.

701
01:16:21,960 --> 01:16:24,220
PROFESSOR: Right if you wanted it constructed from scratch.

702
01:16:24,220 --> 01:16:25,710
At some point you construct them from scratch.

703
01:16:25,710 --> 01:16:32,345
But what you don't have to know of that is when you have the object you can just say "mul." And it'll multiply.

704
01:16:32,345 --> 01:16:33,279
Yeah?

705
01:16:33,279 --> 01:16:52,270
AUDIENCE: I think the question that was being posed here is, say if I want to change my presentation of complexes, or some operation of complex, how much real code I will have to gets around with, or change to change it in one specific operation?

706
01:16:52,270 --> 01:16:53,490
PROFESSOR: [UNINTELLIGIBLE] what you have to change.

707
01:16:53,490 --> 01:16:56,070
And the point is that you only have to change what you're changing.

708
01:16:56,070 --> 01:17:04,040
See if Martha decides that she would rather-- let's see something silly-- like change the order in the pair.

709
01:17:04,040 --> 01:17:10,970
Like angle and magnitude in the other order, she just makes that change locally.

710
01:17:10,970 --> 01:17:14,790
And the whole thing will propagate through the system in the right way.

711
01:17:14,790 --> 01:17:19,700
Or if suddenly you said, gee, I have another representation for rationals.

712
01:17:19,700 --> 01:17:24,820
And I'm going to stick it here, by filing those operations in the table.

713
01:17:24,820 --> 01:17:32,970
Then suddenly all of these polynomials whose coefficients are coefficients of coefficients, or whatever, also can automatically have available that representation.

714
01:17:32,970 --> 01:17:35,952
That's the power of this particular one.

715
01:17:35,952 --> 01:17:38,700
AUDIENCE: I'm not sure if I can even pose an intelligent sounding question.

716
01:17:38,700 --> 01:17:47,280
But somehow this whole thing went really nicely to this beautiful finish where all the things seemed to fall into place.

717
01:17:47,280 --> 01:17:48,530
Sort of seemed a little contrived.

718
01:17:50,930 --> 01:17:52,670
That's all for the sake, I'm sure, of teaching.

719
01:17:52,670 --> 01:18:04,860
I doubt that the guys who first did this-- and I could be wrong-- figured it all out so that when they just all put it all together, you could all of the sudden, blam, do any kind of arithmetic on any kind of object.

720
01:18:04,860 --> 01:18:11,800
It seems like maybe they had to play with it for a while and had to bash it and rework it.

721
01:18:11,800 --> 01:18:24,620
And it seems like that's the kind of problem we're really faced with we start trying to design a really complex system, is having lots of different kinds of parts and not even knowing what kinds of operations we're going to want to do on those parts.

722
01:18:24,620 --> 01:18:31,700
How to organize the operations in this nice way so that no matter what you do, when you start putting them together everything starts falling out for free.

723
01:18:31,700 --> 01:18:34,340
PROFESSOR: OK, well that's certainly a very intelligent question.

724
01:18:37,020 --> 01:18:44,590
One part is this is a very good methodology that people have discovered a lot coming from symbolic algebra.

725
01:18:44,590 --> 01:18:47,590
Because there are a lot of complications.

726
01:18:47,590 --> 01:18:53,310
To allow you to implement these things before you decide what you want all the operations to be, and all of that.

727
01:18:53,310 --> 01:18:58,560
So in some sense it's an answer that people have discovered by wading through this stuff.

728
01:18:58,560 --> 01:19:02,160
In another sense, it is a very contrived example.

729
01:19:02,160 --> 01:19:09,010
AUDIENCE: It seems like to be able to do this you do have to wade through it for a certain amount of time before you can become good at it.

730
01:19:09,010 --> 01:19:12,220
PROFESSOR: Let me show you how terribly contrived this is.

731
01:19:12,220 --> 01:19:14,130
So you can write all these wonderful things.

732
01:19:14,130 --> 01:19:30,880
But the system that I wrote here, and if we had another half an hour to give this lecture I would have given this part of it, which says, notice that it breaks down if I tell it to do something as foolish as add 3 plus 7/2.

733
01:19:30,880 --> 01:19:37,560
Because what will happen is you'll get to operate-2, and operate-2 will say, oh this is type number, and that's type rational.

734
01:19:37,560 --> 01:19:38,810
I don't know how to add them.

735
01:19:41,530 --> 01:19:50,480
So you'd like the system at least to be able to say something like, gee, before you do that change that to 3/1.

736
01:19:50,480 --> 01:19:53,500
Turn it into a rational number, hand that to the rational package.

737
01:19:55,510 --> 01:19:58,860
That's the thing I didn't talk about in this lecture.

738
01:19:58,860 --> 01:20:03,390
It's a little bit in the book, which talks about the problem of what's called coercion.

739
01:20:03,390 --> 01:20:19,110
Where you wanted-- see, having so carefully set up all of these types as distinct objects, a lot of times you want to also put in knowledge about how to view an ordinary number as a kind of rational.

740
01:20:19,110 --> 01:20:21,620
Or view an ordinary number as a kind of complex.

741
01:20:21,620 --> 01:20:28,420
That's where the complexity in the system really starts happening, where you talk about, see where do I put that knowledge?

742
01:20:28,420 --> 01:20:33,130
Is it rational to know that ordinary numbers might be pieces of [UNINTELLIGIBLE] of them?

743
01:20:33,130 --> 01:20:47,510
Or they're terrible, terrible examples, like if I might want to add a complex number to a rational number.

744
01:20:50,080 --> 01:20:50,760
Bad example.

745
01:20:50,760 --> 01:20:52,010
5/7.

746
01:20:53,860 --> 01:21:01,540
Then somebody's got to know that I have to convert these to another type, which is complex numbers whose parts might be rationals.

747
01:21:01,540 --> 01:21:02,680
And who worries about that?

748
01:21:02,680 --> 01:21:03,950
Does complex worry about that?

749
01:21:03,950 --> 01:21:05,030
Does rational worry about that?

750
01:21:05,030 --> 01:21:06,900
Does plus worry about that?

751
01:21:06,900 --> 01:21:08,520
That's where the real complexity comes in.

752
01:21:08,520 --> 01:21:11,380
And that's where it's pretty well sorted out.

753
01:21:11,380 --> 01:21:18,460
And a lot of, in fact, all of this message passing stuff was motivated by problems like this.

754
01:21:18,460 --> 01:21:28,050
And when you really push it, people are-- somehow the algebraic manipulation problem seems to be so complex that the people who are always at the edge of it are exactly in the state you said.

755
01:21:28,050 --> 01:21:33,470
They're wading through this thing, mucking around, seeing what they use, trying to distill stuff.

756
01:21:33,470 --> 01:21:39,250
AUDIENCE: I just want to come back to this issue of complexity once more.

757
01:21:39,250 --> 01:21:49,580
It certainly seems to be true that you have a great deal of flexibility in altering the lower level kinds of things.

758
01:21:49,580 --> 01:21:55,450
But it is true that you are, in a sense, freezing higher level operations.

759
01:21:55,450 --> 01:22:02,060
Or at least if you change them you don't know where all of the changes are going to show up, or how they are.

760
01:22:02,060 --> 01:22:04,840
PROFESSOR: OK, that's an extremely good question.

761
01:22:04,840 --> 01:22:24,650
What I have to do is, if I decide there's a new general operation called equality test, then all of these people have to decide whether or not they would like to have an equality test by looking in the table.

762
01:22:24,650 --> 01:22:27,870
There're ways to decentralize it even more.

763
01:22:27,870 --> 01:22:40,450
That's what I sort of hinted at last time, where I said you could not only have this type as a symbol, but you actually might store in each object the operations that it knows of that.

764
01:22:40,450 --> 01:22:51,030
So you might have things like greatest common divisor, which is a thing here which is defined only for integers, and not in general for rational numbers.

765
01:22:51,030 --> 01:22:53,110
So it might be a very, very fragmented system.

766
01:22:53,110 --> 01:22:59,960
And then depending on where you want your flexibility, there's a whole spectrum of places that you can build that in.

767
01:22:59,960 --> 01:23:06,370
But you're pointing at the place where this starts being weak, that there has to be some agreement on top here about these general operations.

768
01:23:06,370 --> 01:23:08,390
Or at least people have to think about them.

769
01:23:08,390 --> 01:23:14,010
Or you might decide, you might have a table that's very sparse, that only has a few things in it.

770
01:23:14,010 --> 01:23:15,490
But there are lot of ways to play that game.

771
01:23:19,780 --> 01:23:21,030
OK, thank you.

772
01:23:23,534 --> 01:23:25,099
[MUSIC: "JESU, JOY OF MAN'S DESIRING" BY JOHANN SEBASTIAN BACH]

