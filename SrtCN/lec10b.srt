1
00:00:04,725 --> 00:00:17,875
[音乐]
[JESU, JOY OF MAN'S DESIRING]

2
00:00:18,910 --> 00:00:20,612
教授: 接下来我要解开
PROFESSOR: Well, there's one bit of mystery left,

3
00:00:21,168 --> 00:00:23,360
目前仅剩的谜团
which I'd like to get rid of right now.

4
00:00:24,440 --> 00:00:28,804
我们能毫无顾虑地用CONS
And that's that we've been blithely doing things like cons

5
00:00:30,000 --> 00:00:31,620
就好像空间足够多一样
assuming there's always another one.

6
00:00:32,800 --> 00:00:36,320
我们总是在使用
That we've been doing these things like

7
00:00:36,510 --> 00:00:37,440
CAR和CDR
car-ing and cdr-ing

8
00:00:37,472 --> 00:00:39,744
并假设知道它们是如何实现的
and assuming that we had some idea how this can be done.

9
00:00:40,020 --> 00:00:40,675
事实上
Now indeed

10
00:00:41,075 --> 00:00:44,403
我们认为它等同于过程
we said that that's equivalent to having procedures.

11
00:00:45,376 --> 00:00:47,570
但这没有真正解决问题
OK? But that doesn't really solve the problem,

12
00:00:47,730 --> 00:00:50,256
因为过程依赖各种复杂的机制
because the procedure need all sorts of complicated mechanisms

13
00:00:50,272 --> 00:00:51,376
需要诸如环境结构之类的东西
like environment structures

14
00:00:51,640 --> 00:00:52,768
才能运行起来
and things like that to work.

15
00:00:53,010 --> 00:00:54,890
而归根结底它们也是
And those were ultimately made out of conses

16
00:00:54,890 --> 00:00:56,425
由CONS之类的东西构成的
in the model that we had,

17
00:00:56,700 --> 00:00:58,473
这的确没有解决问题
so that really doesn't solve the problem.

18
00:00:59,380 --> 00:01:01,136
目前的问题是
Now the problem here is

19
00:01:01,312 --> 00:01:03,970
粘合这些数据结构的是什么东西？
is the glue the data structure's made out of.

20
00:01:04,760 --> 00:01:06,409
它可能是怎样的一个东西?
What kind of possible thing could it be?

21
00:01:07,040 --> 00:01:10,460
我们已经见过了一台机器
OK? We've been showing you things like a machine,

22
00:01:10,460 --> 00:01:13,968
一台计算机具有一个控制器
a computer that has a controller,

23
00:01:14,275 --> 00:01:15,450
和一些寄存器
and some registers,

24
00:01:15,450 --> 00:01:16,475
还可能有一个栈
and maybe a stack.

25
00:01:16,980 --> 00:01:18,128
但是我们还没提到一些东西
And we haven't said anything about,

26
00:01:18,160 --> 00:01:19,950
例如 大内存
for example, larger memory.

27
00:01:20,570 --> 00:01:22,382
我先 现在是时候讨论它们了
And I think that's what we have to worry about right now.

28
00:01:23,740 --> 00:01:27,886
#TBD
But just to make it perfectly clear that this is an inessential,

29
00:01:28,825 --> 00:01:30,791
#TBD
purely implementational thing,

30
00:01:31,100 --> 00:01:32,600
让我举个例子
I'd like to show you, for example,

31
00:01:32,600 --> 00:01:34,208
如何用数字来表示这些东西
how you can do it all with the numbers.

32
00:01:35,232 --> 00:01:36,820
有个比较简单的方法
That's an easy one.

33
00:01:37,590 --> 00:01:39,000
一位著名的逻辑学家 哥德尔
Famous fellow by the name of Godel,

34
00:01:44,096 --> 00:01:46,016
在20世纪30年代末
a logician at the end of the 1930s,

35
00:01:46,384 --> 00:01:48,700
发明了一个很巧妙的方法
invented a very clever way

36
00:01:48,700 --> 00:01:52,275
能够把复杂的表达式
of encoding the complicated expressions

37
00:01:52,816 --> 00:01:53,520
表示成数字
as numbers.

38
00:01:54,320 --> 00:01:55,050
例如
For example--

39
00:01:55,050 --> 00:01:58,000
我不会精确描述哥德尔的方法是怎样的
I'm not saying exactly what Godel's scheme is,

40
00:01:58,000 --> 00:01:59,488
因为他没有使用CONS之类的术语
because he didn't use words like cons.

41
00:01:59,660 --> 00:02:00,608
他使用了其它的组合手段
He had other kinds of

42
00:02:00,912 --> 00:02:02,600
来编码表达式
of ways of combining to make expressions.

43
00:02:03,090 --> 00:02:03,888
他的思路是
But he said,

44
00:02:03,920 --> 00:02:06,816
用不同数字分别代表每个代数式
I'm going to assign a number to every algebraic expression.

45
00:02:07,920 --> 00:02:09,725
通过用这些数字进行一些数学运算 #TBD
And the way I'm going to manufacture these numbers

46
00:02:09,725 --> 00:02:11,650
来把这些部分组合起来
is by combining the numbers of the parts.

47
00:02:12,470 --> 00:02:13,456
举例来说
So for example,

48
00:02:13,625 --> 00:02:15,350
我们在创造世界的时候
what we were doing our world,

49
00:02:15,350 --> 00:02:18,016
如果用数字
we could say that if objects

50
00:02:20,784 --> 00:02:22,220
来表示对象
are represented by numbers,

51
00:02:30,670 --> 00:02:37,936
那么(CONS X Y)
then cons of x and y

52
00:02:38,040 --> 00:02:41,072
就可以表示为
could be represented by, could be represented by

53
00:02:41,552 --> 00:02:43,770
2的X次幂乘3的Y次幂
2 to the x times 2 to the y.

54
00:02:46,130 --> 00:02:48,032
因为这样我们还能取出它的每一部分
Because then we could extract the parts.

55
00:02:49,560 --> 00:02:50,976
举例来说
We could say, for example,

56
00:02:51,184 --> 00:02:55,888
(CAR X)
that then car of, say, x

57
00:02:56,550 --> 00:03:05,184
就是X中因数2的个数
is the number of factors of 2 in x.

58
00:03:06,690 --> 00:03:08,784
当然(CDR X)是一样的
OK? And of course cdr is the same thing.

59
00:03:10,690 --> 00:03:15,579
它就X中因数3的个数
It's the number of factors of 3 in x.

60
00:03:16,510 --> 00:03:18,651
这是个非常合理的方案
Now this is a perfectly reasonable scheme,

61
00:03:19,100 --> 00:03:20,112
只不过就是
except for the fact that

62
00:03:20,128 --> 00:03:23,984
数字的位数会急剧地增大
the numbers rapidly get to be much larger in number of digits

63
00:03:24,320 --> 00:03:26,550
甚至比宇宙中的粒子还多
 than the number of protons in the universe.

64
00:03:27,950 --> 00:03:29,888
所以除了在理论中
So there's no easy way to use this scheme

65
00:03:29,904 --> 00:03:31,216
没有实现这种方案的好办法
other than the theoretical one.

66
00:03:33,430 --> 00:03:34,486
另一方面
On the other hand,

67
00:03:35,125 --> 00:03:37,558
也有其它的表示方式
there are other ways of representing these things.

68
00:03:38,450 --> 00:03:40,016
我们把它们表示为
We have been thinking in terms

69
00:03:40,256 --> 00:03:42,420
一些小盒子
of little boxes, boxes.

70
00:03:43,320 --> 00:03:46,432
我们把CONS结构
We've been thinking about our cons structures

71
00:03:46,500 --> 00:03:48,054
想象为这样的东西
as looking sort of like this.

72
00:03:50,280 --> 00:03:52,576
它们是里面装着东西的小隔间
They're little pigeon holes with things in them.

73
00:03:53,568 --> 00:03:55,470
这些格子组成一个树
And of course we arrange them in little trees.

74
00:03:57,210 --> 00:03:59,975
我希望半导体制造商
I wish that the semiconductor manufacturers

75
00:03:59,975 --> 00:04:02,075
能够提供适配这样需求的芯片
would supply me with something appropriate for this,

76
00:04:02,700 --> 00:04:03,760
但事实上
but actually

77
00:04:03,850 --> 00:04:05,312
他们提供给我的却是
what they do supply me with

78
00:04:06,208 --> 00:04:07,960
线性的内存
is a linear memory.

79
00:04:09,380 --> 00:04:13,467
内存是一串小隔间
Memory is sort of a big pile of pigeonholes,

80
00:04:15,120 --> 00:04:16,340
像这样的小隔间
pigeonholes like this.

81
00:04:17,720 --> 00:04:20,251
每个小隔间里可以保存确定大小的对象
Each of which can hold a certain sized object,

82
00:04:20,944 --> 00:04:22,200
一个尺寸固定的对象
a fixed size object.

83
00:04:23,390 --> 00:04:24,075
例如
So, for example,

84
00:04:24,070 --> 00:04:25,664
一个含25个元素的表
a complicated list with 25 elements

85
00:04:25,664 --> 00:04:26,640
就放不进这里
won't fit in one of these.

86
00:04:28,550 --> 00:04:30,900
然而 它们每一个都是由地址索引的
However, each of these is indexed by an address.

87
00:04:33,970 --> 00:04:34,992
因此它们的地址可能是
So the address might be

88
00:04:35,024 --> 00:04:35,500
这里是0
zero here,

89
00:04:35,500 --> 00:04:36,225
这里是1
one here,

90
00:04:36,225 --> 00:04:36,700
这里是2
two here,

91
00:04:36,700 --> 00:04:37,250
这里是3
three here,

92
00:04:37,250 --> 00:04:37,944
以此类推
and so on.

93
00:04:38,060 --> 00:04:40,400
这里写的数字并不重要
That we write these down as numbers is unimportant.

94
00:04:40,400 --> 00:04:41,680
重要的是 它们不重复
What matters is that they're distinct

95
00:04:41,950 --> 00:04:43,425
有了它们就能找到下一个在哪
as a way to get to the next one.

96
00:04:44,970 --> 00:04:46,144
在其中每一个小隔间里面
And inside of each of these,

97
00:04:46,366 --> 00:04:49,110
我们可以把东西放进去
we can stuff something into these pigeonholes.

98
00:04:49,530 --> 00:04:50,774
对于没有造过计算机的我们来说
That's what memory is like,

99
00:04:51,020 --> 00:04:53,664
内存就是这样子的
for those of you who haven't built a computer.

100
00:04:54,150 --> 00:04:54,650
现在
Now.

101
00:04:56,690 --> 00:04:57,536
现在的问题是
Now the problem is

102
00:04:57,536 --> 00:04:59,970
如何用这样的结构
how are we going to impose on this type of structure,

103
00:05:00,425 --> 00:05:01,725
来实现这个树形结构
this nice tree structure.

104
00:05:03,290 --> 00:05:04,575
其实并不难
Well it's not very hard,

105
00:05:04,575 --> 00:05:06,350
已经有大量的方案来做这个了
and there have been numerous schemes involved in this.

106
00:05:06,875 --> 00:05:08,800
最重要的一个方案是
The most important one is to say,

107
00:05:08,800 --> 00:05:12,575
假设半导体生产厂
well assuming that the semiconductor manufacturer allows me to arrange

108
00:05:13,151 --> 00:05:15,775
允许我们的其中一个小隔间足够大
my memory so that one of these pigeonholes is big enough

109
00:05:16,287 --> 00:05:18,325
能够装得下另一个的地址
to hold the address of another

110
00:05:19,350 --> 00:05:20,831
另一个未使用的小隔间的地址
I haven't made.

111
00:05:22,050 --> 00:05:23,700
事实上它需要更大一点
Now it actually has to be a little bit bigger

112
00:05:23,700 --> 00:05:27,650
因为我还要存一些信息在里面
because I have to also install or store some information

113
00:05:27,650 --> 00:05:30,390
它标示了这里面是什么东西
as to a tag which describes the kind of thing that's there.

114
00:05:30,390 --> 00:05:31,647
我们过一会能看到
And we'll see that in a second.

115
00:05:32,625 --> 00:05:36,081
如果半导体生产厂没这么良心
And of course if the semiconductor manufacturer doesn't arrange it so I can do that,

116
00:05:36,081 --> 00:05:38,575
我就需要用一些机智的方式
then of course I can, with some cleverness,

117
00:05:38,575 --> 00:05:41,823
把它们组合起来以供使用
arrange combinations of these to fit together in that way.

118
00:05:43,770 --> 00:05:47,050
我们想象一下
So we're going to have to imagine

119
00:05:47,050 --> 00:05:49,546
把这个复杂的树形结构
imposing this complicated tree structure

120
00:05:49,546 --> 00:05:51,200
塞进线性内存里
on our nice linear memory.

121
00:05:51,740 --> 00:05:54,475
#TBD
If we look at the first still store,

122
00:05:54,475 --> 00:05:58,304
我们发现了一个传统的实现方案
we see a classic scheme for doing that.

123
00:05:59,490 --> 00:06:02,625
它是把Lisp结构
It's a standard way of representing Lisp structures

124
00:06:03,225 --> 00:06:05,875
放入线性内存的基本方式
in a linear memory.

125
00:06:06,275 --> 00:06:08,325
我们把这块内存
What we do is we divide this memory

126
00:06:08,725 --> 00:06:11,123
分为两部分
into two parts.

127
00:06:12,030 --> 00:06:13,427
一个叫the-cars的数组
An array called the cars,

128
00:06:14,450 --> 00:06:15,923
一个叫the-cdrs的数组
and an array called the cdrs.

129
00:06:17,580 --> 00:06:21,275
它是不是顺序地址
Now whether those happen to be sequential addresses or whatever,

130
00:06:21,275 --> 00:06:22,003
其实并不重要
it's not important.

131
00:06:22,875 --> 00:06:25,203
这是实现细节了
That's somebody's implementation details.

132
00:06:25,800 --> 00:06:28,403
但有两个数组
But there are two arrays here.

133
00:06:28,960 --> 00:06:32,755
一维数组是由顺序的下标索引的
Linear arrays indexed by sequential indices like this.

134
00:06:34,840 --> 00:06:36,851
每个小隔间里存的
What is stored in each of these pigeonholes

135
00:06:37,467 --> 00:06:39,859
是一个带类型的对象
is a typed object.

136
00:06:41,430 --> 00:06:42,575
这里是
And what we have here

137
00:06:42,575 --> 00:06:45,300
以字母p开头
are types which begin with letters like p,

138
00:06:45,300 --> 00:06:46,725
表示序对
standing for a pair.

139
00:06:47,790 --> 00:06:49,375
以n开头 表示数字
Or n, standing for a number.

140
00:06:50,040 --> 00:06:52,255
e开头 表示空列表
Or e, standing for an empty list.

141
00:06:54,813 --> 00:06:55,839
以及列表的结尾
The end of the list.

142
00:06:57,025 --> 00:06:59,975
如果我们想表示这样一个对象
And so if we wish to represent an object like this,

143
00:06:59,975 --> 00:07:02,164
列表由(1 2)开始
the list beginning with 1, 2

144
00:07:02,650 --> 00:07:05,503
3和4是它的第二和第三个元素
and then having a 3 and a 4 as its second and third elements.

145
00:07:06,430 --> 00:07:08,831
它第一个部分是一个包含了列表的列表
A list containing a list as its first part

146
00:07:09,350 --> 00:07:10,650
后面接着是两个数字
and then two numbers

147
00:07:10,650 --> 00:07:12,000
分别为第二和第三部分
as a second and third parts.

148
00:07:12,870 --> 00:07:16,672
现在我们用盒子和指针表示法来描绘它
Then of course we draw it sort of like this these days, in box-and-pointer notation.

149
00:07:17,320 --> 00:07:18,000
你能发现
And you see,

150
00:07:18,000 --> 00:07:22,275
有三个格子里是CAR指针
these are the three cells that have as their car pointer

151
00:07:22,275 --> 00:07:27,104
对象是(1 2)或3或4
the object which is either 1, 2 or 3 or 4.

152
00:07:28,390 --> 00:07:29,750
当然这个(1 2)
And then of course the 1, 2,

153
00:07:29,750 --> 00:07:31,325
即整个结构的CAR
the car of this entire structure,

154
00:07:31,325 --> 00:07:34,875
就是一个包含子列表的子结构
is itself a substructure which contains a sublist like that.

155
00:07:35,940 --> 00:07:37,200
我要做的是
What I'm about to do

156
00:07:37,200 --> 00:07:41,467
就是按照下标把它们放进去
is put down places which are-- I'm going to assign indices.

157
00:07:41,880 --> 00:07:43,562
像这里的1
Like this 1, over here,

158
00:07:43,562 --> 00:07:46,850
代表了这个格子的下标
represents the index of this cell.

159
00:07:49,850 --> 00:07:51,475
这里的指针
But that pointer that we see here

160
00:07:52,375 --> 00:07:57,400
是对the-cars和the-cdrs里的小隔间的引用
is a reference to the pair of pigeonholes in the cars and the cdrs

161
00:07:57,400 --> 00:07:58,675
在线性内存里
that are labeled by 1

162
00:07:58,675 --> 00:08:00,371
被标记为1
in my linear memory down here.

163
00:08:02,000 --> 00:08:05,363
如果我想把这个结构塞进线性内存中
So if I wish to impose this structure on my linear memory,

164
00:08:05,850 --> 00:08:07,525
要做的是
what I do is I say, oh yes,

165
00:08:07,525 --> 00:08:12,220
把它放进格子1中
why don't we drop this into cell 1?

166
00:08:12,220 --> 00:08:12,660
我拿了个1
I pick one.

167
00:08:12,660 --> 00:08:14,270
这是个1
There's 1.

168
00:08:14,270 --> 00:08:16,225
这是它的CAR
And that says that its car,

169
00:08:16,225 --> 00:08:17,950
我要把它赋值给一个序对
I'm going to assign it to be a pair.

170
00:08:17,950 --> 00:08:18,725
这个序对
It's a pair,

171
00:08:20,025 --> 00:08:21,555
序号是5
which is in index 5.

172
00:08:22,590 --> 00:08:23,900
它的CDR
And the cdr,

173
00:08:23,900 --> 00:08:25,139
就是这个
which is this one over here,

174
00:08:25,390 --> 00:08:26,135
它是个序对
is a pair

175
00:08:26,135 --> 00:08:27,700
我会把它放到2的位置
which I'm going to stick into place 2.

176
00:08:28,340 --> 00:08:28,980
即p2
p2.

177
00:08:30,890 --> 00:08:32,950
我们看p2
And take a look at p2.

178
00:08:32,950 --> 00:08:34,725
p2的CAR
Oh yes, well p2 is a thing

179
00:08:34,900 --> 00:08:37,225
是数字3
whose car is the number 3,

180
00:08:37,225 --> 00:08:38,644
如你所见 n3
so as you see, an n3.

181
00:08:39,520 --> 00:08:41,524
它的CDR
And whose cdr, over here,

182
00:08:41,727 --> 00:08:43,400
是一个序对
is a pair,

183
00:08:43,975 --> 00:08:45,812
在位置4
which lives in place 4.

184
00:08:46,640 --> 00:08:47,796
这就是p4
So that's what this p4 is.

185
00:08:48,650 --> 00:08:51,167
p4是一个数字
p4 is a number

186
00:08:51,850 --> 00:08:53,876
它的值是4 存在CDR中
whose value is 4 in its car

187
00:08:54,475 --> 00:08:55,650
它的CDR
and whose cdr

188
00:08:55,650 --> 00:08:58,484
是个空列表 在这儿
is an empty list right there.

189
00:08:59,170 --> 00:09:00,020
这就结束了
And that ends it.

190
00:09:00,690 --> 00:09:04,907
这就是在线性内存中
So this is the traditional way of representing

191
00:09:04,907 --> 00:09:09,748
表示二叉树的传统方式
this kind of binary tree in a linear memory.

192
00:09:11,620 --> 00:09:15,100
那么 下一个问题是
Now the next question, of course,

193
00:09:15,100 --> 00:09:18,440
我们可能担心如何实现
that we might want to worry about is just a little bit of implementation.

194
00:09:18,440 --> 00:09:23,625
这意味着当我写下一个对a赋值的过程
That means that when I write procedures of the form assigned a,

195
00:09:23,625 --> 00:09:30,140
#TBD
[UNINTELLIGIBLE] procedures-- lines of register machine code of the form assigned a, the car of [UNINTELLIGIBLE] b,

196
00:09:30,140 --> 00:09:31,975
我实际上想做的是
what I really mean

197
00:09:31,975 --> 00:09:37,100
定位这些元素
is addressing these elements.

198
00:09:38,740 --> 00:09:43,000
我们会把它当作一个缩写
And so we're going to think of that as a abbreviation for it.

199
00:09:44,470 --> 00:09:46,600
当然 为了把它们写下来
Now of course in order to write that down

200
00:09:46,600 --> 00:09:49,425
我要引入一种叫作向量的结构
I'm going to introduce some sort of a structure called a vector.

201
00:09:52,120 --> 00:09:54,750
我们得有一种东西用来引用向量
And we're going to have something which will reference a vector,

202
00:09:56,840 --> 00:09:58,710
这样我们就能把它写下来
just so we can write it down.

203
00:09:58,710 --> 00:10:00,436
它叫向量vector
Which takes the name of the vector,

204
00:10:01,025 --> 00:10:03,970
我觉得这个名字起得不太靠谱
or the-- I don't think that name is the right word.

205
00:10:03,970 --> 00:10:09,400
它接受vector和index两个参数
Which takes the vector and the index,

206
00:10:11,201 --> 00:10:14,657
#TBD
and I have to have a way of setting one of those with something called a vector set,

207
00:10:14,657 --> 00:10:15,608
我不太在意
I don't really care.

208
00:10:16,280 --> 00:10:17,550
举个例子
But let's look, for example,

209
00:10:18,113 --> 00:10:20,425
在这种实现中
at then that kind of implementation

210
00:10:21,250 --> 00:10:23,182
CAR和CDR是什么样子的
of car and cdr.

211
00:10:26,470 --> 00:10:30,800
如果我有一个寄存器b
So for example if I happen to have a register b,

212
00:10:31,150 --> 00:10:34,640
它存了一个序对的下标
which contains the type index of a pair,

213
00:10:35,950 --> 00:10:38,800
即它是指向一个序对的指针
and therefore it is the pointer to a pair,

214
00:10:39,350 --> 00:10:40,850
我可以取它的CAR
then I could take the car of that and

215
00:10:41,425 --> 00:10:44,112
存到寄存器a里面
if I-- write this down-- I might put that in register a.

216
00:10:44,490 --> 00:10:46,864
事实上它是
What that really is is a representation of

217
00:10:47,375 --> 00:10:50,191
#TBD
the assign to a,

218
00:10:50,191 --> 00:10:55,425
#TBD
the value of vector reffing-- or array indexing, if you will-- or something,

219
00:10:55,425 --> 00:11:01,136
#TBD
the cars object-- whatever that is-- with the index, b.

220
00:11:02,650 --> 00:11:03,760
与CDR类似
And similarly for cdr.

221
00:11:04,100 --> 00:11:05,725
我们可以用同样的方式
And we can do the same thing

222
00:11:05,725 --> 00:11:08,496
来对数据结构赋值
for assignment to data structures,

223
00:11:08,925 --> 00:11:10,925
如果我们需要这么做的话
If we need to do that sort of things at all.

224
00:11:11,840 --> 00:11:13,808
构建这个并不太难
It's not too hard to build that.

225
00:11:14,580 --> 00:11:15,600
下一个问题是
Well now the next question is

226
00:11:15,600 --> 00:11:17,008
我们如何分配它们
how are we going to do allocation.

227
00:11:18,010 --> 00:11:20,138
我说过很多次 我需要一个CONS
And every so often I say I want a cons.

228
00:11:21,400 --> 00:11:23,790
当然 CONS并没有长在树上
Now conses don't grow on trees.

229
00:11:23,790 --> 00:11:25,340
或许它们应该那样
Or maybe they should.

230
00:11:25,340 --> 00:11:28,975
我需要某种获得下一个的方法
But I have to have some way of getting the next one.

231
00:11:29,980 --> 00:11:31,475
我需要某种方案
I have to have some idea of

232
00:11:31,475 --> 00:11:33,690
当内存不再使用的时候
if their memory is unused

233
00:11:33,690 --> 00:11:35,630
我可以重新分配它们
that I might want to allocate from.

234
00:11:35,630 --> 00:11:37,380
有很多方案可以实现这一点
And there are many schemes for doing this.

235
00:11:37,380 --> 00:11:40,450
我给你看这这个东西是不必要的
And the particular thing I'm showing you right now is not essential.

236
00:11:42,100 --> 00:11:43,175
然而它很方便
However it's convenient

237
00:11:43,175 --> 00:11:44,960
并且被实现很多次了
and has been done many times.

238
00:11:44,960 --> 00:11:47,660
其中一种被称为自由表分配方案
One scheme's was called the free list allocation scheme.

239
00:11:47,660 --> 00:11:48,684
它的意思就是
What that means is

240
00:11:48,684 --> 00:11:51,550
世界上所有的空闲内存
that all of the free memory that there is in the world

241
00:11:51,550 --> 00:11:53,429
都连在一个链表中
is linked together in a linked list,

242
00:11:54,550 --> 00:11:56,373
就像其他东西一样
just like all the other stuff.

243
00:11:56,960 --> 00:11:59,075
每当你需要一个新的格子
And whenever you need a free cell

244
00:11:59,075 --> 00:12:00,213
来进行CONS的时候
to make a new cons,

245
00:12:00,950 --> 00:12:02,264
你把第一个拿去用
you grab the first one

246
00:12:02,264 --> 00:12:03,825
让它的CDR作为新的自由表
make the free list be the cdr of it,

247
00:12:04,325 --> 00:12:05,553
然后分配它
and then allocate that.

248
00:12:06,030 --> 00:12:08,325
就像这样
And so what that looks like is something like this.

249
00:12:09,530 --> 00:12:16,817
我们的自由表从6开始
Here we have the free list starting in 6.

250
00:12:18,510 --> 00:12:23,729
它是一个指向8的指针
And what that is is a pointer-off to say 8.

251
00:12:24,860 --> 00:12:25,628
它表示
So what it says is,

252
00:12:25,628 --> 00:12:26,553
当前这个是空闲的
this one is free

253
00:12:26,553 --> 00:12:27,953
下一个在8
and the next one is an 8.

254
00:12:28,870 --> 00:12:29,881
这个是空闲的
This one is free

255
00:12:29,881 --> 00:12:32,271
下一个在3
and the next one is in 3,

256
00:12:32,271 --> 00:12:33,457
下一个是空闲的
the next one that's free.

257
00:12:33,930 --> 00:12:34,950
这个是空闲的
That one's free

258
00:12:34,950 --> 00:12:37,680
下一个在0
and the next one is in 0.

259
00:12:37,680 --> 00:12:38,250
这个是空闲的
That one's free

260
00:12:38,250 --> 00:12:39,857
下一个在15
and the next one's in 15.

261
00:12:40,940 --> 00:12:41,975
以此类推
Something like that.

262
00:12:42,780 --> 00:12:44,977
我们可以想象有这样的结构
We can imagine having such a structure.

263
00:12:46,400 --> 00:12:48,250
一旦我们有了这样的机制
Given that we have something like that,

264
00:12:49,450 --> 00:12:50,925
那么当你需要空间的时候
then it's possible to

265
00:12:50,925 --> 00:12:52,421
就能获取一个
just get one when you need it.

266
00:12:53,825 --> 00:12:56,466
对于进行CONS的程序
And so a program for doing cons,

267
00:12:57,450 --> 00:12:59,320
这就是CONS的程序会是什么样子
this is what cons might turn into.

268
00:12:59,320 --> 00:13:02,573
把B和C进行CONS之后的值
To assign to a register A the result of cons-ing,

269
00:13:02,950 --> 00:13:05,825
赋值给A寄存器
a B onto C,

270
00:13:06,200 --> 00:13:09,275
结果包括B和C
the value in this containing B and the value containing C,

271
00:13:09,275 --> 00:13:12,475
我们要做的是使用自由表前面的第一个
what we have to do is get the current [? type ?] ahead of the freelist,

272
00:13:12,475 --> 00:13:14,300
让它的CDR成为新的自由表
make the free list be its cdr.

273
00:13:15,643 --> 00:13:20,475
我们要把CAR修改为
Then we have to change the cars to be the thing we're

274
00:13:20,475 --> 00:13:25,450
#TBD
making up to be in A to be the B, the thing in B.

275
00:13:25,900 --> 00:13:31,722
我们还要把CDR改为#TBD
And we have to make change the cdrs of the thing that's in A to be C.

276
00:13:33,200 --> 00:13:36,650
#TBD
And then what we have in A is the right new frob, whatever it is.

277
00:13:36,650 --> 00:13:38,186
这就是我们要的对象
The object that we want.

278
00:13:40,470 --> 00:13:42,500
我之前告诉过你们
Now there's a little bit of

279
00:13:42,500 --> 00:13:43,975
这里撒了个谎
a cheat here that I haven't told you about,

280
00:13:43,975 --> 00:13:47,326
#TBD
which is somewhere around here I haven't set that

281
00:13:48,455 --> 00:13:53,050
#TBD
I've the type of the thing that I'm cons-ing up to be a pair, and I ought to.

282
00:13:53,510 --> 00:13:55,675
#TBD
So there should be some sort of bits here are being set,

283
00:13:55,675 --> 00:13:57,914
我只是还没把它写下来
and I just haven't written that down.

284
00:13:59,810 --> 00:14:02,450
#TBD
We could have arranged it, of course, for the free lift to be made out of pairs.

285
00:14:03,100 --> 00:14:04,882
因此这是没问题的
And so then there's no problem with that.

286
00:14:06,430 --> 00:14:09,925
#TBD
But that sort of-- again, an inessential detail in a way

287
00:14:10,225 --> 00:14:16,850
#TBD
some particular programmer or architect or whatever might manufacture his machine or Lisp system.

288
00:14:17,540 --> 00:14:18,711
例如
So for example,

289
00:14:19,075 --> 00:14:20,247
看这个
just looking at this,

290
00:14:20,650 --> 00:14:23,550
假设我们要为
to allocate

291
00:14:23,550 --> 00:14:26,834
这个之前见过的数据结构分配空间
given that I had already the structure that you saw before,

292
00:14:27,100 --> 00:14:30,265
假设我要分配一个新单元
supposing I wanted to allocate a new cell,

293
00:14:30,550 --> 00:14:36,617
把列表(1 1 2)
which is going to be representation of list one, one, two,

294
00:14:37,075 --> 00:14:42,161
放到(1 2)为CAR这个列表的前面
where already one two was the car of the list we were playing with before.

295
00:14:43,430 --> 00:14:44,450
这不怎么难
Well that's not so hard.

296
00:14:44,780 --> 00:14:46,200
#TBD
I stored that one and one,

297
00:14:46,200 --> 00:14:49,175
那么p1表示的就是它
so p1 one is the representation of this.

298
00:14:49,530 --> 00:14:50,839
这个是p5
This is p5.

299
00:14:51,675 --> 00:14:53,512
它是应该是这个的CDR
That's going to be the cdr of this.

300
00:14:54,070 --> 00:14:55,525
现在我们想用掉一些自由表
Now we're going to pull something off the free list,

301
00:14:55,525 --> 00:14:57,303
记住自由表从6开始
but remember the free list started at six.

302
00:14:57,780 --> 00:15:00,183
分配之后的新自由表指针是8
The new free list after this allocation is eight,

303
00:15:00,600 --> 00:15:02,551
一个从8开始的自由表
a free list beginning at eight.

304
00:15:02,890 --> 00:15:03,722
当然
And of course

305
00:15:03,722 --> 00:15:06,157
现在6里面是数字1
in six now we have a number one,

306
00:15:06,157 --> 00:15:07,306
就是我们想要的
which is what we wanted,

307
00:15:07,306 --> 00:15:11,562
它的CDR是在位置5的序对
with its cdr being the pair starting in location five.

308
00:15:13,330 --> 00:15:14,506
没费多少力气
And that's no big deal.

309
00:15:16,810 --> 00:15:20,450
这里依然存在的一个问题是
So the only problem really remaining here is,

310
00:15:21,000 --> 00:15:23,402
我们没有无限大的内存
well, I don't have an infinitely large memory.

311
00:15:25,080 --> 00:15:26,666
如果它需要花费一些时间
If I do this for a little while,

312
00:15:27,250 --> 00:15:30,150
例如 假设进行一次CONS花费1微秒
say, for example, supposing it takes me a microsecond to do a cons,

313
00:15:30,600 --> 00:15:32,975
我们要进行一百万次CONS
and I have a million cons memory

314
00:15:33,600 --> 00:15:35,279
那么我就要消耗1秒钟的时间
then I'm only going to run out in a second,

315
00:15:35,950 --> 00:15:37,007
这就很糟糕了
and that's pretty bad.

316
00:15:38,000 --> 00:15:40,625
如何预防这样的灾难
So what we do to prevent that disaster,

317
00:15:40,625 --> 00:15:42,191
生态灾难
that ecological disaster,

318
00:15:42,600 --> 00:15:44,300
在提问环节之后我们再继续讨论
talk about right after questions.

319
00:15:44,300 --> 00:15:45,263
有人要提问吗?
Are there any questions?

320
00:15:51,500 --> 00:15:52,030
请讲
Yes.

321
00:15:52,030 --> 00:15:54,675
学生: 在环境图表中
AUDIENCE: In the environment diagrams that we were drawing

322
00:15:54,675 --> 00:15:58,250
我们画了过程体
we would use the body of procedures,

323
00:15:58,250 --> 00:16:04,350
#TBD
and you would eventually wind up with things that were no longer useful in that structure.

324
00:16:04,930 --> 00:16:06,890
它是如何表示的
How is that represented?

325
00:16:06,890 --> 00:16:09,180
教授: 这其实是两个问题
PROFESSOR: There's two problems here.

326
00:16:09,180 --> 00:16:10,250
第一个问题是
One you were asking

327
00:16:10,250 --> 00:16:13,438
材料没用了
is that material becomes useless.

328
00:16:13,870 --> 00:16:14,920
我们稍后就会讲
We'll talk about that in a second.

329
00:16:14,920 --> 00:16:17,175
如何预防生态灾难
That has to do with how to prevent ecological disasters.

330
00:16:18,100 --> 00:16:19,200
如果我制造了一堆垃圾
If I make a lot of garbage

331
00:16:19,200 --> 00:16:21,399
我需要自己清理掉
I have to somehow be able to clean up after myself.

332
00:16:21,820 --> 00:16:23,255
我们一会儿就要讲
And we'll talk about that in a second.

333
00:16:23,430 --> 00:16:24,575
第二个问题
The other question you're asking

334
00:16:24,575 --> 00:16:27,210
你问的是如何表示环境
is how you represent the environments, I think.

335
00:16:27,210 --> 00:16:27,600
学生: 对
AUDIENCE: Yes.

336
00:16:27,600 --> 00:16:28,190
教授: 好
PROFESSOR: OK.

337
00:16:28,190 --> 00:16:30,860
环境结构能够以任意的方式表示
And the environment structures can be represented in arbitrary ways.

338
00:16:30,860 --> 00:16:31,780
有很多种表示方式
There are lots of them.

339
00:16:31,780 --> 00:16:33,630
我的意思是 我这里只教你了列表格子的表示方式
I mean, here I'm just telling you about list cells.

340
00:16:33,630 --> 00:16:34,925
当然 每个真实的系统
Of course every real system

341
00:16:34,925 --> 00:16:36,725
都有任意长度的向量
has vectors of arbitrary length

342
00:16:36,725 --> 00:16:41,080
也有长度的向量表示#TBD
as well as the vectors of length, too, which represent list cells.

343
00:16:41,080 --> 00:16:44,909
在一个专业的Lisp系统中
And the environment structures that one uses in a

344
00:16:44,909 --> 00:16:47,300
环境结构是用
professionally written Lisp system

345
00:16:47,300 --> 00:16:49,699
向量表示的
tend to be vectors

346
00:16:49,699 --> 00:16:51,925
其中包含了约等于参数数量的元素
which contain a number of elements approximately

347
00:16:51,925 --> 00:16:54,601
--比它稍微多一点
equal to the number of arguments-- a little bit more

348
00:16:55,350 --> 00:16:58,290
因为你需要#TBD
because you need certain glue.

349
00:16:58,290 --> 00:17:00,740
记住环境是在框架里的
So remember, the environment is in a frame.

350
00:17:00,740 --> 00:17:03,980
框架是应用过程时被构建出来的
The frames are constructed by applying a procedure.

351
00:17:03,980 --> 00:17:06,825
#TBD
In doing so, an allocation is made of

352
00:17:06,825 --> 00:17:11,270
#TBD
a place which is the number of arguments long plus [? unglue ?]

353
00:17:11,270 --> 00:17:12,713
#TBD
that gets linked into a chain.

354
00:17:13,325 --> 00:17:15,660
在这个层次上 和ALGOL差不多
It's just like algol at that level.

355
00:17:19,810 --> 00:17:20,725
还有其他问题吗?
There any other questions?

356
00:17:23,700 --> 00:17:23,920
好
OK.

357
00:17:23,920 --> 00:17:26,106
谢谢 我们休息一下
Thank you, and let's take a short break.

358
00:17:26,350 --> 00:18:10,625
[音乐]
[JESU, JOY OF MAN'S DESIRING]

359
00:18:12,270 --> 00:18:14,550
教授: 就像我刚才提到过的
PROFESSOR: Well, as I just said,

360
00:18:14,550 --> 00:18:17,975
半导体厂商生产的计算机内存
computer memories supplied by the semiconductor manufacturers

361
00:18:17,975 --> 00:18:19,000
容量是有限的
are finite.

362
00:18:19,420 --> 00:18:20,408
这的确很可惜
And that's quite a pity.

363
00:18:21,620 --> 00:18:23,352
可能并不永远是这样
It might not always be that way.

364
00:18:24,030 --> 00:18:25,623
简单算一下
Just for a quick calculation,

365
00:18:25,623 --> 00:18:28,860
你可以看到 如果内存的价格
you can see that it's possible that if memory's

366
00:18:28,860 --> 00:18:30,800
继续保持当前的趋势的话
prices keep going at the rate they're going

367
00:18:31,225 --> 00:18:33,872
如果你执行CONS的时候一直花费1微秒
that if you still took a microsecond second to do a cons,

368
00:18:34,425 --> 00:18:35,900
那么 首先大家知道
then-- first of all,

369
00:18:35,900 --> 00:18:38,864
pi乘10的7次方秒大约是一年
everybody should know that there's about pi times ten to the seventh seconds in a year.

370
00:18:39,450 --> 00:18:41,325
那么就有
And so that would be

371
00:18:41,325 --> 00:18:42,733
10的6次方乘10的7次方
ten to the seventh plus ten to the sixth

372
00:18:42,733 --> 00:18:43,940
也就是10的13次方
is ten to the thirteenth.

373
00:18:43,940 --> 00:18:45,506
那么在机器的一生中
So there's maybe ten to the fourteenth conses

374
00:18:45,506 --> 00:18:46,800
就能有10的14次方个CONS
in the life of a machine.

375
00:18:47,520 --> 00:18:50,576
如果你的机器上有10的14次方个字的内存
If there was ten to the fourteenth words of memory on your machine,

376
00:18:51,200 --> 00:18:52,368
你永远不会用完
you'd never run out.

377
00:18:54,020 --> 00:18:55,760
这并不是完全没有道理
And that's not completely unreasonable.

378
00:18:56,310 --> 00:18:58,460
10的14次方不是个非常大的数字
Ten to the fourteenth is not a very large number.

379
00:19:03,860 --> 00:19:05,180
我不觉觉得它是个很大的数字
I don't think it is.

380
00:19:05,180 --> 00:19:08,700
但我喜欢在天文学领域进行比较
But then again I like to play with astronomy.

381
00:19:09,250 --> 00:19:12,450
距离我们最近的星星至少有10的18次方厘米远
It's at least ten to the eighteenth centimeters between us and the nearest star.

382
00:19:12,930 --> 00:19:18,850
我担心的是
But the thing I'm about to worry about is,

383
00:19:19,150 --> 00:19:21,275
至少以现在的经济状况
at least in the current economic state of affairs,

384
00:19:21,275 --> 00:19:23,575
10的14次方内存很贵
ten to the fourteenth pieces of memory is expensive.

385
00:19:24,200 --> 00:19:28,600
因此我认为我们需要适应更小的内存
And so I suppose what we have to do is make do with much smaller memories.

386
00:19:30,025 --> 00:19:33,442
一般来说
Now in general

387
00:19:33,442 --> 00:19:35,145
我们需要有无限内存的错觉
we want to have an illusion of infinity.

388
00:19:35,800 --> 00:19:37,225
我们需要整理它
All we need to do is arrange it

389
00:19:37,825 --> 00:19:39,689
那么在我们需要内存的时候就能获得它
so that whenever you look, the thing is there.

390
00:19:42,875 --> 00:19:45,550
这是个非常重要的想法
That's really an important idea.

391
00:19:49,540 --> 00:19:51,975
人或者计算机只能存在有限的时间
A person or a computer lives only a finite amount of time

392
00:19:52,325 --> 00:19:54,599
只能看有限的东西
and can only take a finite number of looks at something.

393
00:19:55,280 --> 00:19:57,375
因此你只需要有限的东西
And so you really only need a finite amount of stuff.

394
00:19:58,190 --> 00:19:59,000
只要你去整理它
But you have to arrange it

395
00:19:59,000 --> 00:20:00,383
那么不管实际有多少
so no matter how much there is,

396
00:20:00,773 --> 00:20:03,461
你要求这里有多少
how much you really claim there is,

397
00:20:03,461 --> 00:20:04,749
当你去看的时候
there's always enough stuff

398
00:20:04,749 --> 00:20:06,900
总有足够的东西
so that when you take a look, it's there.

399
00:20:06,900 --> 00:20:08,157
因此你只需要有限的数量
And so you only need a finite amount.

400
00:20:08,750 --> 00:20:09,949
我们看
But let's see.

401
00:20:11,630 --> 00:20:13,533
我们之前提过一个问题
One problem is, as was brought up,

402
00:20:13,925 --> 00:20:15,450
在很多情况下
that there are possible ways

403
00:20:15,725 --> 00:20:19,125
我们制造了大量我们不需要的东西
that there is lots of stuff that we make that we don't need.

404
00:20:19,410 --> 00:20:21,813
我们可以进行回收再利用
And we could recycle the material out of which its made.

405
00:20:22,625 --> 00:20:23,533
举个例子
An example

406
00:20:24,150 --> 00:20:25,500
事实上
is the fact that

407
00:20:25,500 --> 00:20:28,400
当我们调用一个过程的时候
we're building environment structures,

408
00:20:28,400 --> 00:20:30,470
都会构建环境结构
and we do so every time we call a procedure.

409
00:20:30,470 --> 00:20:32,565
我们把它构建在一个环境框架中
We have built in it a environment frame.

410
00:20:33,141 --> 00:20:36,075
环境框架不用存在很长时间
That environment frame doesn't necessarily have a very long lifetime.

411
00:20:36,730 --> 00:20:38,699
它只在有用的时候才会存在
Its lifetime, meaning its usefulness,

412
00:20:39,425 --> 00:20:42,603
可能只在调用过程的时候才会存在
may exist only over the invocation of the procedure.

413
00:20:42,850 --> 00:20:45,275
如果过程把另一个过程
Or if the procedure exports another procedure

414
00:20:45,275 --> 00:20:46,875
作为返回值返回
by returning it as a value

415
00:20:46,875 --> 00:20:48,525
并且这个过程是在它的内部定义的
and that procedure is defined inside of it,

416
00:20:48,525 --> 00:20:53,500
那么外层过程的框架的存活时间
well then the lifetime of the frame of the outer procedure still is

417
00:20:53,500 --> 00:20:57,900
就是被返回的过程的存活时间
only the lifetime of the procedure which was exported.

418
00:20:58,530 --> 00:20:59,575
最终
And so ultimately,

419
00:20:59,575 --> 00:21:00,972
就会产生很多垃圾
a lot of that is garbage.

420
00:21:01,960 --> 00:21:04,108
还有其他产生垃圾的方式
There are other ways of producing garbage as well.

421
00:21:05,370 --> 00:21:06,675
用户产生垃圾
Users produce garbage.

422
00:21:07,240 --> 00:21:08,075
举例来说
An example of

423
00:21:08,075 --> 00:21:10,225
用户的垃圾是这样的东西
user garbage is something like this.

424
00:21:10,930 --> 00:21:14,000
如果我们写个程序
If we write a program to, for example,

425
00:21:14,000 --> 00:21:15,800
把两个列表连接到一起
append two lists together,

426
00:21:16,050 --> 00:21:18,325
唯一的办法是
well one way to do it is

427
00:21:18,325 --> 00:21:21,375
把第一个列表逆序塞到空列表中
to reverse the first list onto the empty list

428
00:21:21,375 --> 00:21:23,725
把新列表逆序塞到第二个列表中
and reverse that onto the second list.

429
00:21:24,703 --> 00:21:26,925
这并不是完成任务的很差的办法
Now that's not terribly bad way of doing it.

430
00:21:28,160 --> 00:21:28,850
然而
And however,

431
00:21:28,850 --> 00:21:32,025
程序所生成的中间结果
the intermediate result, which is the reversal of the first list

432
00:21:33,875 --> 00:21:35,576
即第一个逆序的列表
as done by this program,

433
00:21:36,700 --> 00:21:38,525
在它被复制回第二个列表之后
is never going to be accessed ever again

434
00:21:38,525 --> 00:21:40,568
再也不会被用到了
after it's copied back on to the second.

435
00:21:41,010 --> 00:21:42,232
它是个中间结果
It's an intermediate result.

436
00:21:43,580 --> 00:21:45,432
它很难被找到
It's going to be hard to ever see

437
00:21:46,075 --> 00:21:48,056
没有人能访问到它
how anybody would ever be able to access it.

438
00:21:48,600 --> 00:21:49,848
事实上 它会消失掉
In fact, it will go away.

439
00:21:51,050 --> 00:21:52,900
如果我们制造了大量这样的垃圾
Now if we make a lot of garbage like that,

440
00:21:52,900 --> 00:21:54,200
我们应该被允许这样做
and we should be allowed to,

441
00:21:54,800 --> 00:21:57,550
但应该有某些方法去回收这些垃圾
then there's got to be some way to reclaim that garbage.

442
00:21:58,800 --> 00:22:00,900
我现在要告诉你
Well, what I'd like to tell you about now

443
00:22:01,700 --> 00:22:03,775
一个非常聪明的技巧
is a very clever technique

444
00:22:04,325 --> 00:22:16,225
Lisp系统可以证明一个小定理#TBD
whereby a Lisp system can prove a small theorem every so often on the [? forum, ?] the following piece of junk will never be accessed again.

445
00:22:17,410 --> 00:22:19,809
它对将来的计算没有任何影响
It can have no affect on the future of the computation.

446
00:22:21,400 --> 00:22:23,841
事实上 这基于一个很简单的想法
It's actually based on a very simple idea.

447
00:22:24,725 --> 00:22:28,065
我们已经把计算机设计成这个样子
We've designed our computers to look sort of like this.

448
00:22:28,950 --> 00:22:30,943
有一些数据路径
There's some data path,

449
00:22:30,943 --> 00:22:33,505
保存了寄存器
which contains the registers.

450
00:22:35,280 --> 00:22:42,275
有EXP, ENV和VAL之类的东西
There are things like exp, and env, and val, and so on.

451
00:22:42,610 --> 00:22:44,025
这里有个叫STACK的东西
And there's one here called stack,

452
00:22:46,025 --> 00:22:49,071
某种指向一个结构的东西
some sort which points off to a structure somewhere,

453
00:22:49,071 --> 00:22:50,240
它是个栈
which is the stack.

454
00:22:50,240 --> 00:22:51,740
我们过一会再研究它
And we'll worry about that in a second.

455
00:22:51,740 --> 00:22:53,625
这有一些有限控制器
There's some finite controller,

456
00:22:54,389 --> 00:22:56,730
有限状态机控制器
finite state machine controller.

457
00:22:56,730 --> 00:22:59,513
这些控制信号通过这里
And there's some control signals that go this way and

458
00:22:59,800 --> 00:23:01,679
谓词结果通过这里
predicate results that come this way,

459
00:23:01,679 --> 00:23:03,350
这部分并不太有趣
not the interesting part.

460
00:23:03,350 --> 00:23:06,806
这里有某种结构化的内存
There's some sort of structured memory,

461
00:23:06,806 --> 00:23:08,271
我刚才给你讲过如何构建它
which I just told you how to make,

462
00:23:08,271 --> 00:23:10,460
它可能包括一个栈
which may contain a stack.

463
00:23:10,460 --> 00:23:12,431
我没有告诉你如何把东西构建成任意形状
I didn't tell you how to make things of arbitrary shape,

464
00:23:12,431 --> 00:23:13,450
只有序对
only pairs.

465
00:23:13,450 --> 00:23:14,350
但事实上
But in fact

466
00:23:14,350 --> 00:23:17,177
你可以用一个大列表来模拟栈
with what I've told you can simulate a stack by a big list.

467
00:23:17,775 --> 00:23:18,850
我没准备干这个
I don't plan to do that,

468
00:23:18,850 --> 00:23:20,360
这不是个好办法
it's not a nice way to do it.

469
00:23:20,360 --> 00:23:22,745
但是我们可以有这样一个东西
But we could have something like that.

470
00:23:22,990 --> 00:23:25,647
这里有各种数据结构
We have all sorts of little data structures in here

471
00:23:25,647 --> 00:23:27,750
它们通过有趣的方式互相连接
that are hooked together in funny ways.

472
00:23:30,115 --> 00:23:32,025
它们和其他东西连接到一起
They connect to other things.

473
00:23:32,560 --> 00:23:33,250
以此类推
And so on.

474
00:23:33,250 --> 00:23:34,225
归根结底
And ultimately

475
00:23:34,455 --> 00:23:37,190
这里的东西是指向这里的指针
things up there are pointers to these.

476
00:23:37,190 --> 00:23:38,873
寄存器里的东西
The things that are in the registers

477
00:23:39,407 --> 00:23:43,609
是指向Lisp结构内存的数据结构指针
are pointers off to the data structures that live in this Lisp structure memory.

478
00:23:44,910 --> 00:23:49,850
#TBD
Now the truth of the matter is

479
00:23:51,055 --> 00:23:54,266
机器的整个意识是在寄存器里的
that the entire consciousness of this machine is in these registers.

480
00:23:55,550 --> 00:23:58,750
如果这个机器
There is no possible way that the machine,

481
00:23:58,750 --> 00:24:01,374
构建得正确的话
if done correctly, if built correctly,

482
00:24:01,374 --> 00:24:03,418
它无法访问Lisp结构内存中任何东西
can access anything in this Lisp structure memory

483
00:24:04,575 --> 00:24:06,475
除了在Lisp结构内存中
unless the thing in that Lisp structure memory

484
00:24:08,095 --> 00:24:13,066
与序列数据结构连接的寄存器
is connected by a sequence of data structures to the registers.

485
00:24:15,070 --> 00:24:18,314
#TBD如果合法数据结构选择器
If it's accessible by legitimate data structure selectors

486
00:24:19,088 --> 00:24:21,322
通过寄存器里保存的指针能够访问它
from the pointers that are stored in these registers.

487
00:24:22,280 --> 00:24:24,650
类似数组引用
Things like array references, perhaps.

488
00:24:24,940 --> 00:24:28,170
或者#TBD
Or cons cell references, cars and cdrs.

489
00:24:28,790 --> 00:24:30,950
但我不能只讨论内存中的任意位置
But I can't just talk about a random place in this memory,

490
00:24:30,950 --> 00:24:31,950
因为我找不到它
because I can't get to it.

491
00:24:32,740 --> 00:24:34,904
#TBD
These are being arbitrary names I'm not allowed to count,

492
00:24:37,008 --> 00:24:38,985
#TBD
at least as I'm evaluating expressions.

493
00:24:41,620 --> 00:24:43,275
如果是这样的话
If that's the case

494
00:24:43,275 --> 00:24:45,336
就可以证明一个简单的理论
then there's a very simple theorem to be proved.

495
00:24:47,160 --> 00:24:47,900
就是说
Which is,

496
00:24:47,900 --> 00:24:50,520
#TBD
if I start with all lead pointers that are in all these registers

497
00:24:51,164 --> 00:24:52,550
递归地取出
and recursively chase out,

498
00:24:52,825 --> 00:24:56,150
把所有能访问到的东西做标记
marking all the places I can get to by selectors,

499
00:24:56,900 --> 00:24:59,400
最终就能标记所有能访问的东西
then eventually I mark everything they can be gotten to.

500
00:25:00,650 --> 00:25:02,699
任何未标记的都是垃圾
Anything which is not so marked is garbage

501
00:25:02,699 --> 00:25:03,750
它们可以被回收
and can be recycled.

502
00:25:05,560 --> 00:25:06,400
非常简单
Very simple.

503
00:25:07,200 --> 00:25:09,100
不会影响未来的计算
Cannot affect the future of the computation.

504
00:25:11,180 --> 00:25:15,750
看下这个特殊的例子
So let me show you that in a particular example.

505
00:25:17,124 --> 00:25:22,200
#TBD
Now that means I'm going to have to append to my description of the list structure a mark.

506
00:25:23,640 --> 00:25:27,825
在这里是一个Lisp结构化的内存
And so here, for example, is a Lisp structured memory.

507
00:25:29,080 --> 00:25:31,333
在这块内存里是一个Lisp数据结构
And in this Lisp structured memory is a Lisp structure

508
00:25:31,333 --> 00:25:34,150
我们把这个起始位置
beginning in a place I'm going to call--

509
00:25:35,875 --> 00:25:36,775
称为根
this is the root.

510
00:25:38,590 --> 00:25:40,120
它不必真是的根
Now it doesn't really have to have a root.

511
00:25:40,120 --> 00:25:41,950
因为有很多这种东西 与寄存器类似
It could be a bunch of them, like all the registers.

512
00:25:42,670 --> 00:25:44,138
但我可以#TBD
But I could cleverly arrange it

513
00:25:44,138 --> 00:25:46,300
因此所有的寄存器 所有在旧寄存器里的东西
so all the registers, all the things that are in old registers

514
00:25:46,300 --> 00:25:50,460
也应该放在这个根结构里
are also at the right moment put into this root structure,

515
00:25:50,460 --> 00:25:51,850
然后我们有一个指针指向它
and then we've got one pointer to it.

516
00:25:51,850 --> 00:25:52,675
我不是很在意
I don't really care.

517
00:25:54,570 --> 00:25:58,050
思路是 我们要一直把东西用cons连接起来 直到我们的free list为空
So the idea is we're going to cons up stuff until our free list is empty.

518
00:25:58,720 --> 00:25:59,675
我们用尽所有的空间
We've run out of things.

519
00:26:00,950 --> 00:26:04,475
现在我们要证明这个理论
Now we're going to do this process of proving the theorem

520
00:26:04,475 --> 00:26:06,900
#TBD
that a certain percentage of the memory has got crap in it.

521
00:26:07,850 --> 00:26:09,250
然后我们要回收它
And then we're going to recycle that

522
00:26:09,787 --> 00:26:10,875
构建一个新的树
to grow new trees,

523
00:26:11,904 --> 00:26:14,570
这是对于垃圾基本处理方式
a standard use of such garbage.

524
00:26:17,090 --> 00:26:18,840
那么我们要做什么呢?
So in any case, what do we have here?

525
00:26:18,840 --> 00:26:22,545
从p5这个位置开始
Well we have some data structure which starts out over here

526
00:26:22,545 --> 00:26:24,275
存了一些数据结构
in p5.

527
00:26:25,150 --> 00:26:26,750
从1开始
and it will start at one

528
00:26:27,275 --> 00:26:32,209
事实上 p5是一个CAR
And in fact it has a car in p5,

529
00:26:32,209 --> 00:26:33,980
它的CDR在2这个位置
and its cdr is in two.

530
00:26:33,980 --> 00:26:35,800
所有标记都是从0开始的
And all the marks start out at zero.

531
00:26:36,700 --> 00:26:39,000
我们要开始标记了
Well let's start marking, just to play this game.

532
00:26:39,920 --> 00:26:40,525
好
OK.

533
00:26:42,540 --> 00:26:44,475
例如
So for example,

534
00:26:44,475 --> 00:26:46,950
因为我可以从根访问到它
since I can access one from the root

535
00:26:46,950 --> 00:26:47,975
我就标记一下
I will mark that.

536
00:26:48,390 --> 00:26:49,175
让我标记一下
Let me mark it.

537
00:26:50,960 --> 00:26:51,450
砰
Bang.

538
00:26:52,430 --> 00:26:53,150
这个被标记了
That's marked.

539
00:26:54,560 --> 00:26:57,510
因为这有个5
Now since I have a five here

540
00:26:57,510 --> 00:26:58,675
所以我跑到了5
I can go to five

541
00:26:59,025 --> 00:27:00,725
看 我要标记这个
and see, well I'll mark that.

542
00:27:01,450 --> 00:27:01,760
砰
Bang.

543
00:27:01,760 --> 00:27:02,600
这是个有用的东西
That's useful stuff.

544
00:27:02,900 --> 00:27:05,275
但5的CAR是个数字
But five references as a number in its car,

545
00:27:05,275 --> 00:27:06,765
我对标记数字不感兴趣
I'm not interested in marking numbers

546
00:27:06,765 --> 00:27:08,175
但它的CDR是7
but its cdr is seven.

547
00:27:08,700 --> 00:27:09,750
所以我可以标记它
So I can mark that.

548
00:27:10,450 --> 00:27:11,075
砰
Bang.

549
00:27:12,260 --> 00:27:13,400
7是一个空列表
Seven is the empty list,

550
00:27:13,675 --> 00:27:15,100
#TBD
the only thing that references,

551
00:27:15,595 --> 00:27:17,120
它的CAR是个数字
and it's got a number in its car.

552
00:27:17,120 --> 00:27:17,850
对它不感兴趣
Not interesting.

553
00:27:19,490 --> 00:27:20,500
让我们回到这里
Well now let's go back here.

554
00:27:20,500 --> 00:27:21,650
我忘记了一些事情
I forgot about something.

555
00:27:21,650 --> 00:27:22,175
2
Two.

556
00:27:22,840 --> 00:27:24,850
换句话说 如果我看格子1
See in other words, if I'm looking at cell one,

557
00:27:25,425 --> 00:27:29,450
格子1包括了一个2
cell one contains a two right over here.

558
00:27:30,370 --> 00:27:31,300
一个到2的引用
A reference to two.

559
00:27:31,730 --> 00:27:34,975
这意味着我应该标记2
That means I should go mark two.

560
00:27:35,700 --> 00:27:36,275
砰
Bang.

561
00:27:37,140 --> 00:27:38,960
2包括了一个到4的引用
Two contains a reference to four.

562
00:27:38,960 --> 00:27:40,279
它的CAR是个数字
It's got a number in its car,

563
00:27:40,279 --> 00:27:41,200
我对它不感兴趣
I'm not interested in that

564
00:27:41,475 --> 00:27:42,600
所以我要标记它
so I'm going to go mark that.

565
00:27:43,780 --> 00:27:46,100
4通过CAR引用了7
Four refers to seven through its car,

566
00:27:46,750 --> 00:27:48,475
它的CDR是空的
and is empty in its cdr,

567
00:27:48,475 --> 00:27:49,576
但由于我已经标记过了
but I've already marked that one

568
00:27:49,576 --> 00:27:50,750
就不再次标记它了
so I don't have to mark it again.

569
00:27:51,400 --> 00:27:53,875
这就是这个地方所有能够访问的结构
This is all the accessible structure from that place.

570
00:27:55,000 --> 00:27:56,575
很简单的递归标记算法
Simple recursive mark algorithm.

571
00:27:58,710 --> 00:28:01,900
这个算法有一些不足的地方
Now there are some unhappinesses about that algorithm,

572
00:28:01,900 --> 00:28:04,025
我们稍后会说
and we can worry about that a second.

573
00:28:04,920 --> 00:28:06,525
但基本上你能看到
But basically you'll see

574
00:28:06,525 --> 00:28:07,850
所有没被标记的地方
that all the things that have not been marked

575
00:28:09,625 --> 00:28:11,504
都是无用的
are places that are free,

576
00:28:11,504 --> 00:28:12,525
可以回收
and I could recycle.

577
00:28:14,250 --> 00:28:15,750
所以下一步就是
So the next stage after that is going to be

578
00:28:15,750 --> 00:28:17,050
扫描整个内存
to scan through all of my memory,

579
00:28:17,945 --> 00:28:20,350
寻找未被标记的东西
looking for things that are not marked.

580
00:28:21,180 --> 00:28:22,450
每当遇到一个已标记的东西
Every time I come across a marked thing

581
00:28:22,450 --> 00:28:23,225
就把标记去掉
I unmark it,

582
00:28:23,225 --> 00:28:25,575
每当遇到未标记的东西时
and every time I come across an unmarked thing

583
00:28:26,297 --> 00:28:27,825
我就把它连接到我的自由表里面
I'm going to link it together in my free list.

584
00:28:28,770 --> 00:28:30,300
传统而且非常简单的算法
Classic, very simple algorithm.

585
00:28:32,120 --> 00:28:33,100
我们看
So let's see.

586
00:28:33,840 --> 00:28:34,770
它很简单吗?
Is that very simple?

587
00:28:34,770 --> 00:28:35,570
是的
Yes it is.

588
00:28:35,570 --> 00:28:38,009
我不会深入代码细节
I'm not going to go through the code in any detail,

589
00:28:38,009 --> 00:28:39,650
只是想给你看看它有多长
but I just want to show you about how long it is.

590
00:28:40,090 --> 00:28:41,100
看这个标记阶段
Let's look at the mark phase.

591
00:28:41,575 --> 00:28:44,145
这是标记阶段的第一部分
Here's the first part of the mark phase.

592
00:28:45,060 --> 00:28:46,000
我们找到根
We pick up the root.

593
00:28:46,500 --> 00:28:47,525
我们要
We're going to do some

594
00:28:47,675 --> 00:28:51,050
我们要对它进行递归过程调用
We're going to use that as a recursive procedure call.

595
00:28:52,380 --> 00:28:54,475
当我们完成标记之后
We're going to sweep from there,

596
00:28:54,775 --> 00:28:56,950
就从这里开始清除
after when we're done with marking.

597
00:28:57,380 --> 00:29:03,075
#TBD
And then we're going to do a little couple of instructions that do this checking out on the marks and changing the marks and things like that,

598
00:29:03,075 --> 00:29:04,900
按照我刚才讲的那个算法进行
according to the algorithm I've just shown you.

599
00:29:05,500 --> 00:29:06,470
#TBD
It comes out here.

600
00:29:06,470 --> 00:29:07,650
你需要标记它们的CAR
You have to mark the cars of things

601
00:29:07,875 --> 00:29:10,212
也需要标记它们的CDR
and you also have to be able to mark the cdrs of things.

602
00:29:10,660 --> 00:29:12,100
这就是整个标记阶段
That's the entire mark phase.

603
00:29:14,370 --> 00:29:16,164
我给你讲个关于它的小故事
I'll just tell you a little story about this.

604
00:29:16,590 --> 00:29:19,375
古董货DEC PDP-6计算机
The old DEC PDP-6 computer,

605
00:29:20,937 --> 00:29:24,850
它的标记清除垃圾回收就是这样的
this was the way that the mark-sweep garbage collection, as it was, was written.

606
00:29:26,740 --> 00:29:28,500
程序很短
The program was so small

607
00:29:29,257 --> 00:29:31,600
包括它需要的数据
that with the data that it needed,

608
00:29:32,201 --> 00:29:34,875
还包括它用来操作内存的寄存器
with the registers that it needed to manipulate the memory,

609
00:29:36,169 --> 00:29:38,975
能放到机器的快速寄存器里 #TBD 16
it fit into the fast registers of the machine, which were 16.

610
00:29:39,280 --> 00:29:39,800
整个程序
The whole program.

611
00:29:39,800 --> 00:29:42,212
你可以在快速寄存器里执行指令
And you could execute instructions in the fast registers.

612
00:29:43,170 --> 00:29:45,000
所以这是个非常短的程序
So it's an extremely small program,

613
00:29:45,850 --> 00:29:47,075
它跑得飞快
and it could run very fast.

614
00:29:48,870 --> 00:29:51,300
很不幸
Now unfortunately, of course,

615
00:29:51,610 --> 00:29:54,025
因为这个程序是递归的
this program, because the fact that it's recursive

616
00:29:54,800 --> 00:29:59,216
#TBD
in the way that you do something first and then you do something after that,

617
00:29:59,216 --> 00:30:01,150
你不得不先处理CAR 再处理CDR
you have to work on the cars and then the cdrs,

618
00:30:01,150 --> 00:30:02,750
这需要海量的内存
it requires auxiliary memory.

619
00:30:03,410 --> 00:30:07,425
所以Lisp系统需要一个栈来进行标记
So Lisp systems-- those requires a stack for marking.

620
00:30:08,260 --> 00:30:11,050
Lisp系统通过这样的方式
Lisp systems that are built this way

621
00:30:11,575 --> 00:30:14,425
限制了你在数据结构上
have a limit to the depth of recursion you can have

622
00:30:14,425 --> 00:30:17,375
进行CAR或者CDR递归的深度
in data structures in either the car or the cdr,

623
00:30:17,817 --> 00:30:19,350
这并不太靠谱
and that doesn't work very nicely.

624
00:30:19,930 --> 00:30:22,175
另一方面 当它足够大的时候你不会发现
On the other hand, you never notice it if it's big enough.

625
00:30:23,180 --> 00:30:28,697
例如对于Maclisp#TBD
And that's certainly been the case for most Maclisp, for example,

626
00:30:28,697 --> 00:30:32,725
#TBD
which ran Macsyma where you could deal with expressions of thousands of elements long.

627
00:30:33,560 --> 00:30:36,025
#TBD
These are algebraic expressions with thousand of terms.

628
00:30:36,825 --> 00:30:38,100
这没什么问题
And there's no problem with that.

629
00:30:39,490 --> 00:30:40,825
垃圾回收器能正常工作
Such, the garbage collector does work.

630
00:30:42,190 --> 00:30:42,925
另一方面
On the other hand,

631
00:30:42,925 --> 00:30:45,375
这个算法有个很精妙的魔改版
there's a very clever modification to this algorithm,

632
00:30:45,375 --> 00:30:46,475
但我不会去讲
which I will not describe,

633
00:30:46,800 --> 00:30:50,768
它是由两个人提出的
by Peter Deutsch and Schorr and Waite--

634
00:30:50,768 --> 00:30:52,725
IBM的Herb Schorr和Waite
Herb Schorr from IBM and Waite,

635
00:30:52,725 --> 00:30:54,750
后者我不认识
who I don't know.

636
00:30:55,380 --> 00:30:56,675
这个算法让你
That algorithm allows you to build--

637
00:30:56,675 --> 00:30:59,550
能够不消耗大量内存就完成工作
you do can do this without auxiliary memory,

638
00:31:00,500 --> 00:31:02,975
通过反转你下降的时候的指针
by remembering as you walk the data structures

639
00:31:02,975 --> 00:31:05,525
#TBD
where you came from by reversing the pointers as you go down

640
00:31:05,525 --> 00:31:07,520
通过反转的指针再回去
and crawling up the reverse pointers as you go up.

641
00:31:07,520 --> 00:31:09,130
这是个很取巧的算法
It's a rather tricky algorithm.

642
00:31:09,130 --> 00:31:12,725
你第一次写它 事实上 前三次你写的时候都会写出惊天大bug
The first time you write it-- or in fact, the first three times you write it it has a terrible bug in it.

643
00:31:14,350 --> 00:31:16,725
也可能跑得奇慢无比
And it's also rather slow,

644
00:31:16,725 --> 00:31:17,675
因为这个算法太复杂了
because it's complicated.

645
00:31:18,110 --> 00:31:20,450
它用了七倍的内存引用
It takes about six times as many memory references

646
00:31:20,850 --> 00:31:23,225
来完成我们刚才讨论的任务
to do the sorts of things that we're talking about.

647
00:31:24,580 --> 00:31:27,075
一旦我完成了标记阶段
Well now once I've done this marking phase,

648
00:31:27,500 --> 00:31:31,510
#TBD
and I get into a position where things look like this, let's look-- yes.

649
00:31:31,510 --> 00:31:35,050
这里完成了标记工作 和我刚才做的一样
Here we have the mark done, just as I did it.

650
00:31:35,590 --> 00:31:37,330
现在我们要进行清除阶段
Now we have to perform the sweep phase.

651
00:31:37,330 --> 00:31:39,325
我刚才已经讲过如何清除了
And I described to you what this sweep is like.

652
00:31:39,820 --> 00:31:42,348
我要从内存的一端开始
I'm going to walk down from one end of memory or the other,

653
00:31:42,348 --> 00:31:43,628
哪一端都可以
I don't care where,

654
00:31:43,628 --> 00:31:46,175
扫描内存中的每个格子
scanning every cell that's in the memory.

655
00:31:47,175 --> 00:31:48,675
在扫描的同时
And as I scan these cells,

656
00:31:49,207 --> 00:31:51,950
如果是空闲内存
I'm going to link them together, if they are free,

657
00:31:51,950 --> 00:31:53,150
就把它们连接到自由表里
into the free list.

658
00:31:53,150 --> 00:31:54,050
如果它们不是空闲内存
And if they're not free,

659
00:31:54,050 --> 00:31:56,075
我就把它们的标记清除掉
I'm going to unmark them so the marks become zero.

660
00:31:57,500 --> 00:31:58,700
事实上
And in fact what I get--

661
00:31:58,700 --> 00:32:00,460
最终的程序并不很复杂
well the program is not very complicated.

662
00:32:00,460 --> 00:32:02,225
它只是变长了一些
It looks sort of like this-- it's a little longer.

663
00:32:02,780 --> 00:32:04,175
这是第一部分
Here's the first piece of it.

664
00:32:04,820 --> 00:32:06,710
它从内存的顶端下降下来
This one's coming down from the top of memory.

665
00:32:06,710 --> 00:32:09,580
我不期望你现在就搞懂它
I don't want you to try to understand this at this point.

666
00:32:09,580 --> 00:32:10,550
它挺简单的
It's rather simple.

667
00:32:11,030 --> 00:32:12,525
这是个非常简单的算法
It's a very simple algorithm,

668
00:32:13,075 --> 00:32:15,970
#TBD
but there's pieces of it that just sort of look like this.

669
00:32:15,970 --> 00:32:17,375
非常显而易见
They're all sort of obvious.

670
00:32:18,600 --> 00:32:20,307
在清理结束后
And after we've done the sweep,

671
00:32:20,307 --> 00:32:22,025
我们就得到了长这个样子的结果
we get an answer that looks like that.

672
00:32:25,330 --> 00:32:28,500
标记清除算法有一些缺点
Now there are some disadvantages with mark-sweep algorithms of this sort.

673
00:32:29,590 --> 00:32:30,350
最严重的一个是
Serious ones.

674
00:32:31,450 --> 00:32:33,203
最重要的缺点是
One important disadvantage is

675
00:32:33,203 --> 00:32:34,975
你的内存越来越大
that your memories get larger and larger.

676
00:32:36,826 --> 00:32:38,875
内存空间越来越大
As you say, address spaces get larger and larger,

677
00:32:38,875 --> 00:32:40,800
你想用它存更多东西
you're willing to represent more and more stuff,

678
00:32:41,370 --> 00:32:44,750
这导致扫描整个内存的耗时特别长
then it gets very costly to scan all of memory.

679
00:32:46,360 --> 00:32:48,900
你真正想做的是只扫描有用的东西
What you'd really like to do is only scan useful stuff.

680
00:32:50,490 --> 00:32:51,550
这样就会好一点
It would even be better

681
00:32:52,075 --> 00:32:57,725
如果你意识到有些东西是有用的
if you realized that some stuff was known to be good and useful,

682
00:32:58,283 --> 00:33:00,370
你就没必要去多次检查它
and you don't have to look at it more than once or twice.

683
00:33:00,370 --> 00:33:01,200
或者不用经常去检查它
Or very rarely.

684
00:33:01,550 --> 00:33:04,325
对于那些你不太确定的
Whereas other stuff that you're not so sure about,

685
00:33:05,003 --> 00:33:06,425
你可以在每次需要的时候
you can look at more detail

686
00:33:07,100 --> 00:33:08,750
进行仔细检查
every time you want to do this,

687
00:33:09,931 --> 00:33:10,850
也就是垃圾回收的时候
want to garbage collect.

688
00:33:11,910 --> 00:33:15,100
这些算法就是用了这样的方法
Well there are algorithms that are organized in this way.

689
00:33:15,660 --> 00:33:18,282
我要介绍一个著名的古老算法
Let me tell you about a famous old algorithm

690
00:33:18,282 --> 00:33:21,375
它让你只检查可用部分的内存
which allows you only look at the part of memory which is known to be useful.

691
00:33:22,800 --> 00:33:25,550
这让它成为了最快的垃圾回收算法
And which happens to be the fastest known garbage collector algorithm.

692
00:33:26,310 --> 00:33:29,450
它就是Minsky-Fenichel-Yochelson垃圾回收算法
This is the Minsky-Fenichel-Yochelson garbage collector algorithm.

693
00:33:30,150 --> 00:33:36,525
它在1961年或1960年时由Minsky发明
It was invented by Minsky in 1961 or '60 or something,

694
00:33:36,525 --> 00:33:39,825
当时是给RLE PDP-1 Lisp用的
for the RLE PDP-1 Lisp,

695
00:33:40,125 --> 00:33:43,584
这个机器只有4096个字的线性内存
which had 4,096 words of list memory,

696
00:33:45,650 --> 00:33:46,800
还有个磁鼓
and a drum.

697
00:33:48,480 --> 00:33:51,875
#TBD
And the whole idea was to garbage collect this terrible memory.

698
00:33:53,050 --> 00:33:55,625
Minsky发现打成目的最容易的方法是
What Minsky realized was the easiest way to do this

699
00:33:56,200 --> 00:33:58,475
一视同仁地扫描整个内存
is to scan the memory in the same sense,

700
00:33:58,475 --> 00:34:00,600
遍历好的结构
walking the good structure,

701
00:34:01,575 --> 00:34:03,525
把它复制到磁鼓中
copying it out into the drum,

702
00:34:04,700 --> 00:34:05,475
压缩一下
compacted.

703
00:34:06,350 --> 00:34:09,127
之后把它们复制出来
And then when we were done copying it all out,

704
00:34:09,127 --> 00:34:10,900
并把它们交换回内存里
then you swap that back into your memory.

705
00:34:12,300 --> 00:34:14,710
不管你有没有用磁鼓或者其他的内存
Now whether or you not use a drum, or another piece of memory,

706
00:34:14,710 --> 00:34:16,425
这不重要
or something like that isn't important.

707
00:34:17,030 --> 00:34:17,575
事实上
In fact,

708
00:34:17,575 --> 00:34:19,600
我觉得现在应该没人用磁鼓了吧
I don't think people use drums anymore for anything.

709
00:34:20,350 --> 00:34:25,425
但这个算法依赖
But this algorithm basically depends upon having

710
00:34:25,425 --> 00:34:28,575
大约两倍于你实际使用的内存
about twice as much address space as you're actually using.

711
00:34:30,270 --> 00:34:33,125
最开始 你有一些
And so what you have is some, initially,

712
00:34:33,125 --> 00:34:36,600
可用的数据和垃圾的混合物
some mixture of useful data and garbage.

713
00:34:37,110 --> 00:34:38,975
它被成为fromspace
So this is called fromspace.

714
00:34:45,179 --> 00:34:47,050
这是crud的混合
And this is a mixture of crud.

715
00:34:47,800 --> 00:34:49,950
有些是有用的有些没有
Some of it's important and some of it isn't.

716
00:34:52,000 --> 00:34:55,775
有一个地方需要足够大
Now there's another place which is hopefully big enough,

717
00:34:55,775 --> 00:34:57,123
这个地方叫topspace
if we recall, tospace,

718
00:34:57,123 --> 00:34:58,240
要把东西复制进去
which is where we're copying to.

719
00:35:01,590 --> 00:35:02,600
然后就发生了
And what happens is--

720
00:35:02,600 --> 00:35:04,970
我不会深入细节
and I'm not going to go through this detail.

721
00:35:04,970 --> 00:35:07,075
书上写得很清楚了
It's in our book quite explicitly.

722
00:35:07,590 --> 00:35:10,400
有一个你开始的根节点
There's a root point where you start from.

723
00:35:11,030 --> 00:35:14,300
你从这里开始
And the idea is that you start with the root.

724
00:35:14,600 --> 00:35:16,425
复制你看到的第一个东西
You copy the first thing you see,

725
00:35:17,832 --> 00:35:19,752
根指针指向的第一个东西
the first thing that the root points at,

726
00:35:19,752 --> 00:35:21,425
复制到topspace的开始
to the beginning of tospace.

727
00:35:22,810 --> 00:35:25,975
第一个东西是一个序对或者数据结构
The first thing is a pair or something like, a data structure.

728
00:35:27,560 --> 00:35:31,775
然后在那里留下一个破碎的心
You then also leave behind a broken heart saying,

729
00:35:31,775 --> 00:35:35,743
表示我把东西从这移动到这
I moved this object from here to here,

730
00:35:35,743 --> 00:35:37,050
在它要去的地方分配空间
giving the place where it moved to.

731
00:35:37,800 --> 00:35:39,650
叫作破碎的心是因为
This is called a broken heart because

732
00:35:39,650 --> 00:35:43,825
1966年我的一个朋友实现了它
a friend of mine who implemented one of these in 1966

733
00:35:43,825 --> 00:35:45,262
而他是个文艺青年
was a very romantic character

734
00:35:45,262 --> 00:35:46,760
就取名叫破碎的心
and called it a broken heart.

735
00:35:49,580 --> 00:35:51,150
不论如何
But in any case,

736
00:35:51,150 --> 00:35:52,942
接下来要做的是
the next thing you do

737
00:35:52,942 --> 00:35:55,175
这有个新的free pointer
is now you have a new free pointer which is here,

738
00:35:55,175 --> 00:35:57,840
你开始扫描
and you start scanning.

739
00:35:57,840 --> 00:35:59,775
你扫描这个你刚复制过的数据结构
You scan this data structure you just copied.

740
00:36:00,551 --> 00:36:02,195
每当你encounter一个指针到里面
And every time you encounter a pointer in it,

741
00:36:02,195 --> 00:36:04,000
你把它当作根指针
you treat it as if it was the root pointer here.

742
00:36:04,000 --> 00:36:05,170
对不起
Oh, I'm sorry.

743
00:36:05,170 --> 00:36:07,150
你做的另一件事是 你将根指针移动到这里
The other thing you do is you now move the root pointer to there.

744
00:36:09,220 --> 00:36:10,175
所以你可以扫描这里
So now you scan this,

745
00:36:10,175 --> 00:36:12,375
把每个遇到的东西都作为根指针对待
and everything you see you treat as it were the root pointer.

746
00:36:14,110 --> 00:36:15,450
如果你看到了什么
So if you see something,

747
00:36:15,450 --> 00:36:17,400
它指向了这里的某个地方
well it points up into there somewhere.

748
00:36:18,510 --> 00:36:21,125
它指向了你没复制的东西吗?
Is it pointing at a thing which you've not copied yet?

749
00:36:21,780 --> 00:36:22,875
这里有破碎的心吗
Is there a broken heart there?

750
00:36:23,880 --> 00:36:24,844
如果那有破碎的心
If there's a broken heart there

751
00:36:24,844 --> 00:36:26,202
就说明那里有东西被复制了
and it's something you have copied,

752
00:36:26,202 --> 00:36:28,750
#TBD
you've just replaced this pointer with the thing a broken heart points at.

753
00:36:29,825 --> 00:36:32,125
如果它还没被复制
If this thing has not been copied,

754
00:36:32,125 --> 00:36:34,430
你把它复制到这里
you copy it to the next place over here.

755
00:36:34,430 --> 00:36:35,950
把你的free指针移到这里
Move your free pointer over here,

756
00:36:37,053 --> 00:36:40,825
然后在那放个破碎的心
and then leave a broken heart behind

757
00:36:41,050 --> 00:36:41,800
继续扫描
and scan.

758
00:36:43,670 --> 00:36:46,400
最终已扫描的指针追上了free指针
And eventually when the scant pointer hits the free pointer,

759
00:36:46,825 --> 00:36:48,525
内存里的所有东西都被复制了
everything in memory has been copied.

760
00:36:50,140 --> 00:36:52,075
那么就有一大堆空闲空间了
And then there's a whole bunch of empty space up here,

761
00:36:52,075 --> 00:36:54,470
你就可以把它们放进自由表里
which you could either make into a free list, if that's what you want to do.

762
00:36:54,470 --> 00:36:56,270
但通常在这种系统中你不会这样做
But generally you don't in this kind of system.

763
00:36:56,270 --> 00:36:59,150
在这个系统中你顺序分配你的内存
In this system you sequentially allocate your memory.

764
00:37:00,910 --> 00:37:02,975
这是个非常 非常好的算法
That is a very, very nice algorithm,

765
00:37:02,975 --> 00:37:05,975
在你们用的scheme里就有这样的东西
and sort of the one we use in the scheme that you've been using.

766
00:37:06,790 --> 00:37:09,475
它应该是--
And it's expected--

767
00:37:09,475 --> 00:37:12,125
我相信没人能发现比它跑得更快的算法
I believe no one has found a faster algorithm than that.

768
00:37:12,400 --> 00:37:14,850
有一些对这个算法的简单修改
There are very simple modifications to this algorithm

769
00:37:14,850 --> 00:37:16,775
由Henry Baker发明
invented by Henry Baker

770
00:37:17,175 --> 00:37:20,311
它让你能实时运行这个算法
which allow one to run this algorithm in real time,

771
00:37:20,311 --> 00:37:22,010
这意味着你在垃圾回收的时候不需要停下来
meaning you don't have to stop to garbage collect.

772
00:37:22,010 --> 00:37:26,327
你能让机器运行的CONS操作
But you could interleave the consing that the machine does when its running

773
00:37:26,327 --> 00:37:28,400
与垃圾回收过程交错进行
with steps of the garbage collection process,

774
00:37:28,850 --> 00:37:31,200
垃圾回收器是分散式的
so that the garbage
collector's distributed

775
00:37:31,200 --> 00:37:32,416
机器不需要停下来
and the machine doesn't have to stop,

776
00:37:32,416 --> 00:37:33,475
再让垃圾回收开始运作
and garbage collecting can start.

777
00:37:34,640 --> 00:37:38,000
在使用虚拟内存的机器中
Of course in the case of machines with virtual memory

778
00:37:38,900 --> 00:37:41,509
其中有很多无法访问的地方
where a lot of it is in inaccessible places,

779
00:37:41,509 --> 00:37:43,600
会使过程变得十分昂贵
this becomes a very expensive process.

780
00:37:44,460 --> 00:37:48,650
有许多对它进行改进的尝试
And there have been numerous attempts to make this much better.

781
00:37:49,190 --> 00:37:52,645
对于感兴趣的同学 这有一篇论文
There is a nice paper, for those of you who are interested,

782
00:37:52,645 --> 00:37:54,650
由Moon等人写的
by Moon and other people

783
00:37:54,650 --> 00:37:59,514
这篇论文描述了对于insky-Fenichel-Yochelson算法的一种改良办法
which describes a modification to the incremental Minsky-Fenichel-Yochelson algorithm,

784
00:37:59,514 --> 00:38:01,425
和Baker算法的一个修改
and modification the Baker algorithm

785
00:38:01,425 --> 00:38:06,600
让使用虚拟内存的系统更加高效
which is more efficient for virtual memory systems.

786
00:38:08,340 --> 00:38:12,840
现在最后一个谜团也解开了
Well I think now the mystery to this is sort of gone.

787
00:38:12,840 --> 00:38:14,090
谁有问题呢
And I'd like to see if there are any questions.

788
00:38:19,780 --> 00:38:20,810
请讲
Yes.

789
00:38:20,810 --> 00:38:25,125
学生: 我在楼上的一些系统里看到你运行的垃圾回收器
AUDIENCE: I saw one of you run the garbage collector on the systems upstairs,

790
00:38:25,937 --> 00:38:28,497
它看起来跑得飞快
and it seemed to me to run extremely fast.

791
00:38:28,497 --> 00:38:31,880
它真的清理了整个内存吗?
Did the whole thing take-- does it sweep through all of memory?

792
00:38:31,880 --> 00:38:32,510
教授: 没有
PROFESSOR: No.

793
00:38:32,510 --> 00:38:35,912
它只清理了那些需要复制有用数据结构的内存
It swept through exactly what was needed to copy the useful structure.

794
00:38:37,320 --> 00:38:38,950
它是个复制收集器
It's a copying collector.

795
00:38:39,300 --> 00:38:44,600
它确实很快#TBD
And it is very fast. On the whole, I suppose to copy--

796
00:38:45,050 --> 00:38:48,442
#TBD
in a Bobcat-- to copy,

797
00:38:48,442 --> 00:38:53,200
一个3MB的东西将在1秒内完成
I think, a three megabyte thing or something is less than a second, real time.

798
00:38:54,925 --> 00:38:58,625
它们是非常小的程序
Really, these are very small programs.

799
00:38:58,625 --> 00:39:02,200
你需要注意到的一件事是
One thing you should realise is that

800
00:39:02,913 --> 00:39:04,400
垃圾回收器必须要小
garbage collectors have to be small.

801
00:39:05,400 --> 00:39:07,100
不是因为它们需要跑得很快
Not because they have to be fast,

802
00:39:07,905 --> 00:39:10,650
而是因为没人能对一个复杂的垃圾回收器排查错误
but because no one can debug a complicated garbage collector.

803
00:39:11,340 --> 00:39:13,075
如果一个垃圾回收器不能正常工作
A garbage collector, if it doesn't work,

804
00:39:14,049 --> 00:39:15,933
它会把你的内存搞得一团糟
will trash your memory in such a way

805
00:39:15,933 --> 00:39:17,550
而你却束手无策
that you cannot figure out what the hell happened.

806
00:39:18,350 --> 00:39:19,675
#TBD
You need an audit trail.

807
00:39:20,660 --> 00:39:22,150
因为它把所有东西都换了位置
Because it rearranges everything,

808
00:39:22,150 --> 00:39:23,336
你又如何知道发生了什么
and how do you know what happened there?

809
00:39:23,740 --> 00:39:26,587
#TBD
So this is the only kind of program that

810
00:39:26,925 --> 00:39:31,970
#TBD
it really, seriously matters if you stare at it long enough so you believe that it works.

811
00:39:31,970 --> 00:39:33,400
#TBD
And sort of prove it to yourself.

812
00:39:35,100 --> 00:39:36,940
无法对它进行查错
So there's no way to debug it.

813
00:39:36,940 --> 00:39:38,960
这意味着它需要足够小
And that takes it being small enough

814
00:39:38,960 --> 00:39:39,975
让你能脑补出它的工作情况
so you can hold it in your head.

815
00:39:41,690 --> 00:39:43,925
垃圾回收器的就是如此特殊
Garbage collectors are special in this way.

816
00:39:45,020 --> 00:39:46,775
所以每个#TBD的垃圾回收器一定体积很小
So every reasonable garbage collector has gotten small,

817
00:39:46,775 --> 00:39:48,450
而通常小程序跑得就快
and generally small programs are fast.

818
00:39:52,050 --> 00:39:52,430
请提问
Yes.

819
00:39:52,430 --> 00:39:54,510
学生: 您能再重复一遍这个技术的名字吗?
AUDIENCE: Can you repeat the name of this technique once again?

820
00:39:54,510 --> 00:39:56,925
教授: 是Minsky-Fenichel-Yochelson垃圾回收器
PROFESSOR: That's the Minsky-Fenichel-Yochelson garbage collector.

821
00:39:58,420 --> 00:39:59,340
学生: 啥?
AUDIENCE: You got that?

822
00:39:59,340 --> 00:40:02,210
教授: Minsky在1961年时为RLE PDP-1发明了它
PROFESSOR: Minsky invented it in '61 for the RLE PDP-1.

823
00:40:02,210 --> 00:40:06,450
它的一个版本被Fenichel和Yochelson继续开发优化后
A version of it was developed and elaborated

824
00:40:06,450 --> 00:40:10,275
被用在了Multics Maclisp里面
to be used in Multics Maclisp by Fenichel and Yochelson

825
00:40:11,378 --> 00:40:14,750
那时大约是1968或者1969年
in somewhere around 1968 or '69.

826
00:40:19,570 --> 00:40:20,650
好
OK.

827
00:40:20,650 --> 00:40:21,400
休息一下
Let's take a break.

828
00:40:22,640 --> 00:41:16,675
[音乐]
[JESU, JOY OF MAN'S DESIRING]

829
00:41:17,310 --> 00:41:19,675
教授: 我们到课程的最后一部分了
PROFESSOR: Well we've come to the end of this subject,

830
00:41:19,675 --> 00:41:23,850
我已经给你们展示了一个通用的机器
and we've already shown you a universal machine

831
00:41:24,475 --> 00:41:26,740
它被简化为求值器
which is down to evaluator.

832
00:41:27,025 --> 00:41:28,388
它被简化到
It's down to the level of detail

833
00:41:28,388 --> 00:41:29,675
你能想象自己可以做一个
you could imagine you could make one.

834
00:41:30,420 --> 00:41:33,325
这就是个特定的Lisp实现
This is a particular implementation of Lisp,

835
00:41:33,900 --> 00:41:36,074
就是用我昨天讲到的
built on one of those

836
00:41:36,074 --> 00:41:38,050
scheme芯片做的
scheme chips that was talked about yesterday,

837
00:41:38,050 --> 00:41:39,180
就是这个
sitting over here.

838
00:41:39,350 --> 00:41:42,000
#TBD
This is mostly interface to somebody's memory

839
00:41:42,600 --> 00:41:44,750
#TBD
with a little bit of timing and other such stuff.

840
00:41:45,225 --> 00:41:47,250
但它们实际能以合理的速度
But this fellow actually ran Lisp

841
00:41:47,775 --> 00:41:50,175
运行Lisp
at a fairly reasonable rate, as interpretive.

842
00:41:50,610 --> 00:41:53,825
它跑得像1979年的
It ran Lisp as fast as a DEC PDP-10

843
00:41:54,225 --> 00:41:55,650
DEC PDP-10一样快
back in 1979.

844
00:41:56,500 --> 00:41:59,675
这是一个硬件
And so it's gotten pretty hardware.

845
00:42:00,025 --> 00:42:02,175
是个实物
Pretty concrete.

846
00:42:02,470 --> 00:42:06,075
#TBD
We've also downed you a bit with the things you can compute.

847
00:42:07,370 --> 00:42:10,550
那么有我们无法计算的情况吗?
But is it the case that there are things we can't compute?

848
00:42:11,850 --> 00:42:13,500
让我以展示一些
And so I'd like to end this with

849
00:42:13,750 --> 00:42:17,225
你不能计算的东西作为结尾
showing you some things that you'd like be able to compute that you can't.

850
00:42:18,190 --> 00:42:19,375
答案是 是的
The answer is yes,

851
00:42:19,375 --> 00:42:20,825
有无法计算的事物
there are things you can't compute.

852
00:42:22,720 --> 00:42:23,471
例如
For example,

853
00:42:24,450 --> 00:42:25,825
你很想要这样一种东西
something you'd really like is--

854
00:42:27,800 --> 00:42:29,300
当你正在写一个编译器时
if you're writing a compiler

855
00:42:29,775 --> 00:42:31,425
你想要一个程序
you'd like a program that would check

856
00:42:32,000 --> 00:42:33,975
检查你的代码能不能正常运行
that the thing you're going to do will work.

857
00:42:34,630 --> 00:42:35,400
这不是很棒吗?
Wouldn't that be nice?

858
00:42:36,080 --> 00:42:37,875
你希望能够捕获死循环
You'd like something that would catch infinite loops,

859
00:42:37,875 --> 00:42:38,500
例如
for example,

860
00:42:39,450 --> 00:42:42,425
用户的程序里的死循环
in programs that were written by users.

861
00:42:43,190 --> 00:42:45,125
但通常你写不出这样的程序
But in general you can't write such a program

862
00:42:45,350 --> 00:42:47,575
它读取和检测某个程序
that will read any program and determine whether or not

863
00:42:48,350 --> 00:42:49,300
是不是死循环
it's an infinite loop.

864
00:42:50,990 --> 00:42:51,685
我给你展示一下
Let me show you that.

865
00:42:51,685 --> 00:42:53,775
这是个关于数学的小例子
It's a little bit of a minor mathematics.

866
00:42:58,780 --> 00:42:59,650
设想
Let's imagine

867
00:43:00,050 --> 00:43:01,781
在我们开始之前
that we just had a mathematical function

868
00:43:01,781 --> 00:43:02,620
有一个数学函数
before we start.

869
00:43:02,620 --> 00:43:03,425
这里就有一个
And there is one,

870
00:43:03,825 --> 00:43:04,550
称为S
called s,

871
00:43:05,475 --> 00:43:07,546
它接受一个过程
which takes a procedure

872
00:43:12,525 --> 00:43:14,230
和它的参数a
and its argument, a.

873
00:43:19,175 --> 00:43:20,525
S所做的是
And what s does

874
00:43:21,650 --> 00:43:24,014
检测以a为参数运行p时
is it determines whether or not

875
00:43:24,014 --> 00:43:25,975
是否安全
it's safe to run p on a.

876
00:43:26,900 --> 00:43:28,175
我的意思是
And what I mean by that is this:

877
00:43:28,400 --> 00:43:35,125
如果a可以作为p的参数
it's true if p applied to a

878
00:43:35,625 --> 00:43:36,740
最终能返回一个值
to a will converge

879
00:43:41,400 --> 00:43:42,450
就返回true
to a value

880
00:43:44,350 --> 00:43:45,330
在没有报错的情况下
without an error.

881
00:43:52,700 --> 00:43:54,025
但当以a为参数调用p
And it's false

882
00:43:56,100 --> 00:43:57,200
是死循环
if p of a

883
00:43:59,675 --> 00:44:00,765
或者会报错
or makes an error.

884
00:44:05,875 --> 00:44:06,950
就返回false
loops forever

885
00:44:15,000 --> 00:44:17,225
这确实是个函数
Now that's surely a function.

886
00:44:18,780 --> 00:44:20,725
对于你输入的任何过程
There is some for every procedure

887
00:44:21,200 --> 00:44:22,850
或者任何参数
and for every argument you could give it

888
00:44:23,925 --> 00:44:25,425
它只能返回true或false
that is either true or false

889
00:44:25,925 --> 00:44:27,850
不会报错
that it converges without making an error.

890
00:44:28,440 --> 00:44:30,150
你可以为它们画一张巨大的表格
And you could make a giant table of them.

891
00:44:32,225 --> 00:44:32,925
但问题是
But the question is,

892
00:44:32,925 --> 00:44:34,093
你能写个一个过程
can you write a procedure

893
00:44:34,093 --> 00:44:35,925
计算这个函数的值吗?
that compute the values of this function?

894
00:44:37,430 --> 00:44:39,025
假设我们能做到
Well let's assume that we can.

895
00:44:39,720 --> 00:44:40,550
假设
Suppose

896
00:44:44,000 --> 00:44:45,675
我们有个过程
that we have a procedure

897
00:44:48,550 --> 00:44:52,775
叫作SAFE?
procedure called "safe"

898
00:44:56,475 --> 00:44:59,900
它能计算S的值
that computes the value of s.

899
00:45:12,475 --> 00:45:14,925
现在我要用几种方法
Now I'm going to show you by several methods

900
00:45:15,900 --> 00:45:18,475
证明你做不到
that you can't do this.

901
00:45:19,760 --> 00:45:20,626
最简单的一个
The easiest one,

902
00:45:20,626 --> 00:45:21,425
或者说第一个
or the first one,

903
00:45:21,425 --> 00:45:23,450
我们定义一个叫diag1的过程
let's define a procedure called diag1.

904
00:45:23,810 --> 00:45:24,945
#TBD
Given that we have safe,

905
00:45:25,200 --> 00:45:26,993
我们可以定义
we can define diag1

906
00:45:34,425 --> 00:45:35,550
diag1
diag1

907
00:45:37,550 --> 00:45:39,056
是有一个参数p
to be the procedure

908
00:45:39,675 --> 00:45:41,700
的过程
of one argument, p,

909
00:45:42,450 --> 00:45:44,050
它有着这样的属性
which has the following properties.

910
00:45:44,780 --> 00:45:50,675
如果它对自己应用p
If it's safe to apply p to itself,

911
00:45:53,325 --> 00:45:55,325
那么就形成了死循环
then I wish to have an infinite loop.

912
00:45:59,225 --> 00:46:00,925
否则我会返回3
Otherwise I'm going to return 3.

913
00:46:03,680 --> 00:46:04,470
它也可能是42
Maybe it was 42.

914
00:46:04,470 --> 00:46:06,425
宇宙的终极答案是什么?
What's the answer to the big question?

915
00:46:07,060 --> 00:46:08,875
我们当然知道死循环是什么
Where of course we know what an infinite loop is.

916
00:46:12,050 --> 00:46:12,964
死循环
Infinite loop,

917
00:46:13,825 --> 00:46:16,025
没有参数的过程
to be a procedure of no arguments,

918
00:46:16,025 --> 00:46:18,075
这是一个极好的lambda运算循环
which is that nice lambda calculus loop.

919
00:46:18,430 --> 00:46:19,289
lambda (x)
Lambda of x,

920
00:46:19,400 --> 00:46:20,475
(X X)
x of x,

921
00:46:21,300 --> 00:46:24,680
应用到(lambda (x) (x x))
applied to lambda of x, x of x.

922
00:46:24,680 --> 00:46:26,550
没什么想象的余地了
So there's nothing left to the imagination here.

923
00:46:29,830 --> 00:46:31,175
总结一下
Well let's see what the story is.

924
00:46:32,500 --> 00:46:33,908
我假设
I'm supposing it's the case

925
00:46:35,450 --> 00:46:38,772
我们担心有个过程
that we worry about the procedure

926
00:46:39,000 --> 00:46:43,450
把diag1应用到diag1上
called diag1 applied to diag1.

927
00:46:46,275 --> 00:46:47,775
那会发生什么呢?
Well what could it possibly be?

928
00:46:49,970 --> 00:46:51,390
我不知道
Well I don't know.

929
00:46:51,390 --> 00:46:53,213
将diag1代换为
We're going to substitute diag1

930
00:46:53,550 --> 00:46:55,500
p的过程体
for p in the body here.

931
00:46:57,310 --> 00:47:00,220
计算(diag1 diag1)安全吗?
Well is it safe to compute diag1 of diag1?

932
00:47:00,220 --> 00:47:00,780
我不知道
I don't know.

933
00:47:00,780 --> 00:47:01,825
有两种可能
There are two possibilities.

934
00:47:03,400 --> 00:47:05,501
如果计算(diag1 diag1)是安全的
If it's safe to compute diag1 of diag1

935
00:47:05,875 --> 00:47:07,000
这意味着不会循环
that means it shouldn't loop.

936
00:47:08,490 --> 00:47:09,225
意味着我到了这里
That means I go to here,

937
00:47:09,225 --> 00:47:10,350
然后我生成了个死循环
but then I produce an infinite loop.

938
00:47:10,560 --> 00:47:11,575
所以它不是安全的
So it can't be safe.

939
00:47:12,210 --> 00:47:14,781
但如果计算(diag1 diag1)不安全
But if it's not safe to compute diag1 of diag1

940
00:47:14,900 --> 00:47:16,020
那么它的结果是3
then the answer to this is 3.

941
00:47:16,020 --> 00:47:17,267
但那是(diag1 diag1)
But that's diag1 of diag1,

942
00:47:17,267 --> 00:47:18,200
所以它必须安全才行
so it had to be safe.

943
00:47:20,530 --> 00:47:23,600
由于这个矛盾
So therefore by contradiction

944
00:47:24,325 --> 00:47:26,300
你无法写出这个SAFE?过程
you cannot produce safe.

945
00:47:27,400 --> 00:47:29,805
对于没听懂这个叙述的同学
For those of you who were boggled by that one

946
00:47:30,250 --> 00:47:32,150
我换个方式再讲一遍
I'm going to say it again, in a different way.

947
00:47:32,820 --> 00:47:34,475
请听另一个版本
Listen to one more alternative.

948
00:47:35,530 --> 00:47:36,950
我们定义diag2
Let's define diag2.

949
00:47:39,840 --> 00:47:41,600
这个diag的名字
These are named diag because

950
00:47:42,650 --> 00:47:44,725
来源于康托尔的对角论证法
of Cantor's diagonal argument.

951
00:47:45,000 --> 00:47:47,050
#TBD
These are instances of

952
00:47:47,050 --> 00:47:49,395
#TBD
a famous argument which was originally used by

953
00:47:49,450 --> 00:47:52,650
Cantor在19世纪末
Cantor in the late part of the last century

954
00:47:52,775 --> 00:47:56,106
证明了实数是无限的
to prove that the real numbers were not countable,

955
00:47:56,675 --> 00:47:59,450
用整数无法数完实数
that there are too many real numbers to be counted by integers.

956
00:48:00,190 --> 00:48:01,741
举例来说
That there are more points on a line,

957
00:48:01,741 --> 00:48:02,500
在数轴上
for example,

958
00:48:02,500 --> 00:48:02,506
点的数量比计数的数字多
than there are counting numbers.

959
00:48:02,506 --> 00:48:04,425
直线上的点比自然数多
than there are counting numbers.

960
00:48:05,260 --> 00:48:06,858
这或许不是个显而易见的结论
It may or may not be obvious,

961
00:48:06,858 --> 00:48:08,175
但我不想深入讨论这个
and I don't want to get into that now.

962
00:48:10,900 --> 00:48:12,450
但是diag2
But diag2

963
00:48:13,300 --> 00:48:15,820
仍有一个参数的过程p
is again a procedure of one argument p.

964
00:48:15,820 --> 00:48:17,475
这几乎与之前的例子相同
It's almost the same as the previous one,

965
00:48:17,725 --> 00:48:24,323
如果计算(p p)是安全的
which is, if it's safe to compute p on p,

966
00:48:25,175 --> 00:48:26,675
那么我就要
then I'm going to produce--

967
00:48:27,267 --> 00:48:31,025
要去计算
then I want to compute

968
00:48:31,575 --> 00:48:32,775
一些(p p)之外的
some other things

969
00:48:33,800 --> 00:48:37,825
其他东西
other than p of p.

970
00:48:38,960 --> 00:48:40,210
否则我就返回false
Otherwise I'm going to put out false.

971
00:48:43,600 --> 00:48:45,300
这里的other-than意思是
Where other then it says,

972
00:48:45,300 --> 00:48:46,352
不管这个(p p)是什么
whatever p of p,

973
00:48:46,352 --> 00:48:47,475
我都返回一些别的东西
I'm going to put out something else.

974
00:48:48,880 --> 00:48:50,075
我会告诉你
I can give you an example of

975
00:48:50,075 --> 00:48:51,525
一个other-than的定义
a definition of other than

976
00:48:51,575 --> 00:48:52,575
我觉得它是可用的
which I think works.

977
00:48:53,890 --> 00:48:55,225
我们看
Let's see.

978
00:48:55,640 --> 00:48:56,330
是的
Yes.

979
00:48:56,330 --> 00:48:57,266
定义other-than
Where other than

980
00:49:03,950 --> 00:49:07,265
是一个以x为参数的过程
be a procedure of one argument x which says,

981
00:49:08,050 --> 00:49:12,961
如果x等于'A
if its eq x to, say, quote a,

982
00:49:13,325 --> 00:49:15,075
那么结果是'B
then the answer is quote b.

983
00:49:15,720 --> 00:49:16,970
否则结果是'A
Otherwise it's quote a.

984
00:49:20,090 --> 00:49:21,900
这就能做到不管参数是什么
That always produces something

985
00:49:22,075 --> 00:49:23,450
我都能给出与参数不同的结果
which is not what its argument is.

986
00:49:25,350 --> 00:49:26,125
就是这样
That's all it is.

987
00:49:26,540 --> 00:49:27,375
这就是我要的
That's all I wanted.

988
00:49:28,250 --> 00:49:29,587
我们考虑一下这个
Well now let's consider this one,

989
00:49:29,587 --> 00:49:31,150
(diag2 diag2)
diag2 of diag2.

990
00:49:38,220 --> 00:49:39,000
看
Well look.

991
00:49:39,950 --> 00:49:41,725
这个东西会做些危险的事情
This only does something dangerous,

992
00:49:42,000 --> 00:49:43,450
比如求值(p p)
like calling p of p,

993
00:49:44,750 --> 00:49:45,950
如果它是是安全的
if it's safe to do so.

994
00:49:47,470 --> 00:49:49,168
如果SAFE?能够被定义的话
So if safe defined at all,

995
00:49:50,300 --> 00:49:52,496
如果你能定义SAFE?过程
if you can define such a procedure, safe,

996
00:49:52,975 --> 00:49:54,325
那么这个过程
then this procedure

997
00:49:54,608 --> 00:49:56,400
总是安全的
is always defined and therefore safe

998
00:49:56,525 --> 00:49:57,225
对于任意输入来说都是
on any inputs.

999
00:50:01,540 --> 00:50:03,504
那么(diag2 diag2)
So diag2 of diag2

1000
00:50:03,875 --> 00:50:12,200
一定会返回(diag2 diag2)以外的东西
must reduce to other than diag2 of diag2.

1001
00:50:15,825 --> 00:50:16,975
这就没意义了
And that doesn't make sense,

1002
00:50:17,800 --> 00:50:19,309
又产生了悖论
so we have a contradiction,

1003
00:50:19,850 --> 00:50:21,575
因此我们不能定义SAFE?
and therefore we can't define safe.

1004
00:50:22,950 --> 00:50:24,237
我只想这样证明两次
I just waned to do that twice,

1005
00:50:24,750 --> 00:50:25,825
有些许不同
slightly differently,

1006
00:50:26,625 --> 00:50:27,905
你不会感到
so you wouldn't feel

1007
00:50:28,800 --> 00:50:30,975
第一个证明是个把戏
that the first one was a trick.

1008
00:50:32,825 --> 00:50:33,450
他们都是小把戏
They may be both tricks,

1009
00:50:33,800 --> 00:50:35,300
但它们稍微有些不同
but they're at least slightly different.

1010
00:50:37,300 --> 00:50:39,200
#TBD
So I suppose that pretty much wraps it up.

1011
00:50:40,080 --> 00:50:41,973
我们刚刚论证了停机问题
I've just proved what we call the halting theorem,

1012
00:50:43,000 --> 00:50:44,925
#TBD
and I suppose with that we're going to halt.

1013
00:50:46,720 --> 00:50:47,970
#TBD
I hope you have a good time.

1014
00:50:50,900 --> 00:50:51,765
有什么问题吗?
Are there any questions?

1015
00:50:53,300 --> 00:50:53,810
请讲
Yes.

1016
00:50:53,810 --> 00:50:56,275
学生: diag1的值是什么?
AUDIENCE: What is the value of s of diag1?

1017
00:50:56,750 --> 00:50:57,430
教授: 什么的值?
PROFESSOR: Of what?

1018
00:50:57,430 --> 00:50:58,950
学生: (S diag1)的值
AUDIENCE: S of diag1.

1019
00:51:00,120 --> 00:51:02,037
如果你说S是个函数
If you said s is a function

1020
00:51:02,037 --> 00:51:02,620
我们可以
and we can [INTERPOSING VOICES]

1021
00:51:02,620 --> 00:51:03,870
教授: 噢 我不知道啊
PROFESSOR: Oh, I don't know.

1022
00:51:03,870 --> 00:51:04,350
我不知道
I don't know.

1023
00:51:04,350 --> 00:51:04,882
它是一个函数
It's a function,

1024
00:51:04,882 --> 00:51:05,950
但我不知道如何计算它
but I don't know how to compute it.

1025
00:51:06,800 --> 00:51:08,125
我做不到
I can't do it.

1026
00:51:08,610 --> 00:51:09,775
我也只是个机器
I'm just a machine, too.

1027
00:51:11,530 --> 00:51:12,210
对吧?
Right?

1028
00:51:12,210 --> 00:51:13,375
原则上来说
There's no machine

1029
00:51:13,375 --> 00:51:14,050
没有机器
that in principle--

1030
00:51:14,475 --> 00:51:16,875
会处在你刚才问的那个情况中
it might be that in that particular case you just asked,

1031
00:51:16,875 --> 00:51:18,580
#TBD
with some thinking I could figure it out.

1032
00:51:18,580 --> 00:51:19,375
但通常情况下
But in general

1033
00:51:19,600 --> 00:51:21,050
我无法计算S的值
I can't compute the value of s

1034
00:51:21,050 --> 00:51:22,525
别的机器也做不到
any better than any other machine can.

1035
00:51:23,780 --> 00:51:24,925
存在这样一个函数
There is such a function,

1036
00:51:25,925 --> 00:51:28,000
没有任何机器能够计算它
it's just that no machine can be built to compute it.

1037
00:51:29,580 --> 00:51:30,050
现在
Now

1038
00:51:30,672 --> 00:51:33,675
#TBD
there's a way of saying that that should not be surprising.

1039
00:51:35,225 --> 00:51:36,250
#TBD
Going through this--

1040
00:51:36,250 --> 00:51:38,362
我并没有时间在这展示这个
I mean, I don't have time to do this here,

1041
00:51:38,450 --> 00:51:43,000
但这样的函数非常多
but the number of functions is very large.

1042
00:51:44,400 --> 00:51:47,754
如果有一定量的可能输入
If there's a certain number of answers possible

1043
00:51:47,754 --> 00:51:49,626
和结果
and a certain number of inputs possible,

1044
00:51:49,875 --> 00:51:51,800
那么结果对应输入的数量
then it's the number of answers raised to the number inputs

1045
00:51:51,800 --> 00:51:53,200
就是可能函数的数量
is the number of possible functions.

1046
00:51:54,500 --> 00:51:55,970
对于同一个参数来说
On one variable.

1047
00:51:58,150 --> 00:52:04,325
#TBD
Now that's always bigger than the thing you're raising to, the exponent.

1048
00:52:05,480 --> 00:52:09,800
函数的数量
The number of functions is larger

1049
00:52:09,950 --> 00:52:12,725
比一个人能写出的
than the number of programs

1050
00:52:13,306 --> 00:52:14,100
程序的数量更多
that one can write,

1051
00:52:14,825 --> 00:52:16,450
因为有无穷多的参数
by an infinity counting argument.

1052
00:52:17,575 --> 00:52:19,000
可能会更多
And it's much larger.

1053
00:52:19,475 --> 00:52:22,124
所以不可计算的函数数量
So there must be a lot of functions

1054
00:52:22,124 --> 00:52:23,550
一定会非常多
that can't be computed by programs.

1055
00:52:26,280 --> 00:52:27,475
学生: 不久前
AUDIENCE: A few moments ago

1056
00:52:27,475 --> 00:52:28,563
你讲了规范
you were talking about specifications

1057
00:52:28,563 --> 00:52:30,640
和自动生成解决方案
and automatic generation of solutions.

1058
00:52:30,640 --> 00:52:33,360
你觉得在规范和解决方案之间存在#TBD吗?
Do you see any steps between specifications and solutions?

1059
00:52:37,250 --> 00:52:38,225
教授: 存在的
PROFESSOR: Steps between.

1060
00:52:38,720 --> 00:52:39,375
你是说
You mean, you're saying,

1061
00:52:39,375 --> 00:52:42,603
如何按照规范
how you go about constructing

1062
00:52:42,603 --> 00:52:45,205
构建相应的装置吗?
devices given that have specifications for the device?

1063
00:52:45,205 --> 00:52:45,500
是的
Sure.

1064
00:52:45,500 --> 00:52:48,361
学生: 软件工程中有很多
AUDIENCE: There's a lot of software engineering

1065
00:52:48,361 --> 00:52:49,900
层次化的设计
that goes through specifications through

1066
00:52:49,900 --> 00:52:51,900
并进行实现的规范
many layers of design and then implementation.

1067
00:52:52,430 --> 00:52:52,850
教授: 是的
PROFESSOR: Yes?

1068
00:52:52,850 --> 00:52:53,700
学生: 我很好奇
AUDIENCE: I was curious

1069
00:52:53,700 --> 00:52:54,625
你觉得这现实吗?
if you think that's realistic.

1070
00:52:55,600 --> 00:52:57,175
教授: 我觉得其中一些是现实的
PROFESSOR: Well I think that some of it's realistic

1071
00:52:57,175 --> 00:52:58,100
另一些不现实
and some of it isn't.

1072
00:52:58,100 --> 00:53:00,538
如果你想制造一个滤波器
I mean, surely if I want to build an electrical filter

1073
00:53:01,175 --> 00:53:07,160
我这有个挺有趣的例子
and I have a rather interesting possibility.

1074
00:53:07,160 --> 00:53:10,615
假设我想制造一个东西
Supposing I want to build a thing that matches

1075
00:53:11,050 --> 00:53:14,071
无线电广播发射机
some power output to the radio transmitter,

1076
00:53:14,475 --> 00:53:18,750
到某些天线
to some antenna.

1077
00:53:19,906 --> 00:53:23,230
#TBD
And I'm really out of this power-- it's output tube out here.

1078
00:53:23,230 --> 00:53:25,920
问题是它们的阻抗不同
And the problem is that they have different impedances.

1079
00:53:25,920 --> 00:53:27,550
我希望能够匹配阻抗
I want them to match the impedances.

1080
00:53:27,550 --> 00:53:29,150
我也想制造一个滤波器
I also want to make a filter

1081
00:53:29,150 --> 00:53:32,780
用来过滤一些谐波辐射
in there which is going to get rid of some harmonic radiation.

1082
00:53:32,780 --> 00:53:36,638
一个老派的技术叫作
Well one old-fashioned technique for doing this is called

1083
00:53:36,825 --> 00:53:38,860
镜像阻抗或之类的东西
image impedances, or something like that.

1084
00:53:38,860 --> 00:53:39,500
你要做的是
And what you do

1085
00:53:39,500 --> 00:53:40,850
你有个基础的模块
is you say you have a basic module

1086
00:53:40,850 --> 00:53:42,750
称为L型滤波器
called an L-section.

1087
00:53:43,300 --> 00:53:44,550
就像这样
Looks like this.

1088
00:53:47,080 --> 00:53:49,800
如果把它连接到某些电阻R上
If I happen to connect this to some resistance, r,

1089
00:53:50,050 --> 00:53:52,600
#TBD
and if I make this impedance x, xl,

1090
00:53:52,725 --> 00:53:55,400
#TBD
and if it happens to be q times r,

1091
00:53:55,400 --> 00:53:58,525
这就成了一个低通滤波器
then this produces a low pass filter

1092
00:53:58,525 --> 00:54:00,865
有q^2+1的阻抗匹配
with a q square plus one impedance match.

1093
00:54:02,110 --> 00:54:03,120
这就是我想要的
Just what I need.

1094
00:54:03,120 --> 00:54:03,875
因为这样我就可以
Because now I can take two of these,

1095
00:54:03,875 --> 00:54:05,300
把它们匹配到一起了
hook them together

1096
00:54:06,025 --> 00:54:06,510
就像这样
like this.

1097
00:54:11,660 --> 00:54:13,150
我拿来另一个
OK, and I take another one

1098
00:54:13,625 --> 00:54:18,290
想这样把它们连到一起
and I'll hook them together like that.

1099
00:54:18,290 --> 00:54:19,950
有两个L型滤波器连接起来
And I have two L-sections hooked together.

1100
00:54:20,320 --> 00:54:23,070
这能让它的阻抗降到我知道的值
And this will step the impedance down to one that I know,

1101
00:54:23,375 --> 00:54:25,225
让它的阻抗升到我知道的值
and this will step it up to one I know.

1102
00:54:25,530 --> 00:54:27,850
这两个低通滤波器都过滤掉了一些谐波
Each of these is a low pass filter getting rid of some harmonics.

1103
00:54:28,090 --> 00:54:29,072
这是个不错的滤波器
It's good filter,

1104
00:54:29,072 --> 00:54:30,270
它成为π型滤波器
it's called a pie-section filter.

1105
00:54:30,270 --> 00:54:30,800
很好
Great.

1106
00:54:31,700 --> 00:54:34,974
除了实际上
Except for the fact that in doing what I just did,

1107
00:54:35,250 --> 00:54:37,850
我在系统里放了些无用的东西
I've made a terrible inefficiency in this system.

1108
00:54:38,620 --> 00:54:40,725
我在本该一个线圈的地方用了两个
I've made two coils where I should have made one.

1109
00:54:41,620 --> 00:54:44,600
在大多数软件工程中
And the problem with most software engineering art

1110
00:54:44,894 --> 00:54:47,150
在人工优化和编译之外
is that there's no mechanism,

1111
00:54:47,150 --> 00:54:48,800
不存在一种机制
other than people optimization and compilers,

1112
00:54:48,800 --> 00:54:51,344
能在自顶向下的设计中
for getting rid of the redundant parts

1113
00:54:51,344 --> 00:54:53,550
去掉冗余的部分
that are constructed when doing top down design.

1114
00:54:55,350 --> 00:54:56,076
或许会更糟
It's even worse,

1115
00:54:56,076 --> 00:54:57,804
有很多重要的结构
there are lots of very important structures

1116
00:54:57,804 --> 00:54:59,025
你无法采用这种方式构建
that you can't construct at all this way.

1117
00:55:01,110 --> 00:55:03,535
我觉得自上而下的设计方式
So I think that the standard top down design

1118
00:55:03,535 --> 00:55:04,875
是一种很短视的手段
is a rather shallow business.

1119
00:55:05,710 --> 00:55:06,600
它不会真的抓到
Doesn't really capture

1120
00:55:06,600 --> 00:55:08,100
设计者真正想要的结果
what people want to do in design.

1121
00:55:08,315 --> 00:55:10,100
我再举一个电子学的例子
I'll give you another electrical example.

1122
00:55:10,100 --> 00:55:11,750
电子学的例子
Electrical examples are so much clearer

1123
00:55:11,907 --> 00:55:13,364
要比计算的例子直观得多
than computational examples,

1124
00:55:13,364 --> 00:55:14,275
因为计算的例子
because computation examples require

1125
00:55:14,275 --> 00:55:16,525
解释起来比较复杂
a certain degree of complexity to explain them.

1126
00:55:17,220 --> 00:55:20,163
电子学世界中 我最喜欢的例子之一是
But one of my favorite examples in the electrical world

1127
00:55:20,600 --> 00:55:24,195
是如何设计中频放大器中
is how would I ever come up with the output stage

1128
00:55:24,195 --> 00:55:26,550
输入级和输出级的连接方式
of this inter-stage connection in an IF amplifier.

1129
00:55:27,530 --> 00:55:31,500
这是一个三极管
It's a little transistor here, and let's see.

1130
00:55:32,410 --> 00:55:33,400
这有个LC震荡电路
Well I'm going to have a tank,

1131
00:55:36,450 --> 00:55:39,175
我要把它
and I'm going to hook this up to, say,

1132
00:55:41,375 --> 00:55:43,975
把它与下一级的输入线圈耦合在一起
I'm going to link-couple that to the input of the next stage.

1133
00:55:44,850 --> 00:55:47,475
这是个完美的可行方案
Here's a perfectly plausible plan--

1134
00:55:48,225 --> 00:55:50,875
除了我这个电流方向画错了
well except for the fact that since I put that going up

1135
00:55:50,875 --> 00:55:52,925
电流应该是这个方向
I should make that going that way.

1136
00:55:53,170 --> 00:55:55,775
这是个完美的可行方案
Here's a perfectly plausible plan for a--

1137
00:55:55,775 --> 00:55:56,700
不对
no I shouldn't.

1138
00:55:57,125 --> 00:55:57,940
我犯蠢了
I'm dumb.

1139
00:55:58,400 --> 00:55:59,075
对不起
Excuse me.

1140
00:55:59,690 --> 00:56:00,425
这不重要
Doesn't matter.

1141
00:56:00,730 --> 00:56:01,540
关键在于这是一个
The point is it's a perfect

1142
00:56:01,540 --> 00:56:03,425
把两级耦合起来的完美方案
plan for a couple two stages together.

1143
00:56:04,590 --> 00:56:06,925
分层来看时会产生什么问题?
Now what the problem is is what's this hierarchically?

1144
00:56:07,620 --> 00:56:08,800
#TBD
It's not one thing.

1145
00:56:09,480 --> 00:56:11,990
当分层来看时它就没有任何意义了
Hierarchically it doesn't make any sense at all.

1146
00:56:11,990 --> 00:56:14,325
这是一个调谐电路的电感
It's the inductance of a tuned circuit,

1147
00:56:15,550 --> 00:56:18,025
这是变压器的初级线圈
it's the primary of a transformer,

1148
00:56:19,100 --> 00:56:21,825
这是直流的通路
and it's also the DC path by

1149
00:56:21,825 --> 00:56:23,575
它是三极管的集电极
which bias conditions get to the

1150
00:56:23,575 --> 00:56:25,100
的偏置条件
collector of that transistor.

1151
00:56:26,460 --> 00:56:28,800
没有任何简单的自顶向下设计
And there's no simple top-down design

1152
00:56:28,800 --> 00:56:30,175
能够得到这样的结构
that's going to produce a structure like that

1153
00:56:30,225 --> 00:56:34,025
对于同一个东西有大量的复用
with so many overlapping uses for a particular thing.

1154
00:56:34,530 --> 00:56:36,729
玩拼字游戏
Playing Scrabble,

1155
00:56:36,729 --> 00:56:38,841
当你要完成三倍分数的词时
where you have to do triple word scores,

1156
00:56:39,300 --> 00:56:43,600
自顶向下的设计策略并不容易
or whatever, is not so easy in top-down design strategy.

1157
00:56:44,950 --> 00:56:50,700
真正的工程基于努力成果的吸引力#TBD
Yet most of real engineering is based on getting the most oomph for effort.

1158
00:56:52,140 --> 00:56:53,525
那就是你所看到的东西
And that's what you're seeing here.

1159
00:56:54,860 --> 00:56:55,550
嗯?
Yeah?

1160
00:56:55,550 --> 00:56:56,810
学生: 这是最后一个问题吗?
AUDIENCE: Is this the last question?

1161
00:57:00,282 --> 00:57:02,525
[笑声]
[LAUGHTER]

1162
00:57:18,640 --> 00:57:19,890
教授: 看起来是
PROFESSOR: Apparently so.

1163
00:57:23,575 --> 00:57:24,125
谢谢大家
Thank you.

1164
00:57:25,300 --> 00:57:36,500
[掌声]
[APPLAUSE]

1165
00:57:39,040 --> 00:58:52,200
[音乐]
[JESU, JOY OF MAN'S DESIRING]

