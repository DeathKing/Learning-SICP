1
00:00:20,970 --> 00:00:28,870
PROFESSOR: OK, well, we've been looking at streams, this signal processing way of putting systems together.

2
00:00:28,870 --> 00:00:40,635
And remember, the key idea is that we decouple the apparent order of events in our programs from the actual order of events in the computer.

3
00:00:40,635 --> 00:00:47,500
And that means that we can start dealing with very long streams and only having to generate the elements on demand.

4
00:00:47,500 --> 00:00:51,560
That sort of on-demand computation is built into the stream's data structure.

5
00:00:54,450 --> 00:00:58,040
So if we have a very long stream, we only compute what we need.

6
00:00:58,040 --> 00:01:00,750
The things only get computed when we actually ask for them.

7
00:01:00,750 --> 00:01:02,110
Well, what are examples?

8
00:01:02,110 --> 00:01:04,800
Are they actually asking for them?

9
00:01:04,800 --> 00:01:11,050
For instance, we might ask for the n-th element of a stream.

10
00:01:16,360 --> 00:01:20,400
Here's a procedure that computes the n-th element of a stream.

11
00:01:20,400 --> 00:01:25,570
An integer n, the n-th element of some stream s, and we just recursively walk down the stream.

12
00:01:25,570 --> 00:01:27,960
And the end of 0, we compute the head.

13
00:01:27,960 --> 00:01:34,310
Otherwise, it's the n-th the minus 1 element of the tail of the stream.

14
00:01:34,310 --> 00:01:41,700
Those two are just like for Lisp, but the difference is those elements aren't going to get computed until we walk down, taking successive n-ths.

15
00:01:41,700 --> 00:01:45,910
So that's one way that the stream elements might get forced.

16
00:01:45,910 --> 00:01:49,300
And another way, here's a little procedure that prints a stream.

17
00:01:49,300 --> 00:01:54,150
We say print a stream, so to print a stream s.

18
00:01:54,150 --> 00:01:55,315
Well, what do we do?

19
00:01:55,315 --> 00:01:59,720
We print the head of the stream, and that will cause the head to be computed.

20
00:01:59,720 --> 00:02:04,990
And then we recursively print stream the tail of the stream.

21
00:02:04,990 --> 00:02:09,660
And if we're already done, maybe we have to return something about the message done.

22
00:02:09,660 --> 00:02:14,310
OK, and then so if you make a stream, you could say here's the stream, this very long stream.

23
00:02:14,310 --> 00:02:21,320
And then you say print the stream, and the elements of the stream will get computed successively as that print calls them.

24
00:02:21,320 --> 00:02:24,680
They won't get all computed initially.

25
00:02:24,680 --> 00:02:30,190
So in this way, we can deal with some very long streams.

26
00:02:30,190 --> 00:02:33,600
Well, how long can a stream be?

27
00:02:33,600 --> 00:02:36,360
Well, it can be infinitely long.

28
00:02:36,360 --> 00:02:38,920
Let's look at an example here on the computer.

29
00:02:38,920 --> 00:02:57,420
I could walk up to this computer, and I could say-- how about we'll define the stream of integers starting with some number N, the stream of positive integers starting with some number n.

30
00:02:59,760 --> 00:03:19,010
And that's cons-stream of n onto the integers from one more.

31
00:03:24,680 --> 00:03:25,930
So there are the integers.

32
00:03:28,800 --> 00:03:31,500
Then I could say let's get all the integers.

33
00:03:34,410 --> 00:03:44,580
define the stream of integers to be the integers starting with 1.

34
00:03:48,840 --> 00:04:02,995
And now if I say something like what's the what's the 20th integer.

35
00:04:02,995 --> 00:04:07,270
So it's 21 because we start counting at 0.

36
00:04:07,270 --> 00:04:09,450
Or I can do more complicated things.

37
00:04:09,450 --> 00:04:10,840
Let me to define a little predicate here.

38
00:04:13,740 --> 00:04:19,160
How about define no-seven.

39
00:04:19,160 --> 00:04:23,376
It's going to test an integer, and it's going to say it's not.

40
00:04:28,820 --> 00:04:38,175
I take the remainder of x by 7, I don't get 0.

41
00:04:41,890 --> 00:04:58,885
And then I could say define the integers with no sevens to be, take all the integers and filter them to have no sevens.

42
00:05:11,570 --> 00:05:16,360
So now I've got the stream of all the integers that are not divisible by seven.

43
00:05:16,360 --> 00:05:28,320
So if I say what's the 100th integer and the list not divisible by seven, I get 117.

44
00:05:28,320 --> 00:05:35,270
Or if I'd like to say well, gee, what are all of them?

45
00:05:35,270 --> 00:05:41,700
So I could say print stream all these integers with no seven, it goes off printing.

46
00:05:45,100 --> 00:05:47,070
You may have to wait a very long time to see them all.

47
00:05:52,670 --> 00:06:01,100
Well, you can start asking, gee, is it really true that this data structure with the integers is really all the integers?

48
00:06:01,100 --> 00:06:04,053
And let me draw a picture of that program I just wrote.

49
00:06:08,170 --> 00:06:19,775
Here's the definition of the integers again that I just typed in, Right it's a cons of the first integer under the integer starting with the rest. Now, we can make a picture of that and see what it looks like.

50
00:06:22,720 --> 00:06:27,420
Conceptually, what I have is a box that's the integer starting with n.

51
00:06:27,420 --> 00:06:37,705
It takes in some number n, and it's going to return a stream of-- this infinite stream of all integers starting with n.

52
00:06:37,705 --> 00:06:38,690
And what do I do?

53
00:06:38,690 --> 00:06:42,470
Well, this is an integers from box.

54
00:06:45,070 --> 00:06:45,800
What's it got in it?

55
00:06:45,800 --> 00:06:54,110
Well, it takes in this n, and it increments it.

56
00:06:58,030 --> 00:07:03,170
And then it puts the result into recursively another integer's from box.

57
00:07:06,870 --> 00:07:14,270
It takes the result of that and the original n and puts those together with a cons and forms a stream.

58
00:07:14,270 --> 00:07:18,530
So that's a picture of that program I wrote.

59
00:07:18,530 --> 00:07:18,780
Let's see.

60
00:07:18,780 --> 00:07:23,320
These kind of diagrams we first saw drawn by Peter Henderson, the same guy who did the Escher language.

61
00:07:23,320 --> 00:07:28,530
We call them Henderson diagrams. And the convention here is that you put these things together.

62
00:07:28,530 --> 00:07:37,270
And the solid lines are things coming out are streams, and dotted lines are initial values going in.

63
00:07:37,270 --> 00:07:43,070
So this one has the shape of-- it takes in some integer, some initial value, and outputs a stream.

64
00:07:46,410 --> 00:07:48,380
Again, you can ask.

65
00:07:48,380 --> 00:07:52,340
Is that data structure integers really all the integers?

66
00:07:52,340 --> 00:07:58,190
Or is it is something that's cleverly arranged so that whenever you look for an integer you find it there?

67
00:07:58,190 --> 00:07:59,780
That's sort of a philosophical question, right?

68
00:07:59,780 --> 00:08:04,450
If something is there whenever you look, is it really there or not?

69
00:08:04,450 --> 00:08:09,420
It's sort of the same sense in which the money in your savings account is in the bank.

70
00:08:12,380 --> 00:08:19,830
Well, let me do another example.

71
00:08:19,830 --> 00:08:28,470
Gee, we started the course with an algorithm from Alexandria, which was Heron of Alexandria's algorithm for computing the square root.

72
00:08:28,470 --> 00:08:32,030
Let's take a look at another Alexandrian algorithm.

73
00:08:32,030 --> 00:08:39,110
This one is Eratosthenes method for computing all of the primes.

74
00:08:41,169 --> 00:08:42,830
It is called the Sieve of Eratosthenes.

75
00:08:42,830 --> 00:08:53,880
And what you do is you start out, and you list all the integers, say, starting with 2.

76
00:08:53,880 --> 00:08:57,310
And then you take the first integer, and you say, oh, that's prime.

77
00:08:57,310 --> 00:09:01,230
And then you go look at the rest, and you cross out all the things divisible by 2.

78
00:09:01,230 --> 00:09:05,250
So I cross out this and this and this.

79
00:09:05,250 --> 00:09:11,160
This takes a long time because I have to do it for all of the integers.

80
00:09:11,160 --> 00:09:22,010
So I go through the entire list of integers, crossing the ones divisible by 2.

81
00:09:22,010 --> 00:09:27,040
And now when I finish with all of the integers, I go back and look and say what am I left with?

82
00:09:27,040 --> 00:09:29,330
Well, the first thing that starts there is 3.

83
00:09:29,330 --> 00:09:30,770
So 3 is a prime.

84
00:09:30,770 --> 00:09:35,120
And now I go back through what I'm left with, and I cross out all the things divisible by 3.

85
00:09:35,120 --> 00:09:44,050
So let's see, 9 and 15 and 21 and 27 and 33 and so on.

86
00:09:44,050 --> 00:09:45,350
I won't finish.

87
00:09:45,350 --> 00:09:47,250
Then I see what I'm left with.

88
00:09:47,250 --> 00:09:50,860
And the next one I have is 5.

89
00:09:50,860 --> 00:09:54,540
Now I can through the rest, and I find the first one that's divisible by 5.

90
00:09:54,540 --> 00:09:58,030
I cross out from the remainder all the ones that are divisible by 5.

91
00:09:58,030 --> 00:10:01,890
And I do that, and then I go through and find 7.

92
00:10:01,890 --> 00:10:06,810
Go through all the rest, cross out things divisible 7, and I keep doing that forever.

93
00:10:06,810 --> 00:10:10,120
And when I'm done, what I'm left with is a list of all the primes.

94
00:10:10,120 --> 00:10:15,430
So that's the Sieve of Eratosthenes.

95
00:10:15,430 --> 00:10:17,930
Let's look at it as a computer program.

96
00:10:17,930 --> 00:10:19,550
It's a procedure called sieve.

97
00:10:27,910 --> 00:10:30,480
Now, I just write what I did.

98
00:10:30,480 --> 00:10:34,510
I'll say to sieve some stream s.

99
00:10:38,770 --> 00:10:41,870
I'm going to build a stream whose first element is the head of this.

100
00:10:41,870 --> 00:10:59,020
Remember, I always found the first thing I was left with, and the rest of it is the result of taking the tail of this, filtering it to throw away all the things that are divisible by the head of this, and now sieving the result.

101
00:10:59,020 --> 00:11:01,980
That's just what I did.

102
00:11:01,980 --> 00:11:06,900
And now to get the infinite stream of times, we just sieve all the integers starting from 2.

103
00:11:14,920 --> 00:11:16,300
Let's try that.

104
00:11:16,300 --> 00:11:19,760
We can actually do it.

105
00:11:19,760 --> 00:11:41,350
I typed in the definition of sieve before, I hope, so I can say something like define the primes to be the result of sieving the integers starting with 2.

106
00:11:46,760 --> 00:11:48,100
So now I've got this list of primes.

107
00:11:48,100 --> 00:11:50,990
That's all of the primes, right?

108
00:11:50,990 --> 00:12:01,010
So, if for example, what's the 20th prime in that list?

109
00:12:01,010 --> 00:12:02,540
73.

110
00:12:02,540 --> 00:12:07,750
See, and that little pause, it was only at the point when I started asking for the 20th prime is that it started computing.

111
00:12:10,370 --> 00:12:14,960
Or I can say here let's look at all of the primes.

112
00:12:22,780 --> 00:12:25,350
And there it goes computing all of the primes.

113
00:12:25,350 --> 00:12:28,570
Of course, it will take a while again if I want to look at all of them, so let's stop it.

114
00:12:32,030 --> 00:12:33,130
Let me draw you a picture of that.

115
00:12:33,130 --> 00:12:34,890
Well, I've got a picture of that.

116
00:12:34,890 --> 00:12:37,900
What's that program really look like?

117
00:12:37,900 --> 00:12:42,610
Again, some practice with these diagrams, I have a sieve box.

118
00:12:42,610 --> 00:12:43,560
How does sieve work?

119
00:12:43,560 --> 00:12:44,810
It takes in a stream.

120
00:12:48,850 --> 00:12:50,870
It splits off the head from the tail.

121
00:12:50,870 --> 00:12:54,970
And the first thing that's going to come out of the sieve is the head of the original stream.

122
00:12:57,796 --> 00:13:02,550
Then it also takes the head and uses that.

123
00:13:02,550 --> 00:13:03,850
It takes the stream.

124
00:13:03,850 --> 00:13:09,152
It filters the tail and uses the head to filter for nondivisibility.

125
00:13:09,152 --> 00:13:15,130
It takes the result of nondivisibility and puts it through another sieve box and puts the result together.

126
00:13:15,130 --> 00:13:19,650
So you can think of this sieve a filter, but notice that it's an infinitely recursive filter.

127
00:13:19,650 --> 00:13:27,130
Because inside the sieve box is another sieve box, and inside that is another sieve box and another sieve box.

128
00:13:27,130 --> 00:13:28,960
So you see we start getting some very powerful things.

129
00:13:28,960 --> 00:13:36,690
We're starting to mix this signal processing view of the world with things like recursion that come from computation.

130
00:13:36,690 --> 00:13:40,970
And there are all sorts of interesting things you can do that are like this.

131
00:13:40,970 --> 00:13:42,220
All right, any questions?

132
00:13:48,190 --> 00:13:49,440
OK, let's take a break.

133
00:14:28,820 --> 00:14:32,690
Well, we've been looking at a couple of examples of stream programming.

134
00:14:34,790 --> 00:14:41,490
All the stream procedures that we've looked at so far have the same kind of character.

135
00:14:41,490 --> 00:14:51,000
We've been writing these recursive procedures that kind of generate these stream elements one at a time and put them together in cons-streams. So we've been thinking a lot about generators.

136
00:14:51,000 --> 00:15:07,350
There's another way to think about stream processing, and that's to focus not on programs that sort of process these elements as you walk down the stream, but on things that kind of process the streams all at once.

137
00:15:07,350 --> 00:15:12,410
To show you what I mean, let me start by defining two procedures that will come in handy.

138
00:15:12,410 --> 00:15:22,330
The first one's called add streams. Add streams takes two streams: s1 and s2.

139
00:15:22,330 --> 00:15:22,460
and.

140
00:15:22,460 --> 00:15:32,970
It's going to produce a stream whose elements are the are the corresponding sums. We just sort of add them element-wise.

141
00:15:32,970 --> 00:15:36,810
If either stream is empty, we just return the other one.

142
00:15:36,810 --> 00:15:50,090
Otherwise, we're going to make a new stream whose head is the sum of the two heads and whose tail is the result of recursively adding the tails.

143
00:15:50,090 --> 00:15:53,150
So that will produce the element-wise sum of two streams.

144
00:15:53,150 --> 00:15:57,500
And then another useful thing to have around is scale stream.

145
00:15:57,500 --> 00:16:09,710
Scale stream takes some constant number in a stream s and is going to produce the stream of elements of s multiplied by this constant.

146
00:16:09,710 --> 00:16:18,290
And that's easy, that's just a map of the function of an element that multiplies it by the constant, and we map that down the stream.

147
00:16:20,520 --> 00:16:27,910
So given those two, let me show you what I mean by programs that operate on streams all at once.

148
00:16:27,910 --> 00:16:30,200
Let's look at this.

149
00:16:30,200 --> 00:16:31,680
Suppose I write this.

150
00:16:31,680 --> 00:16:52,190
I say define--  I'll call it ones-- to be cons-stream of 1 onto ones.

151
00:16:54,860 --> 00:16:56,950
What's that?

152
00:16:56,950 --> 00:17:03,330
That's going to be an infinite stream of ones because the first thing is 1.

153
00:17:03,330 --> 00:17:11,780
And the tail of it is a thing whose first thing is 1 and whose tail is a thing whose first thing is 1 and so on and so on and so on.

154
00:17:11,780 --> 00:17:15,130
So that's an infinite stream of ones.

155
00:17:15,130 --> 00:17:18,599
And now using that, let me give you another definition of the integers.

156
00:17:18,599 --> 00:17:48,270
We can define the integers to be-- well, the first integer we'll take to be 1, this cons-stream of 1 onto the element-wise sum onto add streams of the integers to ones.

157
00:17:54,950 --> 00:18:06,640
The integers are a thing whose first element is 1, and the rest of them you get by taking those integers and incrementing each one by one.

158
00:18:06,640 --> 00:18:13,940
So the second element of the integers is the first element of the integers incremented by one.

159
00:18:13,940 --> 00:18:31,250
And the rest of that is the next one, and the third element of that is the same as the first element of the tail of the integers incremented by one, which is the same as the first element of the original integers incremented by one and incremented by one again and so on.

160
00:18:35,240 --> 00:18:36,310
That looks pretty suspicious.

161
00:18:36,310 --> 00:18:40,150
See, notice that it works because of delay.

162
00:18:40,150 --> 00:18:43,870
See, this looks like-- let's take a look at ones.

163
00:18:43,870 --> 00:18:51,130
This looks like it couldn't even be processed because it's suddenly saying in order to know what ones is, I say it's cons-stream of something onto ones.

164
00:18:51,130 --> 00:18:55,250
The reason that works is because of that very sneaky hidden delay in there.

165
00:18:55,250 --> 00:19:00,290
Because what this really is, remember, cons-stream is just an abbreviation.

166
00:19:00,290 --> 00:19:08,785
This really is cons of 1 onto delay of ones.

167
00:19:12,140 --> 00:19:15,500
So how does that work?

168
00:19:15,500 --> 00:19:18,020
You say I'm going to define ones.

169
00:19:18,020 --> 00:19:20,700
First I see what ones is supposed to be defined as.

170
00:19:20,700 --> 00:19:32,710
Well, ones is supposed to be defined as a cons whose first part is 1 and whose second part is, well, it's a promise to compute something that I don't worry about yet.

171
00:19:32,710 --> 00:19:37,270
So it doesn't bother me that at the point I do this definition, ones isn't defined.

172
00:19:37,270 --> 00:19:40,670
Having run the definition now, ones is defined.

173
00:19:40,670 --> 00:19:44,920
So that when I go and look at the tail of it, it's defined.

174
00:19:44,920 --> 00:19:46,590
It's very sneaky.

175
00:19:46,590 --> 00:19:48,470
And an integer is the same way.

176
00:19:48,470 --> 00:19:53,210
I can refer to integers here because hidden way down-- because of this cons-stream.

177
00:19:53,210 --> 00:19:57,050
It's the cons-stream of 1 onto something that I don't worry that yet.

178
00:19:57,050 --> 00:20:02,570
So I don't look at it, and I don't notice that integers isn't defined at the point where I try and run the definition.

179
00:20:06,320 --> 00:20:12,430
OK, let me draw a picture of that integers thing because it still maybe seems a little bit shaky.

180
00:20:12,430 --> 00:20:15,020
What do I do?

181
00:20:15,020 --> 00:20:26,590
I've got the stream of ones, and that sort of comes in and goes into an adder that's going to be this add streams thing.

182
00:20:29,310 --> 00:20:35,760
And that goes in-- that's going to put out the integers.

183
00:20:40,760 --> 00:20:48,060
And the other thing that goes into the adder here is the integer, so there's a little feedback loop.

184
00:20:48,060 --> 00:20:53,180
And all I need to start it off is someplace I've got a stick that initial 1.

185
00:20:57,100 --> 00:21:02,910
In a real signal processing thing, this might be a delay element with that was initialized to 1.

186
00:21:02,910 --> 00:21:07,860
But there's a picture of that ones program.

187
00:21:07,860 --> 00:21:17,360
And in fact, that looks a lot like-- if you've seen real signal block diagram things, that looks a lot like accumulators, finite state accumulators.

188
00:21:17,360 --> 00:21:28,440
And in fact, we can modify this a little bit to change this into something that integrates a stream or a finite state accumulator, however you like to think about it.

189
00:21:28,440 --> 00:21:45,700
So instead of the ones coming in and getting out the integers, what we'll do is say there's a stream s coming in, and we're going to get out the integral of this, successive values of that, and it looks almost the same.

190
00:21:45,700 --> 00:21:54,260
The only thing we're going to do is when s comes in here, before we just add it in we're going to multiply it by some number dt.

191
00:21:57,680 --> 00:22:00,000
And now what we have here, this is exactly the same thing.

192
00:22:00,000 --> 00:22:04,020
We have a box, which is an integrator.

193
00:22:09,790 --> 00:22:19,980
And it takes in a stream s, and instead of 1 here, we can put the additional value for the integral.

194
00:22:19,980 --> 00:22:25,270
And that one looks very much like a signal processing block diagram program.

195
00:22:25,270 --> 00:22:27,980
In fact, here's the procedure that looks exactly like that.

196
00:22:31,490 --> 00:22:34,010
Find the integral of a stream.

197
00:22:34,010 --> 00:22:42,230
So an integral's going to take a stream and produce a new stream, and it takes in an initial value and some time constant.

198
00:22:42,230 --> 00:22:43,040
And what do we do?

199
00:22:43,040 --> 00:22:49,400
Well, we internally define this thing int, and we make this internal name so we can feed it back, loop it around itself.

200
00:22:49,400 --> 00:23:01,280
And int is defined to be something that starts out at the initial value, and the rest of it is gotten by adding together.

201
00:23:01,280 --> 00:23:06,880
We take our input stream, scale it by dt, and add that to int.

202
00:23:06,880 --> 00:23:10,690
And now we'll return from all that the value of integral is this thing int.

203
00:23:10,690 --> 00:23:15,920
And we use this internal definition syntax so we could write a little internal definition that refers to itself.

204
00:23:21,880 --> 00:23:23,710
Well, there are all sorts of things we can do.

205
00:23:23,710 --> 00:23:25,500
Let's try this one.

206
00:23:25,500 --> 00:23:26,895
how about the Fibonacci numbers.

207
00:23:26,895 --> 00:23:32,625
You can say define fibs.

208
00:23:36,350 --> 00:23:37,985
Well, what are the Fibonacci numbers?

209
00:23:37,985 --> 00:23:50,090
They're something that starts out with 0, and the next one is 1.

210
00:23:56,260 --> 00:24:11,000
And the rest of the Fibonacci numbers are gotten by adding the Fibonacci numbers to their own tail.

211
00:24:17,570 --> 00:24:20,580
There's a definition of the Fibonacci numbers.

212
00:24:20,580 --> 00:24:21,430
How does that work?

213
00:24:21,430 --> 00:24:31,870
Well, we start off, and someone says compute for us the Fibonacci numbers, and we're going to tell you it starts out with 0 and 1.

214
00:24:35,790 --> 00:24:45,830
And everything after the 0 and 1 is gotten by summing two streams. One is the fibs themselves, and the other one is the tail of the fibs.

215
00:24:48,870 --> 00:24:58,360
So if I know that these start out with 0 and 1, I know that the fibs now start out with 0 and 1, and the tail of the fibs start out with 1.

216
00:24:58,360 --> 00:25:06,300
So as soon as I know that, I know that the next one here is 0 plus 1 is 1, and that tells me that the next one here is 1 and the next one here is 1.

217
00:25:06,300 --> 00:25:09,390
And as soon as I know that, I know that the next one is 2.

218
00:25:09,390 --> 00:25:11,700
So the next one here is 2 and the next one here is 2.

219
00:25:11,700 --> 00:25:12,950
And this is 3.

220
00:25:14,720 --> 00:25:18,530
This one goes to 3, and this is 5.

221
00:25:18,530 --> 00:25:21,500
So it's a perfectly sensible definition.

222
00:25:21,500 --> 00:25:22,830
It's a one-line definition.

223
00:25:22,830 --> 00:25:30,150
And again, I could walk over to the computer and type that in, exactly that, and then say print stream the Fibonacci numbers, and they all come flying out.

224
00:25:32,790 --> 00:25:36,810
See, this is a lot like learning about recursion again.

225
00:25:36,810 --> 00:25:45,160
Instead of thinking that recursive procedures, we have recursively defined data objects.

226
00:25:45,160 --> 00:25:53,090
But that shouldn't surprise you at all, because by now, you should be coming to really believe that there's no difference really between procedures and data.

227
00:25:53,090 --> 00:25:58,210
In fact, in some sense, the underlying streams are procedures sitting there, although we don't think of them that way.

228
00:25:58,210 --> 00:26:03,630
So the fact that we have recursive procedures, well, then it should be natural that we have recursive data, too.

229
00:26:07,840 --> 00:26:09,720
OK, well, this is all pretty neat.

230
00:26:09,720 --> 00:26:14,990
Unfortunately, there are problems that streams aren't going to solve.

231
00:26:14,990 --> 00:26:17,580
Let me show you one of them.

232
00:26:17,580 --> 00:26:36,390
See, in the same way, let's imagine that we're building an analog computer to solve some differential equation like, say, we want to solve the equation y prime dy dt is y squared, and I'm going to give you some initial value.

233
00:26:36,390 --> 00:26:38,030
I'll tell you y of 0 equals 1.

234
00:26:41,060 --> 00:26:43,690
Let's say dt is equal to something.

235
00:26:46,770 --> 00:26:51,040
Now, in the old days, people built analog computers to solve these kinds of things.

236
00:26:51,040 --> 00:26:53,020
And the way you do that is really simple.

237
00:26:53,020 --> 00:27:03,055
You get yourself an integrator, like that one, an integrator box.

238
00:27:03,055 --> 00:27:08,530
And we put in the initial value y of 0 is 1.

239
00:27:08,530 --> 00:27:13,890
And now if we feed something in and get something out, we'll say, gee, what we're getting out is the answer.

240
00:27:13,890 --> 00:27:21,490
And what we're going to feed in is the derivative, and the derivative is supposed to be the square of the answer.

241
00:27:21,490 --> 00:27:42,910
So if we take these values and map using square, and if I feed this around, that's how I build a block diagram for an analog computer that solves this differential equation.

242
00:27:42,910 --> 00:27:47,230
Now, what we'd like to do is write a stream program that looks exactly like that.

243
00:27:47,230 --> 00:27:49,390
And what do I mean exactly like that?

244
00:27:49,390 --> 00:28:13,790
Well, I'd say define y to be the integral of dy starting at 1 with 0.001 as a time step.

245
00:28:13,790 --> 00:28:16,805
And I'd like to say that says this.

246
00:28:16,805 --> 00:28:20,850
And then I'd like to say, well, dy is gotten by mapping the square along y.

247
00:28:20,850 --> 00:28:33,510
So define dy to be map square along y.

248
00:28:33,510 --> 00:28:41,410
So there's a stream description of this analog computer, and unfortunately, it doesn't work.

249
00:28:41,410 --> 00:28:51,190
And you can see why it doesn't work because when I come in and say define y to be the integral of dy, it says, oh, the integral of y-- huh?

250
00:28:51,190 --> 00:28:53,710
Oh, that's undefined.

251
00:28:53,710 --> 00:28:58,770
So I can't write this definition before I've written this one.

252
00:28:58,770 --> 00:29:03,580
On the other hand, if I try and write this one first, it says, oh, I define y to be the map of square along y?

253
00:29:03,580 --> 00:29:05,770
Oh, that's not defined yet.

254
00:29:05,770 --> 00:29:11,580
So I can't write this one first, and I can't write that one first. So I can't quite play this game.

255
00:29:17,560 --> 00:29:20,460
Well, is there a way out?

256
00:29:20,460 --> 00:29:22,200
See, we can do that with ones.

257
00:29:22,200 --> 00:29:34,770
See, over here, we did this thing ones, and we were able to define ones in terms of ones because of this delay that was built inside because cons-stream had a delay.

258
00:29:34,770 --> 00:29:36,070
Now, why's it sensible?

259
00:29:36,070 --> 00:29:40,730
Why's it sensible for cons-stream to be built with this delay?

260
00:29:40,730 --> 00:29:45,950
The reason is that cons-stream can do a useful thing without looking at its tail.

261
00:29:45,950 --> 00:29:54,870
See, if I say this is cons-stream of 1 onto something without knowing anything about something, I know that the stream starts off with 1.

262
00:29:54,870 --> 00:29:57,910
That's why it was sensible to build something like cons-stream.

263
00:29:59,960 --> 00:30:06,320
So we put a delay in there, and that allows us to have this sort of self-referential definition.

264
00:30:06,320 --> 00:30:08,190
Well, integral is a little bit the same way.

265
00:30:08,190 --> 00:30:17,580
See, notice for an integral, I can-- let's go back and look at integral for a second.

266
00:30:17,580 --> 00:30:28,970
See, notice integral, it makes sense to say what's the first thing in the integral without knowing the stream that you're integrating.

267
00:30:28,970 --> 00:30:33,140
Because the first thing in the integral is always going to be the initial value that you're handed.

268
00:30:33,140 --> 00:30:37,090
So integral could be a procedure like cons-stream.

269
00:30:37,090 --> 00:30:46,710
You could define it, and then even before it knows what it's supposed to be integrating, it knows enough to say what its initial value is.

270
00:30:46,710 --> 00:30:58,430
So we can make a smarter integral, which is aha, you're going to give me a stream to integrate and an initial value, but I really don't have to look at that stream that I'm supposed to integrate until you ask me to work down the stream.

271
00:30:58,430 --> 00:31:03,710
In other words, integral can be like cons-stream, and you can expect that there's going to be a delay around its integrand.

272
00:31:03,710 --> 00:31:05,610
And we can write that.

273
00:31:05,610 --> 00:31:07,650
Here's a procedure that does that.

274
00:31:07,650 --> 00:31:17,110
Another version of integral, and this is almost like the previous one, except the stream it's going to get in is going to expect to be a delayed object.

275
00:31:17,110 --> 00:31:18,850
And how does this integral work?

276
00:31:18,850 --> 00:31:32,300
Well, the little thing it's going to define inside of itself says on the cons-stream, the initial value is the initial value, but only inside of that cons-stream, and remember, there's going to be a hidden delay inside here.

277
00:31:34,950 --> 00:31:43,180
Only inside of that cons-stream will I start looking at what the actual delayed object is.

278
00:31:43,180 --> 00:31:45,970
So my answer is the first thing's the initial value.

279
00:31:45,970 --> 00:31:59,260
If anybody now asks me for my tail, at that point, I'm going to force that delayed object-- and I'll call that s-- and I do the add streams. So this is an integral which is sort of like cons-stream.

280
00:31:59,260 --> 00:32:07,330
It's not going to actually try and see what you handed it as the thing to integrate until you look past the first element.

281
00:32:10,120 --> 00:32:27,090
And if we do that and we can make this work, all we have to do here is say define y to the integral of delay of y, of delay of dy.

282
00:32:27,090 --> 00:32:35,280
So y is going to be the integral of delay of dy starting at 1, and now this will work.

283
00:32:35,280 --> 00:32:44,600
Because I type in the definition of y, and that says, oh, I'm supposed to use the integral of something I don't care about right now because it's a delay.

284
00:32:44,600 --> 00:32:46,320
And these things, now you define dy.

285
00:32:46,320 --> 00:32:47,550
Now, y is defined.

286
00:32:47,550 --> 00:32:51,700
So when I define dy, it can see that definition for y.

287
00:32:51,700 --> 00:32:52,840
Everything is now started up.

288
00:32:52,840 --> 00:32:54,920
Both streams have their first element.

289
00:32:54,920 --> 00:33:00,590
And then when I start mapping down, looking at successive elements, both y and dy are defined.

290
00:33:00,590 --> 00:33:08,660
So there's a little game you can play that goes a little bit beyond just using the delay that's hidden inside streams. Questions?

291
00:33:13,178 --> 00:33:14,428
OK, let's take a break.

292
00:34:07,300 --> 00:34:14,320
Well, just before the break, I'm not sure if you noticed it, but something nasty started to happen.

293
00:34:14,320 --> 00:34:34,389
We've been going along with the streams and divorcing time in the programs from time in the computers, and all that divorcing got hidden inside the streams. And then at the very end, we saw that sometimes in order to really take advantage of this method, you have to pull out other delays.

294
00:34:34,389 --> 00:34:39,030
You have to write some explicit delays that are not hidden inside that cons-stream.

295
00:34:39,030 --> 00:34:49,929
And I did a very simple example with differential equations, but if you have some very complicated system with all kinds of self-loops, it becomes very, very difficult to see where you need those delays.

296
00:34:49,929 --> 00:34:55,550
And if you leave them out by mistake, it becomes very, very difficult to see why the thing maybe isn't working.

297
00:34:55,550 --> 00:35:08,690
So that's kind of mess, that by getting this power and allowing us to use delay, we end up with some very complicated programming sometimes, because it can't all be hidden inside the streams.

298
00:35:08,690 --> 00:35:11,036
Well, is there a way out of that?

299
00:35:11,036 --> 00:35:13,480
Yeah, there is a way out of that.

300
00:35:13,480 --> 00:35:25,450
We could change the language so that all procedures acted like cons-stream, so that every procedure automatically has an implicit delay around its arguments.

301
00:35:25,450 --> 00:35:27,520
And what would that mean?

302
00:35:27,520 --> 00:35:32,210
That would mean when you call a procedure, the arguments wouldn't get evaluated.

303
00:35:32,210 --> 00:35:39,260
Instead, they'd only be evaluated when you need them, so they might be passed off to some other procedure, which wouldn't evaluate them either.

304
00:35:39,260 --> 00:35:42,150
So all these procedures would be passing promises around.

305
00:35:42,150 --> 00:35:52,380
And then finally maybe when you finally got down to having to look at the value of something that was handed to a primitive operator would you actually start calling in all those promises.

306
00:35:52,380 --> 00:36:02,920
If we did that, since everything would have a uniform delay, then you wouldn't have to write any explicit delays, because it would be automatically built into the way the language works.

307
00:36:02,920 --> 00:36:34,560
Or another way to say that, technically what I'm describing is what's called-- if we did that, our language would be so-called normal-order evaluation language versus what we've actually been working with, which is called applicative order--  versus applicative-order evaluation.

308
00:36:34,560 --> 00:36:36,835
And remember the substitution model for applicative order.

309
00:36:36,835 --> 00:36:43,590
It says when you go and evaluate a combination, you find the values of all the pieces.

310
00:36:43,590 --> 00:36:47,600
You evaluate the arguments and then you substitute them in the body of the procedure.

311
00:36:47,600 --> 00:36:49,890
Normal order says no, don't do that.

312
00:36:49,890 --> 00:36:58,640
What you do is effectively substitute in the body of the procedure, but instead of evaluating the arguments, you just put a promise to compute them there.

313
00:36:58,640 --> 00:37:09,340
Or another way to say that is you take the expressions for the arguments, if you like, and substitute them in the body of the procedure and go on, and never really simplify anything until you get down to a primitive operator.

314
00:37:09,340 --> 00:37:11,840
So that would be a normal-order language.

315
00:37:11,840 --> 00:37:13,490
Well, why don't we do that?

316
00:37:13,490 --> 00:37:18,940
Because if we did, we'd get all the advantages of delayed evaluation with none of the mess.

317
00:37:18,940 --> 00:37:24,710
In fact, if we did that and cons was just a delayed procedure, that would make cons the same as cons-stream.

318
00:37:24,710 --> 00:37:32,350
We wouldn't need streams of all because lists would automatically be streams. That's how lists would behave, and data structures would behave that way.

319
00:37:32,350 --> 00:37:35,270
Everything would behave that way, right?

320
00:37:35,270 --> 00:37:41,020
You'd never really do any computation until you actually needed the answer.

321
00:37:41,020 --> 00:37:44,790
You wouldn't have to worry about all these explicit annoying delays.

322
00:37:44,790 --> 00:37:47,160
Well, why don't we do that?

323
00:37:47,160 --> 00:37:49,230
First of all, I should say people do do that.

324
00:37:49,230 --> 00:37:51,850
There's some very beautiful languages.

325
00:37:51,850 --> 00:38:00,710
One of the very nicest is a language called Miranda, which is developed by David Turner at the University of Kent.

326
00:38:00,710 --> 00:38:01,930
And that's how this language works.

327
00:38:01,930 --> 00:38:14,970
It's a normal-order language and its data structures, which look like lists, are actually streams. And you write ordinary procedures in Miranda, and they do these prime things and eight queens things, just without anything special.

328
00:38:14,970 --> 00:38:17,790
It's all built in there.

329
00:38:17,790 --> 00:38:19,040
But there's a price.

330
00:38:21,190 --> 00:38:23,170
Remember how we got here.

331
00:38:23,170 --> 00:38:27,480
We're decoupling time in the programs from time in the machines.

332
00:38:27,480 --> 00:38:33,140
And if we put delay, that sort of decouples it everywhere, not just in streams. Remember what we're trying to do.

333
00:38:33,140 --> 00:38:39,300
We're trying to think about programming as a way to specify processes.

334
00:38:39,300 --> 00:38:47,030
And if we give up too much time, our language becomes more elegant, but it becomes a little bit less expressive.

335
00:38:47,030 --> 00:38:51,480
There are certain distinctions that we can't draw.

336
00:38:51,480 --> 00:38:53,980
One of them, for instance, is iteration.

337
00:38:53,980 --> 00:39:01,230
Remember this old procedure, iterative factorial, that we looked at quite a long time ago.

338
00:39:01,230 --> 00:39:12,120
Iterative factorial had a thing, and it said there was an internal procedure, and there was a state which was a product and a counter, and we iterate that going around the loop.

339
00:39:12,120 --> 00:39:15,730
And we said that was an iterative procedure because it didn't build up state.

340
00:39:15,730 --> 00:39:23,900
And the reason it didn't build up state is because this iter that's called is just passing these things around to itself.

341
00:39:23,900 --> 00:39:31,660
Or in the substitution model, you could see in the substitution model that Jerry did, that in an iterative procedure, that state doesn't have to grow.

342
00:39:31,660 --> 00:39:34,840
And in fact, we said it doesn't, so this is an iteration.

343
00:39:34,840 --> 00:39:41,150
But now think about this exact same text if we had a normal-order language.

344
00:39:41,150 --> 00:39:45,650
What would happen is this would no longer be an iterative procedure?

345
00:39:45,650 --> 00:39:52,330
And if you really think about the details of the substitution model, which I'm not going to do here, this expression would grow.

346
00:39:52,330 --> 00:39:53,280
Why would it grow?

347
00:39:53,280 --> 00:39:58,080
It's because when iter calls itself, it calls itself with this product.

348
00:39:58,080 --> 00:40:02,510
If it's a normal-order language, that multiplication is not going to get done.

349
00:40:02,510 --> 00:40:06,670
That's going to say I'm to call myself with a promise to compute this product.

350
00:40:06,670 --> 00:40:09,760
And now iter goes around again.

351
00:40:09,760 --> 00:40:18,400
And I'm going to call myself with a promise to compute this product where now one of the one factors is a promise.

352
00:40:18,400 --> 00:40:19,430
And I call myself again.

353
00:40:19,430 --> 00:40:31,790
And if you write out the substitution model for that iterative process, you'll see exactly the same growth in state, all those promises that are getting remembered that have to get called in at the very end.

354
00:40:31,790 --> 00:40:36,980
So one of the disadvantages is that you can't really express iteration.

355
00:40:36,980 --> 00:40:54,610
Maybe that's a little theoretical reason why not, but in fact, people who are trying to write real operating systems in these languages are running into exactly these types of problems. Like it's perfectly possible to implement a text editor in languages like these.

356
00:40:54,610 --> 00:41:10,230
But after you work a while, you suddenly have 3 megabytes of stuff, which is-- I guess they call them the dragging tail problem of people who are looking at these, of promises that sort of haven't been called in because you couldn't quite express an iteration.

357
00:41:10,230 --> 00:41:20,110
And one of the research questions in these kinds of languages are figuring out the right compiler technology to get rid of the so-called dragging tails.

358
00:41:20,110 --> 00:41:23,940
It's not simple.

359
00:41:23,940 --> 00:41:32,056
But there's another kind of more striking issue about why you just don't go ahead and make your language normal order.

360
00:41:32,056 --> 00:41:42,000
And the reason is that normal-order evaluation and side effects just don't mix.

361
00:41:42,000 --> 00:41:45,350
They just don't go together very well.

362
00:41:45,350 --> 00:42:00,400
Somehow, you can't-- it's sort of you can't simultaneously go around trying to model objects with local state and change and at the same time do these normal-order tricks of de-coupling time.

363
00:42:00,400 --> 00:42:03,790
Let me just show you a really simple example, very, very simple.

364
00:42:03,790 --> 00:42:07,520
Suppose we had a normal-order language.

365
00:42:07,520 --> 00:42:09,550
And I'm going to start out in this language.

366
00:42:09,550 --> 00:42:10,520
This is now normal order.

367
00:42:10,520 --> 00:42:13,570
I'm going to define x to be 0.

368
00:42:13,570 --> 00:42:15,750
It's just some variable I'll initialize.

369
00:42:15,750 --> 00:42:22,640
And now I'm going to define this little funny function, which is an identity function.

370
00:42:22,640 --> 00:42:26,770
And what it does, it keeps track of the last time you called it using x.

371
00:42:31,620 --> 00:42:36,760
So the identity of n just returns n, but it sets x to be n.

372
00:42:36,760 --> 00:42:42,580
And now I'll define a little increment function, which is a very little, simple scenario.

373
00:42:42,580 --> 00:42:47,230
Now, imagine I'm interacting with this in the normal-order language, and I type the following.

374
00:42:47,230 --> 00:42:54,190
I say define y to be increment the identity function of 3, so y is going to be 4.

375
00:42:57,410 --> 00:42:59,520
Now, I say what's x?

376
00:42:59,520 --> 00:43:04,710
Well, x should have been the value that was remembered last when I called the identity function.

377
00:43:04,710 --> 00:43:08,530
So you'd expect to say, well, x is 3 at this point, but it's not.

378
00:43:08,530 --> 00:43:17,000
Because when I defined y here, what I really defined y to be increment of a promise to do this thing.

379
00:43:17,000 --> 00:43:21,560
So I didn't look at y, so that identity function didn't get run.

380
00:43:21,560 --> 00:43:25,320
So if I type in this definition and look at x, I'm going to get 0.

381
00:43:28,360 --> 00:43:38,342
Now, if I go look at y and say what's y, say y is 4, looking at y, that very active looking at y caused the identity function to be run.

382
00:43:38,342 --> 00:43:40,740
And now x will get remembered as 3.

383
00:43:40,740 --> 00:43:42,020
So here x will be 0.

384
00:43:42,020 --> 00:43:43,280
Here, x will be 3.

385
00:43:43,280 --> 00:43:57,100
That's a tiny, little, simple scenario, but you can see what kind of a mess that's going to make for debugging interactive programs when you have normal-order evaluation.

386
00:43:57,100 --> 00:43:59,690
It's very confusing.

387
00:43:59,690 --> 00:44:09,780
But it's very confusing for a very deep reason, which is that the whole idea of putting in delays is that you throw away time.

388
00:44:09,780 --> 00:44:11,750
That's why we can have these infinite processes.

389
00:44:11,750 --> 00:44:17,790
Since we've thrown away time, we don't have to wait for them to run, right?

390
00:44:17,790 --> 00:44:28,760
We decouple the order of events in the computer from what we write in our programs. But when we talk about state and set and change, that's exactly what we do want control of.

391
00:44:28,760 --> 00:44:34,570
So it's almost as if there's this fundamental contradiction in what you want.

392
00:44:34,570 --> 00:44:42,410
And that brings us back to these sort of philosophical mutterings about what is it that you're trying to model and how do you look at the world.

393
00:44:42,410 --> 00:44:47,140
Or sometimes this is called the debate over functional programming.

394
00:44:53,570 --> 00:45:00,440
A so-called purely functional language is one that just doesn't have any side effects.

395
00:45:00,440 --> 00:45:06,360
Since you have no side effects, there's no assignment operator, so there are no terrible consequences of it.

396
00:45:06,360 --> 00:45:07,930
You can use a substitution-like thing.

397
00:45:07,930 --> 00:45:15,050
Programs really are like mathematics and not like models in the real world, not like objects in the real world.

398
00:45:15,050 --> 00:45:17,170
There are a lot of wonderful things about functional languages.

399
00:45:17,170 --> 00:45:29,260
Since there's no time, you never have any synchronization problems. And if you want to put something into a parallel algorithm, you can run the pieces of that parallel processing any way you want.

400
00:45:29,260 --> 00:45:33,640
There's just never any synchronization to worry that, and it's a very congenial environment for doing this.

401
00:45:33,640 --> 00:45:35,450
The price is you give up assignment.

402
00:45:39,060 --> 00:45:44,520
So an advocate of a functional language would say, gee, that's just a tiny price to pay.

403
00:45:44,520 --> 00:45:46,510
You probably shouldn't use assignment most of the time anyway.

404
00:45:46,510 --> 00:45:54,190
And if you just give up assignment, you can be in this much, much nicer world than this place with objects.

405
00:45:54,190 --> 00:45:56,300
Well, what's the rejoinder to that?

406
00:45:56,300 --> 00:46:00,300
Remember how we got into this mess.

407
00:46:00,300 --> 00:46:04,440
We started trying to model things that had local state.

408
00:46:04,440 --> 00:46:06,840
So remember Jerry's random number generator.

409
00:46:06,840 --> 00:46:14,080
There was this random number generator that had some little state in it to compute the next random number and the next random number and the next random number.

410
00:46:14,080 --> 00:46:21,050
And we wanted to hide that state away from the Cesaro compute part process, and that's why we needed set.

411
00:46:21,050 --> 00:46:24,070
We wanted to package that stated modularly.

412
00:46:24,070 --> 00:46:27,560
Well, a functional programming person would say, well, you're just all wet.

413
00:46:27,560 --> 00:46:29,840
I mean, you can write a perfectly good modular program.

414
00:46:29,840 --> 00:46:33,250
It's just you're thinking about modularity wrong.

415
00:46:33,250 --> 00:46:36,880
You're hung up in this next random number and the next random number and the next random number.

416
00:46:36,880 --> 00:46:39,880
Why don't you just say let's write a program.

417
00:46:39,880 --> 00:46:44,445
Let's write an enumerator which just generates an infinite stream of random numbers.

418
00:46:49,010 --> 00:46:54,540
We can sort of have that stream all at once, and that's going to be our source of random numbers.

419
00:46:54,540 --> 00:47:06,880
And then if you like, you can put that through some sort of processor, which is-- I don't know-- a Cesaro test, and that can do what it wants.

420
00:47:06,880 --> 00:47:28,140
And what would come out of there would be a stream of successive approximations to pi.

421
00:47:28,140 --> 00:47:35,540
So as we looked further down this stream, we'd tug on this Cesaro thing, and it would pull out more and more random numbers.

422
00:47:35,540 --> 00:47:39,720
And the further and further we look down the stream, the better an approximation we'd get to pi.

423
00:47:39,720 --> 00:47:43,890
And it would do exactly the same as the other computation, except we're thinking about the modularity different.

424
00:47:43,890 --> 00:47:49,400
We're saying imagine we had all those infinite streams of random numbers all at once.

425
00:47:49,400 --> 00:47:53,860
You can see the details of this procedure in the book.

426
00:47:53,860 --> 00:48:03,280
Similarly, there are other things that we tend to get locked into on this one and that one and the next one and the next one, which don't have to be that way.

427
00:48:03,280 --> 00:48:08,900
Like you might think about like a banking system, which is a very simple idea.

428
00:48:08,900 --> 00:48:12,210
Imagine we have a program that sort of represents a bank account.

429
00:48:18,810 --> 00:48:31,510
The bank account might have in it-- if we looked at this in a sort of message-passing view of the world, we'd say a bank account is an object that has some local state in there, which is the balance, say.

430
00:48:34,110 --> 00:48:48,560
And a user using this system comes and sends a transaction request. So the user sends a transaction request, like deposit some money, and the bank account maybe-- let's say the bank account always responds with what the current balance is.

431
00:48:48,560 --> 00:48:54,350
The user says let's deposits some money, and the bank account sends back a message which is the balance.

432
00:48:54,350 --> 00:48:59,150
And the user says deposit some more, and the bank account sends back a message.

433
00:48:59,150 --> 00:49:03,200
And just like the random number generator, you'd say, gee, we would like to use set.

434
00:49:03,200 --> 00:49:09,570
We'd like to have balance be a piece of local state inside this bank account because we want to separate the state of the user from the state of the bank account.

435
00:49:13,280 --> 00:49:16,420
Well, that's the message-processing view.

436
00:49:16,420 --> 00:49:22,740
There's a stream view with that thing, which does the same thing without any set or side effects.

437
00:49:22,740 --> 00:49:31,180
And the idea is again we don't think about anything having local state.

438
00:49:31,180 --> 00:49:38,640
We think about the bank account as something that's going to process a stream of transaction requests.

439
00:49:38,640 --> 00:49:49,490
So think about this bank account not as something that goes message by message, but something that takes in a stream of transaction requests like maybe successive deposit announced.

440
00:49:49,490 --> 00:49:55,940
1, 2, 2, 4, those might be successive amounts to deposit.

441
00:49:55,940 --> 00:50:03,770
And then coming out of it is the successive balances 1, 3, 5, 9.

442
00:50:03,770 --> 00:50:10,820
So we think of the bank account not as something that has state, but something that acts sort of on the infinite stream of requests.

443
00:50:10,820 --> 00:50:12,370
But remember, we've thrown away time.

444
00:50:12,370 --> 00:50:30,010
So what we can do is if the user's here, we can have this infinite stream of requests being generated one at a time coming from the user and this transaction stream coming back on a printer being printed one at a time.

445
00:50:30,010 --> 00:50:39,560
And if we drew a little line here, right there to the user, the user couldn't tell that this system doesn't have state.

446
00:50:39,560 --> 00:50:42,660
It looks just like the other one, but there's no state in there.

447
00:50:45,120 --> 00:50:53,835
And by the way, just to show you, here's an actual implementation of this-- we'll call it make deposit account because you can only deposit.

448
00:50:53,835 --> 00:51:00,020
It takes an initial balance and then a stream of deposits you might make.

449
00:51:00,020 --> 00:51:00,820
And what is it?

450
00:51:00,820 --> 00:51:18,300
Well, it's just cons-stream of the balance onto make a new account stream whose initial balance is the old balance plus the first thing in the deposit stream and make deposit account works on the rest of which is the tail of the deposit stream.

451
00:51:18,300 --> 00:51:28,790
So there's sort of a very typical message-passing, object-oriented thing that's done without side effects at all.

452
00:51:28,790 --> 00:51:32,250
There are very many things you can do this way.

453
00:51:32,250 --> 00:51:36,400
Well, can you do everything without assignment?

454
00:51:36,400 --> 00:51:40,050
Can everybody go over to purely functional languages?

455
00:51:40,050 --> 00:51:48,100
Well, we don't know, but there seem to be places where purely functional programming breaks down.

456
00:51:48,100 --> 00:51:58,850
Where it starts hurting is when you have things like this, but you also mix it up with the other things that we had to worry that, which are objects and sharing and two independent agents being the same.

457
00:51:58,850 --> 00:52:02,960
So under a typical one, suppose you want to extend this bank account.

458
00:52:02,960 --> 00:52:04,210
So here's a bank account.

459
00:52:12,220 --> 00:52:18,780
Bank accounts take in a stream of transaction requests and put out streams of, say, balances or responses to that.

460
00:52:18,780 --> 00:52:26,090
But suppose you want to model the fact that this is a joint bank account between two independent people.

461
00:52:26,090 --> 00:52:33,140
So suppose there are two people, say, Bill and Dave, who have a joint bank account.

462
00:52:35,960 --> 00:52:36,850
How would you model this?

463
00:52:36,850 --> 00:52:45,880
Well, Bill puts out a stream of transaction requests, and Dave puts out a stream of transaction requests, and somehow, they have to merge into this bank account.

464
00:52:45,880 --> 00:53:01,190
So what you might do is write a little stream processing thing called merge, which sort of takes these, merges them together, produces a single stream for the bank account.

465
00:53:01,190 --> 00:53:03,610
Now they're both talking to the same bank account.

466
00:53:03,610 --> 00:53:06,600
That's all great, but how do you write merge?

467
00:53:06,600 --> 00:53:09,730
What's this procedure merge?

468
00:53:09,730 --> 00:53:12,760
You want to do something that's reasonable.

469
00:53:12,760 --> 00:53:24,150
Your first guess might be to say, well, we'll take alternate requests from Bill and Dave. But what happens if suddenly in the middle of this thing, Dave goes away on vacation for two years?

470
00:53:24,150 --> 00:53:27,690
Then Bill's sort of stuck.

471
00:53:27,690 --> 00:53:29,750
So what you want to do is-- well, it's hard to describe.

472
00:53:29,750 --> 00:53:33,380
What you want to do is what people call fair merge.

473
00:53:38,410 --> 00:53:46,010
The idea of fair merge is it sort of should do them alternately, but if there's nothing waiting here, it should take one twice.

474
00:53:46,010 --> 00:53:48,450
Notice I can't even say that without talking about time.

475
00:53:51,300 --> 00:54:18,010
So one of the other active researcher areas in functional languages is inventing little things like fair merge and maybe some others, which will take the places where I used to need side effects and objects and sort of hide them away in some very well-defined modules of the system so that all the problems of assignment don't sort of leak out all over the system but are captured in some fairly well-understood things.

476
00:54:20,780 --> 00:54:38,360
More generally, I think what you're seeing is that we're running across what I think is a very basic problem in computer science, which is how to define languages that somehow can talk about delayed evaluation, but also be able to reflect this view that there are objects in the world.

477
00:54:38,360 --> 00:54:41,230
How do we somehow get both?

478
00:54:41,230 --> 00:54:43,040
And I think that's a very hard problem.

479
00:54:43,040 --> 00:54:53,840
And it may be that it's a very hard problem that has almost nothing to do with computer science, that it really is a problem having to do with two very incompatible ways of looking at the world.

480
00:54:53,840 --> 00:54:55,090
OK, questions?

481
00:55:17,556 --> 00:55:25,890
AUDIENCE: You mentioned earlier that once you introduce assignment, the general rule for using the substitution model is you can't.

482
00:55:25,890 --> 00:55:27,570
Unless you're very careful, you can't.

483
00:55:27,570 --> 00:55:28,260
PROFESSOR: Right.

484
00:55:28,260 --> 00:55:40,300
AUDIENCE: Is there a set of techniques or a set of guidelines for localizing the effects of assignment so that the very careful becomes defined?

485
00:55:40,300 --> 00:55:42,890
PROFESSOR: I don't know.

486
00:55:42,890 --> 00:55:45,430
Let me think.

487
00:55:45,430 --> 00:55:51,480
Well, certainly, there was an assignment inside memo proc, but that was sort of hidden away.

488
00:55:51,480 --> 00:55:53,480
It ended up not making any difference.

489
00:55:53,480 --> 00:56:00,390
Part of the reason for that is once this thing triggered that it had run and gotten an answer, that answer will never change.

490
00:56:00,390 --> 00:56:02,080
So that was sort of a one-time assignment.

491
00:56:02,080 --> 00:56:11,250
So one very general thing you can do is if you only do what's called a one-time assignment and never change anything, then you can do better.

492
00:56:11,250 --> 00:56:18,490
One of the problems in this merge thing, people have-- let me see if this is right.

493
00:56:18,490 --> 00:56:30,820
I think it's true that with fair merge, with just fair merge, you can begin effectively simulating assignment in the rest of the language.

494
00:56:30,820 --> 00:56:39,520
It seems like anything you do to go outside-- I'm not quite sure that's true for fair merge, but it's true of a little bit more general things that people have been doing.

495
00:56:39,520 --> 00:56:47,970
So it might be that any little bit you put in, suddenly if they allow you to build arbitrary stuff, it's almost as bad as having assignment altogether.

496
00:56:47,970 --> 00:56:51,590
But that's an area that people are thinking about now.

497
00:56:51,590 --> 00:57:04,730
AUDIENCE: I guess I don't see the problem here with merge if I call Bill, if Bill is a procedure, then Bill is going to increment the bank account or build the list that 's going to put in the next element.

498
00:57:04,730 --> 00:57:07,170
If I call Dave twice in a row, that will do that.

499
00:57:07,170 --> 00:57:09,350
I'm not sure where fair merge has to be involved.

500
00:57:09,350 --> 00:57:11,200
PROFESSOR: The problem is imagine these really as people.

501
00:57:11,200 --> 00:57:14,850
See, here I have the user who's interacting with this bank account.

502
00:57:14,850 --> 00:57:17,070
Put in a request, get an answer.

503
00:57:17,070 --> 00:57:18,200
AUDIENCE: Right.

504
00:57:18,200 --> 00:57:24,220
PROFESSOR: But if the only way I can process request is to alternate them from two people-- AUDIENCE: Well, why would you alternate them?

505
00:57:24,220 --> 00:57:25,070
PROFESSOR: Why don't I?

506
00:57:25,070 --> 00:57:26,140
AUDIENCE: Yes.

507
00:57:26,140 --> 00:57:26,580
Why do you?

508
00:57:26,580 --> 00:57:27,640
PROFESSOR: Think of them as real people, right?

509
00:57:27,640 --> 00:57:29,280
This guy might go away for a year.

510
00:57:29,280 --> 00:57:35,480
And you're sitting here at the bank account window, and you can't put in two requests because it's waiting for this guy.

511
00:57:35,480 --> 00:57:37,380
AUDIENCE: Why does it have to be waiting for one?

512
00:57:37,380 --> 00:57:39,110
PROFESSOR: Because it's trying to compute a function.

513
00:57:39,110 --> 00:57:41,720
I have to define a function.

514
00:57:41,720 --> 00:57:51,690
Another way to say that is the answer to what comes out of this merge box is not a function of what goes in.

515
00:57:51,690 --> 00:57:53,490
Because, see, what would the function be?

516
00:57:53,490 --> 00:58:03,470
Suppose he puts in 1, 1, 1, 1, and he puts in 2, 2, 2, 2.

517
00:58:03,470 --> 00:58:05,910
What's the answer supposed to be?

518
00:58:05,910 --> 00:58:08,740
It's not good enough to say it's 1, 2, 1, 2, 1, 2.

519
00:58:08,740 --> 00:58:09,390
AUDIENCE: I understand.

520
00:58:09,390 --> 00:58:11,560
But when Bill puts in 1, 1 goes in.

521
00:58:11,560 --> 00:58:13,950
When Dave puts in 2 twice, 2 goes in twice.

522
00:58:13,950 --> 00:58:15,450
When Bill puts in-- PROFESSOR: Right.

523
00:58:15,450 --> 00:58:23,980
AUDIENCE: Why can't it be hooked to the time of the input-- the actual procedural-- PROFESSOR: Because I don't have time.

524
00:58:23,980 --> 00:58:26,900
See, all I can say is I'm going to define a function.

525
00:58:26,900 --> 00:58:28,150
I don't have time.

526
00:58:32,070 --> 00:58:38,420
There's no concept if it's going to alternate, except if nobody's there, it's going to wait a while for him.

527
00:58:38,420 --> 00:58:47,810
It's just going to say I have the stream of requests, the timeless infinite streams of all the requests that Dave would have made, right?

528
00:58:47,810 --> 00:58:51,690
And the timeless infinite stream of all the requests Bill would have made, and I want to operate on them.

529
00:58:51,690 --> 00:58:53,510
See, that's how this bank account is working.

530
00:58:56,710 --> 00:59:05,340
And the problem is that these poor people who are sitting at the bank account windows have the misfortune to exist in time.

531
00:59:05,340 --> 00:59:10,070
They don't see their infinite stream of all the requests they would have ever made.

532
00:59:10,070 --> 00:59:11,550
They're waiting now, and they want an answer.

533
00:59:14,290 --> 00:59:25,290
So if you're sitting there-- if this is the screen operation on some time-sharing system and it's working functionally, you want an answer then when you talk the character.

534
00:59:25,290 --> 00:59:30,910
You don't want it to have to wait for everybody in the whole system to have typed one character before it can get around to service you.

535
00:59:30,910 --> 00:59:33,890
So that's the problem.

536
00:59:33,890 --> 00:59:36,850
I mean, the fact that people live in time, apparently.

537
00:59:36,850 --> 00:59:38,620
If they didn't, it wouldn't be a problem.

538
00:59:49,100 --> 00:59:54,740
AUDIENCE: I'm afraid I miss the point of having no time in this banking transaction.

539
00:59:54,740 --> 00:59:56,880
Isn't time very important?

540
00:59:56,880 --> 01:00:00,790
For instance, the sequence of events.

541
01:00:00,790 --> 01:00:08,400
If Dave take out $100, then the timing sequence should be important.

542
01:00:08,400 --> 01:00:11,260
How do you treat transactions as streams?

543
01:00:11,260 --> 01:00:14,260
PROFESSOR: Well, that's the thing I'm saying.

544
01:00:14,260 --> 01:00:17,510
This is an example where you can't.

545
01:00:17,510 --> 01:00:18,610
You can't.

546
01:00:18,610 --> 01:00:24,170
The point is what comes out of here is simply not a function of the stream going in here and the stream going in here.

547
01:00:24,170 --> 01:00:32,860
It's a function of the stream going in here and the stream going in here and some kind of information about time, which is precisely what a normal-order language won't let you say.

548
01:00:34,810 --> 01:00:46,400
AUDIENCE: In order to brings this back into a more functional perspective, could we just explicitly time stamp all the inputs from Bill and Dave and define fair merge to just be the sort on those time stamps?

549
01:00:49,150 --> 01:00:49,550
PROFESSOR: Yeah, you can do that.

550
01:00:49,550 --> 01:00:50,600
You can do that sort of thing.

551
01:00:50,600 --> 01:01:00,970
Another thing you could say is imagine that really what this function is, is that it does a read every microsecond, and then if there's none there, that's considered an empty one.

552
01:01:00,970 --> 01:01:03,610
That's about equivalent to what you said.

553
01:01:03,610 --> 01:01:07,110
And yes, you can do that, but that's a clg.

554
01:01:07,110 --> 01:01:10,170
So it's not quite only implementation we're worried about.

555
01:01:10,170 --> 01:01:18,824
We're worried about expressive power in the language, and what we're running across is a real mismatch between what we can say easily and what we'd like to say.

556
01:01:18,824 --> 01:01:26,080
AUDIENCE: It sounds like where we're getting hung up with that is the fact it expects one input from both Bill and Dave at the same time.

557
01:01:26,080 --> 01:01:28,530
PROFESSOR: It's not quite one, but it's anything you define.

558
01:01:28,530 --> 01:01:36,110
So you can say Dave can go twice as often, but if anything you predefine, it's not the right thing.

559
01:01:36,110 --> 01:01:41,930
You can't decide at some particular function of their input requests.

560
01:01:41,930 --> 01:01:47,290
Worse yet, I mean, worse yet, there are things that even merge can't do.

561
01:01:47,290 --> 01:01:52,470
One thing you might want to do that's even more general is suddenly you add somebody else to this bank account system.

562
01:01:52,470 --> 01:01:56,030
You go and you add John to this bank account system.

563
01:01:56,030 --> 01:02:02,040
And now there's yet another stream that's going to come into the picture at some time which we haven't prespecified.

564
01:02:02,040 --> 01:02:08,860
So that's something even fair merge can't do, and they're things called-- I forget-- natagers or something.

565
01:02:08,860 --> 01:02:11,790
That's a generalization of fair merge to allow that.

566
01:02:11,790 --> 01:02:19,580
There's a whole sort of research discipline saying how far can you push this functional perspective by adding more and more mechanism?

567
01:02:19,580 --> 01:02:25,610
And how far does that go before the whole thing breaks down and you might as well been using set anyway.

568
01:02:25,610 --> 01:02:28,960
AUDIENCE: You need to set him up on automatic deposit.

569
01:02:28,960 --> 01:02:39,630
[LAUGHTER]

570
01:02:39,630 --> 01:02:40,880
PROFESSOR: OK, thank you.

