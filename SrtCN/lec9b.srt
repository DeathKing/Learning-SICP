1
00:00:16,300 --> 00:00:18,080
教授：我想大家已经意识到
PROFESSOR: Well, I hope you appreciate that we have

2
00:00:20,010 --> 00:00:22,730
我们介绍了一些真正的魔法
we have inducted you into some real magic,

3
00:00:24,200 --> 00:00:27,240
创造新语言的魔法
the magic of building languages

4
00:00:27,420 --> 00:00:28,720
用来创造全新的语言
really building new languages.

5
00:00:29,690 --> 00:00:30,400
我们学了些什么？
What have we looked at?

6
00:00:30,430 --> 00:00:32,780
我们学习了一门用来操作图片的Escher的语言
We've looked at an Escher picture language.

7
00:00:38,920 --> 00:00:41,150
这门语言由Peter Henderson发明
OK? this language invented by Peter Henderson.

8
00:00:42,010 --> 00:00:46,490
我们还学习了数字逻辑语言
We looked at digital logic language.

9
00:00:53,160 --> 00:00:55,550
以及 我们还学习了查询语言
Let's see.We've looked at the query language.

10
00:00:59,700 --> 00:01:00,780
然而你需要明白的是
And the thing you should realize is,

11
00:01:00,810 --> 00:01:03,100
尽管它们都是“玩具级”的语言示例
even though these were toy examples,

12
00:01:04,700 --> 00:01:07,610
但也确实是实用工具的核心
they really are the kernels of really useful things.

13
00:01:08,250 --> 00:01:09,480
比如说
So, for instance,

14
00:01:10,120 --> 00:01:11,184
Escher图片语言
the Escher picture language

15
00:01:11,200 --> 00:01:14,336
就被MIT的学生Henry Wu拿去
 was taken byHenry Wu, who's a student at MIT,

16
00:01:14,880 --> 00:01:16,432
开发成了一门用于
and developed into a real

17
00:01:16,976 --> 00:01:19,450
为电路板布局的语言
language for laying out PC boards,

18
00:01:20,350 --> 00:01:22,560
它就是在这些结构上扩展而来
based just on extending those structures.

19
00:01:23,240 --> 00:01:24,650
至于数字逻辑语言
And the digital logic language,

20
00:01:24,680 --> 00:01:26,080
Gerry教授在上课的时候也提到过
Gerry mentioned when he showed it to you,

21
00:01:26,430 --> 00:01:29,920
它被扩展为了一个仿真器的基础
was really extended to be used as the basis for a simulator

22
00:01:30,850 --> 00:01:32,960
用来设计真实的计算机
that was used to design a real computer.

23
00:01:33,460 --> 00:01:34,320
至于查询语言
And the query language,

24
00:01:34,350 --> 00:01:36,440
当然就是Prolog语言的一种核心
of course, is kind of the germ of prolog.

25
00:01:37,510 --> 00:01:39,070
我们构造的这些语言
So we built all of these languages,

26
00:01:39,550 --> 00:01:40,650
全都是用Lisp编写
they're all based on LISP.

27
00:01:43,630 --> 00:01:44,590
很多人问
A lot of people ask

28
00:01:45,270 --> 00:01:48,730
Lisp适合用来解决哪一类问题？
what particular problems is LISP good for solving for?

29
00:01:48,750 --> 00:01:49,930
答案就是
The answer is LISP is not...

30
00:01:50,330 --> 00:01:52,650
Lisp不适合解决任何一类问题
LISP is not good for solving any particular problems.

31
00:01:53,530 --> 00:01:54,600
Lisp擅长的是
What LISP is good for

32
00:01:54,730 --> 00:01:57,150
用它来构造一门合适的语言
is constructing within it the right language

33
00:01:57,180 --> 00:01:58,570
来解决你的问题
to solve the problems you want to solve,

34
00:01:59,170 --> 00:02:00,440
你应该像这样看待Lisp
and that's how you should think about it.

35
00:02:01,470 --> 00:02:03,390
那么既然这些语言都基于Lisp
So all of these languages were based on LISP.

36
00:02:04,570 --> 00:02:05,720
那Lisp又基于什么？
Now, what's LISP based on?

37
00:02:06,970 --> 00:02:07,880
它又从何而来？
Where's that come from?

38
00:02:07,900 --> 00:02:09,400
这个我们也学过
Well, we looked at that too.

39
00:02:09,580 --> 00:02:16,090
我们学过元循环求值器
We looked at the meta-circular evaluator

40
00:02:21,530 --> 00:02:23,400
学习了元循环求值器后 我们说
the meta-circular evaluator and sort of said

41
00:02:23,420 --> 00:02:25,760
Lisp就是基于Lisp的
well, LISP is based on LISP.

42
00:02:25,800 --> 00:02:27,480
而当我们研究它的时候
And when we start looking at that,

43
00:02:28,270 --> 00:02:29,950
我们必须得施展一些真正的魔法 对吧？
we've got to do some real magic, right?

44
00:02:29,950 --> 00:02:31,740
这又是什么意思呢？
So what does that mean, right?

45
00:02:31,740 --> 00:02:34,960
Y算子、不动点
Y operators, and fixed points,

46
00:02:35,760 --> 00:02:38,330
以及这样的一个观念--
and the idea that what this means is

47
00:02:38,360 --> 00:02:41,440
Lisp实际上是一个方程的不动点
that LISP is somehow the fixed-point equation for the

48
00:02:42,200 --> 00:02:45,420
一个通过自身来定义的有趣方程
for this funny set of things which are defined in terms of themselves.

49
00:02:47,400 --> 00:02:48,560
这确实是神奇的魔法
Now, it's real magic.

50
00:02:49,070 --> 00:02:52,350
那么今天 作为魔法的最后一步
Well, today, for a final piece of magic,

51
00:02:52,620 --> 00:02:54,030
我们要把它们通通消除掉
we're going to make all the magic go away.

52
00:03:06,800 --> 00:03:07,980
我们已经知道怎么做了
We already know how to do that.

53
00:03:09,770 --> 00:03:10,768
核心要思想是
The idea is, we're going to take

54
00:03:11,136 --> 00:03:12,730
将Lisp语言
the register machine architecture

55
00:03:13,360 --> 00:03:15,500
实现在使用寄存器架构的机器上
and show how to implement LISP on terms of that.

56
00:03:15,500 --> 00:03:17,936
回想一下 寄存器机器的关键之处在于
And, remember, the idea of the register machine

57
00:03:19,600 --> 00:03:24,680
机器的一部分是确定且有穷的
is that there's a fixed and finite part of the machine.

58
00:03:24,720 --> 00:03:26,120
它有一个有穷状态控制器
There's a finite-state controller,

59
00:03:26,120 --> 00:03:27,872
它用特定的硬件
which dose particular thing

60
00:03:27,888 --> 00:03:29,310
去完成特定的事情
with a particular amount of hardware.

61
00:03:30,510 --> 00:03:31,740
其中还有一些运算所需的
There are particular data paths,

62
00:03:31,760 --> 00:03:33,240
特殊数据通路
the operation the machine does

63
00:03:33,550 --> 00:03:35,290
然后 为了实现递归
And then, in order to implement recursion

64
00:03:35,530 --> 00:03:37,600
并且维持无穷的假象
and sustain the illusion of infinity,

65
00:03:37,820 --> 00:03:39,770
还使用了一种称作“栈”的大内存
there's some large amount of memory, which is the stack.

66
00:03:42,060 --> 00:03:43,728
所以如果我们在
So, if we implement LISP

67
00:03:43,920 --> 00:03:45,500
寄存器机器上实现了Lisp
in terms of a register machine,

68
00:03:47,020 --> 00:03:48,350
那么这个时候
then everything ought to become,

69
00:03:48,400 --> 00:03:49,850
所有的东西都会完全具体化
at this point,completely concrete.

70
00:03:49,850 --> 00:03:51,230
所有的魔法都会消除
All the magic should go away.

71
00:03:51,650 --> 00:03:53,520
这堂课结束时
And, by the end of this talk,

72
00:03:53,530 --> 00:03:54,780
我想让你感觉到
I want you get the feeling

73
00:03:55,140 --> 00:03:59,050
相对于神秘的元循环求值器
that, as opposed to this very mysterious meta-circular evaluator

74
00:03:59,670 --> 00:04:02,600
Lisp求值器是非常具体的东西
that a LISP evaluator really is something that's concrete enough

75
00:04:02,850 --> 00:04:04,570
你甚至可以把它放在手心中
that you can hold in the palm of your hand.

76
00:04:04,760 --> 00:04:06,240
你可以想象一下
You should be able to imagine holding

77
00:04:06,570 --> 00:04:07,900
手里拿着一个Lisp解释器的情景
holding a LISP interpreter there.

78
00:04:09,630 --> 00:04:10,940
好 那我们怎么做呢？
All right, how are we going to do this?

79
00:04:10,950 --> 00:04:12,760
所有的原料都已经齐全
We already have all the ingredients.

80
00:04:13,960 --> 00:04:17,450
上节课Gerry教了你们
See, what you learned last time from Gerry

81
00:04:17,600 --> 00:04:21,470
对一个任意的Lisp过程
is how to take any particular couple of LISP procedures.

82
00:04:22,600 --> 00:04:24,280
如何手动地把它们
and hand-translate them

83
00:04:24,750 --> 00:04:26,670
翻译成在寄存器机器上运行的代码
into something that runs on a register machine.

84
00:04:28,200 --> 00:04:30,520
那么 要在寄存器机器上实现Lisp本身
So, to implement all of LISP on a register machine,

85
00:04:30,570 --> 00:04:31,440
我们只需要
all we have to do

86
00:04:31,690 --> 00:04:33,450
把最关键的过程
is take the particular procedures

87
00:04:33,680 --> 00:04:35,420
也就是元循环求值器
that are the meta-circular evaluator

88
00:04:36,170 --> 00:04:38,110
手工翻译成寄存器机器的代码
and hand-translate them for a register machine.

89
00:04:39,040 --> 00:04:40,250
这就实现了整个Lisp
And that does all of LISP

90
00:04:42,140 --> 00:04:43,008
因此 我们已经知道了
Right? So, in principle,

91
00:04:43,024 --> 00:04:44,430
实现的原理
we already know how to do this.

92
00:04:45,380 --> 00:04:46,544
而且实际上
And, indeed, it's going to be no

93
00:04:46,688 --> 00:04:48,864
这跟翻译
no different, in kind,

94
00:04:50,000 --> 00:04:53,400
递归版的阶乘或斐波那契数列
from in say recursive factorial

95
00:04:53,420 --> 00:04:54,670
没什么区别
or recursive Fibonacci.

96
00:04:54,670 --> 00:04:56,000
只是它规模更大 代码更多
It's just bigger and there's more of it.

97
00:04:56,840 --> 00:04:58,030
只是包含了更多细节
So it'd just be more details,

98
00:04:58,040 --> 00:04:59,660
但是没有任何新的概念
but nothing really conceptually new.

99
00:05:01,480 --> 00:05:03,020
当我们完成这个以后
And also, when we've done that,

100
00:05:03,080 --> 00:05:04,760
所有的东西都变得明确了
and the thing is completely explicit,

101
00:05:04,870 --> 00:05:06,910
当我们看到如何用一系列的
and we see how to implement LISP

102
00:05:06,940 --> 00:05:10,080
寄存器操作来实现Lisp之后
in terms of the actual sequential register operations,

103
00:05:10,160 --> 00:05:11,630
它就成为了我们整个课程中
that's going to be our final

104
00:05:11,950 --> 00:05:14,160
最明确的Lisp模型
most explicit model of LISP in this course.

105
00:05:14,810 --> 00:05:16,950
回忆一下 这个过程贯穿了整个课程
And, remember, that's a progression through this course.

106
00:05:16,950 --> 00:05:18,250
我们先从代换模型开始
We started out with substitution,

107
00:05:18,280 --> 00:05:19,580
它和代数有点相似
which is sort of like algebra.

108
00:05:20,240 --> 00:05:21,870
然后学习了环境模型
And then we went to the environment model,

109
00:05:21,880 --> 00:05:24,000
它引入了“框架”的概念
which talked about the actual frames

110
00:05:24,030 --> 00:05:25,310
以及框架之间的关联
and how they got linked together.

111
00:05:26,320 --> 00:05:27,880
然后我们在元循环求值器中
And then we made that more concrete

112
00:05:27,900 --> 00:05:29,360
把它变得更具体了
in the meta-circular evaluator.

113
00:05:31,050 --> 00:05:31,640
但是有的事情
There are things

114
00:05:31,870 --> 00:05:33,980
元循环求值器没有告诉我们
the meta-circular evaluator doesn't tell us.

115
00:05:34,360 --> 00:05:35,340
你应该认识到这点
You should realize that.

116
00:05:36,090 --> 00:05:38,640
比如说 我们还不知道
For instance, it left unanswered the question

117
00:05:38,730 --> 00:05:42,670
像这里的递归阶乘过程
of how a procedure, like recursive factorial here,

118
00:05:45,170 --> 00:05:47,130
为何不断地申请新的空间
somehow takes space that grows.

119
00:05:47,210 --> 00:05:47,980
另一方面
On the other hand,

120
00:05:48,160 --> 00:05:51,940
一个语法上看起来像是递归的过程
a procedure which also looks syntactically recursive,

121
00:05:52,110 --> 00:05:55,070
比如FACT-ITER 并不占用栈空间
called fact-iter, somehow doesn't take space.

122
00:05:55,100 --> 00:05:59,160
我们通过代换模型来证明
We justify that it doesn't need to take space

123
00:06:00,500 --> 00:06:01,960
它不占用空间
by showing the substitution model.

124
00:06:01,960 --> 00:06:02,940
但我们并没有说清楚
But we didn't really say

125
00:06:03,420 --> 00:06:06,760
机器是如何做到这一点的
how it happens that the machine manages to do that,

126
00:06:07,310 --> 00:06:08,910
这涉及到一些细节
that that has to do with the details

127
00:06:09,020 --> 00:06:11,120
比如参数是如何传递给过程的
of how arguments are passed to procedures

128
00:06:12,480 --> 00:06:13,690
这是我们在元循环求值器中
And that's the thing we didn't see

129
00:06:13,710 --> 00:06:15,340
没有看到的
in the meta-circular evaluator

130
00:06:15,360 --> 00:06:17,400
完全是因为在所实现的Lisp中
precisely because the way arguments

131
00:06:17,420 --> 00:06:19,200
把参数传递给过程的方式
got passed to procedures in this LISP

132
00:06:19,700 --> 00:06:20,590
取决于
depended on

133
00:06:21,020 --> 00:06:23,500
外部Lisp的传参方式
the way arguments got passed to procedures in this LISP.

134
00:06:25,870 --> 00:06:29,020
但现在 这一点将变得非常明确
But, now, that's going to become extremely explicit.

135
00:06:30,740 --> 00:06:31,120
好
OK.

136
00:06:31,230 --> 00:06:34,300
在开始研究求值器之前
Well, before going on to the evaluator,

137
00:06:34,360 --> 00:06:35,530
我先让你们感受一下
let me just give you a sense of

138
00:06:35,550 --> 00:06:37,000
一个完整Lisp系统是怎么样的
what a whole LISP system looks like

139
00:06:37,600 --> 00:06:39,360
这样你就可以知道 我们要讨论哪部分
so you can see the parts we're going to talk about

140
00:06:39,400 --> 00:06:40,810
不讨论哪些部分
and the parts we're not going to talk about.

141
00:06:43,180 --> 00:06:47,420
首先 这里有一个快乐的Lisp用户
Let's see, over here is a happy LISP user,

142
00:06:48,670 --> 00:06:52,650
他正在和一个叫做读取器的东西交流
and the LISP user is talking to something called the reader.

143
00:07:00,360 --> 00:07:01,530
读取器的工作是
The reader's job in life

144
00:07:01,950 --> 00:07:13,230
读取用户输入的字符串
is to take characters from the user

145
00:07:14,170 --> 00:07:16,620
把它们转化成一种称作
and turn them into data structures

146
00:07:17,200 --> 00:07:19,370
表结构内存的数据结构
in something called a list structure memory.

147
00:07:30,000 --> 00:07:31,720
读取器会读取--
All right, so the reader is going to take

148
00:07:32,650 --> 00:07:33,950
你敲出来的符号、括号
symbols, parentheses,

149
00:07:34,480 --> 00:07:37,120
A和B、1和3这些东西
and A's and B's, and 1s and 3s that you type in,

150
00:07:37,180 --> 00:07:39,040
并把它们变成表结构
and turn these into actual list structure:

151
00:07:39,150 --> 00:07:40,540
变成序对、指针等等
pairs, and pointers, and things.

152
00:07:42,350 --> 00:07:43,920
所以当求值器运行的时候
And so, by the time evaluator is going,

153
00:07:43,930 --> 00:07:45,100
环境里已经不存在原始字符了
there are no characters in the world.

154
00:07:45,850 --> 00:07:48,160
当然 在更现代的Lisp系统中
And, of course, in more modern Lisp systems, there's

155
00:07:49,000 --> 00:07:50,440
可能还有一大团东西
there's sort a big morass here

156
00:07:50,440 --> 00:07:52,170
存在于在读取器和用户之间
that might sit between the user and the reader:

157
00:07:52,410 --> 00:07:54,520
最顶层首先是视窗系统
you know, Windows systems, in top levels,

158
00:07:54,770 --> 00:07:56,030
以及鼠标之类的东西
and mice, and all kinds of things.

159
00:07:56,280 --> 00:07:58,200
但从概念上来说 都是在输入字符
But conceptually, characters are coming in.

160
00:07:59,930 --> 00:08:04,320
总之 读取器把它们都变成指针
All right, the reader transforms these into pointers

161
00:08:05,560 --> 00:08:07,280
指向内存中的对象
pointers to stuff in this memory,

162
00:08:08,270 --> 00:08:10,940
这是求值器的所能看到的东西
and that's what the evaluator sees

163
00:08:15,550 --> 00:08:16,040
明白吗？
OK?

164
00:08:17,020 --> 00:08:18,880
求值器有一些辅助函数
The evaluator has a bunch of helpers.

165
00:08:19,780 --> 00:08:23,160
包括你需要的所有基本运算
It has all possible primitive operators you might want.

166
00:08:23,160 --> 00:08:24,910
也就是说这里另有一盒子东西
So there's a completely separate box,

167
00:08:28,400 --> 00:08:30,250
比如浮点单元
a floating point unit,

168
00:08:32,220 --> 00:08:34,400
或者其它类似的东西来执行这些运算
or all sorts of things, which do the primitive operators.

169
00:08:35,390 --> 00:08:37,680
如果你需要支持更多的基本运算
there's and, if you want more special primitives,

170
00:08:37,710 --> 00:08:39,020
你就实现更多的运算符执行器
you build more primitive operators,

171
00:08:39,050 --> 00:08:40,480
但它们和求值器都是分离的
but they're separate from the evaluator.

172
00:08:42,080 --> 00:08:43,770
求值器最终算出结果
The evaluator finally gets an answer

173
00:08:45,168 --> 00:08:46,768
并且把它们告诉打印程序
and communicates that to the printer.

174
00:08:50,624 --> 00:08:52,016
现在 打印程序的任务就是
And now, the printer's job in life

175
00:08:52,016 --> 00:08:54,544
从求值器取得这个表结构
is this list structure coming from the evaluator,

176
00:08:55,392 --> 00:08:56,992
再把它们变回字符
and turn it back into characters,

177
00:09:01,856 --> 00:09:04,070
然后通过某种界面
and communicate them to the user through

178
00:09:04,288 --> 00:09:05,664
展示给用户
whatever interface there is.

179
00:09:08,050 --> 00:09:11,232
那么 今天我们要讨论的是这个求值器
OK. Well, today, what we're going to talk about is this evaluator.

180
00:09:12,670 --> 00:09:15,200
基本运算和Lisp没有什么特别的关系
The primitive operators have nothing particular to do with LISP,

181
00:09:15,200 --> 00:09:18,144
它们只取决于你怎么实现基本运算
they're however you like to implement primitive operations.

182
00:09:19,360 --> 00:09:22,180
读取器和打印程序实际上很复杂
The reader and printer are actually complicated,

183
00:09:22,180 --> 00:09:23,552
但是我们不去讨论它们
but we're not going to talk about them.

184
00:09:24,688 --> 00:09:27,100
从字符构建表的过程中
They sort of have to do with details of how you might build

185
00:09:27,100 --> 00:09:28,928
它们需要处理很多细节
build up list structure from characters.

186
00:09:29,900 --> 00:09:31,184
说来话长
So that is a long story,

187
00:09:31,184 --> 00:09:32,320
我们就不讨论它了
but we're not going to talk about it,

188
00:09:32,490 --> 00:09:33,696
关于表结构内存
the list structure memory,

189
00:09:34,368 --> 00:09:35,632
我们下次再来讨论
we'll talk about next time.

190
00:09:36,930 --> 00:09:39,728
那么去除了读取和打印的细节
So, pretty much, except for the details of reading and printing,

191
00:09:40,120 --> 00:09:41,712
关于这个求值器
the only mystery that's going to be left

192
00:09:41,728 --> 00:09:43,056
所剩下的唯一谜团
after you see the evaluator

193
00:09:43,250 --> 00:09:45,856
几乎就只有怎么在传统内存上构建表结构了
is how you build list structure on conventional memories.

194
00:09:46,656 --> 00:09:48,208
不过我们把那也放到下次来讨论
But we'll worry about that next time too.

195
00:09:50,580 --> 00:09:51,040
好
OK.

196
00:09:53,344 --> 00:09:56,110
那么 我们先来看看这个求值器
Well, let's start talking about the evaluator.

197
00:09:56,200 --> 00:09:58,320
我将要展示的这个求值器
The one that we're going to show you,

198
00:09:58,496 --> 00:10:01,120
我想 它并没有什么特别的
of course, is not, I think, nothing special about it.

199
00:10:01,152 --> 00:10:04,560
它只是一台专门运行Lisp的寄存器机器
It's just a particular register machine that runs LISP.

200
00:10:04,810 --> 00:10:06,096
它有七个寄存器
And it has seven registers,

201
00:10:07,888 --> 00:10:09,264
这是它的七个寄存器
and here are the seven registers.

202
00:10:09,890 --> 00:10:12,384
这个寄存器叫EXP
There's a register, called EXP

203
00:10:14,120 --> 00:10:15,536
它的任务是存放
and its job is to hold

204
00:10:16,368 --> 00:10:18,032
将要被求值的表达式
the expression to be evaluated.

205
00:10:18,370 --> 00:10:19,808
具体来说
And by that, I mean

206
00:10:20,384 --> 00:10:21,648
它存放的是一个指针
it's going to hold a pointer

207
00:10:22,032 --> 00:10:23,552
指针指向存放着求值的表达式
to someplace in list structure memory

208
00:10:23,568 --> 00:10:25,328
的一处表结构内存
the expression to be evaluated.

209
00:10:26,550 --> 00:10:27,824
还有一个叫做ENV的寄存器
There's a register, called ENV,

210
00:10:28,880 --> 00:10:30,288
它存放着环境
which holds the environment

211
00:10:31,000 --> 00:10:33,056
也就是表达式的求值环境
in which this expression is to be evaluated.

212
00:10:34,070 --> 00:10:35,024
同样的 这也是一个指针
And, again, I made a pointer.

213
00:10:35,024 --> 00:10:36,752
环境是一种数据结构
The environment is some data structure.

214
00:10:38,240 --> 00:10:40,144
这个叫做FUN的寄存器--
There's a register, called FUN, which will

215
00:10:40,752 --> 00:10:42,544
当你在应用一个过程时
which will hold the procedure to be applied

216
00:10:42,576 --> 00:10:43,968
它会存放这个过程
when you go to apply a procedure.

217
00:10:44,560 --> 00:10:46,240
还有寄存器ARGL
A register, called ARGL,

218
00:10:47,360 --> 00:10:49,344
它存放的是已求值的参数
which holds the list of evaluated arguments.

219
00:10:50,540 --> 00:10:51,600
从这里开始你能看到
What you can start seeing here is

220
00:10:51,632 --> 00:10:53,140
求值器的基本构造
the basic structure of the evaluator.

221
00:10:53,140 --> 00:10:54,490
回忆一下它是怎么工作的
Remember how evaluators work.

222
00:10:54,490 --> 00:10:56,624
对这一块输入表达式和环境
There's a piece that takes expressions and environments,

223
00:10:57,670 --> 00:10:59,712
而这一块接收函数
and there's a piece that takes functions

224
00:10:59,744 --> 00:11:02,144
或者说 过程以及参数
or procedures and arguments.

225
00:11:03,480 --> 00:11:06,304
EVAL-APPLY循环使用这些寄存器工作
And going back and forth around here is the eval/apply loop.

226
00:11:07,408 --> 00:11:09,696
所以这些是EVAL-APPLY的基本组成部分
So those are the basic pieces of the eval and apply.

227
00:11:10,200 --> 00:11:10,992
还有一些别的东西
Then there's some other things,

228
00:11:11,008 --> 00:11:11,610
比如CONTINUE寄存器
there's continue.

229
00:11:11,610 --> 00:11:15,340
你之前已经见过CONTINUE寄存器
You just saw before how the continue register is used to

230
00:11:15,340 --> 00:11:18,048
是如何实现递归以及栈操作的
implement recursion and stack discipline.

231
00:11:18,940 --> 00:11:20,688
还有个寄存器用来存放
There's a register that's going to hold the

232
00:11:20,944 --> 00:11:22,520
某个求值的结果
result of some evaluation.

233
00:11:24,140 --> 00:11:24,896
然后 除了这些以外
And then, besides that,

234
00:11:24,896 --> 00:11:26,432
还有一个临时寄存器
there's one temporary register,

235
00:11:26,700 --> 00:11:27,296
它就是UNEV
called UNEV,

236
00:11:27,296 --> 00:11:29,040
一般来讲 在求值器中
which typically, in the evaluator,

237
00:11:29,280 --> 00:11:32,720
它是用来存放正在求值的表达式
is going to be used to hold temporary pieces of the

238
00:11:32,896 --> 00:11:33,950
的临时部分
expression you're working on,

239
00:11:33,950 --> 00:11:35,728
就是那些尚未求值的部分
which you haven't gotten around to evaluate yet

240
00:11:36,976 --> 00:11:39,824
那么 这就是我的七寄存器机器
Right? So there's my machine: a seven-register machine.

241
00:11:40,960 --> 00:11:42,980
当然 你可能想造一台
And, of course, you might want to make a machine with

242
00:11:42,980 --> 00:11:44,960
有更多寄存器的机器 来取得更好性能
a lot more registers to get better performance,

243
00:11:44,976 --> 00:11:47,056
但我们这个只是一台小型机器
but this is just a tiny, minimal one.

244
00:11:48,480 --> 00:11:49,584
那么数据通路呢？
Well, how about the data paths?

245
00:11:49,780 --> 00:11:53,664
这台机器有很多专为Lisp设计的运算
This machine has a lot of special operations for LISP.

246
00:11:55,100 --> 00:11:58,080
这里有几条典型的数据通路
So, here are some typical data paths.

247
00:12:00,120 --> 00:12:01,040
其中一条可能是
A typical one might be,

248
00:12:01,370 --> 00:12:03,408
将EXP寄存器的值
oh, assign to the VAL register

249
00:12:03,408 --> 00:12:04,800
赋给VAL寄存器
the contents of the EXP register.

250
00:12:05,710 --> 00:12:08,016
用我们之前的数据通路图来说
That's in terms of those diagrams you saw,

251
00:12:08,032 --> 00:12:10,816
就是一条箭头上的小按钮
that's a little button on some arrow.

252
00:12:11,900 --> 00:12:13,136
这还有一个更复杂的
Here's a more complicated one.

253
00:12:13,690 --> 00:12:14,800
它判断
It says branch,

254
00:12:15,230 --> 00:12:19,584
如果EXP寄存器的内容是COND语句
if the thing in the expression register is a conditional

255
00:12:20,496 --> 00:12:22,720
那么这里就会跳转到EV-COND标号处
to some label here, called the ev-conditional.

256
00:12:23,808 --> 00:12:26,230
你可以想象出很多种实现它的方法
And you can imagine this implemented in a lot of different ways.

257
00:12:26,230 --> 00:12:28,368
你可以把这个判断看作是
You might imagine this conditional test

258
00:12:28,368 --> 00:12:29,984
一个特殊意图的子过程
as a special purpose sub-routine,

259
00:12:30,600 --> 00:12:33,952
而条件被表示成某种数据抽象
and conditional might be represented as some data abstraction

260
00:12:33,968 --> 00:12:36,000
你在这个层面上不用考虑它
that you don't care about at this level of detail.

261
00:12:36,610 --> 00:12:37,980
那么它可以用子过程实现
So that might be done as a sub-routine.

262
00:12:37,980 --> 00:12:40,672
如果机器通过硬件来判断表达式类型
This might be a machine with hardware-types,

263
00:12:40,900 --> 00:12:44,048
那么某些特定比特就代表了COND语句
and conditional might be testing some bits for a particular code.

264
00:12:45,350 --> 00:12:46,410
有很多种实现办法
There are all sorts of ways that's

265
00:12:46,410 --> 00:12:48,480
它们都低于我们关注的这一层抽象
beneath the level of abstraction we're looking at.

266
00:12:50,190 --> 00:12:51,712
然后还有另一种操作
Another kind of operation,

267
00:12:51,712 --> 00:12:53,240
以及其它很多操作
and there are a lot of different operations

268
00:12:53,240 --> 00:12:56,656
把EXP的第一个子句赋值给EXP
assigned to EXP, the first clause of what's in EXP.

269
00:12:56,840 --> 00:12:58,896
这可能是处理COND语句的一部分
This might be part of processing a conditional.

270
00:12:59,260 --> 00:13:01,808
同样 FIRST-SELECTOR这个选择子
And, again, first clause is some selector

271
00:13:03,072 --> 00:13:04,480
我们也不需要关心它的细节
whose details we don't care about.

272
00:13:04,496 --> 00:13:06,464
同样可以把那也看成一个子过程
And you can, again, imagine that as a sub-routine

273
00:13:06,460 --> 00:13:07,904
用来进行一些表操作
which'll do some list operations,

274
00:13:08,224 --> 00:13:09,180
或者你也可以想象成
or you can imagine that as

275
00:13:09,180 --> 00:13:10,736
一个直接构建在硬件中的东西
something that's built directly into hardware.

276
00:13:12,170 --> 00:13:13,712
我之所以强调
The reason I keep saying you can imagine it

277
00:13:14,032 --> 00:13:15,220
你可以把它想象成硬件直接实现
built directly into hardware

278
00:13:15,220 --> 00:13:17,808
是因为尽管有很多的运算
is even though there are a lot of operations,

279
00:13:18,360 --> 00:13:19,740
但也它们的数量也是固定的
there are still a fixed number of them.

280
00:13:20,128 --> 00:13:21,808
我记不清有多少 大概有150个
I forget how many, maybe 150.

281
00:13:22,370 --> 00:13:25,392
所以假设用硬件实现它们是合理的
So, it's plausible to think of building these directly into hardware.

282
00:13:26,416 --> 00:13:27,680
而这一条更加复杂
Here's a more complicated one.

283
00:13:28,270 --> 00:13:29,472
你会发现 这条涉及到
You can see this has to do with

284
00:13:29,472 --> 00:13:31,104
查找变量的值
looking up the values of variables.

285
00:13:31,500 --> 00:13:33,280
它会查找某条表达式中
It says assign to the VAL register

286
00:13:33,456 --> 00:13:36,912
某个变量的值
the result of looking up the variable value

287
00:13:36,992 --> 00:13:38,528
并赋值给VAL寄存器
of some particular expression,

288
00:13:39,180 --> 00:13:40,304
在本例中 也就是
which, in this case, is supposed to be

289
00:13:40,336 --> 00:13:42,000
在某个环境中查找变量
a variable in some environment.

290
00:13:42,800 --> 00:13:44,688
然后这个操作
And this'll be some operation

291
00:13:45,210 --> 00:13:47,504
会搜索整个环境结构
that search through the environment structure,

292
00:13:47,520 --> 00:13:48,976
无论环境是如何表示的
however it is represented,

293
00:13:49,376 --> 00:13:50,912
并查找该变量
and goes and looks up that variable.

294
00:13:52,176 --> 00:13:53,952
同样 它也不在我们思考的
And, again, that's below the level of detail

295
00:13:53,960 --> 00:13:54,864
的抽象层面上
that we're thinking about.

296
00:13:54,896 --> 00:13:57,300
它需要处理的细节是
This is... this has to do with the details of

297
00:13:57,552 --> 00:13:59,440
用来表示环境的数据结构
the data structures for representing environments.

298
00:14:00,070 --> 00:14:01,216
但是不管怎么说
But, anyway, there is this

299
00:14:01,312 --> 00:14:03,470
这就是这台寄存器机器的
there is this fixed and finite number

300
00:14:04,112 --> 00:14:06,080
有穷数量的固定操作
of operations in the register machine.

301
00:14:08,500 --> 00:14:11,600
那么 它的整体结构是什么样子的？
Well, what's its overall structure?

302
00:14:11,720 --> 00:14:13,232
这有几个典型的运算
Those are some typical operations.

303
00:14:14,768 --> 00:14:16,336
想一想 我们要做什么
Remember what we have to do,

304
00:14:16,440 --> 00:14:18,400
我们需要把元循环求值器
we have to take the meta-circular evaluator--

305
00:14:20,432 --> 00:14:22,760
这就是元循环求值器的一部分
and here's a piece of the meta-circular evaluator.

306
00:14:22,760 --> 00:14:26,896
这是书中使用抽象代码的版本
This is the one using abstract syntax that's in the book.

307
00:14:28,224 --> 00:14:31,536
它和Gerry教授给你们展示的有些不同
It's a little bit different from the one that Gerry shows you.

308
00:14:33,500 --> 00:14:35,104
关于求值器
And the main thing

309
00:14:35,136 --> 00:14:37,870
主要需要记住的是
to remember about the evaluator is that

310
00:14:37,870 --> 00:14:40,960
它是某种针对表达式类型的分情况分析
it's doing some sort of case analysis on the kinds of expressions:

311
00:14:43,760 --> 00:14:45,904
看它是否为自求值的 或被引用的
so if it's either self-evaluated, or quoted,

312
00:14:45,920 --> 00:14:46,864
或是别的什么
or whatever else.

313
00:14:48,560 --> 00:14:50,576
而在大部分情况下
And then, in the general case where

314
00:14:50,860 --> 00:14:52,960
它处理的是一个过程应用
the expression it's looking at is an application,

315
00:14:53,550 --> 00:14:55,360
那么里面有一些技巧性的递归过程
there's some tricky recursions going on.

316
00:14:55,750 --> 00:14:59,360
首先 EVAL要调用它自己
First of all, eval has to call itself

317
00:14:59,790 --> 00:15:01,456
来求值运算符以及
both to evaluate the operator

318
00:15:02,144 --> 00:15:04,048
所有的运算对象
and to evaluate all the operands.

319
00:15:05,880 --> 00:15:07,408
因此这些标红线的地方
So there's this sort of red recursion

320
00:15:07,632 --> 00:15:09,280
就是某种在语法树上的递归
of values walking down the tree

321
00:15:10,944 --> 00:15:12,270
这是很简单的递归
that's sort of the easy recursion.

322
00:15:12,270 --> 00:15:14,448
只是EVAL在递归地遍历语法树
That's just eval walking down this tree of expressions.

323
00:15:14,750 --> 00:15:15,536
然后在求值器中
Then, in the evaluator,

324
00:15:15,536 --> 00:15:16,460
有一个复杂的递归
there's a hard recursion.

325
00:15:16,490 --> 00:15:17,920
由绿线到红线的递归
There's the red to green.

326
00:15:18,000 --> 00:15:19,660
由EVAL调用APPLY
Eval calls apply.

327
00:15:22,470 --> 00:15:26,450
也就是把过程调用
That's the case where evaluating a procedure argument

328
00:15:26,450 --> 00:15:28,720
归约为了 将过程应用在
reduces to applying the procedure

329
00:15:28,944 --> 00:15:29,936
实参表上
to the list of arguments.

330
00:15:30,370 --> 00:15:31,760
然后请看APPLY
And then, apply comes over here.

331
00:15:34,770 --> 00:15:36,672
APPLY需要过程PROC和参数ARGS
Apply takes a procedure and arguments

332
00:15:37,650 --> 00:15:39,456
一般情况下
and, in the general case

333
00:15:39,488 --> 00:15:40,816
PROC都是一个复合过程
where there's a compound procedure,

334
00:15:41,050 --> 00:15:42,192
随着APPLY不断被调用
apply goes around and

335
00:15:42,256 --> 00:15:43,152
绿线处会调用红线处
green calls red.

336
00:15:43,344 --> 00:15:46,448
APPLY被调用并再次调用EVAL
Eval-- Apply comes around and calls eval again.

337
00:15:48,170 --> 00:15:49,792
EVAL会求值过程体
Eval's the body of the procedure

338
00:15:50,240 --> 00:15:52,592
基于一个扩展了的环境
in the result of extending the environment

339
00:15:53,696 --> 00:15:55,280
这个环境通过将过程的形式参数
with the parameters of the procedure

340
00:15:55,480 --> 00:15:56,928
与实际参数绑定起来而得
by binding the arguments.

341
00:15:59,620 --> 00:16:00,624
而对于最基本的情况
Except in the primitive case,

342
00:16:00,640 --> 00:16:02,528
它会调用PRIMITIVE-APPLY过程
where it just calls something else primitive-apply

343
00:16:02,736 --> 00:16:04,704
而那又不是求值器的工作了
which is not really the business of the evaluator.

344
00:16:05,980 --> 00:16:07,472
那么像这样从红到绿
So this sort of red to green,

345
00:16:07,470 --> 00:16:08,400
又到红又到绿
to red to green,

346
00:16:09,792 --> 00:16:12,720
这就是EVAL-APPLY循环
Right? That's the that's the eval/apply loop,

347
00:16:14,064 --> 00:16:15,744
这就是我们在求值器中
and that's the thing that we're going to want to see

348
00:16:16,192 --> 00:16:17,728
想要看到的东西
in the evaluator.

349
00:16:19,696 --> 00:16:21,070
这样 你不会惊异于
Well, it won't surprise you at all that

350
00:16:21,070 --> 00:16:23,520
这个求值器的两大部分
the two big pieces of this evaluator

351
00:16:25,344 --> 00:16:27,040
对应于EVAL-APPLY
are correspond to eval and apply.

352
00:16:27,470 --> 00:16:29,440
一个部分叫EVAL-DISPATCH
There's a piece called eval-dispatch,

353
00:16:29,600 --> 00:16:31,200
另一部分叫做APPLY-DISPATCH
and a piece called apply-dispatch.

354
00:16:32,000 --> 00:16:34,090
在我们关注代码细节之前
And, before we get into the details of the code,

355
00:16:34,208 --> 00:16:35,760
理解它们的方法就是
the way to understand this is to think,

356
00:16:36,090 --> 00:16:39,024
假设这些求值器的各个部分
again, in terms of these pieces of evaluator

357
00:16:39,024 --> 00:16:40,976
和这个世界中其它的部分有一些约定
having contracts with the rest of the world.

358
00:16:41,870 --> 00:16:43,184
在进入这些肮脏的细节前
What do they do from the outside

359
00:16:43,200 --> 00:16:45,504
它们在外部做了什么？
before getting into the grungy details?

360
00:16:45,780 --> 00:16:49,328
针对EVAL-DISPATCH的约定
Well, the contract for eval-dispatch--

361
00:16:50,016 --> 00:16:51,408
还记得吗 它对应的是EVAL
remember, it corresponds to eval.

362
00:16:51,552 --> 00:16:54,100
它要在环境中求值一个表达式
It's got to evaluate an expression in an environment.

363
00:16:54,100 --> 00:16:55,888
那么 这部分要做的就是
So, in particular, what this one is going to do,

364
00:16:56,520 --> 00:16:58,688
EVAL-DISPATCH会假设当你调用它的时候
eval-dispatch will assume that, when you call it,

365
00:16:59,680 --> 00:17:01,488
你想要求值的表达式
that the expression you want to evaluate

366
00:17:01,488 --> 00:17:02,528
就存放在EXP寄存器中
is in the EXP register.

367
00:17:03,640 --> 00:17:07,392
而求值所基于的环境
The environment in which you want the evaluation

368
00:17:07,456 --> 00:17:09,056
则存放在ENV环境中
to take place is in the ENV register.

369
00:17:09,560 --> 00:17:10,672
而CONTINUE寄存器用来指示
And continue tells you

370
00:17:10,848 --> 00:17:12,464
当求值完成后
the place where the machine should go next

371
00:17:12,528 --> 00:17:13,920
机器需要去向何方
when the evaluation is done.

372
00:17:17,280 --> 00:17:19,184
EVAL-DISPATCH的约定实际上就是
Eval-dispatch's contract is that

373
00:17:19,280 --> 00:17:21,264
它会执行实际的求值
it'll actually perform that evaluation,

374
00:17:21,400 --> 00:17:22,464
并且在求值结束后
and, at the end of which,

375
00:17:23,280 --> 00:17:25,632
它会转到由CONTINUE寄存器指定的位置
it'll end up at the place specified by continue.

376
00:17:26,610 --> 00:17:29,168
求值的结果会存放在VAL寄存器中
The result of the evaluation will be in the VAL register.

377
00:17:29,820 --> 00:17:30,960
需要提醒的是
And it just warns you,

378
00:17:30,992 --> 00:17:32,912
它对其余的寄存器
it makes no promises about

379
00:17:32,960 --> 00:17:34,608
不做任何承诺
what happens to rest the registers.

380
00:17:35,230 --> 00:17:36,816
其它所有的寄存器都可能被修改
All other registers might be destroyed.

381
00:17:37,490 --> 00:17:40,144
那么这是一部分
So, there's one piece, OK?

382
00:17:41,552 --> 00:17:43,488
这些部分一块构成了APPLY-DISPATCH
Together, the pieces, apply-dispatch

383
00:17:43,520 --> 00:17:44,928
它们对应了APPLY
that corresponds to apply,

384
00:17:46,096 --> 00:17:48,432
用来把一个过程应用在一些参数上
it's got to apply a procedure to some arguments,

385
00:17:48,730 --> 00:17:51,430
因此它假设ARGL寄存器
so it assumes that this register, ARGL,

386
00:17:51,680 --> 00:17:53,776
存放着求值后的参数列表
contains a list of the evaluated arguments.

387
00:17:54,540 --> 00:17:55,968
FUN寄存器存放着那个过程
FUN contains the procedure.

388
00:17:57,220 --> 00:17:58,832
它们对应于元循环求值器中的
Those correspond to the arguments to

389
00:17:58,944 --> 00:18:01,360
参数应用部分
the apply procedure in the meta-circular evaluator.

390
00:18:03,970 --> 00:18:06,048
在我们的这个求值器中
And apply, in this particular evaluator,

391
00:18:06,064 --> 00:18:07,584
我们APPLY时采用的约定是
we're going to use a discipline which says

392
00:18:07,720 --> 00:18:08,976
当APPLY完成后--
the place that apply

393
00:18:09,470 --> 00:18:11,200
机器应该跳转到
the place the machine should go to next

394
00:18:11,792 --> 00:18:13,456
的下一个地方应该是
when apply is done, is at the moment

395
00:18:13,552 --> 00:18:15,920
APPLY-DISPATCH被调用时的栈顶元素
apply-dispatch is called at the top of the stack

396
00:18:17,070 --> 00:18:21,248
这只是针对这台机器的约定
that's just discipline for the way this particular machine's organized.

397
00:18:21,840 --> 00:18:23,700
现在已经给出了APPLY的所有约定
And now apply's contract is given all that.

398
00:18:23,936 --> 00:18:25,376
它会去执行应用
It'll perform the application.

399
00:18:25,540 --> 00:18:27,856
这个应用的结果将会保存在VAL寄存器中
The result of that application will end up in VAL.

400
00:18:28,890 --> 00:18:29,952
栈会被弹出
The stack will be popped.

401
00:18:31,120 --> 00:18:31,664
同样的
And, again,

402
00:18:31,712 --> 00:18:34,030
其它所有寄存器的内容都可能被修改
the contents of all the other registers may be destroyed.

403
00:18:34,840 --> 00:18:37,824
那么 这就是这台机器的基本结构
All right? So that's the basic organization of this machine.

404
00:18:38,992 --> 00:18:41,504
我们先课间休息一下
Let's break for a little bit and see if there are any questions

405
00:18:41,520 --> 00:18:42,700
然后再来研究一个真实的例子
and then we'll do a real example.

406
00:18:43,530 --> 00:19:08,112
[音乐]
[JESU, JOY OF MAN'S DESIRING]

407
00:19:08,144 --> 00:19:13,472
《计算机程序的构造和解释》
The Structure And Interpretation of Computer Programs

408
00:19:33,100 --> 00:19:35,872
讲师： 哈罗德·艾伯森教授 及 格兰德·杰·萨斯曼教授
By: Prof. Harold Abelson && Sussman Jay Sussman


409
00:19:35,870 --> 00:19:40,384
《计算机程序的构造和解释》
The Structure And Interpretation of Computer Programs

410
00:19:40,380 --> 00:19:45,296
显式控制求值器
Explicit-control Evaluator

411
00:19:47,850 --> 00:19:49,952
现在 我们来研究一下这台寄存器机器
Well, let's take the register machine now,

412
00:19:50,416 --> 00:19:51,776
我们一步一步地跟进
and actually step through,

413
00:19:52,270 --> 00:19:56,944
具体到每一处细节
and really, in real detail,

414
00:19:57,072 --> 00:19:58,520
这样你就能完全具体地看到
so you see completely concrete

415
00:19:58,864 --> 00:20:01,248
表达式是如何求值的
how some expressions are evaluated,

416
00:20:03,150 --> 00:20:06,864
那么我们从一个非常简单的表达式开始
Alright? So, let's start with a very simple expression.

417
00:20:07,456 --> 00:20:13,520
我们要求值的表达式只有一个1
Let's evaluate the expression 1.

418
00:20:18,770 --> 00:20:20,400
我们需要一个环境
And we need an environment,

419
00:20:20,432 --> 00:20:22,352
因此我们假设某处有一个环境
so let's imagine that somewhere there's an environment

420
00:20:22,384 --> 00:20:23,392
我们把它记作E0
we'll call it E0.

421
00:20:30,064 --> 00:20:34,560
由于我们之后也要用到它
And just, since we'll use these later,

422
00:20:35,620 --> 00:20:37,040
而且显然不需要任何东西
we obviously don't really need anything

423
00:20:37,072 --> 00:20:37,930
就可以求值1
to evaluate 1.

424
00:20:38,360 --> 00:20:39,456
但是为了方便以后引用
But, just for reference later,

425
00:20:39,456 --> 00:20:40,944
我们假设环境E0中有
let's assume that E0 has in it

426
00:20:41,440 --> 00:20:43,152
X=3
an X that's bound to 3

427
00:20:43,720 --> 00:20:45,370
Y=4
and a Y that's bound to 4,

428
00:20:48,272 --> 00:20:48,784
好吗？
OK?

429
00:20:49,140 --> 00:20:50,128
现在 我们要做的就是
And now what we're going to do

430
00:20:50,510 --> 00:20:54,592
在这个环境中求值表达式1
is we're going to evaluate 1 in this environment

431
00:20:55,744 --> 00:20:58,544
这样 ENV寄存器就存放了一个指针
and so the ENV register has a pointer

432
00:20:59,650 --> 00:21:01,040
指向这个环境E0
to this environment, E0, all right?

433
00:21:03,312 --> 00:21:05,650
那么我们来看它是怎么进行的
Right? So let's watch that thing go.

434
00:21:05,650 --> 00:21:07,264
我要步步跟进代码
What I'm going to do is step through the code.

435
00:21:08,260 --> 00:21:10,000
这样的话 我会充当控制器
And, let's see, I'll be the controller.

436
00:21:10,040 --> 00:21:10,800
现在我需要的是--
And now what I need,

437
00:21:11,024 --> 00:21:12,490
由于这台机器已经变得相当复杂
since this gets rather complicated,

438
00:21:12,980 --> 00:21:16,830
我需要一个小小的执行单元
is a very little execution unit.

439
00:21:16,830 --> 00:21:18,160
那么请上我们的执行单元
So here's the execution unit, OK?

440
00:21:22,620 --> 00:21:23,120
好的
OK.

441
00:21:28,590 --> 00:21:29,968
好 现在我们要开始了
All right, now we're going to start.

442
00:21:30,530 --> 00:21:32,480
我们要从EVAL-DISPATCH启动机器
We're going to start the machine at eval-dispatch。

443
00:21:33,264 --> 00:21:34,624
这是整个过程的开始
Right? That's the beginning of this.

444
00:21:35,870 --> 00:21:38,752
EVAL-DISPATCH会查看表达式并进行分派
Eval-dispatch is going to look at the expression and dispatch,

445
00:21:39,320 --> 00:21:40,064
就像EVAL
just like eval

446
00:21:40,870 --> 00:21:42,000
先从第一句看起
where we look at the very first thing.

447
00:21:42,048 --> 00:21:47,950
先判断表达式是不是自求值的
We branch on whether or not this expression is self-evaluating.

448
00:21:47,950 --> 00:21:49,968
SELF-EVALUATING?是我们放入机器的
Self-evaluating is some abstraction

449
00:21:49,968 --> 00:21:51,100
一个抽象过程
we put into the machine--

450
00:21:52,224 --> 00:21:53,510
它对于数字1来说为真
it's going to be true for numbers--

451
00:21:53,648 --> 00:21:55,520
因此跳转的目的是EV-SELF-EVAL
to a place called ev-self-eval,

452
00:21:56,770 --> 00:21:58,208
那么我作为控制器
So me, being the controller,

453
00:21:58,224 --> 00:21:59,552
会去查看EV-SELF-EVAL
looks at ev-self-eval,

454
00:22:00,064 --> 00:22:01,072
所以我们要跳到那里
so we'll go over to there.

455
00:22:02,600 --> 00:22:04,768
EV-SELF-EAVL的代码是--
Ev-self-eval says fine,

456
00:22:06,544 --> 00:22:09,904
把EXP寄存器的值赋值给VAL寄存器
assign to val whatever is in the expression unit.

457
00:22:15,248 --> 00:22:16,512
我遇到一个BUG
And I have a bug

458
00:22:17,936 --> 00:22:20,592
因为我初始化机器的时候没有做一件事情
because what I didn't do when I initialized this machine

459
00:22:21,620 --> 00:22:22,896
也就是指定当它执行完毕后
is also say what's supposed

460
00:22:22,912 --> 00:22:24,192
应该做什么
to happen when it's done,

461
00:22:24,650 --> 00:22:26,832
所以在启动机器的时候
so I should have started out the machine

462
00:22:27,376 --> 00:22:29,856
应该将CONTINUE寄存器设置为DONE
with done being in the continue register,

463
00:22:31,184 --> 00:22:33,264
所以我们给VAL赋值
OK? So we assign to VAL.

464
00:22:33,370 --> 00:22:35,568
然后执行(GOTO (FETCH CONTINUE))
And now go to fetch of continue,

465
00:22:35,632 --> 00:22:36,560
并且修改--
and now change--

466
00:22:38,096 --> 00:22:38,608
好
OK.

467
00:22:40,000 --> 00:22:41,168
好 我们来看一个更复杂的
OK, let's try something harder.

468
00:22:42,160 --> 00:22:43,456
我们先重置机器
Let's reset the machine here,

469
00:22:44,864 --> 00:22:50,880
然后把X放入EXP寄存器中
and we'll put in the expression register, X, OK?

470
00:22:56,710 --> 00:22:58,208
重新从EVAL-DISPATCH开始
Start again at eval-dispatch.

471
00:22:59,610 --> 00:23:01,690
先检查它是自求值的么？
Check, is it self-evaluating?

472
00:23:01,690 --> 00:23:02,032
不是
No.

473
00:23:02,650 --> 00:23:03,616
它是变量吗
Is it a variable?

474
00:23:04,630 --> 00:23:05,024
是的
Yes.

475
00:23:05,560 --> 00:23:07,072
我们跳转到EV-VARIABLE
We go off to ev-variable.

476
00:23:08,380 --> 00:23:10,976
它说：查找EXP寄存器中变量的值
It says assign to VAL,

477
00:23:12,130 --> 00:23:15,696
并把它赋值给VAL寄存器
look up the variable value in the expression register

478
00:23:21,232 --> 00:23:22,912
(GOTO (FETCH CONTINUE))
Go to fetch of continue.

479
00:23:23,968 --> 00:23:24,480
Sussman教授：DONE
PROFESSOR: Done.

480
00:23:27,616 --> 00:23:28,096
Abelson教授：好
PROFESSOR: OK.

481
00:23:29,312 --> 00:23:30,768
这些都是最基本的理念
Alright, Well, that's the basic idea. Those're

482
00:23:31,330 --> 00:23:32,656
这是这台机器上的简单运算
That's a simple operation of the machine.

483
00:23:32,680 --> 00:23:35,072
现在 我们来做些有意义的事情
Now, let's actually do something a little bit more interesting.

484
00:23:36,070 --> 00:23:38,640
我们看这条表达式
Let's look at the expression

485
00:23:43,584 --> 00:23:47,936
(+ X Y)
the sum of x and y.

486
00:23:49,696 --> 00:23:51,280
现在我们会看到
OK. And now we'll see how you start

487
00:23:52,416 --> 00:23:54,016
如何展开这些表达式树
unrolling these expression trees.

488
00:23:57,136 --> 00:23:58,688
我们再次从EVAL-DISPATCH开始
Well, start again at eval-dispatch.

489
00:24:04,610 --> 00:24:05,808
是自求值的吗？
Self-evaluating?

490
00:24:05,952 --> 00:24:06,528
不是
No.

491
00:24:06,704 --> 00:24:07,712
是变量吗？不是
Variable? No.

492
00:24:07,820 --> 00:24:08,992
它也不是我在这里
All the other special forms

493
00:24:08,992 --> 00:24:10,120
没有列出的特殊形式
which I didn't write down,

494
00:24:10,270 --> 00:24:12,480
比如引用、LAMBDA、SET! 等等
like quote, and lambda, and set, and whatever,

495
00:24:12,480 --> 00:24:13,088
它都不是
it's none of those.

496
00:24:13,260 --> 00:24:14,736
它是一个过程应用
It turns out to be an application,

497
00:24:15,880 --> 00:24:17,424
所以我们要跳转到EV-APPLICATION
so we go off to ev-application.

498
00:24:19,970 --> 00:24:24,944
回忆一下EV-APPLICATION要做什么
Ev-application, remember what it's going to do overall.

499
00:24:25,580 --> 00:24:28,192
它先要求值运算符
It is going to evaluate the operator.

500
00:24:28,272 --> 00:24:31,408
然后求值运算对象
It's going to evaluate the arguments,

501
00:24:32,368 --> 00:24:34,304
然后再进行应用
and then it's going to go apply them.

502
00:24:35,060 --> 00:24:36,096
所以在我们开始之前
So, before we start,

503
00:24:36,944 --> 00:24:37,880
由于我们是严格按照代码来执行的
since we're being very literal,

504
00:24:37,880 --> 00:24:38,880
我们最好记住
we'd better remember that,

505
00:24:39,070 --> 00:24:40,544
在这个环境中的某处
somewhere in this environment,

506
00:24:40,576 --> 00:24:42,368
连接到了另一个环境
it's linked to another environment

507
00:24:43,980 --> 00:24:44,944
其中符号'+
in which plus

508
00:24:45,728 --> 00:24:49,160
跟基本的加法过程绑定在了一起
is bound to the primitive procedure plus

509
00:24:51,632 --> 00:24:54,032
这样 求值+时就不会导致“变量未定义”
before we get an unknown variable in our machine.

510
00:24:55,340 --> 00:24:56,848
现在我们来到了EV-APPLICATION
OK, so we're at ev-application.

511
00:24:59,856 --> 00:25:04,320
把EXP寄存器对应的运算对象
OK, assign to UNEV the operands

512
00:25:04,928 --> 00:25:06,896
赋值给UNEV寄存器
of what's in the expression register.

513
00:25:07,616 --> 00:25:08,832
这些是运算对象
OK. Those are the operands.

514
00:25:09,230 --> 00:25:11,664
UNEV这个临时寄存器
UNEV's a temporary register

515
00:25:11,680 --> 00:25:12,590
就是用来暂存它们的
where we're going to save them.

516
00:25:13,220 --> 00:25:13,860
Sussman教授：我正在赋值
PROFESSOR: I'm assigning.

517
00:25:14,288 --> 00:25:16,624
Abelson教授：把运算符赋值给EXP寄存器
PROFESSOR: Assign to EXP the operator.

518
00:25:18,070 --> 00:25:20,096
注意 现在我们已经修改了EXP中的表达式
Now, notice we've destroyed that expression in EXP,

519
00:25:21,840 --> 00:25:23,616
但是我们需要的部分在UNEV中
but the piece that we need is now in UNEV.

520
00:25:25,820 --> 00:25:26,816
现在 我们要准备好
Now, we're going to get set up to

521
00:25:26,816 --> 00:25:28,592
去递归地求值运算符
to recursively evaluate the operator.

522
00:25:28,750 --> 00:25:31,696
把CONTINUE寄存器保存在栈上
Save the continue register on the stack.

523
00:25:34,864 --> 00:25:36,096
保存ENV
Save the environment.

524
00:25:40,480 --> 00:25:41,696
保存UNEV
Save UNEV.

525
00:25:49,536 --> 00:25:54,640
把标号EVAL-ARGS赋值给CONTINUE寄存器
OK, assign to continue a label called eval-args.

526
00:26:01,400 --> 00:26:01,950
我们做了什么
Now, what have we done?

527
00:26:01,950 --> 00:26:04,380
我们为递归调用做了必要的准备
We've set up for a recursive call.

528
00:26:04,380 --> 00:26:05,888
我们要开始执行EVAL-DISPATCH
We're about to go to eval-dispatch.

529
00:26:06,280 --> 00:26:08,832
我们为递归调用EVAL-DISPATCH做好了准备
We've set up for a recursive call to eval-dispatch.

530
00:26:10,230 --> 00:26:10,864
我们做了哪些事情
What did we do?

531
00:26:11,020 --> 00:26:13,648
我们把之后要用到的东西
We took the things we're going to need later,

532
00:26:14,480 --> 00:26:15,984
也就是UNEV中的运算对象
those operands that were in UNEV;

533
00:26:16,360 --> 00:26:18,992
以及我们最终求值运算对象时
the environment in which we're going to eventually have to,

534
00:26:19,168 --> 00:26:20,720
会用到的环境
maybe, evaluate those operands;

535
00:26:22,288 --> 00:26:23,936
以及我们最终想要去的位置
the place we eventually want to go to,

536
00:26:23,952 --> 00:26:25,072
本例中 也就是DONE
which, in this case, was done;

537
00:26:25,344 --> 00:26:26,704
我们把它们保存在栈上
we've saved them on the stack.

538
00:26:27,104 --> 00:26:28,416
我们之所以把它们保存在栈上
The reason we saved them on the stack

539
00:26:28,430 --> 00:26:30,672
是因为EVAL-DISPATCH并不会保证
is because eval-dispatch makes no promises

540
00:26:30,944 --> 00:26:32,544
不会去修改这些寄存器
about what registers it may destroy.

541
00:26:33,550 --> 00:26:35,020
那么所有这些东西都存在了栈上
So all that stuff is saved on the stack.

542
00:26:35,020 --> 00:26:36,912
现在我们满足了EVAL-DISPATCH的约定
Now, we've set up eval-dispatch's contract.

543
00:26:37,380 --> 00:26:38,752
这是一条新的表达式
There's a new expression,

544
00:26:38,784 --> 00:26:40,048
也就是+运算符
which is the operator plus;

545
00:26:41,072 --> 00:26:41,952
以及一个新的环境
a new environment,

546
00:26:41,984 --> 00:26:43,600
尽管在本例中是同一个环境
although, in this case, it's the same one;

547
00:26:44,250 --> 00:26:45,872
以及在完成后要返回的位置
and a new place to go to when you're done,

548
00:26:45,872 --> 00:26:46,910
也就是EVAL-ARGS
which is eval-args.

549
00:26:47,600 --> 00:26:48,130
这样就满足了
So that's set up.

550
00:26:48,130 --> 00:26:49,680
现在我们来执行EVAL-DISPATCH
Now, we're going to go off to eval-dispatch.

551
00:26:50,890 --> 00:26:52,368
我们回到了EVAL-DISPATCH
Here we are back at eval-dispatch.

552
00:26:53,056 --> 00:26:54,400
它不是自求值的
It's not self-evaluating.

553
00:26:54,440 --> 00:26:55,472
但它是一个变量
Oh, it's a variable,

554
00:26:56,320 --> 00:26:58,064
因此我们最好跳转到EV-VARIABLE
so we'd better go off to ev-variable,

555
00:26:59,792 --> 00:27:02,656
EV-VARIABLE首先要给VAL赋值
Right? Ev-variable is assigned to VAL.

556
00:27:02,704 --> 00:27:06,336
查找表达式中变量的值
Look up the variable value of the expression,

557
00:27:08,496 --> 00:27:10,752
那么VAL寄存器中应该是基本的加法运算
OK? So VAL is the primitive procedure plus.

558
00:27:13,376 --> 00:27:15,168
然后(GOTO (FETCH CONTINUE))
And go to fetch of continue.

559
00:27:15,232 --> 00:27:16,112
Sussman教授：它是EVAL-ARGS
PROFESSOR: Eval-args.

560
00:27:16,208 --> 00:27:18,736
Abelson教授：现在它是EVAL-ARGS而不是DONE了
PROFESSOR: Right, which is now eval-args not done.

561
00:27:19,424 --> 00:27:21,264
然后我们来到EVAL-ARGS
So we come back here at eval-args,

562
00:27:22,160 --> 00:27:23,024
看看它要做什么
and what do we do?

563
00:27:23,072 --> 00:27:24,848
我们要恢复之前保存的东西
We're going to restore the stuff that we saved,

564
00:27:25,200 --> 00:27:26,576
因此调用(RESTORE UNEV)
so we restore UNEV.

565
00:27:29,216 --> 00:27:31,696
注意 这里并不是必要的
And notice, there, it wasn't necessary,

566
00:27:31,744 --> 00:27:32,900
但通常来说都会有这么一步
although, in general, it would be.

567
00:27:32,900 --> 00:27:35,168
它可以是任意的求值过程
It might be some arbitrary evaluation that happened.

568
00:27:35,430 --> 00:27:36,704
恢复ENV寄存器
We restore ENV.

569
00:27:47,872 --> 00:27:52,048
然后把(FETCH VAL)赋值给FUN
OK, we assign to FUN fetch of VAL.

570
00:27:59,952 --> 00:28:02,816
现在我们要开始求值参数了
OK, now, we're going to go off and start evaluating some arguments.

571
00:28:04,340 --> 00:28:06,480
首先 我们最好把FUN寄存器保存起来
Well, first thing we'd better do is save FUN

572
00:28:07,424 --> 00:28:10,624
因为求值过程中可能发生任何事情
because some arbitrary stuff might happen in that evaluation.

573
00:28:15,330 --> 00:28:16,880
我们初始化参数列表
We initialize the argument list.

574
00:28:16,912 --> 00:28:19,296
给ARGL赋值一个空的参数列表
Assign to argl an empty argument list,

575
00:28:20,880 --> 00:28:22,176
然后跳转到EVAL-ARG-LOOP
and go to eval-arg-loop,

576
00:28:24,860 --> 00:28:26,272
在EVAL-ARG-LOOP中
At eval-arg-loop,

577
00:28:27,770 --> 00:28:31,536
我们想要去一条一条的求值
the idea of this is we're going to evaluate the pieces of the

578
00:28:31,616 --> 00:28:33,370
UNEV中的表达式
expressions that are in UNEV, one by one,

579
00:28:33,540 --> 00:28:35,680
然后把它们从UNEV中的待求值表
and move them from unevaluated in UNEV

580
00:28:35,900 --> 00:28:37,264
移动到ARGL中的已求值表中
to evaluated in the arg list.

581
00:28:37,840 --> 00:28:39,184
然后我们保存ARGL
OK. So we save argl.

582
00:28:43,950 --> 00:28:47,264
然后我们把UNEV中的第一个运算对象
We assign to EXP the first operand 

583
00:28:47,376 --> 00:28:48,380
赋值给EXP
of the stuff in UNEV.

584
00:28:53,770 --> 00:28:55,890
然后我们检查它是否为最后一个运算对象
Now, we check and see if that was the last operand.

585
00:28:55,890 --> 00:28:56,912
在这里 它还不是
In this case, it is not.

586
00:28:58,992 --> 00:29:01,552
然后我们保存环境
So we save the environment.

587
00:29:08,000 --> 00:29:10,064
我们之所以保存UNEV
We save UNEV

588
00:29:11,616 --> 00:29:13,500
是因为稍后我们可能会需要它们
because those are all things we might need later.

589
00:29:13,500 --> 00:29:14,400
我们需要环境
We're going to need the environment

590
00:29:14,448 --> 00:29:15,648
来进行一些求值
to do some more evaluations.

591
00:29:15,800 --> 00:29:16,608
我们需要UNEV寄存器来指示
We're going to need UNEV

592
00:29:16,624 --> 00:29:19,200
其余的待求值参数
to look at what the rest of those arguments were.

593
00:29:20,340 --> 00:29:21,552
我们要把CONTINUE寄存器赋值为
We're going to assign continue

594
00:29:21,560 --> 00:29:24,448
ACCUMULATE-ARG这个标号
a place called accumulate-args, or accumulate-arg.

595
00:29:31,136 --> 00:29:34,016
现在 我们已经准备好再次调用EVAL-DISPATCH了
OK, now, we've set up for another call to eval-dispatch,

596
00:29:37,072 --> 00:29:38,544
现在让我把这个短路掉
All right, now, let me short-circuit this

597
00:29:39,120 --> 00:29:41,090
这里我们不跟进EVAL-DISPATCH的细节
so we don't go through the details of eval-dispatch.

598
00:29:41,090 --> 00:29:42,640
EVAL-DISPATCH的约定说：
Eval-dispatch's contract says

599
00:29:42,970 --> 00:29:45,008
我的调用完成后
i'm going to end up,

600
00:29:45,136 --> 00:29:45,960
整个机器的状态会变为
the world will end up,

601
00:29:46,032 --> 00:29:48,208
也就是在ENV环境中求值EXP表达式
with the value of evaluating this expression

602
00:29:48,240 --> 00:29:50,270
求值结果会保存在VAL寄存器中
in this environment in the VAL register,

603
00:29:50,270 --> 00:29:51,072
结束状态就是这样
and I'll end up there.

604
00:29:51,320 --> 00:29:52,624
那么我们把这些全都省略掉
So we short-circuit all of this,

605
00:29:54,432 --> 00:29:56,368
最后VAL的内容是3
and a 3 ends up in VAL.

606
00:29:58,010 --> 00:29:59,760
并且当我们从EVAL-DISPATCH返回的时候
And, when we return from eval-dispatch,

607
00:29:59,760 --> 00:30:01,760
我们会返回到ACCUMULAT-ARG这里
we're going to return to accumulate-arg.

608
00:30:02,304 --> 00:30:03,232
Sussman教授：跳转到ACCUMULATE-ARG
PROFESSOR: Accumulate-arg.

609
00:30:06,224 --> 00:30:08,208
Abelson教授：VAL寄存器里是3 对吧？
PROFESSOR: With 3 in the VAL register, OK?

610
00:30:08,720 --> 00:30:10,592
我们跳过了求值的细节
So that short-circuited that evaluation.

611
00:30:10,650 --> 00:30:11,320
现在我们要做什么？
Now, what do we do?

612
00:30:11,320 --> 00:30:13,680
我们返回继续看剩下的参数
We're going to go back and look at the rest of the arguments,

613
00:30:13,680 --> 00:30:14,832
我们恢复UNEV
so we restore UNEV.

614
00:30:17,510 --> 00:30:19,008
恢复ENV
We restore ENV.

615
00:30:25,792 --> 00:30:27,056
然后恢复ARGL
We restore argl.

616
00:30:28,650 --> 00:30:29,170
这件事
One thing.

617
00:30:30,064 --> 00:30:31,456
Sussman教授：糟糕 奇偶错误
PROFESSOR: Oops! Parity error.

618
00:30:33,760 --> 00:30:34,832
Abelson教授：恢复ARGL
PROFESSOR: Restore argl.

619
00:30:45,570 --> 00:30:49,760
然后 我们把VAL寄存器和ARGL给CONS起来
OK, we assign to argl consing on

620
00:30:50,656 --> 00:30:52,640
然后赋值给ARGL寄存器
fetch of the value register to what's in argl.

621
00:30:59,360 --> 00:31:02,960
我们把UNEV中剩余的运算对象
OK, we assign to UNEV the rest of the operands

622
00:31:03,344 --> 00:31:04,528
赋值给UNEV
in fetch of UNEV,

623
00:31:08,912 --> 00:31:10,768
然后我们返回到EVAL-ARG-LOOP
and we go back to eval-arg-loop.

624
00:31:11,510 --> 00:31:12,280
Sussman教授：EVAL-ARG-LOOP
PROFESSOR: Eval-arg-loop.

625
00:31:12,280 --> 00:31:12,864
Abelson教授：好
PROFESSOR: OK.

626
00:31:15,880 --> 00:31:17,088
现在我们处理下一个参数
Now, we're about to do the next argument,

627
00:31:17,584 --> 00:31:19,312
所以首先我们要保存ARGL
so the first thing we do is save argl.

628
00:31:25,400 --> 00:31:28,272
然后我们把UNEV中的第一个运算对象
OK, we assign to EXP the first operand

629
00:31:29,152 --> 00:31:30,816
赋给EXP
of fetch of UNEV.

630
00:31:34,720 --> 00:31:37,024
然后我们检查它是否为最后一个运算对象
OK, we test and see if that's the last operand.

631
00:31:37,024 --> 00:31:38,000
这里它是最后一个
In this case, it is

632
00:31:39,088 --> 00:31:40,272
所以我们跳到一个特殊的地方
so we're going to go to a special place

633
00:31:40,288 --> 00:31:42,064
来求值最后一个参数
that says evaluate the last argument

634
00:31:43,376 --> 00:31:45,072
因为请注意 在求值这个参数之后
because, notice,after evaluating the argument,

635
00:31:45,104 --> 00:31:46,624
我们就不再需要这个环境了
we don't need the environment any more.

636
00:31:47,648 --> 00:31:48,784
这就是区别
That's going to be the difference.

637
00:31:50,250 --> 00:31:51,856
在这里 在EVAL-LAST-ARG这里
So here, at eval-last-arg,

638
00:31:52,240 --> 00:31:54,928
CONTINUE被赋值为了ACCUMULATE-LAST-ARG
which is assigned to continue accumulate-last-arg,


639
00:32:04,270 --> 00:32:06,900
现在我们再次为EVAL-DISPATCH做准备
now, we're set up again for eval-dispatch.

640
00:32:06,900 --> 00:32:08,512
我们有一个完成时要跳转的目的地
We've got a place to go to when we're done.

641
00:32:08,620 --> 00:32:09,840
我们有一条表达式
We've got an expression.

642
00:32:09,840 --> 00:32:10,800
还有一个环境
We've got an environment.

643
00:32:11,330 --> 00:32:13,648
好 那么我们略过对EVAL-DISPATCH的调用
OK, so we'll short-circuit the call to eval-dispatch.

644
00:32:14,370 --> 00:32:16,416
现在情况是这里有一个Y
And what'll happen is there's a y there,

645
00:32:16,700 --> 00:32:18,560
在这个环境中 它的值是4
it's 4 in that environment,

646
00:32:18,608 --> 00:32:20,096
所以最终VAL寄存器将会是4
so VAL will end up with 4 in it.

647
00:32:21,060 --> 00:32:22,864
然后我们就要以ACCUMULATE-LAST-ARG结束了
And, then, we're going to end up at accumulate-last-arg, OK?

648
00:32:25,450 --> 00:32:26,912
因此 在ACCUMULATE-LAST-ARG中
So, at accumulate-last-arg,

649
00:32:29,280 --> 00:32:30,520
我们恢复ARGL寄存器
we restore argl.

650
00:32:37,696 --> 00:32:42,768
我们把ARGL赋值为
We assign to argl, we assign to argl cons,

651
00:32:43,600 --> 00:32:45,830
将一个新值CONS在它上面的结果
of fetch of the new value onto it,

652
00:32:45,936 --> 00:32:47,392
所以我们在它的旧值前CONS一个4
so we cons a 4 onto that.

653
00:32:49,850 --> 00:32:52,528
我们恢复FUN寄存器中的内容
We restore what was saved in the function register.

654
00:32:53,770 --> 00:32:54,992
需要注意的是 在则个例子中
And notice, in this case,

655
00:32:55,008 --> 00:32:56,270
FUN寄存器还没有被修改过
it had not been destroyed,

656
00:32:56,384 --> 00:32:57,728
但是通常来说 它会的
but in general, it will be.

657
00:32:59,130 --> 00:33:01,504
现在 我们将要调用APPLY-DISPATCH
And now, we're ready to go off to apply-dispatch,

658
00:33:02,650 --> 00:33:04,400
所以我们刚刚步步跟进了EVAL过程
Alright? So we've just gone through the eval.

659
00:33:04,510 --> 00:33:05,856
我们求值了运算符
We evaluated the argument,

660
00:33:06,464 --> 00:33:07,980
以及实际参数
the operator, and the arguments,

661
00:33:07,980 --> 00:33:09,248
现在我们要应用它们了
and now, we're about to apply them.

662
00:33:09,580 --> 00:33:11,376
因此 我们来到APPLY-DISPATCH这里
So we come off to apply-dispatch here

663
00:33:18,032 --> 00:33:19,296
这是APPLY-DISPATCH的代码
We come off to apply-dispatch,

664
00:33:21,056 --> 00:33:22,416
我们要检查它是一个基本过程
and we're going to check whether it's a primitive

665
00:33:22,416 --> 00:33:23,450
还是一个复合过程
or a compound procedure.

666
00:33:23,648 --> 00:33:24,208
Sussman教授：基本过程
PROFESSOR: Yes.

667
00:33:24,544 --> 00:33:24,830
Abelson教授：好的
PROFESSOR: All right.

668
00:33:24,896 --> 00:33:26,528
这里 它是一个基本过程
So, in this case, it's a primitive procedure,

669
00:33:27,456 --> 00:33:28,912
因此 我们跳转到PRIMITIVE-APPLY
and we go off to primitive-apply.

670
00:33:29,790 --> 00:33:31,360
我们来到PRIMITIVE-APPLY
So we go off to primitive-apply,

671
00:33:33,710 --> 00:33:35,376
它说：把VAL赋值为
that says assign to VAL

672
00:33:35,696 --> 00:33:38,256
把基本过程
result of applying primitive procedure

673
00:33:38,360 --> 00:33:40,304
应用在参数表的结果
of the function to the argument list.

674
00:33:41,312 --> 00:33:42,432
Sussman教授：我不知道怎么做加法
PROFESSOR: I don't know how to add.

675
00:33:42,540 --> 00:33:43,808
我只是一个执行单元
I'm just an execution unit.

676
00:33:44,144 --> 00:33:45,350
Abelson教授：我也不知道
PROFESSOR: Well, I don't know how to add either.

677
00:33:45,350 --> 00:33:46,512
我只是一个求值器
I'm just the evaluator,

678
00:33:47,088 --> 00:33:48,360
因此 我们需要一个基本运算执行器
so we need a primitive operator.

679
00:33:48,360 --> 00:33:49,728
那么 请问基本运算执行器
Let's see, so the primitive operator,

680
00:33:49,760 --> 00:33:52,368
3+4等于多少？
What's the... what's the sum of 3 and 4?

681
00:33:52,864 --> 00:33:53,328
学生：7
AUDIENCE: 7.

682
00:33:53,712 --> 00:33:54,656
Abelson教授：好 是7
PROFESSOR: OK, 7.

683
00:33:55,328 --> 00:33:55,990
Sussman教授：谢谢
PROFESSOR: Thank you.

684
00:33:59,200 --> 00:34:00,608
Abelson教授：现在 我们恢复CONTINUE
PROFESSOR: Now, we restore continue,

685
00:34:11,584 --> 00:34:12,900
执行(GOTO (FETCH CONTINUE))
and we go to fetch of continue.

686
00:34:13,072 --> 00:34:13,472
Sussman教授：'DONE
PROFESSOR: Done.

687
00:34:14,208 --> 00:34:14,672
Abelson教授：好
PROFESSOR: OK.

688
00:34:14,920 --> 00:34:18,410
这些是你能看到的最细致的过程了
Well, that was in as much detail as you will ever see.

689
00:34:18,410 --> 00:34:20,192
我们再也不会讲得这么细了
We'll never do it in as much detail again.

690
00:34:21,590 --> 00:34:23,920
有一件重要的事需要注意
One very important thing to notice

691
00:34:24,912 --> 00:34:27,552
我们刚刚执行了一个递归过程
is that we just executed a recursive procedure,

692
00:34:29,568 --> 00:34:31,170
我们在整个过程中使用了栈
Right? This whole thing, we used a stack

693
00:34:31,170 --> 00:34:32,752
而且求值器是递归的
and the evaluator was recursive.

694
00:34:33,070 --> 00:34:35,888
有很多人以为在求值器中
A lot of people think the reason that you need a stack


695
00:34:36,480 --> 00:34:37,856
会用到栈和递归
and recursion in an evaluator

696
00:34:37,872 --> 00:34:38,976
或许是因为
is because you might be

697
00:34:39,090 --> 00:34:42,150
回去求值像阶乘或者FIB那样的递归过程
evaluating recursive procedures like factorial or Fibonacci.

698
00:34:42,150 --> 00:34:42,928
这并不正确
It's not true.

699
00:34:43,670 --> 00:34:44,992
注意 我们在这里进行了递归
So you notice we did recursion here,

700
00:34:45,008 --> 00:34:46,864
而仅仅是去求值(+ X Y)
and all we evaluated was (+ x y)

701
00:34:47,776 --> 00:34:50,656
在求值器中需要递归 实际上是因为
Right? The reason that you need recursion in the evaluator

702
00:34:50,960 --> 00:34:52,976
是因为求值过程本身
is because the evaluation process,

703
00:34:52,992 --> 00:34:54,060
就是递归的
itself, is recursive.

704
00:34:54,450 --> 00:34:56,176
并不是因为你在Lisp中
Right? It's not because the procedure

705
00:34:56,320 --> 00:34:58,096
要求值的那个过程
that you might be evaluating in LISP

706
00:34:58,128 --> 00:34:59,270
是一个递归过程
is a recursive procedure.

707
00:34:59,270 --> 00:35:00,528
这一点很重要
So that's an important thing

708
00:35:00,528 --> 00:35:02,144
人们经常在这里被弄糊涂
that people get confused about a lot.

709
00:35:03,010 --> 00:35:04,272
另一点要注意的是
The other thing to notice is that,

710
00:35:04,272 --> 00:35:05,648
我们在这里完成之后
when we're done here,

711
00:35:06,280 --> 00:35:07,120
真正完成以后
we're really done.

712
00:35:07,120 --> 00:35:08,496
不仅仅是指我们在'DONE这个标号
Not only are we at done,

713
00:35:09,456 --> 00:35:13,232
栈上也没有累积的东西了
but there's no accumulated stuff on the stack,

714
00:35:13,600 --> 00:35:15,712
对吧？机器又回到了它的初始状态
Right? The machine is back to its initial state.

715
00:35:17,008 --> 00:35:18,752
那就是“完成”的其中一部分意义
So that's part of what it means to be done.

716
00:35:19,710 --> 00:35:21,040
换句话说就是
Another way to say that is

717
00:35:22,720 --> 00:35:26,048
整个求值过程是把
the evaluation process has reduced

718
00:35:26,410 --> 00:35:28,320
(+ X Y)这条表达式
the expression, plus X, Y,

719
00:35:30,544 --> 00:35:32,784
归约为这里的7
to the value here, 7.

720
00:35:33,240 --> 00:35:35,456
我所指的“归约”有特殊的意义
And by reduced, I mean a very particular thing.

721
00:35:36,010 --> 00:35:38,180
也就是栈上没剩下任何东西了
It means that there's nothing left on the stack.

722
00:35:38,180 --> 00:35:40,368
机器现在与初始状态相同
The machine is now in the same state,

723
00:35:40,928 --> 00:35:42,656
只是VAL寄存器里有一些东西
except there's something in the value register.

724
00:35:42,720 --> 00:35:44,520
它不是任何问题的子问题
It's not part of a sub-problem of anything.

725
00:35:44,520 --> 00:35:45,632
不需要返回到其它地方
There's nothing to go back to.

726
00:35:46,128 --> 00:35:46,960
好 这节课就讲到这里
OK. Let's break.

727
00:35:50,160 --> 00:35:50,768
有问题吗
Question?

728
00:35:51,088 --> 00:35:54,020
学生：关于栈有一个问题
AUDIENCE: The question here, in the stack,

729
00:35:54,020 --> 00:35:55,820
由于数据有可能是递归的
is because the data may be recursive.

730
00:35:56,208 --> 00:35:58,752
例如 嵌套的表达式
You may have embedded expressions, for instance.

731
00:35:59,310 --> 00:36:02,080
教授：是的 因为你可能遇到嵌套的表达式
PROFESSOR: Yes, because you might have embedded expressions.

732
00:36:02,080 --> 00:36:04,770
但是再说一遍 不要搞混
But, again, don't confuse that

733
00:36:04,770 --> 00:36:07,984
有时候人们说数据是递归的
with what people sometimes mean by the data may be recursive,

734
00:36:08,000 --> 00:36:10,352
他们说的是对于这些表结构的
which is to say you have these list-structured,

735
00:36:11,040 --> 00:36:12,930
一些递归运算
recursive data list operations.

736
00:36:12,930 --> 00:36:13,968
那和这没有关系
That has nothing to do with it.

737
00:36:13,984 --> 00:36:16,160
这只是包含子表达式的表达式而已
It's simply that the expressions contain sub-expressions.

738
00:36:20,048 --> 00:36:23,520
学生：为什么ARGL中参数的顺序是反过来的
AUDIENCE: Why is it that the order of the arguments in the arg list got reversed?

739
00:36:23,552 --> 00:36:25,296
教授：对 我应该提一嘴这个
PROFESSOR: Ah! Yes, I should've mentioned that.

740
00:36:27,260 --> 00:36:29,070
之所以在这里把顺序反过来
Here, the reason the order is reversed--

741
00:36:32,784 --> 00:36:35,376
你首先定义怎么算“逆序”
it's a question of what you mean by reversed.

742
00:36:36,050 --> 00:36:39,904
我记得应该是牛顿
I believe it was Newton.

743
00:36:40,910 --> 00:36:42,416
在光学发展的很早期
In the very early part of optics,

744
00:36:42,432 --> 00:36:43,260
人们意识到
people realized

745
00:36:43,616 --> 00:36:45,360
当你用眼睛通过透镜看东西的时候
that when you look through the lens of your eye,

746
00:36:45,500 --> 00:36:46,730
图像是上下颠倒的
the image was up-side down.

747
00:36:46,730 --> 00:36:48,040
当时有很多的争论说
And there was a lot of argument about

748
00:36:48,040 --> 00:36:50,480
为什么不能是你眼睛平时看见的都是上下颠倒的
why that didn't mean you saw things up-side down.

749
00:36:51,280 --> 00:36:52,656
这实际上是一样的道理
So it's sort of the same issue.

750
00:36:52,860 --> 00:36:53,904
和什么相比反过来了
Reversed from what?

751
00:36:54,810 --> 00:36:56,240
我们只是需要一个约定
So we just need some convention.

752
00:36:56,590 --> 00:37:00,352
它们作为(4 3)出现的原因是
So all we.. The reason that they're coming at 4, 3

753
00:37:00,800 --> 00:37:02,496
是因为我们从UNEV中取出东西
is because taking UNEV

754
00:37:02,528 --> 00:37:04,030
并且把它CONS到了ARGL上面
and consing the result onto argl.

755
00:37:04,520 --> 00:37:06,688
那么你要意识到你已经做了这个约定
So you have to realize you've made that convention.

756
00:37:06,864 --> 00:37:09,376
你需要意识到这点的地方有
The place that you have to realize that--

757
00:37:09,980 --> 00:37:11,230
实际上有两个地方
well, there's actually two places.

758
00:37:11,230 --> 00:37:12,910
首先是在APPLY-PRIMITIVE-OPERATOR
One is in apply-primitive-operator,


759
00:37:12,910 --> 00:37:14,064
你要意识到
which has to realize that

760
00:37:15,120 --> 00:37:16,752
参数传入基本运算的顺序
the arguments to primitives go in,

761
00:37:16,784 --> 00:37:18,720
是和你的书写顺序相反的
the opposite order from the way you're writing them down.

762
00:37:19,490 --> 00:37:21,000
我们之后会在另外一处看到
And the other one is, we'll see later


763
00:37:21,072 --> 00:37:23,808
当你实际绑定绑定函数的形式参数时
when you actually go to bind a function's parameters,

764
00:37:24,010 --> 00:37:25,740
你要意识到参数进入的顺序
you should realize the arguments are going to come in

765
00:37:25,740 --> 00:37:28,544
和你要绑定这些变量时的顺序相反
from the opposite order of the variables to which you're binding them.

766
00:37:28,870 --> 00:37:30,176
所以如果你注意这些
So, if you just keep track of that,

767
00:37:31,088 --> 00:37:31,830
就没有问题了
there's no problem.

768
00:37:31,830 --> 00:37:33,696
同样 这完全是随意的
Also, this is completely arbitrary

769
00:37:33,900 --> 00:37:34,960
因为如果我们做了一个
because, if we'd done,

770
00:37:35,104 --> 00:37:37,152
比如 给向量的各个维度赋值的迭代
say, an iteration through a vector assigning them,

771
00:37:37,420 --> 00:37:38,736
它们可能会以其它顺序输出
they might come out in the other order.

772
00:37:40,410 --> 00:37:42,048
那么这只是这个求值器
OK. So it's just a convention of the way

773
00:37:42,064 --> 00:37:43,536
工作时的一个约定
this particular evaluator works.

774
00:37:45,392 --> 00:37:46,240
好 我们休息一下
All right, let's take a break.

775
00:37:46,330 --> 00:38:02,448
[音乐]
[JESU, JOY OF MAN'S DESIRING]

776
00:38:02,440 --> 00:38:07,648
《计算机程序的构造和解释》
The Structure And Interpretation of Computer Programs

777
00:38:28,620 --> 00:38:32,512
讲师： 哈罗德·艾伯森教授 及 格兰德·杰·萨斯曼教授
By: Prof. Harold Abelson && Sussman Jay Sussman

778
00:38:32,510 --> 00:38:35,680
《计算机程序的构造和解释》
The Structure And Interpretation of Computer Programs

779
00:38:35,680 --> 00:38:39,616
显式控制求值器
Explicit-control Evaluator

780
00:38:41,840 --> 00:38:45,310
教授：我们已经学习了表达式的求值
Professor: We just saw evaluating an expression

781
00:38:45,600 --> 00:38:47,080
虽然这只是一个非常简单的例子
and, of course, that was very simple one. But

782
00:38:48,810 --> 00:38:50,240
但从本质上来说
in essence, it would be no different

783
00:38:50,240 --> 00:38:52,030
它跟那些大型嵌套表达式没什么不同
if it was some big nested expression,

784
00:38:52,030 --> 00:38:54,570
后者只是在栈上递归得更深而已
so there would just be deeper recursion on the stack.

785
00:38:55,130 --> 00:38:56,032
我现在要为你们
But what I want to do now

786
00:38:56,048 --> 00:38:56,910
讲解最后一部分
is show you the last piece.

787
00:38:56,920 --> 00:38:59,820
我要带着你们观察EVAL-APPLY循环
I want to walk you around this eval and apply loop,

788
00:39:01,010 --> 00:39:02,810
我们还没有仔细研究过它
That's the thing we haven't seen, really.

789
00:39:03,000 --> 00:39:04,750
我们还没有见过一个复合程序
We haven't seen any compound procedures

790
00:39:05,200 --> 00:39:07,790
对它的求值会归约为
where evalutation of procedure reduces to

791
00:39:07,920 --> 00:39:10,110
对一个过程的应用
where applying of procedure reduces to

792
00:39:10,120 --> 00:39:11,640
进而是对过程体的求值
evaluating the body of the procedure,

793
00:39:12,440 --> 00:39:15,880
因此 假设我们有这个
so let's just suppose we had this.

794
00:39:15,930 --> 00:39:17,440
假设我们正在考察
Suppose we were looking at the procedure

795
00:39:18,070 --> 00:39:31,600
(DEFINE (F A B) (+ A B)
define F of A and B to be the sum of A and B.

796
00:39:33,990 --> 00:39:37,320
假设我们预先定义好了这个过程
So, as we typed in that procedure previously,

797
00:39:37,690 --> 00:39:41,640
现在 我们将要求值(F X Y)
and now we're going to evaluate F of X and Y

798
00:39:42,270 --> 00:39:44,200
基于的环境是E0
again, in this environment, E,0,

799
00:39:44,350 --> 00:39:47,020
其中X=3 Y=4
where X is bound to 3 and Y is bound to 4.

800
00:39:50,780 --> 00:39:52,110
当执行DEFINE的时候
When the defined is executed,

801
00:39:52,120 --> 00:39:53,690
还记得么 这里是一个LAMBDA
remember, there's a lambda here,

802
00:39:53,820 --> 00:39:55,530
LAMBDA会创建一个过程
and lambdas create procedures.

803
00:39:55,950 --> 00:39:58,490
基本上 会发生的事情是
And, basically, what will happen is,

804
00:39:59,632 --> 00:40:00,688
在环境E0中
in E0,

805
00:40:01,008 --> 00:40:02,650
我们会得到F的绑定
we'll end up with a binding for F,

806
00:40:03,560 --> 00:40:05,610
它指出F是一个过程
which will say F is a procedure,

807
00:40:07,150 --> 00:40:11,280
这个过程的参数是A和B
and its args are A and B,

808
00:40:12,570 --> 00:40:16,190
而过程体是(+ A B)
and its body is plus a,b.

809
00:40:18,110 --> 00:40:20,990
这就是环境大概的样子
So that's what the environment would have looked like

810
00:40:21,210 --> 00:40:22,520
我们之前就定义过了
had we made that definition.

811
00:40:24,220 --> 00:40:27,280
然后 我们去求值(F X Y)
Then, when we go to evaluate F of X and Y,

812
00:40:28,800 --> 00:40:30,896
我们会仔细地解释每一步
we'll go through exactly the same process

813
00:40:31,024 --> 00:40:31,850
就像之前那样
that we did before.

814
00:40:31,880 --> 00:40:33,090
不会跳过重复的表达式
It's even the same expression.

815
00:40:33,280 --> 00:40:34,380
唯一的不同是
The only difference is that

816
00:40:34,400 --> 00:40:36,640
它的内部不再是基本的“+”过程
F, instead of having primitive "plus" in it

817
00:40:37,240 --> 00:40:38,990
它还有这个东西
will have this thing.

818
00:40:41,040 --> 00:40:43,600
因此我们要进行相同的过程
And so we'll go through exactly the same process,

819
00:40:43,600 --> 00:40:44,928
只不过这次
except this time, when we end up

820
00:40:45,264 --> 00:40:47,420
当我们停在APPLY-DISPATCH时
at apply-dispatch,

821
00:40:47,860 --> 00:40:50,280
FUN寄存器中不再是基本的“+”过程
the function register, instead of having primitive plus,

822
00:40:50,440 --> 00:40:53,580
而是一个代表过程的东西
will have a thing that will represent it saying procedure,

823
00:40:54,300 --> 00:40:59,000
其中参数为A和B
where the args are A and B,

824
00:41:00,640 --> 00:41:06,270
过程体是(+ A B)
and the body is plus A, B.

825
00:41:07,870 --> 00:41:09,920
再强调一下 我所谓的ENV
And, again, what I mean, by its ENV,

826
00:41:09,960 --> 00:41:11,120
是一个指向环境的指针
I mean there's a pointer to it,

827
00:41:11,240 --> 00:41:13,070
所以不用担心我在这里写了很多东西
so don't worry that I'm writing a lot of stuff there.

828
00:41:13,280 --> 00:41:15,630
这是一个指向代表过程的数据结构的指针
There's a pointer to this procedure data structure.

829
00:41:17,170 --> 00:41:19,770
因此 我们现在面临着相同的情况
OK, so, we're in exactly the same situation.

830
00:41:20,270 --> 00:41:22,430
我们来到了APPLY-DISPATCH
We get to apply-dispatch,

831
00:41:23,980 --> 00:41:26,480
这是APPLY-DISPATCH的代码
so, here, we come to apply-dispatch.

832
00:41:26,480 --> 00:41:28,730
上一次 我们分支跳转到了一个基本过程
Last time, we branched off to a primitive procedure.

833
00:41:30,010 --> 00:41:30,700
然而这一次
Here, it says oh,

834
00:41:30,840 --> 00:41:32,800
我们遇到的是一个复合过程
we now have a compound procedure,

835
00:41:34,550 --> 00:41:36,600
因此我们要跳转到COMPOUND-APPLY
so we're going to go off to compound-apply.

836
00:41:38,470 --> 00:41:39,920
COMPOUND-APPLY又是怎样定义的呢？
Now, what's compound-apply?

837
00:41:41,920 --> 00:41:44,540
还记得元循环求值器是怎么做的么？
Well, remember what the meta-circular evaluator did?

838
00:41:45,090 --> 00:41:47,400
COMPOUND-APPLY的执行步骤则是
Compound-apply said we're going to evaluate

839
00:41:49,900 --> 00:41:51,600
在一个新的环境中
the body of the procedure

840
00:41:52,940 --> 00:41:54,120
求值一个过程的体
in some new environment.

841
00:41:54,120 --> 00:41:55,870
这个新的环境来自于哪里呢？
Where does that new environment come from?

842
00:41:56,730 --> 00:42:01,360
我们把跟过程一同打包的环境
We take the environment that was packaged with the procedure,

843
00:42:03,020 --> 00:42:05,790
我们把过程的形式参数
we bind the parameters of the procedure

844
00:42:06,000 --> 00:42:07,630
同传递进来的实际参数给绑定起来
to the arguments that we're passing in,

845
00:42:09,750 --> 00:42:11,950
把这个作为新的框架
and use that as a new frame to extend

846
00:42:12,590 --> 00:42:13,790
来扩展过程附带的环境
the procedure environment.

847
00:42:14,990 --> 00:42:16,080
我们就是在这个环境中
And that's the environment

848
00:42:16,300 --> 00:42:18,880
求值过程的体
in which we evaluate the procedure body,

849
00:42:20,120 --> 00:42:24,470
对吧？这就是APPLY-EVAL循环做的事
Right? That's going around the apply/eval loop.

850
00:42:24,470 --> 00:42:26,250
这就是APPLY回过头来调用EVAL
That's apply coming back to call eval,

851
00:42:32,860 --> 00:42:34,920
因此 这就是我们要在COMPOUND-APPLY中要做的所有事
So, now, that's all we have to do in compound-apply.

852
00:42:36,780 --> 00:42:37,720
要怎么来实现呢？
What are we going to do?

853
00:42:37,720 --> 00:42:40,970
我们要构造一个新的环境
We're going to manufacture a new environment.

854
00:42:43,550 --> 00:42:45,640
而我们构造的这个新环境呢
And we're going to manufacture a new environment that,

855
00:42:46,760 --> 00:42:48,110
我们把它记作E1
let's see, that we'll call E1.

856
00:42:52,900 --> 00:42:55,630
E1这个环境呢
E1 is going to be some environment where the

857
00:42:57,310 --> 00:42:59,150
存储了过程的参数绑定
where the parameters of the procedure,

858
00:42:59,210 --> 00:43:03,260
其中A=3 B=4
Nwhere A is bound to 3, and B is bound to 4,

859
00:43:04,270 --> 00:43:05,760
并且它跟E0相连
and it's linked to E0

860
00:43:05,760 --> 00:43:08,080
这是因为 F就是在E0中定义的
because that's where f is defined.

861
00:43:09,270 --> 00:43:10,270
因此 在这个环境中
And, in this environment,

862
00:43:10,270 --> 00:43:11,960
我们要来求值过程的体
we're going to evaluate the body of the procedure.

863
00:43:12,050 --> 00:43:14,480
让我们来看一看
So let's look at that, we're going

864
00:43:16,520 --> 00:43:18,320
我们来看COMPOUND-APPLY的代码
Here we are at compound-apply,

865
00:43:20,300 --> 00:43:23,470
首先是给EXP寄存器赋值
which says assign to the expression register

866
00:43:24,500 --> 00:43:25,984
所赋的值是FUN寄存器
the body of the procedure

867
00:43:25,984 --> 00:43:27,260
所指向过程的体
that's in the function register.

868
00:43:28,380 --> 00:43:30,640
这样 我就将过程的体
So I assign to the expression register

869
00:43:31,296 --> 00:43:32,330
赋值给了EXP寄存器
the procedure body,

870
00:43:40,750 --> 00:43:41,100
对吧？
OK?

871
00:43:42,640 --> 00:43:44,970
而这将在某个环境中求值
That's going to be evaluated in an environment

872
00:43:45,820 --> 00:43:48,320
这个环境是通过将FUN寄存器
which is formed by making some bindings

873
00:43:51,300 --> 00:43:53,670
所指向的过程中的形式参数
using information determined by the procedure--

874
00:43:53,670 --> 00:43:56,250
与实际参数绑定起来 得到的
that's what's in FUN-- and the argument list.

875
00:43:57,800 --> 00:44:00,000
我们先不要关系它的具体细节
And let's not worry about exactly what that does,

876
00:44:00,080 --> 00:44:01,630
你可以知道它的最后结果
but you can see the information's there.

877
00:44:01,930 --> 00:44:03,320
因此MAKE-BINDINGS会说
So make bindings will say oh,

878
00:44:04,040 --> 00:44:07,900
过程本身就附带有一个环境
the procedure, itself, had an environment attached to it.

879
00:44:07,960 --> 00:44:09,320
在这里 我没有写出来
I didn't write that quite here.

880
00:44:09,360 --> 00:44:10,560
但我应该说过它有一个环境
I should've said in environment

881
00:44:11,300 --> 00:44:12,736
因为每个过程在构造时
because every procedure gets built

882
00:44:12,768 --> 00:44:13,440
都有一个环境
with an environment.

883
00:44:13,660 --> 00:44:14,832
因此 通过这个环境
So, from that environment,

884
00:44:15,680 --> 00:44:16,350
它能够知道
it knows

885
00:44:16,600 --> 00:44:18,650
定义该过程时的环境是怎样的
what the procedure's definition environment is.

886
00:44:19,290 --> 00:44:20,750
它知道实际参数是什么
It knows what the arguments are.

887
00:44:21,830 --> 00:44:22,490
它查看ARGL
It looks at argl,

888
00:44:22,490 --> 00:44:24,280
然后你会在这里看到逆序的约定
and then you see a reversal convention here.

889
00:44:24,280 --> 00:44:26,620
它需要知道ARGL是逆序的
It just has to know that argl is reversed,

890
00:44:27,060 --> 00:44:28,810
然后它构造了这个框架 E1
and it builds this frame, E,1.

891
00:44:29,990 --> 00:44:31,088
因此我们假设
All right, so, let's assume that

892
00:44:31,104 --> 00:44:32,920
MAKE-BINDINGS返回的就是这些东西
that's what make bindings returns,

893
00:44:33,360 --> 00:44:36,220
然后 它把E1赋值给ENV
so it assigns to ENV this thing, E,1.

894
00:44:41,340 --> 00:44:42,544
下一步就是
The next thing it says

895
00:44:43,952 --> 00:44:45,840
恢复CONTINUE
is restore continue.

896
00:44:46,890 --> 00:44:48,190
还记得CONTINUE之前是什么吗？
Remember what continue was here?

897
00:44:48,760 --> 00:44:50,430
在最后一段中
It got put up in the last segment.

898
00:44:52,240 --> 00:44:54,020
CONTINUE被保存了
Continue got stored.

899
00:44:54,020 --> 00:44:55,180
它的值是最初的'DONE
That was the original done,

900
00:44:55,320 --> 00:44:56,560
这代表了
which said what are you going to do

901
00:44:56,730 --> 00:44:59,440
在完成这项特定应用后要做的事
after you're done with this particular application?

902
00:45:00,140 --> 00:45:01,720
这是在求值整个应用时
It was one of the very first things that happened

903
00:45:01,760 --> 00:45:03,180
最先发生的事儿
when we evaluated the application.

904
00:45:03,880 --> 00:45:05,870
现在 我们要恢复CONTINUE了
And now, finally, we're going to restore continue.

905
00:45:06,860 --> 00:45:09,550
还记得APPLY-DISPATCH的约定么？
Remember apply-dispatch's contract.

906
00:45:09,580 --> 00:45:11,200
它假设下一步的跳转目标
It assumes that where it should go to next

907
00:45:11,230 --> 00:45:11,980
已经存放在栈上了
was on the stack,

908
00:45:12,030 --> 00:45:13,120
并且 这里确实存放在栈上了
and there it was on the stack.

909
00:45:13,590 --> 00:45:14,760
CONTINUE被赋值成了DONE
Continue has done,

910
00:45:17,820 --> 00:45:19,900
现在我们要回到EVAL-DISPATCH了
and now we're going to go back to eval-dispatch.

911
00:45:19,940 --> 00:45:20,840
我们要再次进行寄存器设置
We're set up again.

912
00:45:20,970 --> 00:45:24,410
我们有表达式、环境、下一步
We have an expression, an environment, and a place to go to.

913
00:45:25,800 --> 00:45:26,890
我不会再细讲了
We're not going to go through that

914
00:45:27,880 --> 00:45:29,550
因为它基本上就是相同的表达式
because it's sort of the same expression.

915
00:45:35,400 --> 00:45:37,792
但是需要注意的是
OK, but the thing, again, to notice

916
00:45:37,824 --> 00:45:38,736
在这个时候
is, at this point,

917
00:45:39,340 --> 00:45:43,720
我们已经归约了原始表达式(F X Y)
we have reduced the original expression, F,X,Y,

918
00:45:44,640 --> 00:45:47,920
通过在E0中求值(F X Y)
We've reduced evaluating F,X,Y in environment E,0

919
00:45:48,890 --> 00:45:52,670
将其归约为在E1中求值(+ A B)
to evaluate plus A, B in E,1.

920
00:45:52,780 --> 00:45:55,920
要注意 栈上并没有什么东西 对吧？
And notice, nothing's on the stack, right?

921
00:45:56,110 --> 00:45:56,830
这是一个归约
It's a reduction.

922
00:45:56,840 --> 00:45:59,800
这个时候 机器的状态中
At this point, the machine does not contain,

923
00:45:59,840 --> 00:46:01,200
并没有包含
as part of its state,

924
00:46:01,760 --> 00:46:03,712
它是求值过程F的
the fact that it's in the middle of evaluating

925
00:46:03,728 --> 00:46:04,880
中间状态的事实
some procedure called f,

926
00:46:05,490 --> 00:46:06,280
它消失了
that's gone,

927
00:46:07,660 --> 00:46:09,550
这里面没有积累的状态
Right? There's no accumulated state?

928
00:46:13,070 --> 00:46:14,370
注意 这个思想非常重要
Again, that's a very important idea.

929
00:46:14,370 --> 00:46:16,330
这意味着
That's the meaning of,

930
00:46:16,760 --> 00:46:18,390
当我们使用代换模型时
when we used to write in the substitution model,

931
00:46:18,390 --> 00:46:20,860
一条表达式会归约到另一条表达式
this expression reduces to that expression.

932
00:46:21,350 --> 00:46:22,660
而你不需要记住任何东西
And you don't have to remember anything.

933
00:46:22,660 --> 00:46:24,500
这里 你就见到了归约的真谛
And here, you see the meaning of reduction.

934
00:46:24,560 --> 00:46:26,160
这个时候 栈上没有任何东西
At this point, there is nothing on the stack.

935
00:46:31,590 --> 00:46:33,630
这样就有一个非常重要的结果
See, that has very important consequences.

936
00:46:35,240 --> 00:46:37,900
让我们回过头来看看迭代式阶乘
Let's go back and look at iterative factorial,

937
00:46:40,420 --> 00:46:42,768
还记得吗？这是某种循环
all right? Remember, this was some sort of loop

938
00:46:44,016 --> 00:46:44,880
用来进行迭代
and doing iter.

939
00:46:45,130 --> 00:46:47,360
我们不断强调 它是一个迭代过程
And we kept saying that's an iterative procedure,

940
00:46:49,260 --> 00:46:53,840
还记得吗
And what we wrote, remember,

941
00:46:58,440 --> 00:47:03,130
我们使用它的时候
are things like, we said,

942
00:47:04,350 --> 00:47:11,070
是像(FACT-ITER 5)这样调用它的
fact-iter of 5.

943
00:47:12,360 --> 00:47:18,670
然后我们把它归约成(ITER 1 1 5)
We wrote things like reduces to iter of 1, and 1, and 5,

944
00:47:19,030 --> 00:47:25,150
然后它归约成(ITER 1 2 5)
which reduces to iter of 1, and 2, and 5,

945
00:47:25,320 --> 00:47:27,070
等等等等
and so on, and so on, and so on.

946
00:47:27,070 --> 00:47:28,170
然后我们又说 看
And we kept saying well, look,

947
00:47:28,170 --> 00:47:30,350
为了实现这个效果 不需要存储任何东西
you don't have to build up any storage to do that.

948
00:47:31,720 --> 00:47:32,730
我们摆了摆手 说
And we waved our hands,

949
00:47:32,750 --> 00:47:34,590
“原则上 这不需要任何存储”
and said in principle, there's no storage needed.

950
00:47:35,040 --> 00:47:36,170
现在你们发现 确实不需要
Now, you see no storage needed.

951
00:47:36,170 --> 00:47:39,090
这里的每一步都是真正的归约 对吧？
Each of these is a real reduction, right?

952
00:47:39,090 --> 00:47:42,600
随着你求值这些表达式
As you walk through these expressions,

953
00:47:47,300 --> 00:47:50,512
在求值这些表达式的过程中
As you walk through these expressions,

954
00:47:50,832 --> 00:47:51,370
你会发现
what you'll see

955
00:47:51,370 --> 00:47:52,810
栈上的这些表达式
are these expressions on the stack

956
00:47:53,750 --> 00:47:55,640
都在一个特定的环境中
in some particular environment,

957
00:47:56,420 --> 00:48:00,020
抱歉 是EXP寄存器中的表达式
and then these expressions, sorry, in the EXP register

958
00:48:00,020 --> 00:48:01,500
是在某个特定的环境中
in some particular environment.

959
00:48:01,570 --> 00:48:02,190
并且 在每一步
And, at each point,

960
00:48:02,190 --> 00:48:04,000
栈上不会积累任何东西
there'll be no accumulated stuff on the stack

961
00:48:04,360 --> 00:48:05,680
因为每一步都是真正的归约
because each one's a real reduction.

962
00:48:09,280 --> 00:48:10,510
因此 举例来说
All right, so, for example,

963
00:48:10,580 --> 00:48:12,510
说得更仔细一点
just to go through it in a little bit more care,

964
00:48:13,460 --> 00:48:16,880
如果我从这样的一条表达式开始
if I start out with an expression that says something like,

965
00:48:22,440 --> 00:48:34,250
比如说 在某个环境中计算(FACT-ITER 5)
oh, say, fact-iter of 5 in some environment

966
00:48:42,110 --> 00:48:46,300
它将在某个时刻创建一个环境
that will, at some point, create an environment

967
00:48:46,810 --> 00:48:48,380
其中N=5
in which n is down to 5.

968
00:48:51,470 --> 00:48:52,010
我们把它写下来
Let's call that--

969
00:48:55,680 --> 00:48:56,590
然后 在某个时候
And, at some point,

970
00:48:56,890 --> 00:49:02,560
机器会归约这整个东西
the machine will reduce this whole thing

971
00:49:02,910 --> 00:49:04,350
将它归约为
to a thing that says that's really

972
00:49:04,760 --> 00:49:09,850
(ITER 1 1 N)
iter of 1, and 1, and n,

973
00:49:10,680 --> 00:49:13,720
然后在环境E1中求值这条表达式
evaluated in this environment, E,1

974
00:49:15,870 --> 00:49:17,160
而不在栈上存放任何东西
with nothing on the stack.

975
00:49:17,160 --> 00:49:19,550
看到了么 这时机器并不会记住
See, at this moment, the machine is not remembering

976
00:49:20,710 --> 00:49:22,500
求值这条ITER表达式--
that evaluating this expression, iter--

977
00:49:25,000 --> 00:49:25,630
也就是某种循环--
which is the loop--

978
00:49:25,790 --> 00:49:28,570
并不是FACT-ITER的一部分
is part of this thing called iterative factorial.

979
00:49:29,680 --> 00:49:30,590
它不会记住这个事实
It's not remembering that.

980
00:49:30,590 --> 00:49:33,170
它只是归约了该表达式
It's just reducing the expression to that, right?

981
00:49:33,170 --> 00:49:36,560
如果我们再来看迭代式阶乘的体
If we look again at the body of iterative factorial,

982
00:49:38,050 --> 00:49:41,080
这条表达式归约为了这条表达式
this expression has reduced to that expression.

983
00:49:42,810 --> 00:49:43,870
哦 这里漏了一个N
Oh, I shouldn't have the n there.

984
00:49:46,590 --> 00:49:47,744
幻灯片中的约定
It's a slightly different convention

985
00:49:47,744 --> 00:49:49,130
和实际程序中稍有不同
from the slide to the program.

986
00:49:53,340 --> 00:49:56,250
那么 ITER的体又是什么？
And, then, what's the body of iter?

987
00:49:56,280 --> 00:49:57,400
ITER的体首先是一个IF--
Well, iter's going to be an if,

988
00:49:58,750 --> 00:50:00,190
我不会再深入IF语句的细节了
and I won't go through the details of if.

989
00:50:00,240 --> 00:50:01,630
它会对谓词求值
It'll evaluate the predicate.

990
00:50:02,400 --> 00:50:03,710
本例中 会返回FALSE
In this case, it'll be false.

991
00:50:03,810 --> 00:50:08,640
然后这里的ITER会归约为表达式--
And this iter will now reduce to the expression

992
00:50:09,850 --> 00:50:20,200
(ITER (* COUNTER PRODUCT)
iter of whatever it says, star, counter product, and--

993
00:50:21,620 --> 00:50:22,240
按照它代码写的--
what does it say--

994
00:50:22,680 --> 00:50:24,560
(+ COUNTER 1))
plus counter 1

995
00:50:28,720 --> 00:50:31,420
在另外的一个环境E2中求值
in some other environment, by this time, E,2,

996
00:50:32,970 --> 00:50:35,980
其中 E2会记录着
where E,2 will be set up having bindings

997
00:50:36,490 --> 00:50:39,390
PRODUCT和COUNTER的值
for product and counter.

998
00:50:42,920 --> 00:50:44,330
它会被归约为这条语句
And it'll reduce to that.

999
00:50:44,940 --> 00:50:46,040
它不会记得
Right? It won't be remembering

1000
00:50:46,060 --> 00:50:48,750
它是一个需要返回到某处的一部分
that it's part of something that it has to return to.

1001
00:50:49,340 --> 00:50:50,430
当ITER再次调用ITER时
And when iter calls iter again,

1002
00:50:50,440 --> 00:50:52,560
它会归约为另一个像这样的东西
it'll reduce to another thing that looks like this

1003
00:50:53,050 --> 00:50:54,680
只是会在新环境E3中
in some environment, E,3,

1004
00:50:54,830 --> 00:50:56,670
里面有关于PRODUCT和COUNTER新的绑定
which has new bindings for product and counter.

1005
00:50:58,800 --> 00:51:05,290
因此 如果你想知道
OK? So, if you're wondering,

1006
00:51:06,090 --> 00:51:07,530
如果你一直感到不安
if you've always been queasy about

1007
00:51:08,250 --> 00:51:10,670
不知道为什么我们说这些过程
about how it is we've been saying those procedures

1008
00:51:10,670 --> 00:51:12,450
虽然从语法上看起来是递归的
that look syntactically recursive,

1009
00:51:13,200 --> 00:51:15,690
但实际上是迭代的
are, in fact, iterative,

1010
00:51:15,870 --> 00:51:17,240
可以在常量空间中运行
run in constant space,

1011
00:51:18,400 --> 00:51:19,750
我不知道这么说是否打消了你们的疑虑
well, I don't know if this makes you less queasy,

1012
00:51:19,750 --> 00:51:21,230
但至少让你们知道发生了什么
but at least it shows you what's happening.

1013
00:51:21,230 --> 00:51:22,810
这其中没有任何构造
There really isn't any buildup there.

1014
00:51:25,910 --> 00:51:27,580
但你也会说 这里面还是有一些构造
Now, you might ask well, is there buildup

1015
00:51:27,980 --> 00:51:30,080
从原则上来说 我们也构造了环境框架
in principle in these environment frames?

1016
00:51:31,710 --> 00:51:32,370
答案则是
And the answer is yeah,

1017
00:51:32,400 --> 00:51:33,840
你确实需要构建这些环境框架
you have to make these new environment frames,

1018
00:51:33,840 --> 00:51:35,264
但是 等你求值完毕后
but you don't have to hang onto them

1019
00:51:35,424 --> 00:51:36,192
不必保留它们
when you're done.

1020
00:51:36,440 --> 00:51:37,610
它们可以被废料收集
They can be garbage collected,

1021
00:51:37,920 --> 00:51:39,470
这些空间也可以被自动地重用
or the space can be reused automatically.

1022
00:51:40,720 --> 00:51:42,990
但你们可以看到求值器控制流
But you see the control structure of the evaluator

1023
00:51:43,250 --> 00:51:46,120
的中心思想就是进行归约
is really using this idea that you actually have a reduction,

1024
00:51:47,020 --> 00:51:49,290
因此这些过程实际上是迭代过程
so these procedures really are iterative procedures.

1025
00:51:50,130 --> 00:51:51,380
好吧 有什么问题么？
All right, let's stop for questions.

1026
00:52:02,680 --> 00:52:03,230
好吧 课件休息吧
All right, let's break.

1027
00:52:04,120 --> 00:52:24,560
[音乐]
[JESU, JOY OF MAN'S DESIRING]

1028
00:52:24,600 --> 00:52:29,696
《计算机程序的构造和解释》
The Structure And Interpretation of Computer Programs

1029
00:52:35,200 --> 00:52:38,368
讲师： 哈罗德·艾伯森教授 及 格兰德·杰·萨斯曼教授
By: Prof. Harold Abelson && Sussman Jay Sussman

1030
00:52:38,360 --> 00:52:42,144
《计算机程序的构造和解释》
The Structure And Interpretation of Computer Programs

1031
00:52:42,140 --> 00:52:46,448
显示控制求值器
Explicit-control Evaluator

1032
00:52:48,770 --> 00:52:51,550
教授：跟迭代过程形成对比的是
PROFESSOR: Let me contrast the iterative procedure

1033
00:52:52,770 --> 00:52:54,896
确实会占用空间的
just so you'll see where space does build up

1034
00:52:55,120 --> 00:52:56,140
递归过程
with a recursive procedure,

1035
00:52:56,170 --> 00:52:57,290
你们可以看到其中的区别
so you can see the difference.

1036
00:52:58,030 --> 00:53:01,200
让我们来看看递归式阶乘的求值
Let's look at the evaluation of recursive factorial.

1037
00:53:02,650 --> 00:53:05,536
这里的FACT-REC
So, here's fact-recursive,

1038
00:53:05,552 --> 00:53:07,220
就是阶乘的标准定义
or standard factorial definition.

1039
00:53:07,220 --> 00:53:10,010
这个当然是一个递归过程
We said this one is still a recursive procedure,

1040
00:53:10,010 --> 00:53:12,570
它的计算过程也是递归的
but this is actually a recursive process.

1041
00:53:13,750 --> 00:53:16,560
然后 只要把它和我们开始的方式联系起来
And then, just to link it back to the way we started,

1042
00:53:16,830 --> 00:53:20,530
我们会通过代换模型发现
we said oh, you can see that it's going to be recursive process

1043
00:53:20,530 --> 00:53:21,820
这是一个递归过程
by the substitution model

1044
00:53:22,360 --> 00:53:28,000
因为 如果我调用(REC-FACT 5)
because, if I say recursive factorial of 5,

1045
00:53:30,450 --> 00:53:34,940
会变成(* 5
that turns into 5 times--

1046
00:53:36,280 --> 00:53:37,820
哦 这里是FACT-REC
what is it, fact-rec, or record fact--

1047
00:53:42,620 --> 00:53:47,930
(* 5 (FACT-REC 4))
5 times recursive factorial of 4,

1048
00:53:49,660 --> 00:53:58,220
又会变成(* 5 (* 4 (FACT-REC 3)))
which turns into 5 times 4 times fact-rec of 3,

1049
00:54:00,220 --> 00:54:08,600
又会变成(* 5 (* 4 (* 3 (* ...
which returns into 5 times 4 times 3 times

1050
00:54:13,450 --> 00:54:15,310
以此类推
and so on, right?

1051
00:54:15,390 --> 00:54:17,390
关键点就是 有一条链条被不断构造出来
The idea is there was this chain of stuff building up,

1052
00:54:18,100 --> 00:54:20,060
这就在代换模型中证明了
which justified, in the substitution model,

1053
00:54:20,080 --> 00:54:21,280
FACT-REC是递归的
the fact that it's recursive.

1054
00:54:21,520 --> 00:54:24,180
现在 让我们来看看这条构造起来的链条
And now, let's actually see that chain of stuff build up

1055
00:54:24,180 --> 00:54:25,290
它又是在机器中的什么地方？
and where it is in the machine, OK?

1056
00:54:27,680 --> 00:54:29,950
好吧 让我们想象一下要从哪里开始
All right, well, let's imagine we're going to start out again.

1057
00:54:30,440 --> 00:54:40,010
我们告诉机器 求值(FACT-REC 5)
We'll tell it to evaluate recursive factorial of 5

1058
00:54:41,450 --> 00:54:43,390
基于的环境是E0
in some environment, again, E0, where

1059
00:54:45,080 --> 00:54:48,970
也就是定义FACT-REC时的环境
where recursive factorial is defined, OK?

1060
00:54:49,550 --> 00:54:51,230
现在 我们知道最终要发生什么
Well, now we know what's eventually going to happen.

1061
00:54:52,250 --> 00:54:53,640
首先
This is going to come along,

1062
00:54:53,920 --> 00:54:55,640
它会对这些东西求值
it'll evaluate those things,

1063
00:54:55,680 --> 00:54:56,990
发现它是一个过程
figure out it's a procedure,

1064
00:54:57,180 --> 00:55:00,160
在这里创建一个新环境E1
build somewhere over here an environment, E1,

1065
00:55:00,880 --> 00:55:03,690
其中N=5
which has n bound to 5,

1066
00:55:04,330 --> 00:55:06,540
并且与E0相连
which hangs off of E0,

1067
00:55:07,800 --> 00:55:08,970
这个E0也就是
which would be, presumably,

1068
00:55:08,990 --> 00:55:12,300
定义FACT-REC的那个环境
the definition environment of recursive factorial.

1069
00:55:14,110 --> 00:55:15,740
然后 在E1这个环境中
OK? And, in this environment,

1070
00:55:15,760 --> 00:55:17,480
求值过程的体
it's going to go off and evaluate the body.

1071
00:55:19,670 --> 00:55:25,920
因此 在这里求值会归约为
So, again, the evaluation here will reduce to

1072
00:55:27,000 --> 00:55:28,920
在E1中求值过程的体
evaluating the body in E1.

1073
00:55:30,160 --> 00:55:31,340
这就需要求值IF语句
That's going to look at an if,

1074
00:55:32,170 --> 00:55:33,530
而我不会讲解IF语句的细节
and I won't go through the details of if.

1075
00:55:33,530 --> 00:55:34,880
IF语句会求值谓词
It'll look at the predicate.

1076
00:55:34,880 --> 00:55:37,530
最后发现需要求值ELSE子句
It'll decide it eventually has to evaluate the alternative.

1077
00:55:37,840 --> 00:55:40,410
因此 这里的整个部分 会归约为
So this whole thing, again, will reduce to

1078
00:55:41,300 --> 00:55:45,530
FACT-REC的ELSE子句
the alternative of recursive factorial,

1079
00:55:45,820 --> 00:55:46,970
也就是谓词为假的部分
the alternative clause,

1080
00:55:47,230 --> 00:55:51,160
整个表达式就归约为了(* N
which says that this whole thing reduces to times n

1081
00:55:53,070 --> 00:55:59,960
(FACT-REC (- N 1))
of recursive factorial of n minus 1

1082
00:56:03,480 --> 00:56:05,550
求值的环境是E1
in the environment E1

1083
00:56:08,380 --> 00:56:10,910
因此 最初的表达式现在就会归约为
OK? So the original expression, now, is going to reduce

1084
00:56:11,040 --> 00:56:12,520
求值这样的一个表达式
to evaluating that expression, all right?

1085
00:56:13,750 --> 00:56:16,280
而现在 我们面对的是一个应用
OK? Now we have an application.

1086
00:56:16,280 --> 00:56:17,630
我们之前求值过应用
We did an application before.

1087
00:56:18,220 --> 00:56:20,250
还记得要怎么求值应用么？
Remember what happens in an application?

1088
00:56:20,360 --> 00:56:21,690
正式求值一个应用之前
The first thing you do is you go off and you

1089
00:56:21,740 --> 00:56:24,810
你需要把CONTINUE寄存器的值保存在栈上
you save the value of the continue register on the stack.

1090
00:56:25,350 --> 00:56:27,180
此时 栈上会有一个值'DONE
So the stack here is going to have done in it.

1091
00:56:29,980 --> 00:56:32,880
接下来 你要为求值子部分做准备
And then you're going to set up to evaluate the sub-parts.

1092
00:56:35,000 --> 00:56:37,200
因此 我们在这里开始求值子部分
OK? So here we go off to evaluate the sub-parts.

1093
00:56:39,470 --> 00:56:41,450
首先要做的是求值运算符
First thing we're going to do is evaluate the operator.

1094
00:56:44,600 --> 00:56:46,320
运算符是怎样求值的呢？
What happens when we evaluate an operator?

1095
00:56:47,250 --> 00:56:48,990
我们通过一些手段
Well, we arrange things so that

1096
00:56:49,000 --> 00:56:51,040
将EXP寄存器指向运算符对应的过程
the operator ends up in the expression register.

1097
00:56:51,480 --> 00:56:53,150
并且让ENV寄存器指向求值的环境
The environments in the ENV register

1098
00:56:53,660 --> 00:56:54,608
而把CONTINUE寄存器赋值为
continue someplace

1099
00:56:54,624 --> 00:56:56,220
用于求值参数的EVAL-ARGS
where we're going to go evaluate the arguments.

1100
00:56:56,590 --> 00:56:57,370
并且 我们把
And, on the stack,

1101
00:56:57,400 --> 00:56:59,290
CONTINUE的原始值保存在栈上
we've saved the original continue,

1102
00:56:59,520 --> 00:57:01,020
我们完成所有工作后 就会跳转到这个地方
which is where we wanted to be when we're all done.

1103
00:57:01,720 --> 00:57:02,860
在我们求值完运算符后
And then the things we needed

1104
00:57:03,580 --> 00:57:05,800
需要做的则是
when we're going to get done evaluating the operator,

1105
00:57:05,900 --> 00:57:07,660
求值对实际参数进行求值
the things we'll need to evaluate the arguments,

1106
00:57:07,690 --> 00:57:12,010
也就是这个环境和这些参数
namely the environment and those arguments,

1107
00:57:12,140 --> 00:57:13,440
这些尚未求值的实际参数
those unevaluated arguments,

1108
00:57:14,200 --> 00:57:15,620
它们现在都还在栈上
so there they are sitting on the stack.

1109
00:57:15,620 --> 00:57:18,590
我们现在就要先来求值运算符
And we're about to go off to evaluate the operator.

1110
00:57:23,260 --> 00:57:26,730
当我们从这个调用返回时
Well, when we return from this particular call--

1111
00:57:26,920 --> 00:57:28,640
在这里 我们将要去调用EVAL-DISPATCH
so we're about to call eval-dispatch here--

1112
00:57:29,380 --> 00:57:30,830
当我们从这个调用返回时
when we return from this call,

1113
00:57:31,450 --> 00:57:32,700
这个运算符所对应的值
the value of that operator,

1114
00:57:32,730 --> 00:57:33,520
在本例中
which, in this case,

1115
00:57:33,552 --> 00:57:35,440
也就是基本的乘法过程
is going to be the primitive multiplier procedure,

1116
00:57:36,440 --> 00:57:37,930
会存放在FUN寄存器中
will end up in the FUN register.

1117
00:57:43,020 --> 00:57:44,530
我们要去求值实际参数
We're going to evaluate some arguments.

1118
00:57:44,530 --> 00:57:45,850
现在这里求值N
They will evaluate n here.

1119
00:57:47,730 --> 00:57:49,870
本例中 会返回5
That'll give us 5, in this case.

1120
00:57:50,250 --> 00:57:52,040
然后我们会把它放入ARGL寄存器
We're going to put that in the argl register,

1121
00:57:53,000 --> 00:57:55,880
然后我们会去求值第二个运算对象
and then we'll go off to evaluate the second operand.

1122
00:57:57,460 --> 00:58:00,480
就在我们准备求值第二个运算对象之时
So, at the point where we go off to evaluate the second operand--

1123
00:58:00,520 --> 00:58:02,192
我会省略计算
and I'll skip details like computing,

1124
00:58:02,208 --> 00:58:03,580
(- N 1)之类的细节
N minus 1, and all of that--

1125
00:58:03,710 --> 00:58:05,880
但是 当我们去求值第二个运算对象时
but, when we go off to evaluate the second operand,

1126
00:58:06,620 --> 00:58:10,440
会最终归约为对FACT-REC的另一个调用
that will eventually reduce to another call to fact-recursive.

1127
00:58:12,000 --> 00:58:14,200
现在 我们在栈上有
And, what we've got on the stack here is

1128
00:58:16,520 --> 00:58:19,940
来自于这个组合式的运算符
the operator from that combination that we're going to use it in

1129
00:58:20,120 --> 00:58:21,070
以及其它的参数
and the other argument.

1130
00:58:23,400 --> 00:58:27,610
现在 我们已经准备好
OK? So, now, we're set up for another call

1131
00:58:28,490 --> 00:58:29,690
去调用另外的FACT-REC了
to recursive factorial.

1132
00:58:30,200 --> 00:58:31,430
而让我们完成了这个调用以后
And, when we're done with this one,

1133
00:58:31,560 --> 00:58:33,640
我们就要跳转到ACCUMULATE-LAST-ARG
we're going to go to accumulate the last arg.

1134
00:58:34,120 --> 00:58:35,200
还记得这是做什么的么？
and remember what that'll do?

1135
00:58:35,200 --> 00:58:35,930
它会说
That'll say oh,

1136
00:58:36,450 --> 00:58:39,280
我们会把这个调用的结果
whatever the result of this has to get combined with that,

1137
00:58:39,280 --> 00:58:40,400
和这个5相乘
and we're going to multiply them.

1138
00:58:41,690 --> 00:58:42,380
但是请注意
But, notice now,

1139
00:58:42,730 --> 00:58:44,810
我们现在处于另一个递归阶乘中
we're at another recursive factorial.

1140
00:58:45,720 --> 00:58:48,920
我们又要再次调用EVAL-DISPATCH
We're about to call eval-dispatch again,

1141
00:58:49,320 --> 00:58:50,600
然而我们并没有真正地“归约”它
except we haven't really reduced it

1142
00:58:50,640 --> 00:58:52,080
因为现在栈上还有东西
because there's stuff on the stack now.

1143
00:58:53,700 --> 00:58:55,390
栈上的这些东西说：“当你返回时”
The stuff on the stack says oh, when you get back,

1144
00:58:55,400 --> 00:58:57,520
你最好把结果和放在这里的5相乘
you'd better multiply it by the 5 you had hanging there.

1145
00:58:58,430 --> 00:59:05,770
所以当我们进行另外的调用
So, when we go off to make another call,

1146
00:59:07,120 --> 00:59:08,840
求值(- N 1)
we evaluate the n minus 1.

1147
00:59:09,300 --> 00:59:11,050
这会返回给我们另一个环境
That gives us another environment which

1148
00:59:11,250 --> 00:59:13,840
其中N的新值为4
in which the new n's going to be down to 4.

1149
00:59:14,600 --> 00:59:16,220
然后又将调用EVAL-DISPATCH
And we're about to call eval-dispatch again.

1150
00:59:19,200 --> 00:59:20,220
我们又创建了另一个调用
We get another call.

1151
00:59:21,350 --> 00:59:24,440
这个4又会遇到相同的情况
That 4 is going to end up in the same situation.

1152
00:59:26,040 --> 00:59:28,620
我们最后会遇到对(FACT-REC N)的又一次调用
We'll end up with another call to fact-recursive n.

1153
00:59:30,020 --> 00:59:32,680
而这时候 栈上会有从最初的调用
And sitting on the stack will be the stuff from the original one

1154
00:59:32,880 --> 00:59:34,510
到最近一次调用的东西
and, now, the subsidiary one we're doing.

1155
00:59:35,360 --> 00:59:36,910
它们都在等待同一个东西
And both of them are waiting for the same thing.

1156
00:59:36,910 --> 00:59:39,160
它们都要跳转到ACCUMULATE-LAST-ARG
They're going to go to accumulate a last argument.

1157
00:59:40,510 --> 00:59:42,940
当然 当我们进行第四次调用时
And then, of course, when we go to the fourth call,

1158
00:59:43,250 --> 00:59:44,380
会发生同样的事
the same thing happens.

1159
00:59:45,640 --> 00:59:47,070
如此往复
And this goes on, and on, and on.

1160
00:59:47,300 --> 00:59:48,600
在这里 你在栈上看到的
And what you see here on the stack,

1161
00:59:50,300 --> 00:59:52,220
栈上面实际存放的是
exactly what's sitting here on the stack,

1162
00:59:52,220 --> 00:59:54,590
基本过程*以及5
the thing that says times and 5.

1163
00:59:54,960 --> 00:59:56,400
而你要把它用来
And what you're going to do with that

1164
00:59:56,590 --> 00:59:58,540
调用ACCUMULATE-LAST-ARG
accumulate that into a last argument.

1165
01:00:00,470 --> 01:00:02,016
就是这样 对吧？
That's exactly this, right?

1166
01:00:02,010 --> 01:00:04,750
这跟它们在表达式中的顺序是一致的
This is exactly where that stuff is hanging.

1167
01:00:05,650 --> 01:00:10,650
实际上 你将要应用的运算符
Effectively, the operator you're going to apply,

1168
01:00:11,720 --> 01:00:14,304
以及当你返回时
the other argument that it's got

1169
01:00:14,320 --> 01:00:15,790
需要去求积的参数
to be multiplied by when you get back

1170
01:00:15,808 --> 01:00:16,910
以及这里的括号
and sort of the parentheses,

1171
01:00:16,940 --> 01:00:18,960
都在告诉你 在对它们进行积累
which says yeah, what you wanted to do was accumulate them.

1172
01:00:19,620 --> 01:00:21,880
因此 你可以看到代换模型并不是这样的谎言
So, you see, the substitution model is not such a lie.

1173
01:00:22,560 --> 01:00:23,630
从某种意义上来说 它实际上是
That really is, in some sense,

1174
01:00:23,640 --> 01:00:25,310
存在于栈上的那些东西
what's sitting right on the stack.

1175
01:00:29,370 --> 01:00:30,400
好吧 从某种意义上来说
All right, so that,

1176
01:00:30,810 --> 01:00:32,480
应该给你们解释了
in some sense, should explain for you,

1177
01:00:33,260 --> 01:00:34,520
或者 至少让你们相信
or at least convince you,

1178
01:00:35,930 --> 01:00:38,720
求值器会通过某些方式
that somehow, this evaluator is managing

1179
01:00:40,060 --> 01:00:42,860
迭代地去求值某些过程
to take these procedures and execute some of them iteratively

1180
01:00:42,950 --> 01:00:44,250
而递归地去求值另外的过程
and some of them recursively,

1181
01:00:45,260 --> 01:00:47,450
尽管从语法上看
even though, as syntactically,

1182
01:00:47,450 --> 01:00:49,050
它们都是递归过程
they look like recursive procedures.

1183
01:00:49,400 --> 01:00:50,640
它又是如何做到的呢？
How's it managing to do that?

1184
01:00:50,660 --> 01:00:53,720
其中的基本原因就是
Well, the basic reason it's managing to do that

1185
01:00:53,800 --> 01:00:55,680
求值器被设置为
is the evaluator is set up

1186
01:00:56,040 --> 01:00:59,260
只保存那些稍后会用到的东西
to save only what it needs later.

1187
01:01:01,090 --> 01:01:04,250
比如说 当你在把
So, for example, at the point where you've reduced

1188
01:01:04,670 --> 01:01:07,390
在一个环境中求值表达式归约为
evaluating an expression and an environment

1189
01:01:07,870 --> 01:01:09,870
将某个过程应用在参数上时
to applying a procedure to some arguments,

1190
01:01:10,520 --> 01:01:12,490
它就不再需要最初的环境了
it doesn't need that original environment anymore

1191
01:01:13,370 --> 01:01:16,650
因为所需要的环境信息都被打包到
because any environment stuff will be packaged inside the procedures

1192
01:01:17,880 --> 01:01:19,360
需要应用的那个过程中了
where the application's going to happen.

1193
01:01:20,750 --> 01:01:21,610
同样 类似地
All right, similarly,

1194
01:01:21,630 --> 01:01:23,650
当你求值一个参数表时
when you're going along evaluating an argument list,

1195
01:01:23,650 --> 01:01:25,200
当你完成对表的求值时
when you've finished evaluating the list,

1196
01:01:25,910 --> 01:01:28,030
当你求值完最后一个参数时
when you're finished evaluating the last argument,

1197
01:01:28,200 --> 01:01:31,610
你就不再需要这个参数表了 对吧？
you don't need that argument list any more, right?

1198
01:01:31,630 --> 01:01:32,940
你也就不再需要
And you don't need the environment where

1199
01:01:33,040 --> 01:01:34,640
求值这些参数所需的环境了
those arguments would be evaluated.

1200
01:01:36,690 --> 01:01:40,890
所以这个解释器如此“智能”的根本原因
So the basic reason that this interpreter is being so smart

1201
01:01:40,890 --> 01:01:42,880
根本不是因为它“智能” 只是因为它老实
is that it's not being smart at all, it's being stupid.

1202
01:01:43,050 --> 01:01:45,740
它的原则就是：“只保存那些需要的”
It's just saying I'm only going to save what I really need.

1203
01:01:48,700 --> 01:01:51,000
这里 让我来给你们展示
Well, let me show you here.

1204
01:01:53,070 --> 01:01:57,200
这是致使尾递归的根本原因
Here's the actual thing that's making a tail recursive.

1205
01:01:58,310 --> 01:02:00,200
要记住 (RESOTRE CONTINUE)这条代码
Remember, it's the restore of continue.

1206
01:02:00,220 --> 01:02:06,940
它指的是 当我去求值过程体的时候
It's saying when I go off to evaluate the procedure body,

1207
01:02:08,960 --> 01:02:11,000
我应该告诉EVAL返回到
I should tell eval to come back to

1208
01:02:11,250 --> 01:02:12,540
最初的求值
the place where that original

1209
01:02:12,540 --> 01:02:14,250
应该返回的地方
evaluation was supposed to come back to.

1210
01:02:15,170 --> 01:02:15,950
因此 从某种角度来说
So, in some sense,

1211
01:02:16,170 --> 01:02:18,840
你想知道是哪一行代码致使了尾递归
you want to say what's the actual line that makes tail recursive

1212
01:02:18,890 --> 01:02:19,440
那么就是这一行
It's that one.

1213
01:02:19,920 --> 01:02:21,530
出于某些奇怪的原因
If I wanted to build a non-

1214
01:02:21,770 --> 01:02:24,800
如果我想构建一个没有尾递归的求值器
tail recursive evaluator, for some strange reason,

1215
01:02:25,690 --> 01:02:26,860
我需要做的就是
all I would need to do

1216
01:02:27,120 --> 01:02:29,290
在这里先不要去恢复CONTINUE
is, instead of restoring continue at this point,

1217
01:02:30,060 --> 01:02:31,660
而是在这里建立一个标号
I'd set up a label down here

1218
01:02:32,750 --> 01:02:36,250
用来标识完成过程应用后的返回位置
called, "Where to come back after you've finished applying the procedure."

1219
01:02:37,640 --> 01:02:39,710
而我会把CONTINUE设置为这个标号
Instead, I'd set continue to that.

1220
01:02:39,920 --> 01:02:41,210
然后跳转到EVAL-DISPATCH
I'd go to eval-dispatch,

1221
01:02:41,400 --> 01:02:43,210
然后EVAL-DISPATCH会回到这里
and then eval-dispatch would come back here.

1222
01:02:43,790 --> 01:02:44,300
而这时
At that point,

1223
01:02:44,320 --> 01:02:45,280
我会恢复CONTINUE
I would restore continue

1224
01:02:45,290 --> 01:02:46,520
并回到最初的返回位置
and go to the original one.

1225
01:02:47,920 --> 01:02:51,000
因此 这里唯一的后果就是
So here, the only consequence of that

1226
01:02:51,150 --> 01:02:52,680
解释器不再是尾递归的了
would be to make it non-tail recursive.

1227
01:02:52,840 --> 01:02:54,620
它会给你完全相同的答案
It would give you exactly the same answers,

1228
01:02:54,720 --> 01:02:57,020
只是当你执行迭代式阶乘
except if you did that iterative factorial

1229
01:02:57,050 --> 01:02:58,360
或者其它迭代过程时
and all those iterative procedures,

1230
01:02:58,600 --> 01:02:59,800
它都会递归地去执行
it would execute recursively.

1231
01:03:03,040 --> 01:03:05,400
然而 我对你们撒了一个小谎
Well, I lied to you a little bit, but just a little bit,

1232
01:03:05,760 --> 01:03:06,990
因为我演示的
because I showed you a slightly

1233
01:03:07,020 --> 01:03:08,330
一个有些过于简化的解释器
over-simplified evaluator

1234
01:03:08,720 --> 01:03:10,380
这个解释器假设每个过程
where it assumes that each procedure --

1235
01:03:11,360 --> 01:03:13,660
只含有一条表达式
each procedure body has only one expression.

1236
01:03:13,890 --> 01:03:14,540
还记得吗 通常来说
Remember, in general,

1237
01:03:14,560 --> 01:03:16,570
过程的体是多条表达式组成的序列
a procedure has a sequence of expressions in it.

1238
01:03:17,870 --> 01:03:20,490
所以没有什么新概念
So there's nothing really conceptually new.

1239
01:03:20,490 --> 01:03:22,280
让我来展示一下实际的求值器
Let me just show you the actual evaluator

1240
01:03:22,890 --> 01:03:24,730
是怎么来处理表达式序列的
that handles sequences of expressions.

1241
01:03:28,470 --> 01:03:29,740
这是现在的COMPOUND-APPLY
This is compound-apply now,

1242
01:03:29,740 --> 01:03:31,310
和之前的唯一不同是
and the only difference from the old one

1243
01:03:32,070 --> 01:03:34,330
它不再直接地跳转到EVAL
is that, instead of going off to eval directly,

1244
01:03:35,980 --> 01:03:38,030
它先获取整个过程的体
it takes the whole body of the procedure,

1245
01:03:38,030 --> 01:03:40,150
在本例中 也就是表达式序列
which, in this case, is a sequence of expressions,

1246
01:03:40,280 --> 01:03:41,710
然后跳转到EVAL-SEQUENCE
and goes off to eval-sequence.

1247
01:03:42,600 --> 01:03:45,320
EVAL-SEQUENCE是一个小型的循环
And eval-sequence is a little loop

1248
01:03:46,830 --> 01:03:49,980
然后每次求值一条表达式
that, basically, does these evaluations one at a time.

1249
01:03:52,630 --> 01:03:53,850
就是这样来求值的--
So it does an evaluation.

1250
01:03:53,900 --> 01:03:54,940
当它求值完一条表达式后
Says oh, when I come back,

1251
01:03:54,970 --> 01:03:56,860
会跳转到这里 去求值下一条
I'd better come back here to do the next one.

1252
01:03:58,440 --> 01:03:59,290
当我完成了所有的求值后
And, when I'm all done,

1253
01:03:59,290 --> 01:04:01,020
我想要跳转到LAST-EXP
when I want to get the last expression,

1254
01:04:01,310 --> 01:04:03,280
我就只需要恢复CONTINUE寄存器
I just restore my continue

1255
01:04:03,920 --> 01:04:05,280
然后跳转到EVAL-DISPATCH
and go off to eval-dispatch.

1256
01:04:06,410 --> 01:04:08,200
同样的 如果你想要在这种求值器中
And, again, if you wanted for some reason

1257
01:04:08,200 --> 01:04:10,350
破坏尾递归机制
to break tail recursion in this evaluator,

1258
01:04:10,640 --> 01:04:13,710
你只需要在LAST-EXP中不做特殊处理即可
all you need to do is not handle the last expression, especially.

1259
01:04:14,900 --> 01:04:17,340
也就是说 当你处理完最后一条表达式
Just say, after you've done the last expression,

1260
01:04:17,360 --> 01:04:18,650
你跳转到另外一个地方
come back to some other place

1261
01:04:19,150 --> 01:04:20,680
在那个地方去恢复CONTINUE
after which you restore continue.

1262
01:04:21,900 --> 01:04:23,260
出于某些原因
And, for some reason,

1263
01:04:23,260 --> 01:04:25,740
很多Lisp求值器倾向于这么做
a lot of LISP evaluators tended to work that way.

1264
01:04:26,550 --> 01:04:28,440
这样做的后果就是
And the only consequence of that is that

1265
01:04:28,860 --> 01:04:30,720
迭代式过程也会使栈增长
iterative procedures built up stack.

1266
01:04:31,880 --> 01:04:33,610
还不清楚为什么会这样
And it's not clear why that happened.

1267
01:04:35,920 --> 01:04:37,980
好吧 我稍微来总结一下
All right. Well, let me just sort of summarize,

1268
01:04:38,090 --> 01:04:39,600
毕竟这是一个大程序
since this is a lot of details

1269
01:04:39,980 --> 01:04:41,040
又有很多细节
in a big program.

1270
01:04:41,120 --> 01:04:42,250
但关键点就是
But the main point is that

1271
01:04:43,040 --> 01:04:43,872
从概念上来说
it's no different,

1272
01:04:44,048 --> 01:04:46,080
这跟翻译其它程序没什么不同
conceptually, from translating any other program.

1273
01:04:47,060 --> 01:04:48,060
核心思想就是
And the main idea is that

1274
01:04:48,060 --> 01:04:50,280
我们已经有了通用求值器程序
we have this universal evaluator program,

1275
01:04:50,330 --> 01:04:51,710
一个元循环求值器
the meta-circular evaluator.

1276
01:04:51,870 --> 01:04:53,070
如果我们把它翻译为了Lisp
If we translate that into LISP,

1277
01:04:53,100 --> 01:04:53,950
那么我们就有了Lisp的所有东西
then we have all of LISP.

1278
01:04:54,330 --> 01:04:55,150
我们就是这么来做的
And that's all we did.

1279
01:04:57,980 --> 01:04:59,680
第二点则是 魔法消失了
The second point is that the magic's gone away.

1280
01:04:59,680 --> 01:05:01,970
这整个系统不再神秘了 对吧？
There should be no more magic in this whole system, right?

1281
01:05:01,970 --> 01:05:07,790
原则上来说 这应该相当清楚了
In principle, it should all be very clear

1282
01:05:07,820 --> 01:05:10,080
只是还不太了解表结构的内存管理
except, maybe, for how list structured memory works,

1283
01:05:10,800 --> 01:05:11,800
我们后面会讲
and we'll see that later.

1284
01:05:12,640 --> 01:05:14,200
这也并不困难
But that's not very hard.

1285
01:05:15,450 --> 01:05:16,350
第三点就是
The third point is that

1286
01:05:16,350 --> 01:05:17,520
所有的这些尾递归
all this tail recursion

1287
01:05:18,240 --> 01:05:21,960
来自于严格的求值纪律
came from the discipline of eval being very careful

1288
01:05:22,550 --> 01:05:24,510
也就是只保存那些后面会用到的东西
to save only what it needs next time.

1289
01:05:25,870 --> 01:05:27,720
而不是一些比较随意的原则
It's not some arbitrary thing

1290
01:05:27,760 --> 01:05:29,860
比如 无论什么时候我们调用一个子过程
where we're saying well, whenever we call a sub-routine,

1291
01:05:29,860 --> 01:05:32,160
我们会保存所有的寄存器并且返回
we'll save all the registers in the world and come back?

1292
01:05:33,940 --> 01:05:36,490
有些时候为了提效 这样做很值得
See, sometimes it pays to really worry about efficiency.

1293
01:05:37,150 --> 01:05:39,960
当你研究求值机器的内部原理时
And, when you're down in the guts of your evaluator machine,

1294
01:05:40,450 --> 01:05:42,560
这类东西就很值得去研究
it really pays to think about things like that

1295
01:05:42,560 --> 01:05:43,960
因为它会带来显著的不同
because it makes big consequences.

1296
01:05:45,230 --> 01:05:47,690
我想现在基本上已经
Well, I hope what this has done

1297
01:05:47,900 --> 01:05:52,300
把这个求值器讲得很清楚了
is really made the evaluator seem concrete.

1298
01:05:52,560 --> 01:05:53,900
我希望你们能相信
I hope you really believe

1299
01:05:54,320 --> 01:05:56,270
真的有人能够
that somebody could hold a LISP

1300
01:05:56,840 --> 01:05:58,560
将一个Lisp求值器放在掌心之中
LISP evaluator in the palm of their hand.

1301
01:05:59,070 --> 01:06:00,490
为了让你们死心塌地
Maybe to help you believe that, here's a

1302
01:06:00,800 --> 01:06:01,960
我给你们看一个Lisp求值器
here's a LISP evaluator

1303
01:06:02,540 --> 01:06:04,060
它就在我的手掌中
that I'm holding the palm of my hand.

1304
01:06:06,160 --> 01:06:10,560
这块求值器芯片实际上
And this is a chip which is actually

1305
01:06:10,890 --> 01:06:13,700
比我给你们展示的求值器还要复杂
quite a bit more complicated than the evaluator I showed you.

1306
01:06:16,864 --> 01:06:19,200
这张图片效果更好
Uh.. maybe, here's a better picture of it.

1307
01:06:22,070 --> 01:06:22,570
在这上面
What there is,

1308
01:06:22,600 --> 01:06:24,380
你可以看到相同的宏观结构
is you can see the same overall structure.

1309
01:06:24,730 --> 01:06:25,930
这是寄存器阵列
This is a register array.

1310
01:06:26,800 --> 01:06:27,710
这些是数据通路
These are the data paths.

1311
01:06:27,720 --> 01:06:29,070
这里有是有穷状态控制器
Here's a finite state controller.

1312
01:06:29,800 --> 01:06:31,040
再强调一下 是有穷状态
And again, finite state,

1313
01:06:31,960 --> 01:06:32,800
全都在这里了
that's all there is.

1314
01:06:32,810 --> 01:06:34,160
在另外的地方还有外部存储
And somewhere there's external memory

1315
01:06:34,160 --> 01:06:35,230
用来存储数据
that'll worry about things.

1316
01:06:35,750 --> 01:06:37,630
而这块芯片非常复杂
And this particular one is very complicated

1317
01:06:37,640 --> 01:06:39,160
是因为它尝试更快地运行Lisp
because it's trying to run LISP fast.

1318
01:06:39,660 --> 01:06:42,970
它具有非常非常之快的并行运算
And it has some very, very fast parallel operations in there

1319
01:06:43,070 --> 01:06:46,320
比如说 如果你想要索引一个数组
like, if you want to index into an array,

1320
01:06:46,700 --> 01:06:50,400
同时又要检查该索引是否为一个整数
simultaneously check that the index is an integer,

1321
01:06:50,430 --> 01:06:52,860
以及该索引没有越界
check that it doesn't exceed the array bands,

1322
01:06:53,040 --> 01:06:55,020
同时还要进行内存存取
and go off and do the memory access,

1323
01:06:55,050 --> 01:06:56,700
它会同时进行这些事
and do all those things simultaneously.

1324
01:06:57,120 --> 01:06:58,400
如果这些操作都没有问题的话
And then, later, if they're all OK,

1325
01:06:58,440 --> 01:06:59,960
最终就会在这里得到结果
actually get the value there.

1326
01:07:00,420 --> 01:07:02,460
因此 数据通路中大量的
So there are a lot of complicated operations

1327
01:07:02,480 --> 01:07:04,650
复杂运算使得Lisp能够并行运行
in these data paths for making LISP run in parallel.

1328
01:07:05,260 --> 01:07:08,416
这完全是求值Lisp的
It's a completely non-risk

1329
01:07:08,768 --> 01:07:10,360
一种无冒险的哲学
philosophy of evaluating LISP.

1330
01:07:10,640 --> 01:07:13,200
并且 这个的微指令也相当复杂
And then, this microcode is pretty complicated.

1331
01:07:13,450 --> 01:07:17,560
让我先看一看
Let's see, there's what?

1332
01:07:17,600 --> 01:07:21,100
这其中有大概389条
There's about 389 instructions of

1333
01:07:21,680 --> 01:07:23,850
220比特的微指令
of 220-bit microcode sitting here

1334
01:07:24,070 --> 01:07:27,940
只因为这些数据通路非常复杂
because these are very complicated data paths.

1335
01:07:27,940 --> 01:07:32,250
整个芯片大概有89,000支晶体管
And the whole thing has about 89,000 transistors, OK?

1336
01:07:33,560 --> 01:07:36,860
好吧 我希望通过这节课解答了大部分疑惑
OK. Well, I hope that that takes away a lot of the mystery.

1337
01:07:37,970 --> 01:07:39,240
也许你们想看一看这块芯片
Maybe somebody wants to look at this.

1338
01:07:46,140 --> 01:07:46,890
好吧 先讲到这里
OK. Let's stop.

1339
01:07:56,460 --> 01:07:56,750
有问题吗？
Questions?

1340
01:07:59,000 --> 01:08:00,420
学生：您所讲的 听起来像是
AUDIENCE: OK, now, it sounds like what you're saying is that,

1341
01:08:00,420 --> 01:08:03,480
如果把(RESTORE CONTINUE)放在合适的地方
with the restore continue put in the proper place,

1342
01:08:03,580 --> 01:08:09,420
这样之前递归求值的过程
that procedures that would invoke a recursive process

1343
01:08:09,420 --> 01:08:11,950
现在就会变成迭代求值的
now invoke an iterative process

1344
01:08:12,670 --> 01:08:15,360
（意义不明）
just by the way that the eval-sequence source?

1345
01:08:15,600 --> 01:08:17,540
教授：我想我应该这么来说
PROFESSOR: I think the way I'd prefer to put it is that,

1346
01:08:17,540 --> 01:08:19,820
如果把(RESTORE CONTINUE)放在了错误的位置
with restore continue put in the wrong place,

1347
01:08:20,550 --> 01:08:25,480
你就会让那些语法上看起来像递归的过程
you can cause any syntactically-looking recursive procedure,

1348
01:08:25,520 --> 01:08:27,280
在运行的时候不断地扩张栈
in fact, to build up stack as it runs.

1349
01:08:28,640 --> 01:08:30,520
但这样是没有原因的
But there's no reason for that,

1350
01:08:33,150 --> 01:08:35,120
你可以自己去试一试
so you might want to play around with it.

1351
01:08:35,150 --> 01:08:38,090
你可以在COMPOND-APPLY返回后
You can just switch around two or three instructions

1352
01:08:38,180 --> 01:08:40,780
交换两、三条语句的顺序
in the way compound-apply comes back,

1353
01:08:41,310 --> 01:08:43,260
那么你得到的就不再是尾递归了
and you'll get something which isn't tail recursive.

1354
01:08:45,060 --> 01:08:46,140
我只是想强调
But the thing I wanted to emphasize

1355
01:08:46,160 --> 01:08:47,400
这其中没有什么魔法
is there's no magic. there's no

1356
01:08:47,670 --> 01:08:48,570
这并不是
It's not as if

1357
01:08:49,310 --> 01:08:52,170
有什么智能的预处理程序
there's some very clever pre-processing program

1358
01:08:52,650 --> 01:08:55,450
它会分析FACT-ITER这个程序
that's looking at this procedure, factorial iter,

1359
01:08:55,470 --> 01:08:56,730
然后说
and say oh, gee, um

1360
01:08:57,420 --> 01:08:58,860
我注意到
I really notice that

1361
01:08:58,880 --> 01:09:01,130
完成这个调用 不需要我进行压栈
I don't have to push stack in order to do this.

1362
01:09:01,130 --> 01:09:02,880
但是有些人是这么认为的
Some people think that that's what's going on.

1363
01:09:03,760 --> 01:09:05,380
而是一种比这个还要蠢的机制
It's something much, much more dumb than that,

1364
01:09:05,380 --> 01:09:07,500
就是在合适的地方插入RESTORE指令
it's this one place you're putting the restore instruction.

1365
01:09:08,560 --> 01:09:09,790
就可以自动地实现
It's just automatic.

1366
01:09:14,720 --> 01:09:17,550
学生：但这不会影响到时间复杂度 对吧？
AUDIENCE: But that's not affecting the time complexity is it?

1367
01:09:17,580 --> 01:09:17,870
教授：不会
PROFESSOR: No.

1368
01:09:18,600 --> 01:09:21,770
学生：它不会迭代地处理
AUDIENCE: It's just that it's handling it recursively

1369
01:09:21,800 --> 01:09:23,020
而是会递归地处理
instead of iteratively.

1370
01:09:23,020 --> 01:09:27,340
但就从完成这两个运算的时间来说
But, in terms of the order of time it takes to finish the operation,

1371
01:09:27,370 --> 01:09:29,220
它们都是相同的 对吧？
it's the same one way or the other, right?

1372
01:09:29,470 --> 01:09:29,760
教授 ：是的
PROFESSOR: Yes.

1373
01:09:29,790 --> 01:09:32,680
尾递归不会改变任何东西的时间复杂度
Tail recursion is not going to change the time complexity of anything

1374
01:09:32,720 --> 01:09:33,290
因为 从某种意义上来说
because, in some sense,

1375
01:09:33,340 --> 01:09:35,150
两者都是相同的算法
it's the same algorithm that's going on.

1376
01:09:36,020 --> 01:09:39,370
它只是让这个过程迭代地运行
What it's doing is really making this thing run as an iteration.

1377
01:09:41,000 --> 01:09:42,640
这样 当参数很大时
Right? Not going to run out of memory

1378
01:09:42,680 --> 01:09:44,220
它不会耗尽所有的内存
you know counting up to a giant number

1379
01:09:44,750 --> 01:09:46,400
因为这其中没有压栈
simply because the stack would get pushed.

1380
01:09:48,350 --> 01:09:50,240
事实上 你们需要相信
See, the thing you really have to believe is that,

1381
01:09:50,560 --> 01:09:51,130
当我们编写--
when we write--

1382
01:09:51,640 --> 01:09:53,780
我们一直把这些代码称作“迭代”
see, we've been writing all these things called iterations,

1383
01:09:53,930 --> 01:09:57,990
把(DEFINE (LOOP) (LOOP))称作无穷循环
infinite loops, define loop to be called loop.

1384
01:10:00,320 --> 01:10:03,360
这就是一个迭代
That's is as much an iteration

1385
01:10:03,650 --> 01:10:05,660
跟我们用DO语句来写无穷循环是一样的
you know as if we wrote do forever loop.

1386
01:10:07,630 --> 01:10:09,280
它们只是语法上不同而已
It's just syntactic sugar as the difference.

1387
01:10:09,280 --> 01:10:11,320
它们实际上都是迭代
These things are real, honest to god, iterations?

1388
01:10:14,730 --> 01:10:16,080
它们并不改变时间复杂度
They don't change the time complexity,

1389
01:10:16,110 --> 01:10:18,530
但是它会把它们变成真正的迭代
but they turn them into real iterations.

1390
01:10:21,680 --> 01:10:23,800
好吧 下课
All right, thank you.

1391
01:10:23,800 --> 01:10:25,800
MIT OpenCourseWare
http://ocw.mit.edu


1392
01:10:25,800 --> 01:10:27,800
本项目主页
https://github.com/DeathKing/Learning-SICP


