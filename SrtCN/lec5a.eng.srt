1
00:00:00,000 --> 00:00:16,830
[MUSIC PLAYING]

2
00:00:16,830 --> 00:00:24,850
PROFESSOR: Well, so far we've invented enough programming to do some very complicated things.

3
00:00:24,850 --> 00:00:29,760
And you surely learned a lot about programming at this point.

4
00:00:29,760 --> 00:00:36,610
You've learned almost all the most important tricks that usually don't get taught to people until they have had a lot of experience.

5
00:00:36,610 --> 00:00:42,755
For example, data directed programming is a major trick, and yesterday you also saw an interpreted language.

6
00:00:45,300 --> 00:00:54,020
We did this all in a computer language, at this point, where there was no assignment statement.

7
00:00:54,020 --> 00:01:02,040
And presumably, for those of you who've seen your Basic or Pascal or whatever, that's usually considered the most important thing.

8
00:01:02,040 --> 00:01:03,580
Well today, we're going to do some thing horrible.

9
00:01:03,580 --> 00:01:07,370
We're going to add an assignment statement.

10
00:01:07,370 --> 00:01:11,110
And since we can do all these wonderful things without it, why should we add it?

11
00:01:11,110 --> 00:01:23,636
An important thing to understand is that today we're going to, first of all, have a rule, which is going to always be obeyed, which is the only reason we ever add a feature to our language is because there is a good reason.

12
00:01:23,636 --> 00:01:36,630
And the good reason is going to boil down to the ability, you now get an ability to break a problem into pieces that are different sets of pieces then you could have broken it down without that, give you another means of decomposition.

13
00:01:38,350 --> 00:01:39,490
However, let's just start.

14
00:01:39,490 --> 00:01:48,240
Let me quick begin by reviewing the kind of language that we have now.

15
00:01:48,240 --> 00:01:51,310
We've been writing what's called functional programs.

16
00:01:51,310 --> 00:01:58,890
And functional programs are a kind of encoding of mathematical truths.

17
00:01:58,890 --> 00:02:07,090
For example, when we look at the factorial procedure that you see on the slide here, it's basically two clauses.

18
00:02:07,090 --> 00:02:11,230
If n is one, the result is one, otherwise n times factorial n minus one.

19
00:02:11,230 --> 00:02:12,990
That's factorial of n.

20
00:02:12,990 --> 00:02:14,960
Well, that is factorial of n.

21
00:02:14,960 --> 00:02:32,680
And written down in some other obscure notation that you might have learned in calculus classes, mathematical logic, what you see there is if n equals one, for the result of n factorial is one, otherwise, greater than one, n factorial is n times n minus one factorial.

22
00:02:32,680 --> 00:02:37,000
True statements, that's the kind of language we've been using.

23
00:02:37,000 --> 00:02:51,390
And whenever we have true statements of that sort, there is a kind of, a way of understanding how they work which is that such processes can be involved by substitution.

24
00:02:51,390 --> 00:03:12,430
And so we see on the second slide here, that the way we understand the execution implied by those statements in arranged in that order, is that you do successive substitutions of arguments for formal parameters in the body of a procedure.

25
00:03:12,430 --> 00:03:14,710
This is basically a sequence of equalities.

26
00:03:14,710 --> 00:03:17,390
Factorial four is four times factorial three.

27
00:03:17,390 --> 00:03:21,290
That is four times three times factorial of two and so on.

28
00:03:21,290 --> 00:03:23,325
We're always preserving truth.

29
00:03:26,580 --> 00:03:38,640
Even though we're talking about true statements, there might be more than one organization of these true statements to describe the computation of a particular function, the computation of the value of a particular function.

30
00:03:38,640 --> 00:03:42,460
So, for example, looking at the next one here.

31
00:03:42,460 --> 00:03:49,780
Here is a way of looking at the sum of n and m.

32
00:03:49,780 --> 00:03:52,930
And we did this one by a recursive process.

33
00:03:52,930 --> 00:04:00,130
It's the increment of the sum of the decrement of n and m.

34
00:04:00,130 --> 00:04:06,240
And, of course, there is some piece of mathematical logic here that describes that.

35
00:04:06,240 --> 00:04:13,120
It's the increment of the sum of the decrement of n and m, just like that.

36
00:04:13,120 --> 00:04:16,440
So there's nothing particularly magic about that.

37
00:04:16,440 --> 00:04:25,310
And, of course, if we can also look at an iterative process for the same, a program that evolves an iterative process, for the same function.

38
00:04:25,310 --> 00:04:29,930
These are two things that compute the same answer.

39
00:04:29,930 --> 00:04:36,720
And we have equivalent mathematical truths that are arranged there.

40
00:04:36,720 --> 00:04:40,430
And just the way you arrange those truths determine the particular process.

41
00:04:40,430 --> 00:04:44,400
In the way choose and arrange them determines the process that's evolved.

42
00:04:44,400 --> 00:04:50,410
So we have the flexibility of talking about both the function to be computed, and the method by which it's computed.

43
00:04:50,410 --> 00:04:53,580
So it's not clear we need more.

44
00:04:53,580 --> 00:04:55,440
However, today I'm going to this awful thing.

45
00:04:55,440 --> 00:04:59,070
I'm going to introduce this assignment operation.

46
00:04:59,070 --> 00:05:02,890
Now, what is this?

47
00:05:02,890 --> 00:05:18,570
Well, first of all, there is going to be another kind of kind of statement, if you will, in a programming language called Set!  Things that do things like assignment, I'm going to put exclamation points after.

48
00:05:18,570 --> 00:05:20,990
We'll talk about what that means in a second.

49
00:05:20,990 --> 00:05:28,090
The exclamation point, again like question mark, is an arbitrary thing we attach to the symbol which is the name, has no significance to the system.

50
00:05:28,090 --> 00:05:35,910
The only significance is to me and you to alert you that this is an assignment of some sort.

51
00:05:35,910 --> 00:05:39,960
But we're going to set a variable to a value.

52
00:05:43,800 --> 00:05:48,600
And what that's going to mean is that there is a time at which something happens.

53
00:05:48,600 --> 00:05:50,100
Here's a time.

54
00:05:50,100 --> 00:05:55,030
If I have time going this way, it's a time access.

55
00:05:55,030 --> 00:05:58,650
Time progresses by walking down the page.

56
00:05:58,650 --> 00:06:06,670
Then an assignment is the first thing we have that produces the difference between a before and an after.

57
00:06:06,670 --> 00:06:14,590
All the other programs that we've written, that have no assignments in them, the order in which they were evaluated didn't matter.

58
00:06:14,590 --> 00:06:17,990
But assignment is special, it produces a moment in time.

59
00:06:17,990 --> 00:06:43,320
So there is a moment before the set occurs and after, such that after this moment in time, the variable has the value, value.

60
00:06:49,310 --> 00:06:57,660
Independent of what value it had before, set! changes the value of the variable.

61
00:06:57,660 --> 00:07:03,150
Until this moment, we had nothing that changed.

62
00:07:03,150 --> 00:07:13,740
So, for example, one of the things we can think of is that the procedures we write for something like factorial are in fact pretty much identical to the function factorial.

63
00:07:13,740 --> 00:07:23,040
Factorial of four, if I write fact4, independent of what context it's in, and independent of how many times I write it, I always get the same answer.

64
00:07:23,040 --> 00:07:25,430
It's always 24.

65
00:07:25,430 --> 00:07:30,360
It's a unique map from the argument to the answer.

66
00:07:30,360 --> 00:07:33,580
And all the programs we've written so far are like that.

67
00:07:33,580 --> 00:07:37,020
However, once I have assignment, that isn't true.

68
00:07:37,020 --> 00:07:50,070
So, for example, if I were to define count to be one.

69
00:07:50,070 --> 00:08:03,870
And then I'm going to define also a procedure, a simple procedure called demo, which takes argument x and does the following operations.

70
00:08:03,870 --> 00:08:09,650
It first sets x to x plus one.

71
00:08:09,650 --> 00:08:14,410
My gosh, this looks just like FORTRAN, right-- in a funny syntax.

72
00:08:16,910 --> 00:08:24,330
And then add to x count, Oh, I just made a mistake.

73
00:08:24,330 --> 00:08:27,010
I want to say, set! count to one plus count.

74
00:08:30,310 --> 00:08:31,730
It's this thing defined here.

75
00:08:34,350 --> 00:08:36,369
And then plus x count.

76
00:08:40,409 --> 00:08:42,559
Then I can try this procedure.

77
00:08:42,559 --> 00:08:43,880
Let's run it.

78
00:08:43,880 --> 00:08:48,125
So, suppose I get a prompt and I say, demo three.

79
00:08:52,210 --> 00:08:53,540
Well, what happens here?

80
00:08:53,540 --> 00:08:57,020
The first thing that happens is count is currently one.

81
00:08:57,020 --> 00:08:59,130
Currently, there is a time.

82
00:08:59,130 --> 00:09:00,710
We're talking about time.

83
00:09:00,710 --> 00:09:02,960
x gets three.

84
00:09:02,960 --> 00:09:08,690
At this moment, I say, oh yes, count is incremented, so count is two.

85
00:09:08,690 --> 00:09:10,710
two plus three is five.

86
00:09:10,710 --> 00:09:14,460
So the answer I get out is five.

87
00:09:14,460 --> 00:09:23,640
Then I say, demo of say, three again.

88
00:09:23,640 --> 00:09:24,830
What do I get?

89
00:09:24,830 --> 00:09:30,760
Well, now count is two, it's not one anymore, because I have incremented it.

90
00:09:30,760 --> 00:09:38,160
But now I go through this process, three goes into x, count becomes one plus count, so that's three now.

91
00:09:38,160 --> 00:09:42,130
The sum of those two is six, so the answer is six.

92
00:09:42,130 --> 00:09:52,170
And what we see is the same expression leads to two different answers, depending upon time.

93
00:09:52,170 --> 00:09:56,290
So demo is not a function, does not compute a mathematical function.

94
00:10:00,020 --> 00:10:07,780
In fact, you could also see why now, of course, this is the first place where the substitution model isn't going to work.

95
00:10:07,780 --> 00:10:11,410
This kills the substitution model dead.

96
00:10:11,410 --> 00:10:25,150
You know, with quotation there were some little problems that a philosopher might notice with the substitutions, because you have to worry about what deductions you can make when you substitute into quotes, if you're allowed to do that at all.

97
00:10:25,150 --> 00:10:29,810
But here the substitution model is dead, can't do anything at all.

98
00:10:29,810 --> 00:10:37,560
Because, supposing I wanted to use a substitution model to consider substituting for count?

99
00:10:37,560 --> 00:10:44,540
Well, my gosh, if I substitute for here and here, they're different ones.

100
00:10:44,540 --> 00:10:46,570
It's not the same count any more.

101
00:10:46,570 --> 00:10:47,880
I get the wrong answer.

102
00:10:47,880 --> 00:10:55,560
The substitution model is a static phenomenon that describes things that are true and not things that change.

103
00:10:55,560 --> 00:10:56,810
Here, we have truths that change.

104
00:11:01,860 --> 00:11:07,870
OK, Well, before I give you any understanding of this, this is very bad.

105
00:11:07,870 --> 00:11:11,520
Now, we've lost our model of computation.

106
00:11:11,520 --> 00:11:15,030
Pretty soon, I'm going to have to build you a new model of computation.

107
00:11:15,030 --> 00:11:18,710
But ours plays with this, just now, in an informal sense.

108
00:11:18,710 --> 00:11:37,810
Of course, what you already see is that when I have something like assignment, the model that we're going to need is different from the model that we had before in that the variables, those symbols like count, or x are no longer going to refer to the values they have, but rather to some sort of place where the value restored.

109
00:11:37,810 --> 00:11:40,330
We're going to have to think that way for a while.

110
00:11:40,330 --> 00:11:44,590
And it's going to be a very bad thing and cause a lot of trouble.

111
00:11:44,590 --> 00:11:53,510
And so, as I said, the very fact that we're inventing this bad thing, means that there had better be a good reason for it, otherwise, just a waste of time and a lot of effort.

112
00:11:53,510 --> 00:11:56,090
Let's just look at some of it just to play.

113
00:11:56,090 --> 00:12:04,430
Supposing we write down the functional version, functional meaning in the old style, of factorial by an iterative process.

114
00:12:09,780 --> 00:12:46,930
Factorial of n, we're going to iterate of m and i, which says if i is greater than n, then the result is m, otherwise, the result of iterating the product of i and m.

115
00:12:46,930 --> 00:12:51,690
So m is going to be the product that I'm accumulating.

116
00:12:51,690 --> 00:12:52,940
m is the product.

117
00:12:58,170 --> 00:12:59,990
And the count I'm going to increase by one.

118
00:13:04,810 --> 00:13:12,060
Plus, ITER, ELSE, COND, define.

119
00:13:12,060 --> 00:13:13,310
I'm going to start this up.

120
00:13:17,000 --> 00:13:21,020
And these days, you should have no trouble reading something like this.

121
00:13:21,020 --> 00:13:26,750
What I have here is a product there being accumulated and a counter.

122
00:13:26,750 --> 00:13:29,050
I start them up both at one.

123
00:13:29,050 --> 00:13:34,800
I'm going to buzz the counter up, i goes to i plus one every time around.

124
00:13:34,800 --> 00:13:42,840
But that's only our putting a time on the process, each of this is just a set of truths, true rules.

125
00:13:42,840 --> 00:13:52,750
And m is going to get a new values of i and m, i times m each time around, and eventually i is going to be bigger than n, in which case, the answer's going to be m.

126
00:13:52,750 --> 00:13:55,760
Now, I'm speaking to you, use time in this.

127
00:13:55,760 --> 00:13:58,210
That's just because I know how the computer works.

128
00:13:58,210 --> 00:13:59,090
But I didn't have to.

129
00:13:59,090 --> 00:14:05,280
This could be a purely mathematical description at this point, because substitution will work for this.

130
00:14:05,280 --> 00:14:11,975
But let's set right down a similar sort of program, using the same algorithm, but with assignments.

131
00:14:15,296 --> 00:14:16,940
So this is called the functional version.

132
00:14:23,840 --> 00:14:25,255
I want to write down an imperative version.

133
00:14:34,150 --> 00:14:36,010
Factorial of n.

134
00:14:36,010 --> 00:14:37,510
I'm going to create my two variables.

135
00:14:40,120 --> 00:14:50,930
Let i initialize itself to one, and m be initialized to one, similar.

136
00:14:50,930 --> 00:15:07,360
We'll create a loop which has COND greater than i, and if i is greater than n, we're done.

137
00:15:07,360 --> 00:15:10,910
And the result is m, the product I'm accumulating.

138
00:15:10,910 --> 00:15:19,320
Otherwise, I'm going to write down three things to do.

139
00:15:19,320 --> 00:15:40,610
I'm going to set! m to the product of i and m, set! i to the sum of i and one, and go around the loop again.

140
00:15:40,610 --> 00:15:44,890
Looks very familiar to you FORTRAN programmers.

141
00:15:44,890 --> 00:15:47,760
ELSE, COND, define, funny syntax though.

142
00:15:51,270 --> 00:15:59,320
Start the loop up, and that's the program.

143
00:15:59,320 --> 00:16:02,790
Now, this program, how do we think about it?

144
00:16:02,790 --> 00:16:04,690
Well, let's just say what we're seeing here.

145
00:16:04,690 --> 00:16:10,810
There are two local variables, i and m, that have been initialized to one.

146
00:16:10,810 --> 00:16:19,240
Every time around the loop, I test to see if i is greater than n, which is the input argument, and if so, the result is the product being accumulated in m.

147
00:16:19,240 --> 00:16:29,130
However, if it's not the end of the loop, if I'm not done, then what I'm going to do is change the product to be the result of multiplying i times the current product.

148
00:16:29,130 --> 00:16:31,530
Which is sort of what we were doing here.

149
00:16:31,530 --> 00:16:33,386
Except here I wasn't changing.

150
00:16:33,386 --> 00:16:46,710
I was making another copy, because the substitution model says, you copy the body of the procedure with the arguments substituted for the formal parameters.

151
00:16:46,710 --> 00:16:51,990
Here I'm not worried about copying, here I've changed the value of m.

152
00:16:51,990 --> 00:16:58,300
I also then change the value of i to i plus one, and go buzzing around.

153
00:16:58,300 --> 00:17:06,160
Seems like essentially the same program, but there are some ways of making errors here that didn't exist until today.

154
00:17:06,160 --> 00:17:20,339
For example, if I were to do the horrible thing of not being careful in writing my program and interchange those two assignments, the program wouldn't compute the same function.

155
00:17:20,339 --> 00:17:27,460
I get a timing error because there's a dependency that m depends upon having the last value of i.

156
00:17:27,460 --> 00:17:36,060
If I try to i first, then I've got the wrong value of i when I multiply by m.

157
00:17:36,060 --> 00:17:40,660
It's a bug that wasn't available until this moment, until we introduced something that had time in it.

158
00:17:43,470 --> 00:17:52,800
So, as I said, first we need a new model of computation, and second, we have to be damn good reason for doing this kind of ugly thing.

159
00:17:52,800 --> 00:17:54,050
Are there any questions?

160
00:17:58,800 --> 00:18:00,505
Speak loudly, David.

161
00:18:00,505 --> 00:18:07,630
AUDIENCE: I'm confused about, we've introduced set now, but we had let before and define before.

162
00:18:07,630 --> 00:18:09,980
I'm confused about the difference between the three.

163
00:18:09,980 --> 00:18:15,280
Wouldn't define work in the same situation as set if you introduced it a bit?

164
00:18:15,280 --> 00:18:20,230
PROFESSOR: No, define is intended for setting something once the first time, for making it.

165
00:18:22,790 --> 00:18:31,970
You've never seen me write on a blackboard two defines in a row whose intention was to change the old value of some variable to a new one.

166
00:18:31,970 --> 00:18:38,120
AUDIENCE: Is that by convention or-- PROFESSOR: No, it's intention.

167
00:18:38,120 --> 00:18:49,850
The answer is that, for example, internal to a procedure, two defines in a row are illegal, two defines in a row of the same variable.

168
00:18:49,850 --> 00:18:51,890
x can't be defined twice.

169
00:18:51,890 --> 00:19:00,840
Whether or not a system catches that error is a different question, but I legislate to you that define happens once on anything.

170
00:19:00,840 --> 00:19:11,610
Now, indeed, in interactive debugging, we intend that you interacting with your computer will redefine things, and so there's a special exception made for interactive debugging.

171
00:19:11,610 --> 00:19:22,460
But define is intended to mean to set up something which will be forever that value after that point.

172
00:19:22,460 --> 00:19:26,490
It's as if all the defines were done at the beginning.

173
00:19:26,490 --> 00:19:37,855
In fact, the only legal place to put a define in Scheme, internal to a procedure, is just at the beginning of a lambda expression, the beginning of the body of a procedure.

174
00:19:41,750 --> 00:19:46,670
Now, let of course does nothing like either of that.

175
00:19:46,670 --> 00:19:52,220
I mean, if you look at what's happening with a let, this happens again exactly once.

176
00:19:52,220 --> 00:19:56,820
It sets up a context where i and m are values one and one.

177
00:19:56,820 --> 00:20:02,880
That context exists throughout this scope, this region of the program.

178
00:20:05,080 --> 00:20:11,110
However, you don't think of that let as setting i again.

179
00:20:11,110 --> 00:20:12,350
It doesn't change it.

180
00:20:12,350 --> 00:20:15,390
i never changes because of the let.

181
00:20:15,390 --> 00:20:18,690
i gets created because of let.

182
00:20:18,690 --> 00:20:22,300
In fact, the let is a very simple idea.

183
00:20:22,300 --> 00:21:16,820
Let does nothing more, Let a variable one to have value one; I'll write this down a little bit more neatly; Let's write, var one have value, the value of expression e1, and variable two, have this value of the expression e2, in an expression e3, is the same thing as a procedure of var one and var two, the formal parameters, and e3 being the body, where var one is bound to the value of e1, and var two gets the value of e2.

184
00:21:19,590 --> 00:21:24,930
So this is, in fact, a perfectly understandable thing from a substitution point of view.

185
00:21:24,930 --> 00:21:28,550
This is really the same expression written in two different ways.

186
00:21:31,820 --> 00:21:37,311
In fact, the way the actual system works is this gets translated into this before anything happens.

187
00:21:37,311 --> 00:21:41,360
AUDIENCE: OK, I'm still unclear as then what makes the difference between a let and a define.

188
00:21:41,360 --> 00:21:49,520
They could-- PROFESSOR: A define is a syntactic sugar, whereby, essentially a bunch of variables get created by lets and then set up once.

189
00:21:57,170 --> 00:21:58,790
OK, time for the first break, I think.

190
00:21:58,790 --> 00:22:00,040
Thank you.

191
00:22:03,480 --> 00:23:04,430
[MUSIC PLAYING]

192
00:23:04,430 --> 00:23:06,530
Well let's see.

193
00:23:06,530 --> 00:23:17,600
I now have to rebuild the model of computation, so you understand how some such mechanical mechanism could work that can do what we've just talked about.

194
00:23:17,600 --> 00:23:22,730
I just recently destroyed your substitution model.

195
00:23:22,730 --> 00:23:26,380
Unfortunately, this model is significantly more complicated than the substitution model.

196
00:23:26,380 --> 00:23:29,010
It's called the environment model.

197
00:23:29,010 --> 00:23:34,660
And I'm going to have to introduce some terminology, which is very good terminology for you to know anyway.

198
00:23:34,660 --> 00:23:36,640
It's about names.

199
00:23:36,640 --> 00:23:42,720
And we're going to give names to the kinds of names things have and the way those names are used.

200
00:23:42,720 --> 00:23:48,290
So this is a meta-description, if you will.

201
00:23:48,290 --> 00:23:54,770
Anyway, there is a pile of an unfortunate terminology here, but we're going to need this to understand what's called the environment model.

202
00:23:54,770 --> 00:23:58,250
We're about to do a little bit of boring, dog-work here.

203
00:23:58,250 --> 00:24:02,280
Let's look at the first transparency.

204
00:24:02,280 --> 00:24:08,880
And we see a description of a word called bound.

205
00:24:08,880 --> 00:24:25,440
And we're going to say that a variable, v, is bound in an expression, e, if the meaning of e is unchanged by the uniform replacement of a variable w, not occurring in e, for every occurrence of v in e.

206
00:24:25,440 --> 00:24:33,490
Now that's a long sentence, so, I think, I'm going to have to say a little bit about that before we even fool around at all here.

207
00:24:33,490 --> 00:24:35,260
Bound variables we're talking about here.

208
00:24:44,030 --> 00:24:46,710
And you've seen lots of them.

209
00:24:46,710 --> 00:24:48,170
You may not know that you've seen lots of them.

210
00:24:48,170 --> 00:24:59,860
Well, I suppose in your logic you saw a logical variables like, for every x there exists a y such that p is true of x and y from your calculus class.

211
00:25:02,960 --> 00:25:16,640
This variable, x, and this variable, y, are bound, because the meaning of this expression does not depend upon the particular letters I used to describe x and y.

212
00:25:16,640 --> 00:25:29,540
If I were to change the w for x, then said for every w there exists a y such that p is true of w and y, it would be the same sentence.

213
00:25:29,540 --> 00:25:30,390
That's what it means.

214
00:25:30,390 --> 00:25:42,415
Or another case of this that you've seen is integral say, from 0 to one of dx over one plus x square.

215
00:25:46,080 --> 00:25:47,440
Well that's something you see all the time.

216
00:25:47,440 --> 00:25:52,270
And this x is a bound variable.

217
00:25:52,270 --> 00:25:58,170
If I change that to a t, the expression is still the same thing.

218
00:25:58,170 --> 00:26:04,850
This is a 1/4 of the arctan of one or something like that.

219
00:26:04,850 --> 00:26:06,620
Yes, that's the arctan of one.

220
00:26:06,620 --> 00:26:13,690
So bound variables are actually fairly common, for those of you who have played a bit with mathematics.

221
00:26:13,690 --> 00:26:19,100
Well, let's go into the programming world.

222
00:26:19,100 --> 00:26:27,570
Instead of the quantifier being something like, for every, or there exists, or integral, a quantifier is a symbol that binds a variable.

223
00:26:27,570 --> 00:26:33,970
And we are going to use the quantifier lambda as being the essential thing that binds variables.

224
00:26:33,970 --> 00:26:44,370
And so we have some nice examples here like that procedure of one argument y which does the following thing.

225
00:26:44,370 --> 00:26:54,145
It calls the procedure of one argument x, which multiplies x by y, and applies that to three.

226
00:26:58,810 --> 00:27:04,790
That procedure has the property there of two bound variables in it, x and y.

227
00:27:04,790 --> 00:27:12,120
This quantifier, lambda here, binds this y, and this quantifier, lambda, binds that x.

228
00:27:12,120 --> 00:27:26,240
Because, if I were to take an arbitrary symbol does not occur in this expression like w and replace all y's with w's in this expression, the expression is still the same, the same procedure.

229
00:27:26,240 --> 00:27:27,430
And this is an important idea.

230
00:27:27,430 --> 00:27:31,500
The reason why we had such things like that is a kind of modularity.

231
00:27:31,500 --> 00:27:42,490
If two people are writing programs, and they work together, it shouldn't matter what names they use internal to their own little machines that they're building.

232
00:27:42,490 --> 00:28:01,200
And so, what I'm really telling you there, is that, for example, this is equivalent to that procedure of one argument y which uses that procedure of one argument d which multiplies z by y.

233
00:28:01,200 --> 00:28:03,570
Because nobody cares what I used in here.

234
00:28:06,270 --> 00:28:08,880
It's a nice example.

235
00:28:08,880 --> 00:28:15,320
On the other hand, I have some variables that are not bound.

236
00:28:15,320 --> 00:28:27,390
For example, that procedure of one argument x which multiplies x by y.

237
00:28:27,390 --> 00:28:32,370
In this case, y is not bound.

238
00:28:32,370 --> 00:28:44,910
Supposing y had the value three, and z had the value four, then this procedure would be the thing that multiplies its argument by three.

239
00:28:44,910 --> 00:28:53,491
If I were to replace every instance of y with z, I would have a different procedure which multiplies every argument that's given by four.

240
00:28:53,491 --> 00:28:57,810
And, in fact, we have a name for such a variable.

241
00:28:57,810 --> 00:29:13,120
Here, we say that a variable, v, is free in the expression, e, if the meaning of the expression, e, is changed by the uniform replacement of a variable, w, not occurring in e for every occurrence of v and e.

242
00:29:13,120 --> 00:29:22,525
So that's why this variable over here, y, is a free variable.

243
00:29:29,010 --> 00:29:52,790
And so free variables in this expression-- And other examples of that is that procedure of one argument y, which is just what we had before, which uses that procedure of one argument x that multiplies x by y--  use that on three.

244
00:29:56,940 --> 00:30:01,795
This procedure has a free variable in it which is asterisk.

245
00:30:05,010 --> 00:30:17,020
See, because, if that has a normal meaning of multiplication, then if I were to replace uniformly all asterisks with pluses, then the meaning of this expression would change.

246
00:30:19,360 --> 00:30:22,850
That's what you mean by a free variable.

247
00:30:22,850 --> 00:30:29,020
So, so far you've learned some logician words which describe the way names are used.

248
00:30:29,020 --> 00:30:35,200
Now, we have to do a little bit more playing around here, a little bit more.

249
00:30:35,200 --> 00:30:39,850
I want to tell you about the regions are over which variables are defined.

250
00:30:42,270 --> 00:30:55,170
You see, we've been very informal about this up till now, and, of course, many of you have probably understood very clearly or most of you, that the x that's being declared here is defined only in here.

251
00:30:58,250 --> 00:31:04,830
This x is the defined only in here, and this y is defined only in here.

252
00:31:07,080 --> 00:31:08,400
We have a name for such an idea.

253
00:31:08,400 --> 00:31:11,660
It's called a scope.

254
00:31:11,660 --> 00:31:14,710
And let me give you another piece of terminology.

255
00:31:14,710 --> 00:31:16,050
It's a long story.

256
00:31:16,050 --> 00:31:20,560
If x is a bound variable in e, then there is a lambda expression where it is bound.

257
00:31:20,560 --> 00:31:24,970
So the only way you can get a bound variable ultimately is by lambda expression.

258
00:31:24,970 --> 00:31:29,670
Then you may worry, does define quite an exception to this?

259
00:31:29,670 --> 00:31:33,100
And it turns out, we could always arrange things so you don't need any defines.

260
00:31:33,100 --> 00:31:34,070
And we'll see that in a while.

261
00:31:34,070 --> 00:31:36,900
It's a very magical thing.

262
00:31:36,900 --> 00:31:39,000
So define really can go away.

263
00:31:39,000 --> 00:31:42,650
The really, only thing that makes names is lambda .

264
00:31:42,650 --> 00:31:44,350
That's its job.

265
00:31:44,350 --> 00:31:48,740
And what's so amazing about a lot of things is you can compute with only lambda.

266
00:31:48,740 --> 00:31:55,880
But, in any case, a lambda expression has a place where it declares a variable.

267
00:31:55,880 --> 00:32:08,730
We call it the formal parameter list or the bound variable list. We say that the lambda expression binds-- so it's a verb-- binds the variables declared in it's found variable list.

268
00:32:08,730 --> 00:32:20,400
In addition, those parts of the expression where the variable is defined, which was declared by some declaration, is called the scope of that variable.

269
00:32:20,400 --> 00:32:22,270
So these are scopes.

270
00:32:22,270 --> 00:32:23,630
This is the scope of y.

271
00:32:27,140 --> 00:32:34,280
And this is the scope of x--  that sort of thing.

272
00:32:41,460 --> 00:33:03,950
OK, well, now we have enough terminology to begin to understand how to make a new model for computation, because the key thing going on here is that we destroyed the substitution model, and we now have to have a model that represents the names as referring to places.

273
00:33:03,950 --> 00:33:09,660
Because if we are going to change something, then we have a place where it's stored.

274
00:33:09,660 --> 00:33:19,280
You see, if a name only refers to a value, and if I tried to change the name's meaning, well, that's not clear.

275
00:33:19,280 --> 00:33:25,030
There's nothing that is the place that that name referred to.

276
00:33:25,030 --> 00:33:25,960
How am I really saying it?

277
00:33:25,960 --> 00:33:29,840
There is nothing shared among all of the instances of that name.

278
00:33:29,840 --> 00:33:34,440
And what we really mean, by a name, is that we fan something out.

279
00:33:34,440 --> 00:33:41,130
We've given something a name, and you have it, and you have it, because I'm given you a reference to it, and I've given you a reference to it.

280
00:33:41,130 --> 00:33:43,580
And we'll see a lot about that.

281
00:33:43,580 --> 00:33:45,986
So let me tell you about environments.

282
00:33:45,986 --> 00:33:52,140
I need the overhead projection machine, thank you.

283
00:33:52,140 --> 00:34:01,590
And so here is a bunch of environment structures.

284
00:34:01,590 --> 00:34:06,490
An environment is a way of doing substitutions virtually.

285
00:34:06,490 --> 00:34:11,409
It represents a place where something is stored which is the substitutions that you haven't done.

286
00:34:14,540 --> 00:34:28,090
It's a place where everything accumulates, where the names of the variables are associated with the values they have such that when you say, what dose this name mean, you look it up in an environment.

287
00:34:28,090 --> 00:34:33,290
So an environment is a function, or a table, or something like that.

288
00:34:33,290 --> 00:34:35,790
But it's a structured sort of table.

289
00:34:35,790 --> 00:34:37,125
It's made out of things called frames.

290
00:34:41,050 --> 00:34:53,940
Frames are pieces of environment, and they are chained together, in some nice ways, by what's called parent links or something like that.

291
00:34:53,940 --> 00:35:05,250
So here, we have an environment structure consisting of three environments, basically, a, b, and c.

292
00:35:05,250 --> 00:35:11,480
d is also an environment, but it's the same one, they share.

293
00:35:11,480 --> 00:35:14,550
And that's the essence of assignment.

294
00:35:14,550 --> 00:35:23,750
If I change a variable, a value of a valuable that lives here, like that one, it should be visible from all places that you're looking at it from.

295
00:35:23,750 --> 00:35:24,990
Take this one, x.

296
00:35:24,990 --> 00:35:30,340
If I change the x to four, it's visible from other places.

297
00:35:30,340 --> 00:35:32,270
But I'm not going to worry about that right now.

298
00:35:32,270 --> 00:35:34,590
We're going to talk a lot about that in a little while.

299
00:35:34,590 --> 00:35:36,830
What do we have here?

300
00:35:36,830 --> 00:35:37,990
Well, these are called frames.

301
00:35:37,990 --> 00:35:43,270
Here is a frame, here's a frame, and here's a frame.

302
00:35:43,270 --> 00:35:52,570
a is an environment which consists of the table which is frame two, followed by the table labeled frame one.

303
00:35:52,570 --> 00:36:04,150
And, in this environment, in say this environment, frame two, x and y are bound.

304
00:36:04,150 --> 00:36:05,920
They have values.

305
00:36:05,920 --> 00:36:20,940
Sorry, in frame one-- In frame two, z is bound, and x is bound, and y is bound, but the value of x that we see, looking from this point of view, is this x.

306
00:36:20,940 --> 00:36:24,940
It's x is seven, rather than this one which is three.

307
00:36:24,940 --> 00:36:27,660
We say that this x shadows this x.

308
00:36:31,070 --> 00:36:42,155
From environment three-- from frame three, from environment b, which refers to frame three, we have variables n and y bound and also x.

309
00:36:44,740 --> 00:36:48,630
This y shadow this one.

310
00:36:48,630 --> 00:36:53,410
So the value, looking from this point of view, of y is two.

311
00:36:53,410 --> 00:36:56,500
The value for looking from this point of view and m is one.

312
00:36:56,500 --> 00:36:58,870
And the value, looking from this point of view, of x is three.

313
00:37:02,310 --> 00:37:06,340
So there we have a very simple environment structure made out of frames.

314
00:37:06,340 --> 00:37:10,990
These correspond to the applications of procedures.

315
00:37:10,990 --> 00:37:14,390
And we'll see that in a second.

316
00:37:14,390 --> 00:37:18,110
So now I have to make you some other nice little structure that we build.

317
00:37:20,870 --> 00:37:27,850
Next slide, we see an object, which I'm going to draw procedures.

318
00:37:27,850 --> 00:37:30,190
This is a procedure.

319
00:37:30,190 --> 00:37:33,150
A procedure is made out of two parts.

320
00:37:33,150 --> 00:37:34,515
It's sort of like a cons.

321
00:37:37,210 --> 00:37:38,460
However, it's the two parts.

322
00:37:40,820 --> 00:37:48,940
The first part refers to some code, something that can be executed, a set of instructions, if you will.

323
00:37:48,940 --> 00:37:50,750
You can think of it that way.

324
00:37:50,750 --> 00:37:53,830
And the second part is the environment.

325
00:37:53,830 --> 00:37:57,250
The procedure is the whole thing.

326
00:37:57,250 --> 00:38:06,250
And we're going to have to use this to capture the values of the free variables that occur in the procedure.

327
00:38:06,250 --> 00:38:11,170
If a variable occurs in the procedure it's either bound in that procedure or free.

328
00:38:11,170 --> 00:38:16,930
If it's bound, then the value will somehow be easy to find.

329
00:38:16,930 --> 00:38:19,070
It will be in some easy environment to get at.

330
00:38:19,070 --> 00:38:27,100
If it's free, we're going to have to have something that goes with the procedure that says where we'll go look for its value.

331
00:38:27,100 --> 00:38:32,290
And the reasons why are not obvious yet, but will be soon.

332
00:38:32,290 --> 00:38:33,760
So here's a procedure object.

333
00:38:33,760 --> 00:38:42,750
It's a composite object consisting of a piece of code and a environment structure.

334
00:38:42,750 --> 00:38:47,650
Now I will tell you the new rules, the complete new rules, for evaluation.

335
00:38:50,690 --> 00:38:53,250
The first rule is-- there's only two of them.

336
00:38:53,250 --> 00:38:57,250
These correspond to the substitution model rules.

337
00:38:57,250 --> 00:39:02,570
And the first one has to do with how do you apply a procedure to its arguments?

338
00:39:05,610 --> 00:39:11,270
And a procedural object is applied to a set of arguments by constructing a new frame.

339
00:39:11,270 --> 00:39:21,490
That frame will contain the mapping of the former parameters to the actual parameters of the arguments that were supplied in the call.

340
00:39:21,490 --> 00:39:34,290
As you know, when we make up a call to a procedure like lambda x times x y, and we call that with the argument three, then we're going to need some mapping of x to three.

341
00:39:34,290 --> 00:39:41,990
It's the same thing as later substituting, if you will, the three for the x in the old model.

342
00:39:41,990 --> 00:39:46,550
So I'm going to build a frame which contains x equals three as the information in that frame.

343
00:39:49,230 --> 00:39:54,170
Now, the body of the procedure will then have to be evaluated which is this.

344
00:39:54,170 --> 00:40:13,100
I will be evaluated in an environment which is constructed by adjoining the new frame that we just made to the environment which was part of the procedure that we applied.

345
00:40:13,100 --> 00:40:15,670
So I'm going to make a little example of that here.

346
00:40:19,220 --> 00:40:25,110
Supposing I have some environment.

347
00:40:25,110 --> 00:40:27,980
Here's a frame which represents it.

348
00:40:27,980 --> 00:40:42,710
And some procedure-- which I'm going to draw with circles here because it's easier than little triangles-- Sorry, those are rhombuses, rhomboidal little pieces of fruit jelly or something.

349
00:40:42,710 --> 00:40:45,960
So here's a procedure which takes this environment.

350
00:40:45,960 --> 00:40:58,010
And the procedure has a piece of code, which is a lambda expression, which binds x and y and then executes an expression, e.

351
00:40:58,010 --> 00:40:59,345
And this is the procedure.

352
00:40:59,345 --> 00:41:01,470
We'll call it p.

353
00:41:01,470 --> 00:41:06,490
I wish to apply that procedure to three and four.

354
00:41:06,490 --> 00:41:09,790
So I want to do p of three and four.

355
00:41:09,790 --> 00:41:13,210
What I'm going to do, of course, is make a new frame.

356
00:41:13,210 --> 00:41:21,740
I build a frame which contains x equals three, and y equals four.

357
00:41:21,740 --> 00:41:27,680
I'm going to connect that frame to this frame over here.

358
00:41:27,680 --> 00:41:34,880
And then this environment, with I will call b, is the environment in which I will evaluate the body of e.

359
00:41:39,940 --> 00:41:46,890
Now, e may contain references to x and y and other things.

360
00:41:46,890 --> 00:41:50,790
x and y will have values right here.

361
00:41:50,790 --> 00:41:55,040
Other things will have their values here.

362
00:41:55,040 --> 00:41:56,920
How do we get this frame?

363
00:41:56,920 --> 00:42:01,980
That we do by the construction of procedures which is the other rule.

364
00:42:01,980 --> 00:42:05,500
And I think that's the next slide.

365
00:42:05,500 --> 00:42:18,300
Rule two, when a lambda expression is evaluated, relative to a particular environment--  See, the way I get a procedure is by evaluating the lambda expression.

366
00:42:18,300 --> 00:42:20,110
Here's a lambda expression.

367
00:42:20,110 --> 00:42:25,170
By evaluating it, I get a procedure which I can apply to three.

368
00:42:25,170 --> 00:42:31,820
Now this lambda expression is evaluated in an environment where y is defined.

369
00:42:31,820 --> 00:42:36,680
And I want the body of this which contains a free version of y.

370
00:42:36,680 --> 00:42:43,350
y is free in here, it's bound over the whole thing, but it's free over here.

371
00:42:43,350 --> 00:42:47,440
I want that y to be this one.

372
00:42:47,440 --> 00:42:55,470
I evaluate this body of this procedure in the environment where y was created.

373
00:42:55,470 --> 00:42:59,140
That's this kind of thing, because that was done by application.

374
00:42:59,140 --> 00:43:04,370
Now, if I ever want to look up the value of y, I have to know where it is.

375
00:43:04,370 --> 00:43:18,110
Therefore, this procedural was created, the creation of the procedure which is the result of evaluating that lambda expression had better capture a pointer or remember the frame in which y was bound.

376
00:43:18,110 --> 00:43:22,100
So that's what this rule is telling us.

377
00:43:22,100 --> 00:43:43,020
So, for example, if I happen to be evaluating a lambda expression, lambda expression in e, lambda of say, x and y, let's call it g in e, evaluating that.

378
00:43:43,020 --> 00:43:47,190
Well, all that means is I now construct a procedure object.

379
00:43:47,190 --> 00:43:48,990
e is some environment.

380
00:43:48,990 --> 00:43:51,920
e is something which has a pointer to it.

381
00:43:51,920 --> 00:44:03,180
I construct a procedure object that points up to that environment, where the code of that is a lambda expression or whatever that translates into.

382
00:44:06,330 --> 00:44:07,580
And this is the procedure.

383
00:44:12,380 --> 00:44:32,950
So this produces for me-- this object here, this environment pointer, captures the place where this lambda expression was evaluated, where the definition was used, where the definition was used to make a procedure, to make the procedure.

384
00:44:32,950 --> 00:44:44,990
So it picks up the environment from the place where that procedure was defined, stores it in the procedure itself, and then when the procedure is used, the environment where it was defined is extended with the new frame.

385
00:44:48,740 --> 00:44:53,090
So this gives us a locus for putting where a variable has a value.

386
00:44:53,090 --> 00:45:01,430
And, for example, if there are lots of guys pointing in at that environment, then they share that place.

387
00:45:01,430 --> 00:45:03,810
And we'll see more of that shortly.

388
00:45:03,810 --> 00:45:14,970
Well, now you have a new model for understanding the execution of programs. I suppose I'll take questions now, and then we'll go on and use that for something.

389
00:45:17,802 --> 00:45:24,580
AUDIENCE: Is it right to say then, the environment is that linked chain of frames-- PROFESSOR: That's right.

390
00:45:24,580 --> 00:45:27,076
AUDIENCE: starting with-- working all the way back?

391
00:45:27,076 --> 00:45:32,470
PROFESSOR: Yes, the environment is a sequence of frames linked together.

392
00:45:32,470 --> 00:45:39,400
And the way I like to think about it, it's the pointer to the first one, because once you've got that you've got them all.

393
00:45:44,080 --> 00:45:44,995
Anybody else?

394
00:45:44,995 --> 00:45:53,600
AUDIENCE: Is it possible to evaluate a procedure or to define a procedure in two different environments such that it will behave differently, and have pointers to both-- PROFESSOR: Oh, yes.

395
00:45:53,600 --> 00:45:57,290
The same procedure is not going to have two different environments.

396
00:45:57,290 --> 00:46:03,430
The same code, the same lambda expression can be evaluated in two environments producing two different procedures.

397
00:46:06,220 --> 00:46:08,690
Each procedure-- AUDIENCE: Their definition has the same name.

398
00:46:08,690 --> 00:46:12,570
Their operation-- PROFESSOR: The definition is written the same, with the same characters.

399
00:46:12,570 --> 00:46:21,340
I can evaluate that set of characters, whatever, that list structure that defines, that is the textual representation.

400
00:46:21,340 --> 00:46:25,650
I can evaluate that in two different environments producing two different procedures.

401
00:46:25,650 --> 00:46:33,490
Each of those procedures has its own local sets of variables, and we'll see that right now.

402
00:46:36,770 --> 00:46:38,020
Anybody else?

403
00:46:42,670 --> 00:46:43,280
OK, thank you.

404
00:46:43,280 --> 00:46:44,530
Let's take a break.

405
00:46:48,750 --> 00:47:22,870
[MUSIC PLAYING]

406
00:47:22,870 --> 00:47:26,670
Well, now I've done this terrible thing to you.

407
00:47:26,670 --> 00:47:43,270
I've introduced a very complicated thing, assignment, which destroys most of the interesting mathematical properties of our programs. Why should I have done this?

408
00:47:43,270 --> 00:47:46,590
What possible good could this do?

409
00:47:46,590 --> 00:47:52,490
Clearly not a nice thing, so I better have a good excuse.

410
00:47:52,490 --> 00:47:58,870
Well, let's do a little bit of playing, first of all, with some very interesting programs that have assignment.

411
00:47:58,870 --> 00:48:04,820
Understand something special about them that makes them somewhat valuable.

412
00:48:04,820 --> 00:48:10,670
Start with a very simple program which I'm going to call make-counter.

413
00:48:10,670 --> 00:48:50,120
I'm going to define make-counter to be a procedure of one argument n which returns as its value a procedure of no arguments-- a procedure that produces a procedure-- which sets n to the increment of n and returns that value of n.

414
00:48:55,520 --> 00:48:57,560
Now we're going to investigate the behavior of this.

415
00:48:57,560 --> 00:48:59,840
It's a sort of interesting thing.

416
00:48:59,840 --> 00:49:06,380
In order to investigate the behavior, I have to make an environment model, because we can't understand this any other way.

417
00:49:08,630 --> 00:49:10,040
So let's just do that.

418
00:49:10,040 --> 00:49:16,240
We start out with some sort of-- let's say there is a global environment that the machine is born with.

419
00:49:16,240 --> 00:49:19,720
Global we'll call it.

420
00:49:19,720 --> 00:49:24,530
And it's going to have in it a bunch of initial things.

421
00:49:24,530 --> 00:49:25,820
We all know what it's got.

422
00:49:25,820 --> 00:49:42,960
It's got things in it like say, plus, and times, and quotient, and difference, and CAR, and et cetera, lots of things.

423
00:49:42,960 --> 00:49:51,290
I don't know what they are, some various squiggles that are the things the machine is born with.

424
00:49:51,290 --> 00:49:57,390
And by doing the definition here, what I plan to do-- Well, what am I doing?

425
00:49:57,390 --> 00:49:59,780
I'm doing this relative to the global environment.

426
00:49:59,780 --> 00:50:03,580
So here's my environment pointer.

427
00:50:03,580 --> 00:50:08,270
In order to do that I have to evaluate this lambda expression.

428
00:50:08,270 --> 00:50:11,490
That means I make a procedure object.

429
00:50:11,490 --> 00:50:13,190
So I'm going to make a procedure object here.

430
00:50:17,400 --> 00:50:23,820
And the procedure object has, as the place it's defined, the global environment.

431
00:50:23,820 --> 00:50:35,340
The procedure object contains some code that represents a procedure of one argument n which returns a procedure of no arguments which does something.

432
00:50:38,320 --> 00:50:55,470
And the define is a way of changing this environment, so that I now add to it a make-counter, a special rule for the special thing defined.

433
00:50:55,470 --> 00:51:03,840
But what that is, is it gives me that pointer to that procedure.

434
00:51:03,840 --> 00:51:06,370
So now the global environment contains make-counter as well.

435
00:51:09,330 --> 00:51:11,800
Now, we're going to do some operations.

436
00:51:11,800 --> 00:51:14,596
I'm going to use this to make some counters.

437
00:51:14,596 --> 00:51:17,140
We'll see what a counter is.

438
00:51:17,140 --> 00:51:26,700
So let's define c1 to be a counter beginning at 0.

439
00:51:35,440 --> 00:51:39,660
Well, we know how to do this now, according to the model.

440
00:51:39,660 --> 00:51:47,900
I have to evaluate the expression make-counter in the global environment, make-counter of 0.

441
00:51:47,900 --> 00:51:50,785
Well, I look up make-counter and see that it's a procedure.

442
00:51:53,630 --> 00:51:56,010
I'm going to have to apply that procedure.

443
00:51:56,010 --> 00:51:59,820
The way I apply the procedure is by constructing a frame.

444
00:52:02,400 --> 00:52:18,810
So I construct a frame which has a value for n in it which is 0, and the parent environment is the one which is the environment of definition of make-counter.

445
00:52:23,890 --> 00:52:28,400
So I've made an environment by applying make-counter to 0.

446
00:52:31,580 --> 00:52:37,455
Now, I have to evaluate the body of make-counter, which is this lambda expression, in that environment.

447
00:52:40,730 --> 00:52:46,360
Well evaluating this body, this body is a lambda expression.

448
00:52:46,360 --> 00:52:49,570
Evaluate a lambda expression means make a procedure object.

449
00:52:49,570 --> 00:52:50,820
So I'm going to make a procedure object.

450
00:52:56,840 --> 00:53:07,656
And that procedure object has the environment it was defined in being that, where n was defined to be 0.

451
00:53:07,656 --> 00:53:17,622
And it has some code, which is the procedure of no arguments which does something, that sets something, and returns n.

452
00:53:17,622 --> 00:53:26,020
And this thing is going to be the object, which in the global environment, will have the name c1.

453
00:53:26,020 --> 00:53:32,625
So we construct a name here, c1, and say that equals that.

454
00:53:35,560 --> 00:53:53,868
Now, but also make another counter, c2 to be make-counter say, starting with 10.

455
00:53:53,868 --> 00:53:57,270
Then I do essentially the same thing.

456
00:53:57,270 --> 00:54:05,690
I apply the make-counter procedure, which I got from here, to make another frame with n being 10.

457
00:54:05,690 --> 00:54:10,050
That frame has the global environment as its parent.

458
00:54:10,050 --> 00:54:18,000
I then construct a procedure which has that as it's frame of definition.

459
00:54:20,440 --> 00:54:25,390
The code of it is the procedure of no arguments which does something.

460
00:54:25,390 --> 00:54:28,700
And it does a set, and so on.

461
00:54:28,700 --> 00:54:31,510
And n comes out.

462
00:54:31,510 --> 00:54:36,950
And c2 is this.

463
00:54:36,950 --> 00:54:40,200
Well, you're already beginning to see something fairly interesting.

464
00:54:40,200 --> 00:54:42,880
There are two n's here.

465
00:54:42,880 --> 00:54:46,330
They are not one n.

466
00:54:46,330 --> 00:54:52,520
Each time I called make-counter, I made another instance of n.

467
00:54:52,520 --> 00:54:54,370
These are distinct and separate from each other.

468
00:54:57,880 --> 00:55:00,783
Now, let's do some execution, use those counters.

469
00:55:00,783 --> 00:55:02,735
I'm going to use those counters.

470
00:55:05,990 --> 00:55:15,900
Well, what happens if I say, c1 at this point?

471
00:55:15,900 --> 00:55:20,840
Well, I go over here, and I say, oh yes, c1 is a procedure.

472
00:55:20,840 --> 00:55:25,060
I'm going to call this procedure on no arguments, but it has no parameters.

473
00:55:25,060 --> 00:55:27,020
That's right.

474
00:55:27,020 --> 00:55:28,080
What's its body?

475
00:55:28,080 --> 00:55:30,130
Well, I have to look over here, because I didn't write it down.

476
00:55:30,130 --> 00:55:39,050
It said, set n to one plus n and return n, increment n.

477
00:55:39,050 --> 00:55:42,970
Well, the n it sees is this one.

478
00:55:42,970 --> 00:55:45,490
So I increment that n.

479
00:55:45,490 --> 00:55:50,040
That becomes one, and I return the value one.

480
00:55:53,050 --> 00:55:58,220
Supposing I then called c2.

481
00:55:58,220 --> 00:55:59,820
Well, what do I do?

482
00:55:59,820 --> 00:56:05,450
I say c2 is this procedure which does the same thing, but here's the n.

483
00:56:05,450 --> 00:56:11,140
It becomes 11.

484
00:56:11,140 --> 00:56:15,980
And so I have an 11 which is the value.

485
00:56:15,980 --> 00:56:18,130
I then can say, let's try c1 again.

486
00:56:21,580 --> 00:56:29,660
c1 is this, that's two, so the answer is two.

487
00:56:29,660 --> 00:56:39,980
And c2 gives me a 12 by the same method, by walking down here looking at that and saying, here's the n, I'm incrementing.

488
00:56:41,630 --> 00:56:44,920
So what I have are computational objects.

489
00:56:44,920 --> 00:56:51,060
There are two counters, each with its own independent local state.

490
00:56:55,540 --> 00:56:56,650
Let's talk about this a little.

491
00:56:56,650 --> 00:56:58,510
This is a strange thing.

492
00:57:01,270 --> 00:57:04,140
What's an object?

493
00:57:04,140 --> 00:57:07,560
It's not at all obvious what an object is.

494
00:57:07,560 --> 00:57:14,800
We like to think about objects, because it's economical to think that way.

495
00:57:14,800 --> 00:57:18,670
It's an intellectual economy.

496
00:57:18,670 --> 00:57:21,120
I am an object.

497
00:57:21,120 --> 00:57:23,610
You are an object.

498
00:57:23,610 --> 00:57:25,030
We are not the same object.

499
00:57:27,600 --> 00:57:45,750
I can divide the world into two parts, me and you, and there's other things as well, such that most of the things I might want to discuss about my workings do not involve you, and most of the things I want to discuss about your workings don't involve me.

500
00:57:45,750 --> 00:58:12,770
I have a blood pressure, a temperature, a respiration rate, a certain amount of sugar in my blood, and numerous, thousands, of state variables-- millions actually, or I don't know how many-- huge numbers of state variables in the physical sense which represent the state of me as a particle, and you have gazillions of them as well.

501
00:58:12,770 --> 00:58:17,290
And most of mine are uncoupled to most of yours.

502
00:58:17,290 --> 00:58:23,940
So we can compute the properties of me without worrying too much about the properties of you.

503
00:58:23,940 --> 00:58:32,760
If we had to work about both of us together, than the number of states that we have to consider is the product of the number of states you have and the number of states I have. But this way it's almost a sum.

504
00:58:32,760 --> 00:58:36,110
Now, indeed there are forces that couple us.

505
00:58:36,110 --> 00:58:38,420
I'm talking to you and your state changes.

506
00:58:38,420 --> 00:58:41,680
I'm looking at you and my state changes.

507
00:58:41,680 --> 00:58:46,190
Some of my state variables, a very few of them, therefore, are coupled to yours.

508
00:58:46,190 --> 00:58:49,720
If you were to suddenly yell very loud, my blood pressure would go up.

509
00:58:54,320 --> 00:59:02,260
However, and it may not be always appropriate to think about the world as being made out of independent states and independent particles.

510
00:59:02,260 --> 00:59:22,300
Lots of the bugs that occur in things like quantum mechanics, or the bugs in our minds that occur when we think about things like quantum mechanics, are due the fact that we are trying to think about things being broken up into independent pieces, when in fact there's more coupling than we see on the surface, or that we want to believe in, because we want to compute efficiently and effectively.

511
00:59:22,300 --> 00:59:23,780
We've been trained to think that way.

512
00:59:29,336 --> 00:59:31,440
Well, let's see.

513
00:59:31,440 --> 00:59:35,140
How would we know if we had objects at all?

514
00:59:35,140 --> 00:59:37,690
How can we tell if we have objects?

515
00:59:37,690 --> 00:59:41,770
Consider some possible optical illusions.

516
00:59:41,770 --> 00:59:44,805
This could be done.

517
00:59:44,805 --> 00:59:52,130
These pieces of chalk are not appropriately identical, but supposing you couldn't tell the difference of them by looking at them.

518
00:59:52,130 --> 00:59:55,725
Well, there's a possibility that this all a game I'm playing with mirrors.

519
00:59:55,725 --> 01:00:01,660
It's really the same piece of chalk, but you're seeing two of them.

520
01:00:01,660 --> 01:00:05,160
How would you know if you're seeing one or two?

521
01:00:05,160 --> 01:00:07,430
Well, there's only one way I know.

522
01:00:07,430 --> 01:00:11,360
You grab one of them and change it and see if the other one changed.

523
01:00:13,580 --> 01:00:16,180
And it didn't, so there's two of them.

524
01:00:19,070 --> 01:00:22,580
And, on the other hand, there is some other screwy properties of things like that.

525
01:00:22,580 --> 01:00:25,040
Like, how do we know if something changed?

526
01:00:25,040 --> 01:00:28,760
We have to look at it before and after the change.

527
01:00:28,760 --> 01:00:32,200
The change is an assignment, it's a moment in time.

528
01:00:32,200 --> 01:00:36,540
But that means we have to know it was the same one that we're looking at.

529
01:00:36,540 --> 01:00:47,380
So some very strange, and unusual, and obscure, and-- I don't understand the problems associated with assignment, and change, and objects.

530
01:00:47,380 --> 01:00:51,420
These could get very, very bad.

531
01:00:51,420 --> 01:00:57,650
For example, here I am, I am a particular person, a particular object.

532
01:00:57,650 --> 01:01:02,430
Now, I can take out my knife, and cut my fingernail.

533
01:01:02,430 --> 01:01:06,030
A piece of my fingernail has fallen off onto the table.

534
01:01:06,030 --> 01:01:14,490
I believe I am the same person I was a second ago, but I'm not physically the same in the slightest.

535
01:01:14,490 --> 01:01:15,620
I have changed.

536
01:01:15,620 --> 01:01:18,180
Why am I the same?

537
01:01:18,180 --> 01:01:21,070
What is the identity of me?

538
01:01:21,070 --> 01:01:22,320
I don't know.

539
01:01:25,170 --> 01:01:29,770
Except for the fact that I have some sort of identity.

540
01:01:29,770 --> 01:01:43,510
And so, I think by introducing assignment and objects, we have opened ourselves up to all the horrible questions of philosophy that have been plaguing philosophers for some thousands of years about this sort of thing.

541
01:01:43,510 --> 01:01:45,880
It's why mathematics is a lot cleaner.

542
01:01:45,880 --> 01:01:50,840
Let's look at the best things I know to say about actions and identity.

543
01:01:52,500 --> 01:02:05,100
We say that an action, a, had an effect on an object, x, or equivalently, that x was changed by a, if some property, p, which was true of x before a, became false of x after a.

544
01:02:05,100 --> 01:02:10,950
Let's test. It still means I have to have the x before and after.

545
01:02:10,950 --> 01:02:19,580
Or, the other way of saying this is, we say that two objects x and y are the same for any action which has an effect on x has the same effect on y.

546
01:02:19,580 --> 01:02:24,650
However, objects are very useful, as I said, for intellectual economy.

547
01:02:24,650 --> 01:02:35,050
One of the things that's incredibly useful about them, is that the world is, we like to think about, made out of independent objects with independent local state.

548
01:02:35,050 --> 01:02:39,730
We like to think that way, although it isn't completely true.

549
01:02:39,730 --> 01:02:58,720
When we want to make very complicated programs that deal with such a world, if we want those programs to be understandable by us and also to be changeable, so that if we change the world we change the program only a little bit, then we want there to be connections, isomorphism, between the objects in the world and the objects in our mental model.

550
01:02:58,720 --> 01:03:02,400
The modularity of the world can give us the modularity in our programming.

551
01:03:02,400 --> 01:03:09,950
So we invent things called object-oriented programming and things like that to provide us with that power.

552
01:03:09,950 --> 01:03:10,990
But it's even easier.

553
01:03:10,990 --> 01:03:12,310
Let's play a little game.

554
01:03:12,310 --> 01:03:22,960
I want to play a little game, show you an even easier example of where modularity can be enhanced by using an assignment statement, judiciously.

555
01:03:22,960 --> 01:03:32,180
One thing I want to enforce and impress on you, is don't use assignment statements the way you use it in FORTRAN or Basic or something or Pascal, to do the things you don't have to do with it.

556
01:03:34,200 --> 01:03:37,010
It's not the right way to think for most things.

557
01:03:37,010 --> 01:03:39,810
Sometimes it's essential, or maybe it's essential.

558
01:03:39,810 --> 01:03:42,320
We'll see more about that too.

559
01:03:42,320 --> 01:03:44,330
OK, let me show you a fun game here.

560
01:03:47,270 --> 01:03:58,450
There was mathematician by the name of Cesaro-- or Cesaro, Cesaro I suppose it is-- who figured out a clever way of computing pi.

561
01:03:58,450 --> 01:04:13,920
It turns out that if I take to random numbers, two integers at random, and compute the greatest common divisor, their greatest common divisor is either one or it's not one.

562
01:04:13,920 --> 01:04:15,445
If it's one, then they have no common divisors.

563
01:04:18,240 --> 01:04:29,580
If their greatest common divisor is one-- the probability that two random numbers, two numbers chosen at random, has as greatest common divisor one is related to pi.

564
01:04:29,580 --> 01:04:40,110
In fact-- yes, it's very strange-- of course there are other ways of computing pi, like dropping pins on flags, and things like that, and sort of the same kind of thing.

565
01:04:40,110 --> 01:04:55,660
So the probability of that the GCD of number one and number two, two random numbers chosen, is 6 over pi squared.

566
01:04:55,660 --> 01:04:57,240
I'm not going to try to prove that.

567
01:04:57,240 --> 01:05:01,120
It's actually not too hard and sort of fun.

568
01:05:01,120 --> 01:05:03,590
How would we estimate such probability?

569
01:05:03,590 --> 01:05:13,570
Well, the way we do that, the way we estimate probabilities, is by doing lots of experiments, and then computing the ratios of the ones that come out one way to the total number of experiments we do.

570
01:05:16,320 --> 01:05:26,360
It's called Monte Carlo, and it's useful in other contexts for doing things like integrals where you have lots and lots of variables-- the space which is limiting the dimensions you are doing you integral in.

571
01:05:26,360 --> 01:06:03,990
But going back to here, Let's look at this slide, We can use Cesaro's method for estimating pi with n trials by taking the square root of six over a Monte Carlo, a Monte Carlo experiment with n trials, using Cesaro's experiment, where Cesaro's experiment is the test of whether the GCD of two random numbers-- And you can see that I've already got some assignments in here, just by what I wrote.

572
01:06:03,990 --> 01:06:20,400
The fact that this word rand, in parentheses, therefore, that procedure call, yields a different value than this one, at least that's what I'm assuming by writing this this way, indicates that this is not a function, that there's internal state in it which is changing.

573
01:06:25,110 --> 01:06:31,530
If the GCD of those two random numbers is equal to one, that's the experiment.

574
01:06:31,530 --> 01:06:36,560
So here I have an experimental method for estimating the value of pi.

575
01:06:36,560 --> 01:06:40,160
Where, I can easily divide this problem into two parts.

576
01:06:40,160 --> 01:06:49,320
One is the specific Monte Carlo experiment of Cesaro, which you just saw, and the other is the general technique of doing Monte Carlo experiments.

577
01:06:49,320 --> 01:06:51,190
And that's what this is.

578
01:06:51,190 --> 01:07:10,230
If I want to do Monte Carlo experiments with n trials, a certain number of trials, and a particular experiment, the way I do that is I make a little iterative procedure which has variable the number of trials remaining and the number trials that have been passed, that I've gotten true.

579
01:07:10,230 --> 01:07:19,150
And if the number remaining is 0, then the answer is the number past divided by this whole number of trials, was the estimate of the probability.

580
01:07:19,150 --> 01:07:22,870
And if it's not, if I have more trials to do, then let's do one.

581
01:07:22,870 --> 01:07:23,860
We do an experiment.

582
01:07:23,860 --> 01:07:27,350
We call the procedure which is experiment on no arguments.

583
01:07:27,350 --> 01:07:38,650
We do the experiment and then, if that turned out to be true, we go around the loop decrementing the number of experiments we have to do by one and incrementing the number that were passed.

584
01:07:38,650 --> 01:07:48,910
And if the experiment was false, we just go around the loop decrementing the number of experiments remaining and keeping the number passed the same.

585
01:07:48,910 --> 01:07:57,730
We start this up iterating over the total number of trials with 0 experiments past. A very elegant little program.

586
01:07:57,730 --> 01:08:03,390
And I don't have to just do this with Cesaro's experiment, it could be lots of Monte Carlo experiments I might do.

587
01:08:03,390 --> 01:08:07,440
Of course, this depends upon the existence of some sort of random number generator.

588
01:08:07,440 --> 01:08:11,210
And random number generators generally look something like this.

589
01:08:13,570 --> 01:08:25,710
There is a random number generator-- is in fact a procedure which is going to do something just like the counter.

590
01:08:25,710 --> 01:08:41,689
It's going to update an x to the result of applying some function to x, where this function is some screwy kind of function that you might find out in Knuth's books on the details of programming.

591
01:08:41,689 --> 01:08:51,720
He does these wonderful books that are full of the details of programming, because I can't remember how to make a random number generator, but I can look it up there, and I can find out.

592
01:08:51,720 --> 01:08:58,319
And then, eventually, I return the value of x which is the state variable internal to the random number generator.

593
01:08:58,319 --> 01:09:03,479
That state variable is initialized somehow, and has a value.

594
01:09:03,479 --> 01:09:10,450
And this procedure is defined in the context where that variable is bound.

595
01:09:10,450 --> 01:09:15,930
So this is a hidden piece of local state that you see here.

596
01:09:15,930 --> 01:09:21,720
And this procedure is defined in that context.

597
01:09:21,720 --> 01:09:24,103
Now, that's a very simple thing to do.

598
01:09:24,103 --> 01:09:26,020
And it's very nice.

599
01:09:26,020 --> 01:09:29,080
Supposing, I didn't want to use assignments.

600
01:09:29,080 --> 01:09:32,840
Supposing, I wanted to write this program without assignments.

601
01:09:32,840 --> 01:09:35,580
What problems would I have?

602
01:09:35,580 --> 01:09:37,890
Well, let's see.

603
01:09:37,890 --> 01:09:44,540
I'd like to use the overhead machine here, thank you.

604
01:09:44,540 --> 01:09:45,870
First of all, let's look at the whole thing.

605
01:09:45,870 --> 01:09:48,140
It's a big story.

606
01:09:48,140 --> 01:09:51,720
Unfortunately, which tells you there is something wrong.

607
01:09:51,720 --> 01:09:54,255
It's at least that big, and it's monolithic.

608
01:09:57,020 --> 01:10:02,120
You don't have to understand or look at the text there right now to see that it's monolithic.

609
01:10:02,120 --> 01:10:05,090
It isn't a thing which is Cesaro's experiment.

610
01:10:05,090 --> 01:10:10,050
It's not pulled out from the Monte Carlo process.

611
01:10:10,050 --> 01:10:10,890
It's not separated.

612
01:10:10,890 --> 01:10:12,140
Let's look why.

613
01:10:14,350 --> 01:10:23,070
Remember, the constraint here is that every procedure return the same value for the same arguments.

614
01:10:23,070 --> 01:10:26,800
Every procedure represents a function.

615
01:10:26,800 --> 01:10:28,275
That's a different kind of constraint.

616
01:10:28,275 --> 01:10:31,840
Because when I have assignments, I can change some internal state variable.

617
01:10:31,840 --> 01:10:35,060
So let's see how that causes things to go wrong.

618
01:10:35,060 --> 01:10:38,510
Well, start at the beginning.

619
01:10:38,510 --> 01:10:42,950
The estimate of pi looks sort of the same.

620
01:10:42,950 --> 01:10:52,990
What I'm doing is I take the square root of six over the random GCD test applied to n, whereas that's what this is.

621
01:10:52,990 --> 01:10:55,390
But here, we are beginning to see something funny.

622
01:10:55,390 --> 01:11:10,870
The random GCD test of a certain number of trials is just like we had before, an iteration on the number of trials remaining, the number of trials that have been passed, and another variable x.

623
01:11:10,870 --> 01:11:12,370
What's that x?

624
01:11:12,370 --> 01:11:14,950
That x is the state of the random number generator.

625
01:11:18,950 --> 01:11:21,150
And it is now going to be used here.

626
01:11:21,150 --> 01:11:31,710
The same random update function that I have over here is the one I would have used in a random number generator if I were building it the other way, the one I get out of Knuth's books.

627
01:11:31,710 --> 01:11:34,950
x is going to get transformed into x1, I need two random numbers.

628
01:11:34,950 --> 01:11:39,550
And x1 is going to get transformed into x2, I have two random numbers.

629
01:11:39,550 --> 01:11:42,620
I then have to do exactly what I did before.

630
01:11:42,620 --> 01:11:43,870
I take the GCD of x1 x2.

631
01:11:43,870 --> 01:11:49,520
If that's one, then I go around the loop with x2 being the next value of x.

632
01:11:54,850 --> 01:12:01,495
You see what's happened here is that the state of the random number generator is no longer confined to the insides of the random number generator.

633
01:12:01,495 --> 01:12:03,450
It has leaked out.

634
01:12:03,450 --> 01:12:10,720
It has leaked out into my procedure that does the Monte Carlo experiment.

635
01:12:10,720 --> 01:12:18,090
But what's worse than that, is it's also, because it was contained inside my experiment itself, Cesaro, it leaked out of that too.

636
01:12:18,090 --> 01:12:36,490
Because Cesaro called twice, has to have a different value each time, if I going to have a legitimate experimental test. So Cesaro can't be a function either, unless I pass it the seed of the random number generator that is going to go wandering around.

637
01:12:36,490 --> 01:12:45,465
So unfortunately, the seed of random number generator has leaked out into Cesaro, from the random number generator, that's leaked into the Monte Carlo experiment.

638
01:12:45,465 --> 01:12:50,310
And, unfortunately, my Monte Carlo experiment here is no longer general.

639
01:12:50,310 --> 01:12:54,405
The Monte Carlo experiment here knows how many random numbers I need to do the experiment.

640
01:12:58,530 --> 01:13:00,230
That's sort of horrible.

641
01:13:00,230 --> 01:13:22,770
I lost an ability to decompose a problem into pieces, because I wasn't willing to accept the little loop of information, the feedback process, that happens inside the random number generator before that was made by having an assignment to a state variable that was confined to the random number generator.

642
01:13:22,770 --> 01:13:34,290
So the fact that the random number generator is an object, with an internal state variable, it's affected by nothing, but it'll give you something, and it will apply it's force to you, that was what we're missing now.

643
01:13:38,140 --> 01:13:45,510
OK, well I think we've seen enough reason for doing this, and it all sort of looks very wonderful.

644
01:13:45,510 --> 01:13:55,440
Wouldn't it be nice if assignment was a good thing and maybe it's worth it, but I'm not sure.

645
01:13:55,440 --> 01:14:01,940
As Mr. Gilbert and Sullivan said, things are seldom what they seem, skim milk masquerades as cream.

646
01:14:01,940 --> 01:14:03,655
Are there any questions?

647
01:14:17,010 --> 01:14:20,120
Are there any philosophers here?

648
01:14:20,120 --> 01:14:21,930
Anybody want to argue about objects?

649
01:14:24,590 --> 01:14:25,840
You're just floored, right?

650
01:14:29,840 --> 01:14:30,805
And you haven't done your homework yet.

651
01:14:30,805 --> 01:14:32,055
You haven't come up with a good question.

652
01:14:36,790 --> 01:14:38,040
Oh, well.

653
01:14:40,110 --> 01:14:41,120
Sure, thank you.

654
01:14:41,120 --> 01:14:42,370
Let's take the long break now.

