1
00:00:18,550 --> 00:00:22,230
PROFESSOR: Well, last time Gerry really let the cat out of the bag.

2
00:00:22,230 --> 00:00:26,350
He introduced the idea of assignment.

3
00:00:26,350 --> 00:00:33,405
Assignment and state.

4
00:00:37,620 --> 00:00:45,350
And as we started to see, the implications of introducing assignment and state into the language are absolutely frightening.

5
00:00:45,350 --> 00:00:48,865
First of all, the substitution model of evaluation breaks down.

6
00:00:48,865 --> 00:00:58,130
And we have to use this much more complicated environment model and this very mechanistic thing with diagrams, even to say what statements in the programming language mean.

7
00:00:58,130 --> 00:01:00,260
And that's not a mere technical point.

8
00:01:00,260 --> 00:01:05,870
See, it's not that we had this particular substitution model and, well, it doesn't quite work, so we have to do something else.

9
00:01:05,870 --> 00:01:10,730
It's that nothing like the substitution model can work.

10
00:01:10,730 --> 00:01:18,080
Because suddenly, a variable is not just something that stands for a value.

11
00:01:18,080 --> 00:01:23,630
A variable now has to somehow specify a place that holds a value.

12
00:01:23,630 --> 00:01:25,885
And the value that's in that place can change.

13
00:01:30,280 --> 00:01:40,410
Or for instance, an expression like f of x might have a side effect in it.

14
00:01:40,410 --> 00:01:49,730
So if we say f of x and it has some value, and then later we say f of x again, we might get a different value depending on the order.

15
00:01:49,730 --> 00:01:54,030
So suddenly, we have to think not only about values but about time.

16
00:01:57,970 --> 00:02:02,520
And then things like pairs are no longer just their CARs and their CDRs.

17
00:02:02,520 --> 00:02:08,449
A pair now is not quite its CAR and its CDR. It's rather its identity.

18
00:02:08,449 --> 00:02:11,650
So a pair has identity.

19
00:02:11,650 --> 00:02:12,900
It's an object.

20
00:02:21,330 --> 00:02:30,900
And two pairs that have the same CAR and CDR might be the same or different, because suddenly we have to worry about sharing.

21
00:02:34,960 --> 00:02:40,480
So all of these things enter as soon as we introduce assignment.

22
00:02:40,480 --> 00:02:45,400
See, this is a really far cry from where we started with substitution.

23
00:02:45,400 --> 00:02:53,540
It's a technically harder way of looking at things because we have to think more mechanistically about our programming language.

24
00:02:53,540 --> 00:02:55,960
We can't just think about it as mathematics.

25
00:02:55,960 --> 00:03:04,050
It's philosophically harder, because suddenly there are all these funny issues about what does it mean that something changes or that two things are the same.

26
00:03:04,050 --> 00:03:18,210
And also, it's programming harder, because as Gerry showed last time, there are all these bugs having to do with bad sequencing and aliasing that just don't exist in a language where we don't worry about objects.

27
00:03:18,210 --> 00:03:23,635
Well, how'd we get into this mess?

28
00:03:23,635 --> 00:03:42,760
Remember what we did, the reason we got into this is because we were looking to build modular systems. We wanted to build systems that fall apart into chunks that seem natural.

29
00:03:42,760 --> 00:04:06,980
So for instance, we want to take a random number generator and package up the state of that random number generator inside of it so that we can separate the idea of picking random numbers from the general Monte Carlo strategy of estimating something and separate that from the particular way that you work with random numbers in that formula developed by Cesaro for pi.

30
00:04:06,980 --> 00:04:24,900
And similarly, when we go off and construct some models of things, if we go off and model a system that we see in the real world, we'd like our program to break into natural pieces, pieces that mirror the parts of the system that we see in the real world.

31
00:04:24,900 --> 00:04:35,160
So for example, if we look at a digital circuit, we say, gee, there's a circuit and it has a piece and it has another piece.

32
00:04:40,100 --> 00:04:43,580
And these different pieces sort of have identity.

33
00:04:43,580 --> 00:04:45,550
They have state.

34
00:04:45,550 --> 00:04:48,580
And the state sits on these wires.

35
00:04:48,580 --> 00:04:52,610
And we think of this piece as an object that's different from that as an object.

36
00:04:52,610 --> 00:05:02,170
And when we watch the system change, we think about a signal coming in here and changing a state that might be here and going here and interacting with a state that might be stored there, and so on and so on.

37
00:05:06,860 --> 00:05:23,365
So what we'd like is we'd like to build in the computer systems that fall into pieces that mirror our view of reality, of the way that the actual systems we're modeling seem to fall into pieces.

38
00:05:23,365 --> 00:05:33,610
Well, maybe the reason that building systems like this seems to introduce such technical complications has nothing to do with computers.

39
00:05:33,610 --> 00:05:44,550
See, maybe the real reason that we pay such a price to write programs that mirror our view of reality is that we have the wrong view of reality.

40
00:05:44,550 --> 00:05:50,150
See, maybe time is just an illusion, and nothing ever changes.

41
00:05:50,150 --> 00:05:55,820
See, for example, if I take this chalk, and we say, gee, this is an object and it has a state.

42
00:05:55,820 --> 00:05:59,710
At each moment it has a position and a velocity.

43
00:05:59,710 --> 00:06:01,240
And if we do something, that state can change.

44
00:06:04,340 --> 00:06:11,340
But if you studied any relativity, for instance, you know that you don't think of the path of that chalk as something that goes on instant by instant.

45
00:06:11,340 --> 00:06:16,020
It's more insightful to think of that whole chalk's existence as a path in space-time.

46
00:06:16,020 --> 00:06:18,040
that's all splayed out.

47
00:06:18,040 --> 00:06:19,840
There aren't individual positions and velocities.

48
00:06:19,840 --> 00:06:24,640
There's just its unchanging existence in space-time.

49
00:06:24,640 --> 00:06:41,490
Similarly, if we look at this electrical system, if we imagine this electrical system is implementing some sort of signal processing system, the signal processing engineer who put that thing together doesn't think of it as, well, at each instance there's a voltage coming in.

50
00:06:41,490 --> 00:06:43,340
And that translates into something.

51
00:06:43,340 --> 00:06:46,810
And that affects the state over here, which changes the state over here.

52
00:06:46,810 --> 00:06:50,420
Nobody putting together a signal processing system thinks about it like that.

53
00:06:50,420 --> 00:06:58,060
Instead, you say there's this signal that's splayed out over time.

54
00:06:58,060 --> 00:07:09,570
And if this is acting as a filter, this whole thing transforms this whole thing for some sort of other output.

55
00:07:09,570 --> 00:07:14,160
You don't think of it as what's happening instant by instant as the state of these things.

56
00:07:14,160 --> 00:07:22,230
And somehow you think of this box as a whole thing, not as little pieces sending messages of state to each other at particular instants.

57
00:07:28,250 --> 00:07:41,130
Well, today we're going to look at another way to decompose systems that's more like the signal processing engineer's view of the world than it is like thinking about objects that communicate sending messages.

58
00:07:41,130 --> 00:07:43,310
That's called stream processing.

59
00:07:54,570 --> 00:08:17,210
And we're going to start by showing how we can make our programs more uniform and see a lot more commonality if we throw out of these programs what you might say is an inordinate concern with worrying about time.

60
00:08:17,210 --> 00:08:19,910
Let me start by comparing two procedures.

61
00:08:23,260 --> 00:08:25,690
The first one does this.

62
00:08:25,690 --> 00:08:27,770
We imagine that there's a tree.

63
00:08:30,400 --> 00:08:33,179
Say there's a tree of integers.

64
00:08:33,179 --> 00:08:34,429
It's a binary tree.

65
00:08:39,100 --> 00:08:40,230
So it looks like this.

66
00:08:40,230 --> 00:08:44,990
And there's integers in each of the nodes.

67
00:08:44,990 --> 00:08:57,210
And what we would like to compute is for each odd number sitting here, we'd like to find the square and then sum up all those squares.

68
00:08:57,210 --> 00:08:59,480
Well, that should be a familiar kind of thing.

69
00:08:59,480 --> 00:09:02,930
There's a recursive strategy for doing it.

70
00:09:02,930 --> 00:09:08,680
We look at each leaf, and either it's going to contribute the square of the number if it's odd or 0 if it's even.

71
00:09:08,680 --> 00:09:17,640
And then recursively, we can say at each tree, the sum of all of them is the sum coming from the right branch and the left branch, and recursively down through the nodes.

72
00:09:17,640 --> 00:09:20,360
And that's a familiar way of thinking about programming.

73
00:09:20,360 --> 00:09:23,960
Let's actually look at that on the slide.

74
00:09:23,960 --> 00:09:37,160
We say to sum the odd squares in a tree, well, there's a test. Either it's a leaf node, and we're going to check to see if it's an integer, and then either it's odd, in which we take the square, or else it's 0.

75
00:09:37,160 --> 00:09:42,120
And then the sum of the whole thing is the sum coming from the left branch and the right branch.

76
00:09:46,340 --> 00:09:51,560
OK, well, let me contrast that with a second problem.

77
00:09:51,560 --> 00:09:59,270
Suppose I give you an integer n, and then some function to compute of the first of each integer in 1 through n.

78
00:09:59,270 --> 00:10:05,600
And then I want to collect together in a list all those function values that satisfy some property.

79
00:10:05,600 --> 00:10:06,880
That's a general kind of thing.

80
00:10:06,880 --> 00:10:14,210
Let's say to be specific, let's imagine that for each integer, k, we're going to compute the k Fibonacci number.

81
00:10:14,210 --> 00:10:19,050
And then we'll see which of those are odd and assemble those into a list.

82
00:10:19,050 --> 00:10:20,710
So here's a procedure that does that.

83
00:10:23,730 --> 00:10:26,240
Find the odd Fibonacci numbers among the first n.

84
00:10:26,240 --> 00:10:28,910
And here is a standard loop the way we've been writing it.

85
00:10:28,910 --> 00:10:30,800
This is a recursion.

86
00:10:30,800 --> 00:10:40,370
It's a loop on k, and says if k is bigger than n, it's the empty list. Otherwise we compute the k-th Fibonacci number, call that f.

87
00:10:40,370 --> 00:10:47,690
If it's odd, we CONS it on to the list starting with the next one.

88
00:10:47,690 --> 00:10:50,390
And otherwise, we just take the next one.

89
00:10:50,390 --> 00:10:53,000
And this is the standard way we've been writing iterative loops.

90
00:10:53,000 --> 00:10:57,600
And we start off calling that loop with 1.

91
00:10:57,600 --> 00:11:01,600
OK, so there are two procedures.

92
00:11:01,600 --> 00:11:02,900
Those procedures look very different.

93
00:11:02,900 --> 00:11:04,390
They have very different structures.

94
00:11:04,390 --> 00:11:11,330
Yet from a certain point of view, those procedures are really doing very much the same thing.

95
00:11:11,330 --> 00:11:26,980
So if I was talking like a signal processing engineer, what I might say is that the first procedure enumerates the leaves of a tree.

96
00:11:31,160 --> 00:11:35,330
And then we can think of a signal coming out of that, which is all the leaves.

97
00:11:35,330 --> 00:11:45,190
We'll filter them to see which ones are odd, put them through some kind of filter.

98
00:11:45,190 --> 00:11:49,000
We'll then put them through a kind of transducer.

99
00:11:49,000 --> 00:11:51,420
And for each one of those things, we'll take the square.

100
00:11:54,200 --> 00:11:58,290
And then we'll accumulate all of those.

101
00:11:58,290 --> 00:12:03,340
We'll accumulate them by sticking them together with addition starting from 0.

102
00:12:07,140 --> 00:12:08,210
That's the first program.

103
00:12:08,210 --> 00:12:11,780
The second program, I can describe in a very, very similar way.

104
00:12:11,780 --> 00:12:19,080
I'll say, we'll enumerate the numbers on this interval, for the interval 1 through n.

105
00:12:22,500 --> 00:12:29,270
We'll, for each one, compute the Fibonacci number, put them through a transducer.

106
00:12:29,270 --> 00:12:35,976
We'll then take the result of that, and we'll filter it for oddness.

107
00:12:35,976 --> 00:12:39,350
And then we'll take those and put them into an accumulator.

108
00:12:39,350 --> 00:12:47,110
This time we'll build up a list, so we'll accumulate with CONS starting from the empty list.

109
00:12:47,110 --> 00:12:51,900
So this way of looking at the program makes the two seem very, very similar.

110
00:12:51,900 --> 00:12:58,050
The problem is that that commonality is completely obscured when we look at the procedures we wrote.

111
00:12:58,050 --> 00:13:06,300
Let's go back and look at some odd squares again, and say things like, where's the enumerator?

112
00:13:06,300 --> 00:13:08,140
Where's the enumerator in this program?

113
00:13:08,140 --> 00:13:11,230
Well, it's not in one place.

114
00:13:11,230 --> 00:13:17,160
It's a little bit in this leaf-node test, which is going to stop.

115
00:13:17,160 --> 00:13:20,630
It's a little bit in the recursive structure of the thing itself.

116
00:13:23,150 --> 00:13:24,120
Where's the accumulator?

117
00:13:24,120 --> 00:13:25,680
The accumulator isn't in one place either.

118
00:13:25,680 --> 00:13:32,180
It's partly in this 0 and partly in this plus.

119
00:13:32,180 --> 00:13:34,510
It's not there as a thing that we can look at.

120
00:13:34,510 --> 00:13:44,470
Similarly, if we look at odd Fibs, that's also, in some sense, an enumerator and an accumulator, but it looks very different.

121
00:13:44,470 --> 00:13:55,680
Because partly, the enumerator is here in this greater than sign in the test. And partly it's in this whole recursive structure in the loop, and the way that we call it.

122
00:13:55,680 --> 00:14:03,600
And then similarly, that's also mixed up in there with the accumulator, which is partly over there and partly over there.

123
00:14:03,600 --> 00:14:14,360
So these very, very natural pieces, these very natural boxes here don't appear in our programs. Because they're kind of mixed up.

124
00:14:14,360 --> 00:14:16,290
The programs don't chop things up in the right way.

125
00:14:19,450 --> 00:14:31,060
Going back to this fundamental principle of computer science that in order to control something, you need the name of it, we don't really have control over thinking about things this way because we don't have our hands in them explicitly.

126
00:14:31,060 --> 00:14:35,510
We don't have a good language for talking about them.

127
00:14:35,510 --> 00:14:44,515
Well, let's invent an appropriate language in which we can build these pieces.

128
00:14:44,515 --> 00:14:50,480
The key to the language is these guys, is what is these things I called signals?

129
00:14:50,480 --> 00:14:53,320
What are these things that are flying on the arrows between the boxes?

130
00:14:56,880 --> 00:15:07,980
Well, those things are going to be data structures called streams. That's going to be the key to inventing this language.

131
00:15:07,980 --> 00:15:08,600
What's a stream?

132
00:15:08,600 --> 00:15:12,220
Well, a stream is, like anything else, a data abstraction.

133
00:15:12,220 --> 00:15:16,870
So I should tell you what its selectors and constructors are.

134
00:15:16,870 --> 00:15:21,435
For a stream, we're going to have one constructor that's called CONS-stream.

135
00:15:25,690 --> 00:15:32,040
CONS-stream is going to put two things together to form a thing called a stream.

136
00:15:32,040 --> 00:15:38,010
And then to extract things from the stream, we're going to have a selector called the head of the stream.

137
00:15:38,010 --> 00:15:44,720
So if I have a stream, I can take its head or I can take its tail.

138
00:15:44,720 --> 00:15:53,160
And remember, I have to tell you George's contract here to tell you what the axioms are that relate these.

139
00:15:53,160 --> 00:16:28,440
And it's going to be for any x and y, if I form the CONS-stream and take the head, the head of CONS-stream of x and y is going to be x and the tail of CONS-stream of x and y is going to be y.

140
00:16:28,440 --> 00:16:34,750
So those are the constructor, two selectors for streams, and an axiom.

141
00:16:34,750 --> 00:16:36,980
There's something fishy here.

142
00:16:36,980 --> 00:16:52,810
So you might notice that these are exactly the axioms for CONS, CAR, and CDR. If instead of writing CONS-stream I wrote CONS and I said head was the CAR and tail was the CDR, those are exactly the axioms for pairs.

143
00:16:52,810 --> 00:16:55,130
And in fact, there's another thing here.

144
00:16:55,130 --> 00:17:08,319
We're going to have a thing called the-empty-stream, which is like the-empty-list.

145
00:17:08,319 --> 00:17:10,030
So why am I introducing this terminology?

146
00:17:10,030 --> 00:17:12,780
Why don't I just keep talking about pairs and lists?

147
00:17:12,780 --> 00:17:15,510
Well, we'll see.

148
00:17:15,510 --> 00:17:21,560
For now, if you like, why don't you just pretend that streams really are just a terminology for lists.

149
00:17:21,560 --> 00:17:28,150
And we'll see in a little while why we want to keep this extra abstraction layer and not just call them lists.

150
00:17:32,300 --> 00:17:42,120
OK, now that we have streams, we can start constructing the pieces of the language to operate on streams. And there are a whole bunch of very useful things that we could start making.

151
00:17:42,120 --> 00:18:05,666
For instance, we'll make our map box to take a stream, s, and a procedure, and to generate a new stream which has as its elements the procedure applied to all the successive elements of s.

152
00:18:05,666 --> 00:18:07,400
In fact, we've seen this before.

153
00:18:07,400 --> 00:18:10,950
This is the procedure map that we did with lists.

154
00:18:10,950 --> 00:18:14,650
And you see it's exactly map, except we're testing for empty-stream.

155
00:18:14,650 --> 00:18:15,560
Oh, I forgot to mention that.

156
00:18:15,560 --> 00:18:20,510
Empty-stream is like the null test. So if it's empty, we generate the empty stream.

157
00:18:20,510 --> 00:18:33,140
Otherwise, we form a new stream whose first element is the procedure applied to the head of the stream, and whose rest is gotten by mapping along with the procedure down the tail of the stream.

158
00:18:33,140 --> 00:18:37,030
So that looks exactly like the map procedure we looked at before.

159
00:18:37,030 --> 00:18:38,350
Here's another useful thing.

160
00:18:38,350 --> 00:18:40,460
Filter, this is our filter box.

161
00:18:40,460 --> 00:18:43,890
We're going to have a predicate and a stream.

162
00:18:43,890 --> 00:18:50,160
We're going to make a new stream that consists of all the elements of the original one that satisfy the predicate.

163
00:18:50,160 --> 00:18:51,270
That's case analysis.

164
00:18:51,270 --> 00:18:56,280
When there's nothing in the stream, we return the empty stream.

165
00:18:56,280 --> 00:19:00,060
We test the predicate on the head of the stream.

166
00:19:00,060 --> 00:19:08,220
And if it's true, we add the head of the stream onto the result of filtering the tail of the stream.

167
00:19:08,220 --> 00:19:13,500
And otherwise, if that predicate was false, we just filter the tail of the stream.

168
00:19:13,500 --> 00:19:16,595
Right, so there's filter.

169
00:19:16,595 --> 00:19:18,560
Let me run through a couple more rather quickly.

170
00:19:18,560 --> 00:19:20,880
They're all in the book and you can look at them.

171
00:19:20,880 --> 00:19:22,110
Let me just flash through.

172
00:19:22,110 --> 00:19:23,260
Here's accumulate.

173
00:19:23,260 --> 00:19:31,560
Accumulate takes a way of combining things and an initial value in a stream and sticks them all together.

174
00:19:31,560 --> 00:19:33,970
If the stream's empty, it's just the initial value.

175
00:19:33,970 --> 00:19:40,900
Otherwise, we combine the head of the stream with the result of accumulating the tail of the stream starting from the initial value.

176
00:19:40,900 --> 00:19:42,830
So that's what I'd use to add up everything in the stream.

177
00:19:42,830 --> 00:19:45,830
I'd accumulate with plus.

178
00:19:45,830 --> 00:19:48,060
How would I enumerate the leaves of a tree?

179
00:19:48,060 --> 00:19:56,640
Well, if the tree is just a leaf itself, I make something which only has that node in it.

180
00:19:56,640 --> 00:20:04,340
Otherwise, I append together the stuff of enumerating the left branch and the right branch.

181
00:20:04,340 --> 00:20:08,130
And then append here is like the ordinary append on lists.

182
00:20:13,190 --> 00:20:13,850
You can look at that.

183
00:20:13,850 --> 00:20:19,150
That's analogous to the ordinary procedure for appending two lists.

184
00:20:19,150 --> 00:20:21,810
How would I enumerate an interval?

185
00:20:21,810 --> 00:20:28,106
This will take two integers, low and high, and generate a stream of the integers going from low to high.

186
00:20:28,106 --> 00:20:31,890
And we can make a whole bunch of pieces.

187
00:20:31,890 --> 00:20:37,670
So that's a little language of talking about streams. Once we have streams, we can build things for manipulating them.

188
00:20:37,670 --> 00:20:40,200
Again, we're making a language.

189
00:20:40,200 --> 00:20:43,060
And now we can start expressing things in this language.

190
00:20:43,060 --> 00:20:47,310
Here's our original procedure for summing the odd squares in a tree.

191
00:20:47,310 --> 00:20:54,590
And you'll notice it looks exactly now like the block diagram, like the signal processing block diagram.

192
00:20:54,590 --> 00:21:01,320
So to sum the odd squares in a tree, we enumerate the leaves of the tree.

193
00:21:01,320 --> 00:21:04,830
We filter that for oddness.

194
00:21:04,830 --> 00:21:06,220
We map that for squareness.

195
00:21:09,320 --> 00:21:14,760
And we accumulate the result of that using addition, starting from 0.

196
00:21:14,760 --> 00:21:17,290
So we can see the pieces that we wanted.

197
00:21:17,290 --> 00:21:22,050
Similarly, the Fibonacci one, how do we get the odd Fibs?

198
00:21:22,050 --> 00:21:30,920
Well, we enumerate the interval from 1 to n, we map along that, computing the Fibonacci of each one.

199
00:21:30,920 --> 00:21:34,810
We filter the result of those for oddness.

200
00:21:34,810 --> 00:21:43,650
And we accumulate all of that stuff using CONS starting from the empty-list.

201
00:21:43,650 --> 00:21:47,680
OK, what's the advantage of this?

202
00:21:47,680 --> 00:21:51,880
Well, for one thing, we now have pieces that we can start mixing and matching.

203
00:21:51,880 --> 00:22:06,210
So for instance, if I wanted to change this, if I wanted to compute the squares of the integers and then filter them, all I need to do is pick up a standard piece like this in that square and put it in.

204
00:22:06,210 --> 00:22:18,030
Or if we wanted to do this whole Fibonacci computation on the leaves of a tree rather than a sequence, all I need to do is replace this enumerator with that one.

205
00:22:18,030 --> 00:22:38,130
See, the advantage of this stream processing is that we're establishing-- this is one of the big themes of the course-- we're establishing conventional interfaces that allow us to glue things together.

206
00:22:38,130 --> 00:22:45,750
Things like map and filter are a standard set of components that we can start using for pasting together programs in all sorts of ways.

207
00:22:45,750 --> 00:22:50,090
It allows us to see the commonality of programs.

208
00:22:50,090 --> 00:22:53,860
I just ought to mention, I've only showed you two procedures.

209
00:22:53,860 --> 00:23:01,410
But let me emphasize that this way of putting things together with maps, filters, and accumulators is very, very general.

210
00:23:01,410 --> 00:23:30,710
It's the generate and test paradigm for programs. And as an example of that, Richard Waters, who was at MIT when he was a graduate student, as part of his thesis research went and analyzed a large chunk of the IBM scientific subroutine library, and discovered that about 60% of the programs in it could be expressed exactly in terms using no more than what we've put here-- map, filter, and accumulate.

211
00:23:30,710 --> 00:23:31,960
All right, let's take a break.

212
00:23:36,620 --> 00:23:37,870
Questions?

213
00:23:40,470 --> 00:23:48,380
AUDIENCE: It seems like the essence of this whole thing is just that you have a very uniform, simple data structure to work with, the stream.

214
00:23:48,380 --> 00:23:48,920
PROFESSOR: Right.

215
00:23:48,920 --> 00:23:53,710
The essence is that you, again, it's this sense of conventional interfaces.

216
00:23:53,710 --> 00:23:55,610
So you can start putting a lot of things together.

217
00:23:55,610 --> 00:24:00,890
And the stream is as you say, the uniform data structure that supports that.

218
00:24:00,890 --> 00:24:03,600
This is very much like APL, by the way.

219
00:24:03,600 --> 00:24:09,560
APL is very much the same idea, except in APL, instead of this stream, you have arrays and vectors.

220
00:24:09,560 --> 00:24:14,815
And a lot of the power of APL is exactly the same reason of the power of this.

221
00:24:19,910 --> 00:24:20,910
OK, thank you.

222
00:24:20,910 --> 00:24:22,160
Let's take a break.

223
00:24:57,470 --> 00:24:57,610
All right.

224
00:24:57,610 --> 00:25:10,810
We've been looking at ways of organizing computations using streams. What I want to do now is just show you two somewhat more complicated examples of that.

225
00:25:10,810 --> 00:25:16,810
Let's start by thinking about the following kind of utility procedure that will come in useful.

226
00:25:16,810 --> 00:25:19,960
Suppose I've got a stream.

227
00:25:19,960 --> 00:25:23,730
And the elements of this stream are themselves streams.

228
00:25:23,730 --> 00:25:26,530
So the first thing might be 1, 2, 3.

229
00:25:32,600 --> 00:25:33,880
So I've got a stream.

230
00:25:33,880 --> 00:25:40,100
And each element of the stream is itself a stream.

231
00:25:40,100 --> 00:25:52,080
And what I'd like to do is build a stream that collects together all of the elements, pulls all of the elements out of these sub-streams and strings them all together in one thing.

232
00:25:52,080 --> 00:25:56,960
So just to show you the use of this language, how easy it is, call that flatten.

233
00:25:56,960 --> 00:26:13,960
And I can define to flatten this stream of streams. Well, what is that?

234
00:26:13,960 --> 00:26:16,240
That's just an accumulation.

235
00:26:16,240 --> 00:26:26,450
I want to accumulate using append, by successively appending.

236
00:26:26,450 --> 00:26:54,370
So I accumulate using append streams, starting with the-empty-stream down that stream of streams.

237
00:26:54,370 --> 00:27:00,830
OK, so there's an example of how you can start using these higher order things to do some interesting operations.

238
00:27:00,830 --> 00:27:05,100
In fact, there's another useful thing that I want to do.

239
00:27:05,100 --> 00:27:21,840
I want to define a procedure called flat-map, flat map of some function and a stream.

240
00:27:21,840 --> 00:27:25,720
And what this is going to do is f will be a stream of elements.

241
00:27:25,720 --> 00:27:31,950
f is going to be a function that for each element in the stream produces another stream.

242
00:27:31,950 --> 00:27:36,000
And what I want to do is take all of the elements and all of those streams and combine them together.

243
00:27:36,000 --> 00:27:51,350
So that's just going to be the flatten of map f down s.

244
00:27:51,350 --> 00:27:54,290
Each time I apply f to an element of s, I get a stream.

245
00:27:54,290 --> 00:27:58,385
If I map it all the way down, I get a stream of streams, and I'll flatten that.

246
00:27:58,385 --> 00:28:06,360
Well, I want to use that to show you a new way to do a familiar kind of problem.

247
00:28:06,360 --> 00:28:14,190
The problem's going to be like a lot of problems you've seen, although maybe not this particular one.

248
00:28:14,190 --> 00:28:15,490
I'm going to give you an integer, n.

249
00:28:18,480 --> 00:28:51,910
And the problem is going to be find all pairs and integers i and j, between 0 and i, with j less than i, up to n, such that i plus j is prime.

250
00:28:55,740 --> 00:29:06,640
So for example, if n equals 6, let's make a little table here, i and j and i plus j.

251
00:29:09,700 --> 00:29:15,520
So for, say, i equals 2 and j equals 1, I'd get 3.

252
00:29:15,520 --> 00:29:21,210
And for i equals 3, I could have j equals 2, and that would be 5.

253
00:29:21,210 --> 00:29:28,400
And 4 and 1 would be 5 and so on, up until i goes to 6.

254
00:29:28,400 --> 00:29:37,350
And what I'd like to return is to produce a stream of all the triples like this, let's say i, j, and i plus j.

255
00:29:37,350 --> 00:29:41,530
So for each n, I want to generate this stream.

256
00:29:41,530 --> 00:29:43,680
OK, well, that's easy.

257
00:29:43,680 --> 00:29:47,230
Let's build it up.

258
00:29:47,230 --> 00:29:50,150
We start like this.

259
00:29:50,150 --> 00:29:56,440
We're going to say for each i, we're going to generate a stream.

260
00:29:56,440 --> 00:30:00,660
For each i in the interval 1 through n, we're going to generate a stream.

261
00:30:00,660 --> 00:30:02,230
What's that stream going to be?

262
00:30:02,230 --> 00:30:04,180
We're going to start by generating all the pairs.

263
00:30:04,180 --> 00:30:20,710
So for each i, we're going to generate, for each j in the interval 1 to i minus 1, we'll generate the pair, or the list with two elements i and j.

264
00:30:23,780 --> 00:30:30,712
So we map along the interval, generating the pairs.

265
00:30:30,712 --> 00:30:33,170
And for each i, that generates a stream of pairs.

266
00:30:33,170 --> 00:30:34,590
And we flatmap it.

267
00:30:34,590 --> 00:30:38,730
Now we have all the pairs i and j, such that i is less than j.

268
00:30:38,730 --> 00:30:39,850
So that builds that.

269
00:30:39,850 --> 00:30:42,990
Now we're got to test them.

270
00:30:42,990 --> 00:30:51,660
Well, we take that thing we just built, the flatmap, and we filter it to see whether the i-- see, we had an i and a j.

271
00:30:51,660 --> 00:31:02,070
i was the first thing in the list, j was the second thing in the list. So we have a predicate which says in that list of two elements is the sum of the CAR and the CDR prime.

272
00:31:02,070 --> 00:31:06,540
And we filter that collection of pairs we just built.

273
00:31:06,540 --> 00:31:09,420
So those are the pairs we want.

274
00:31:09,420 --> 00:31:19,610
Now we go ahead and we take the result of that filter and we map along it, generating the list i and j and i plus j.

275
00:31:19,610 --> 00:31:22,910
And that's our procedure prime-sum-pairs.

276
00:31:22,910 --> 00:31:24,480
And then just to flash it up, here's the whole procedure.

277
00:31:27,945 --> 00:31:30,750
A map, a filter, a flatmap.

278
00:31:34,850 --> 00:31:37,120
There's the whole thing, even though this isn't particularly readable.

279
00:31:37,120 --> 00:31:40,000
It's just expanding that flatmap.

280
00:31:40,000 --> 00:31:54,200
So there's an example which illustrates the general point that nested loops in this procedure start looking like compositions of flatmaps of flatmaps of flatmaps of maps and things.

281
00:31:54,200 --> 00:32:03,230
So not only can we enumerate individual things, but by using flatmaps, we can do what would correspond to nested loops in most other languages.

282
00:32:03,230 --> 00:32:08,410
Of course, it's pretty awful to keep writing these flatmaps of flatmaps of flatmaps.

283
00:32:08,410 --> 00:32:15,480
Prime-sum-pairs you saw looked fairly complicated, even though the individual pieces were easy.

284
00:32:15,480 --> 00:32:21,040
So what you can do, if you like, is introduced some syntactic sugar that's called collect.

285
00:32:21,040 --> 00:32:26,160
And collect is just an abbreviation for that nest of flatmaps and filters arranged in that particular way.

286
00:32:26,160 --> 00:32:29,620
Here's prime-sum-pairs again, written using collect.

287
00:32:29,620 --> 00:32:58,040
It says to find all those pairs, I'm going to collect together a result, which is the list i, j, and i plus j, that's going to be generated as i runs through the interval from 1 to n and as j runs through the interval from 1 to i minus 1, such that i plus j is prime.

288
00:32:58,040 --> 00:33:00,690
So I'm not going to say what collect does in general.

289
00:33:00,690 --> 00:33:03,420
You can look at that by looking at it in the book.

290
00:33:03,420 --> 00:33:08,820
But pretty much, you can see that the pieces of this are the pieces of that original procedure I wrote.

291
00:33:08,820 --> 00:33:16,310
And this collect is just some syntactic sugar for automatically generating that nest of flatmaps and flatmaps.

292
00:33:16,310 --> 00:33:22,120
OK, well, let me do one more example that shows you the same kind of thing.

293
00:33:22,120 --> 00:33:30,200
Here's a very famous problem that's used to illustrate a lot of so-called backtracking computer algorithms. This is the eight queens problem.

294
00:33:30,200 --> 00:33:32,370
This is a chess board.

295
00:33:32,370 --> 00:33:38,000
And the eight queens problem says, find a way to put down eight queens on a chess board so that no two are attacking each other.

296
00:33:38,000 --> 00:33:41,430
And here's a particular solution to the eight queens problem.

297
00:33:41,430 --> 00:33:51,410
So I have to make sure to put down queens so that no two are in the same row or the same column or sit along the same diagonal.

298
00:33:51,410 --> 00:33:56,400
Now, there's sort of a standard way of doing that.

299
00:33:59,740 --> 00:34:04,940
Well, first we need to do is below the surface, at George's level.

300
00:34:04,940 --> 00:34:08,095
We have to find some way to represent a board, and represent positions.

301
00:34:08,095 --> 00:34:09,800
And we'll not worry about that.

302
00:34:09,800 --> 00:34:12,540
But let's assume that there's a predicate called safe.

303
00:34:16,040 --> 00:34:25,400
And what safe is going to do is going to say given that I have a bunch of queens down on the chess board, is it OK to put a queen in this particular spot?

304
00:34:25,400 --> 00:34:32,889
So safe is going to take a row and a column.

305
00:34:32,889 --> 00:34:42,370
That's going to be a place where I'm going to try and put down the next queen, and the rest of positions.

306
00:34:45,420 --> 00:34:58,300
And what safe will say is given that I already have queens down in these positions, is it safe to put another queen down in that row and that column?

307
00:34:58,300 --> 00:34:59,360
And let's not worry about that.

308
00:34:59,360 --> 00:35:01,380
That's George's problem. and it's not hard to write.

309
00:35:01,380 --> 00:35:10,530
You just have to check whether this thing contains any things on that row or that column or in that diagonal.

310
00:35:10,530 --> 00:35:13,590
Now, how would you organize the program given that?

311
00:35:13,590 --> 00:35:20,116
And there's sort of a traditional way to organize it called backtracking.

312
00:35:20,116 --> 00:35:31,290
And it says, well, let's think about all the ways of putting the first queen down in the first column.

313
00:35:31,290 --> 00:35:32,580
There are eight ways.

314
00:35:32,580 --> 00:35:35,880
Well, let's say try the first column.

315
00:35:35,880 --> 00:35:37,300
Try column 1, row 1.

316
00:35:37,300 --> 00:35:43,360
These branches are going to represent the possibilities at each level.

317
00:35:43,360 --> 00:35:45,875
So I'll try and put a queen down in the first column.

318
00:35:45,875 --> 00:35:49,980
And now given that it's in the first column, I'll try and put the next queen down in the first column.

319
00:35:53,035 --> 00:35:56,920
I'll try and put the first queen, the one in the first column, down in the first row.

320
00:35:56,920 --> 00:35:59,050
I'm sorry.

321
00:35:59,050 --> 00:36:01,390
And then given that, we'll put the next queen down in the first row.

322
00:36:01,390 --> 00:36:02,090
And that's no good.

323
00:36:02,090 --> 00:36:04,200
So I'll back up to here.

324
00:36:04,200 --> 00:36:07,510
And I'll say, oh, can I put the first queen down in the second row?

325
00:36:07,510 --> 00:36:08,550
Well, that's no good.

326
00:36:08,550 --> 00:36:09,760
Oh, can I put it down in the third row?

327
00:36:09,760 --> 00:36:12,790
Well, that's good.

328
00:36:12,790 --> 00:36:15,380
Well, now can I put the next queen down in the first column?

329
00:36:15,380 --> 00:36:19,195
Well, I can't visualize this chess board anymore, but I think that's right.

330
00:36:19,195 --> 00:36:20,450
And I try the next one.

331
00:36:20,450 --> 00:36:24,170
And at each place, I go as far down this tree as I can.

332
00:36:24,170 --> 00:36:25,640
And I back up.

333
00:36:25,640 --> 00:36:33,260
If I get down to here and find no possibilities below there, I back all the way up to here, and now start again generating this sub-tree.

334
00:36:33,260 --> 00:36:35,050
And I sort of walk around.

335
00:36:35,050 --> 00:36:40,090
And finally, if I ever manage to get all the way down, I've found a solution.

336
00:36:40,090 --> 00:36:45,930
So that's a typical sort of paradigm that's used a lot in AI programming.

337
00:36:45,930 --> 00:36:47,300
It's called backtracking search.

338
00:36:57,470 --> 00:37:03,860
And it's really unnecessary.

339
00:37:03,860 --> 00:37:06,550
You saw me get confused when I was visualizing this thing.

340
00:37:06,550 --> 00:37:08,550
And you see the complication.

341
00:37:08,550 --> 00:37:10,760
This is a complicated thing to say.

342
00:37:10,760 --> 00:37:12,390
Why is it complicated?

343
00:37:12,390 --> 00:37:18,580
Its because somehow this program is too inordinately concerned with time.

344
00:37:18,580 --> 00:37:22,320
It's too much-- I try this one, and I try this one, and I go back to the last possibility.

345
00:37:22,320 --> 00:37:24,340
And that's a complicated thing.

346
00:37:24,340 --> 00:37:31,200
If I stop worrying about time so much, then there's a much simpler way to describe this.

347
00:37:31,200 --> 00:37:43,400
It says, let's imagine that I have in my hands the tree down to k minus 1 levels.

348
00:37:43,400 --> 00:37:53,560
See, suppose I had in my hands all possible ways to put down queens in the first k columns.

349
00:37:53,560 --> 00:37:54,610
Suppose I just had that.

350
00:37:54,610 --> 00:37:57,070
Let's not worry about how we get it.

351
00:37:57,070 --> 00:37:59,200
Well, then, how do I extend that?

352
00:37:59,200 --> 00:38:02,480
How do I find all possible ways to put down queens in the next column?

353
00:38:02,480 --> 00:38:03,620
It's really easy.

354
00:38:03,620 --> 00:38:16,160
For each of these positions I have, I think about putting down a queen in each row to make the next thing.

355
00:38:16,160 --> 00:38:22,080
And then for each one I put down, I filter those by the ones that are safe.

356
00:38:22,080 --> 00:38:26,860
So instead of thinking about this tree as generated step by step, suppose I had it all there.

357
00:38:29,680 --> 00:38:37,800
And to extend it from level k minus 1 to level k, I just need to extend each thing in all possible ways and only keep the ones that are safe.

358
00:38:37,800 --> 00:38:39,300
And that will give me the tree to level k.

359
00:38:39,300 --> 00:38:44,530
And that's a recursive strategy for solving the eight queens problem.

360
00:38:44,530 --> 00:38:45,780
All right, well, let's look at it.

361
00:38:50,280 --> 00:39:01,030
To solve the eight queens problem on a board of some specified size, we write a sub-procedure called fill-columns.

362
00:39:01,030 --> 00:39:06,086
Fill-columns is going to put down queens up through column k.

363
00:39:06,086 --> 00:39:07,700
And here's the pattern of the recursion.

364
00:39:07,700 --> 00:39:12,990
I'm going to call fill-columns with the size eventually.

365
00:39:12,990 --> 00:39:20,360
So fill-columns says how to put down queens safely in the first k columns of this chess board with a size number of rows in it.

366
00:39:20,360 --> 00:39:23,940
If k is equal to 0, well, then I don't have to put anything down.

367
00:39:23,940 --> 00:39:26,710
So my solution is just an empty chess board.

368
00:39:26,710 --> 00:39:28,070
Otherwise, I'm going to do some stuff.

369
00:39:28,070 --> 00:39:30,522
And I'm going to use collect.

370
00:39:30,522 --> 00:39:31,772
And here's the collect.

371
00:39:34,530 --> 00:39:41,910
I find all ways to put down queens in the first k minus 1 columns.

372
00:39:41,910 --> 00:39:43,320
And this was just what I set for.

373
00:39:43,320 --> 00:39:48,880
Imagine I have this tree down to k minus 1 levels.

374
00:39:48,880 --> 00:39:54,130
And then I find all ways of trying a row, that's just each of the possible rows.

375
00:39:54,130 --> 00:39:58,040
They're size rows, so that's enumerate interval.

376
00:39:58,040 --> 00:40:08,950
And now what I do is I collect together the new row I'm going to try and column k with the rest of the queens.

377
00:40:08,950 --> 00:40:10,200
I adjoin a position.

378
00:40:10,200 --> 00:40:11,290
This is George's problem.

379
00:40:11,290 --> 00:40:13,640
An adjoined position is like safe.

380
00:40:13,640 --> 00:40:19,660
It's a thing that takes a row and a column and the rest of the positions and makes a new position collection.

381
00:40:19,660 --> 00:40:34,620
So I adjoin a position of a new row and a new column to the rest of the queens, where the rest of the queens runs through all possible ways of solving the problem in k minus 1 columns.

382
00:40:34,620 --> 00:40:43,240
And the new row runs through all possible rows such that it was safe to put one there.

383
00:40:43,240 --> 00:40:46,500
And that's the whole program.

384
00:40:46,500 --> 00:40:49,840
There's the whole procedure.

385
00:40:49,840 --> 00:40:56,680
Not only that, that doesn't just solve the eight queens problem, it gives you all solutions to the eight queens problem.

386
00:40:56,680 --> 00:40:58,480
When you're done, you have a stream.

387
00:40:58,480 --> 00:41:01,900
And the elements of that stream are all possible ways of solving that problem.

388
00:41:05,310 --> 00:41:06,260
Why is that simpler?

389
00:41:06,260 --> 00:41:12,720
Well, we threw away the whole idea that this is some process that happens in time with state.

390
00:41:12,720 --> 00:41:14,420
And we just said it's a whole collection of stuff.

391
00:41:14,420 --> 00:41:18,260
And that's why it's simpler.

392
00:41:18,260 --> 00:41:20,110
We've changed our view.

393
00:41:20,110 --> 00:41:22,820
Remember, that's where we started today.

394
00:41:22,820 --> 00:41:26,230
We've changed our view of what it is we're trying to model.

395
00:41:26,230 --> 00:41:31,750
we stop modeling things that evolve in time and have steps and have state.

396
00:41:31,750 --> 00:41:40,750
And instead, we're trying to model this global thing like the whole flight of the chalk, rather than its state at each instant.

397
00:41:40,750 --> 00:41:42,000
Any questions?

398
00:41:43,810 --> 00:41:54,030
AUDIENCE: It looks to me like backtracking would be searching for the first solution it can find, whereas this recursive search would be looking for all solutions.

399
00:41:54,030 --> 00:42:01,360
And it seems that if you have a large enough area to search, that the second is going to become impossible.

400
00:42:01,360 --> 00:42:08,570
PROFESSOR: OK, the answer to that question is the whole rest of this lecture.

401
00:42:08,570 --> 00:42:10,540
It's exactly the right question.

402
00:42:13,522 --> 00:42:22,220
And without trying to anticipate the lecture too much, you should start being suspicious at this point, and exactly those kinds of suspicions.

403
00:42:22,220 --> 00:42:24,830
It's wonderful, but isn't it so terribly inefficient?

404
00:42:24,830 --> 00:42:28,100
That's where we're going.

405
00:42:28,100 --> 00:42:30,020
So I won't answer now, but I'll answer later.

406
00:42:33,350 --> 00:42:34,600
OK, let's take a break.

407
00:43:29,650 --> 00:43:35,600
Well, by now you should be starting to get suspicious.

408
00:43:35,600 --> 00:43:53,740
See, I've showed your this simple, elegant way of putting programs together, very unlike these other traditional programs that sum the odd squares or compute the odd Fibonacci numbers.

409
00:43:53,740 --> 00:44:00,440
Very unlike these programs that mix up the enumerator and the filter and the accumulator.

410
00:44:00,440 --> 00:44:13,800
And by mixing it up, we don't have all of these wonderful conceptual advantages of these streams pieces, these wonderful mix and match components for putting together lots and lots of programs.

411
00:44:13,800 --> 00:44:18,340
On the other hand, most of the programs you've seen look like these ugly ones.

412
00:44:18,340 --> 00:44:19,460
Why's that?

413
00:44:19,460 --> 00:44:33,620
Can it possibly be that computer scientists are so obtuse that they don't notice that if you'd merely did this thing, then you can get this great programming elegance?

414
00:44:33,620 --> 00:44:36,760
There's got to be a catch.

415
00:44:36,760 --> 00:44:39,510
And it's actually pretty easy to see what the catch is.

416
00:44:39,510 --> 00:44:42,030
Let's think about the following problem.

417
00:44:42,030 --> 00:44:54,105
Suppose I tell you to find the second prime between 10,000 and 1 million, or if your computer's larger, say between 10,000 and 100 billion, or something.

418
00:44:54,105 --> 00:44:55,550
And you say, oh, that's easy.

419
00:44:55,550 --> 00:44:57,080
I can do that with a stream.

420
00:44:57,080 --> 00:45:04,160
All I do is I enumerate the interval from 10,000 to 1 million.

421
00:45:04,160 --> 00:45:06,800
So I get all those integers from 10,000 to 1 million.

422
00:45:06,800 --> 00:45:11,762
I filter them for prime-ness, so test all of them and see if they're prime.

423
00:45:11,762 --> 00:45:13,170
And I take the second element.

424
00:45:13,170 --> 00:45:16,130
That's the head of the tail.

425
00:45:16,130 --> 00:45:17,380
Well, that's clearly pretty ridiculous.

426
00:45:21,660 --> 00:45:27,040
We'd not even have room in the machine to store the integers in the first place, much less to test them.

427
00:45:27,040 --> 00:45:29,810
And then I only want the second one.

428
00:45:29,810 --> 00:45:45,090
See, the power of this traditional programming style is exactly its weakness, that we're mixing up the enumerating and the testing and the accumulating.

429
00:45:45,090 --> 00:45:46,670
So we don't do it all.

430
00:45:46,670 --> 00:45:55,210
So the very thing that makes it conceptually ugly is the very thing that makes it efficient.

431
00:45:55,210 --> 00:45:57,800
It's this mixing up.

432
00:45:57,800 --> 00:46:00,420
So it seems that all I've done this morning so far is just confuse you.

433
00:46:00,420 --> 00:46:05,840
I showed you this wonderful way that programming might work, except that it doesn't.

434
00:46:05,840 --> 00:46:09,040
Well, here's where the wonderful thing happens.

435
00:46:09,040 --> 00:46:14,870
It turns out in this game that we really can have our cake and eat it too.

436
00:46:14,870 --> 00:46:36,310
And what I mean by that is that we really can write stream programs exactly like the ones I wrote and arrange things so that when the machine actually runs, it's as efficient as running this traditional programming style that mixes up the generation and the test.

437
00:46:36,310 --> 00:46:40,770
Well, that sounds pretty magic.

438
00:46:40,770 --> 00:46:43,690
The key to this is that streams are not lists.

439
00:46:48,090 --> 00:46:52,115
We'll see this carefully in a second, but for now, let's take a look at that slide again.

440
00:46:52,115 --> 00:47:05,360
The image you should have here of this signal processing system is that what's going to happen is there's this box that has the integers sitting in it.

441
00:47:05,360 --> 00:47:10,940
And there's this filter that's connected to it and it's tugging on them.

442
00:47:10,940 --> 00:47:16,790
And then there's someone who's tugging on this stuff saying what comes out of the filter.

443
00:47:16,790 --> 00:47:24,590
And the image you should have is that someone says, well, what's the first prime, and tugs on this filter.

444
00:47:24,590 --> 00:47:28,020
And the filter tugs on the integers.

445
00:47:28,020 --> 00:47:30,930
And you look only at that much, and then say, oh, I really wanted the second one.

446
00:47:30,930 --> 00:47:33,710
What's the second prime?

447
00:47:33,710 --> 00:47:40,500
And that no computation gets done except when you tug on these things.

448
00:47:40,500 --> 00:47:41,410
Let me try that again.

449
00:47:41,410 --> 00:47:43,815
This is a little device.

450
00:47:43,815 --> 00:47:49,830
This is a little stream machine invented by Eric Grimson who's been teaching this course at MIT.

451
00:47:49,830 --> 00:47:54,780
And the image is here's a stream of stuff, like a whole bunch of the integers.

452
00:47:54,780 --> 00:47:58,700
And here's some processing elements.

453
00:47:58,700 --> 00:48:02,600
And if, say, it's filter of filter of map, or something.

454
00:48:05,570 --> 00:48:12,670
And if I really tried to implement that with streams as lists, what I'd say is, well, I've got this list of things, and now I do the first filter.

455
00:48:12,670 --> 00:48:14,070
So do all this processing.

456
00:48:14,070 --> 00:48:19,610
And I take this and I process and I process and I process and I process.

457
00:48:19,610 --> 00:48:21,910
And now I'm got this new stream.

458
00:48:21,910 --> 00:48:24,070
Now I take that result in my hand someplace.

459
00:48:24,070 --> 00:48:25,260
And I put that through the second one.

460
00:48:25,260 --> 00:48:28,110
And I process the whole thing.

461
00:48:28,110 --> 00:48:29,510
And there's this new stream.

462
00:48:32,130 --> 00:48:36,360
And then I take the result and I put it all the way through this one the same way.

463
00:48:36,360 --> 00:48:43,860
That's what would happen to these stream programs if streams were just lists.

464
00:48:43,860 --> 00:48:50,230
But in fact, streams aren't lists, they're streams. And the image you should have is something a little bit more like this.

465
00:48:50,230 --> 00:48:57,130
I've got these gadgets connected up by this data that's flowing out of them.

466
00:48:59,960 --> 00:49:05,980
And here's my original source of the streams. It might be starting to generate the integers.

467
00:49:05,980 --> 00:49:07,580
And now, what happens if I want a result?

468
00:49:07,580 --> 00:49:10,200
I tug on the end here.

469
00:49:10,200 --> 00:49:13,090
And this element says, gee, I need some more data.

470
00:49:13,090 --> 00:49:15,830
So this one comes here and tugs on that one.

471
00:49:15,830 --> 00:49:17,890
And it says, gee, I need some more data.

472
00:49:17,890 --> 00:49:21,640
And this one tugs on this thing, which might be a filter, and says, gee, I need some more data.

473
00:49:21,640 --> 00:49:25,780
And only as much of this thing at the end here gets generated as I tugged.

474
00:49:25,780 --> 00:49:30,760
And only as much of this stuff goes through the processing units as I'm pulling on the end I need.

475
00:49:30,760 --> 00:49:37,830
That's the image you should have of the difference between implementing what we're actually going to do and if streams were lists.

476
00:49:40,600 --> 00:49:42,430
Well, how do we make this thing?

477
00:49:42,430 --> 00:49:43,400
I hope you have the image.

478
00:49:43,400 --> 00:49:44,947
The trick is how to make it.

479
00:49:47,930 --> 00:49:56,920
We want to arrange for a stream to be a data structure that computes itself incrementally, an on-demand data structure.

480
00:49:59,220 --> 00:50:04,490
And the basic idea is, again, one of the very basic ideas that we're seeing throughout the whole course.

481
00:50:04,490 --> 00:50:09,240
And that is that there's not a firm distinction between programs and data.

482
00:50:09,240 --> 00:50:16,810
So what a stream is going to be is simultaneously this data structure that you think of, like the stream of the leaves of this tree.

483
00:50:16,810 --> 00:50:23,550
But at the same time, it's going to be a very clever procedure that has the method of computing in it.

484
00:50:23,550 --> 00:50:25,930
Well, let me try this.

485
00:50:25,930 --> 00:50:28,460
It's going to turn out that we don't need any more mechanism.

486
00:50:28,460 --> 00:50:35,460
We already have everything we need simply from the fact that we know how to handle procedures as first-class objects.

487
00:50:35,460 --> 00:50:36,880
Well, let's go back to the key.

488
00:50:36,880 --> 00:50:39,030
The key is, remember, we had these operations.

489
00:50:39,030 --> 00:50:48,080
CONS-stream and head and tail.

490
00:50:48,080 --> 00:50:55,080
When I started, I said you can think about this as CONS and think about this as CAR and think about that as CDR, but it's not.

491
00:50:55,080 --> 00:50:57,550
Now, let's look at what they really are.

492
00:50:57,550 --> 00:51:19,540
Well, CONS-stream of x and y is going to be an abbreviation for the following thing.

493
00:51:19,540 --> 00:51:28,000
CONS form a pair, ordinary CONS, of x to a thing called delay of y.

494
00:51:31,188 --> 00:51:39,790
And before I explain that, let me go and write the rest. The head of a stream is going to be just the CAR.

495
00:51:42,380 --> 00:51:56,120
And the tail of a stream is going to be a thing called force the CDR of the stream.

496
00:51:56,120 --> 00:51:58,060
Now let me explain this.

497
00:51:58,060 --> 00:52:01,420
Delay is going to be a special magic thing.

498
00:52:01,420 --> 00:52:10,600
What delay does is take an expression and produce a promise to compute that expression when you ask for it.

499
00:52:10,600 --> 00:52:11,980
It doesn't do any computation here.

500
00:52:11,980 --> 00:52:14,820
It just gives you a rain check.

501
00:52:14,820 --> 00:52:17,110
It produces a promise.

502
00:52:17,110 --> 00:52:25,360
And CONS-stream says I'm going to put together in a pair x and a promise to compute y.

503
00:52:28,230 --> 00:52:31,840
Now, if I want the head, that's just the CAR that I put in the pair.

504
00:52:31,840 --> 00:52:39,110
And the key is that the tail is going to be-- force calls in that promise.

505
00:52:39,110 --> 00:52:44,610
Tail says, well, take that promise and now call in that promise.

506
00:52:44,610 --> 00:52:47,430
And then we compute that thing.

507
00:52:47,430 --> 00:52:48,740
That's how this is going to work.

508
00:52:48,740 --> 00:52:51,550
That's what CONS-stream, head, and tail really are.

509
00:52:54,196 --> 00:52:55,570
Now, let's see how this works.

510
00:52:55,570 --> 00:52:58,410
And we'll go through this fairly carefully.

511
00:52:58,410 --> 00:53:08,650
We're going to see how this works in this example of computing the second prime between 10,000 and a million.

512
00:53:08,650 --> 00:53:11,610
OK, so we start off and we have this expression.

513
00:53:15,820 --> 00:53:26,710
The second prime-- the head of the tail of the result of filtering for primality the integers between 10,000 and 1 million.

514
00:53:26,710 --> 00:53:28,400
Now, what is that?

515
00:53:28,400 --> 00:53:40,250
What that is, that interval between 10,000 and 1 million, well, if you trace through enumerate interval, there builds a CONS-stream.

516
00:53:40,250 --> 00:53:54,480
And the CONS-stream is the CONS of 10,000 to a promise to compute the integers between 10,001 and 1 million.

517
00:53:54,480 --> 00:53:55,750
So that's what this expression is.

518
00:53:55,750 --> 00:53:57,640
Here I'm using the substitution model.

519
00:53:57,640 --> 00:54:01,010
And we can use the substitution model because we don't have side effects and state.

520
00:54:04,270 --> 00:54:08,380
So I have CONS of 10,000 to a promise to compute the rest of the integers.

521
00:54:08,380 --> 00:54:09,850
So only one integer, so far, got enumerated.

522
00:54:14,380 --> 00:54:16,580
Well, I'm going to filter that thing for primality.

523
00:54:19,900 --> 00:54:22,360
Again, you go back and look at the filter code.

524
00:54:22,360 --> 00:54:25,460
What the filter will first do is test the head.

525
00:54:25,460 --> 00:54:33,500
So in this case, the filter will test 10,000 and say, oh, 10,000's not prime.

526
00:54:33,500 --> 00:54:39,220
Therefore, what I have to do recursively is filter the tail.

527
00:54:39,220 --> 00:54:46,340
And what's the tail of it, well, that's the tail of this pair with a promise in it.

528
00:54:46,340 --> 00:54:49,680
Tail now comes in and says, well, I'm going to force that.

529
00:54:49,680 --> 00:55:00,880
I'm going to force that promise, which means now I'm going to compute the integers between 10,001 and 1 million.

530
00:55:00,880 --> 00:55:02,970
OK, so this filter now is looking at that.

531
00:55:07,810 --> 00:55:11,960
That enumerate itself, well, now we're back in the original enumerate situation.

532
00:55:11,960 --> 00:55:19,740
The enumerate is the CONS of the first thing, 10,001, onto a promise to compute the rest.

533
00:55:19,740 --> 00:55:23,060
So now the primality filter is going to go look at 10,001.

534
00:55:23,060 --> 00:55:25,120
It's going to decide if it likes that or not.

535
00:55:25,120 --> 00:55:27,550
It turns out 10,001 isn't prime.

536
00:55:27,550 --> 00:55:29,610
So it'll force it again and again and again.

537
00:55:32,920 --> 00:55:37,100
And finally, I think the first prime it hits is 10,009.

538
00:55:37,100 --> 00:55:40,465
And at that point, it'll stop.

539
00:55:40,465 --> 00:55:45,240
And that will be the first prime, and then eventually, it'll need the second prime.

540
00:55:45,240 --> 00:55:47,030
So at that point, it will go again.

541
00:55:47,030 --> 00:55:53,130
So you see what happens is that no more gets generated than you actually need.

542
00:55:56,690 --> 00:56:04,930
That enumerator is not going to generate any more integers than the filter asks it for as it's pulling in things to check for primality.

543
00:56:04,930 --> 00:56:11,255
And the filter is not going to generate any more stuff than you ask it for, which is the head of the tail.

544
00:56:11,255 --> 00:56:28,160
You see, what's happened is we've put that mixing of generation and test into what actually happens in the computer, even though that's not apparently what's happening from looking at our programs.

545
00:56:28,160 --> 00:56:30,230
OK, well, that seemed easy.

546
00:56:30,230 --> 00:56:33,326
All of this mechanism got put into this magic delay.

547
00:56:33,326 --> 00:56:36,900
So you're saying, gee, that must be where the magic is.

548
00:56:36,900 --> 00:56:39,070
But see there's no magic there either.

549
00:56:39,070 --> 00:56:40,610
You know what delay is.

550
00:56:40,610 --> 00:56:56,490
Delay on some expression is just an abbreviation for--  well, what's a promise to compute an expression?

551
00:56:56,490 --> 00:57:03,000
Lambda of nil, procedure of no arguments, which is that expression.

552
00:57:03,000 --> 00:57:03,930
That's what a procedure is.

553
00:57:03,930 --> 00:57:06,050
It says I'm going to compute an expression.

554
00:57:06,050 --> 00:57:07,460
What's force?

555
00:57:07,460 --> 00:57:10,800
How do I take up a promise?

556
00:57:10,800 --> 00:57:15,890
Well, force of some procedure, a promise, is just run it.

557
00:57:18,710 --> 00:57:20,120
Done.

558
00:57:20,120 --> 00:57:23,580
So there's no magic there at all.

559
00:57:23,580 --> 00:57:26,440
Well, what have we done?

560
00:57:26,440 --> 00:57:30,960
We said the old style, traditional style of programming is more efficient.

561
00:57:30,960 --> 00:57:35,260
And the stream thing is more perspicuous.

562
00:57:35,260 --> 00:57:43,350
And we managed to make the stream procedures run like the other procedures by using delay.

563
00:57:43,350 --> 00:57:54,440
And the thing that delay did for us was to de-couple the apparent order of events in our programs from the actual order of events that happened in the machine.

564
00:57:54,440 --> 00:57:56,540
That's really what delay is doing.

565
00:57:56,540 --> 00:57:58,290
That's exactly the whole point.

566
00:57:58,290 --> 00:58:09,182
We've given up the idea that our procedures, as they run, or as we look at them, mirror some clear notion of time.

567
00:58:09,182 --> 00:58:16,690
And by giving that up, we give delay the freedom to arrange the order of events in the computation the way it likes.

568
00:58:16,690 --> 00:58:17,610
That's the whole idea.

569
00:58:17,610 --> 00:58:24,200
We de-couple the apparent order of events in our programs from the actual order of events in the computer.

570
00:58:24,200 --> 00:58:25,770
OK, well there's one more detail.

571
00:58:25,770 --> 00:58:29,730
It's just a technical detail, but it's actually an important one.

572
00:58:29,730 --> 00:58:39,320
As you run through these recursive programs unwinding, you'll see a lot of things that look like tail of the tail of the tail.

573
00:58:39,320 --> 00:58:43,860
That's the kind of thing that would happen as I go CONSing down a stream all the way.

574
00:58:43,860 --> 00:59:05,290
And if each time I'm doing that, each time to compute a tail, I evaluate a procedure which then has to go re-compute its tail, and re-compute its tail and recompute its tail each time, you can see that's very inefficient compared to just having a list where the elements are all there, and I don't have to re-compute each tail every time I get the next tail.

575
00:59:05,290 --> 00:59:20,390
So there's one little hack to slightly change what delay is, and make it a thing which is-- I'll write it this way.

576
00:59:20,390 --> 00:59:31,000
The actual implementation, delay is an abbreviation for this thing, memo-proc of a procedure.

577
00:59:31,000 --> 00:59:35,150
Memo-proc is a special thing that transforms a procedure.

578
00:59:35,150 --> 00:59:44,806
What it does is it takes a procedure of no arguments and it transforms it into a procedure that'll only have to do its computation once.

579
00:59:44,806 --> 00:59:48,700
And what I mean by that is, you give it a procedure.

580
00:59:48,700 --> 01:00:02,360
The result of memo-proc will be a new procedure, which the first time you call it, will run the original procedure, remember what result it got, and then from ever on after, when you call it, it just won't have to do the computation.

581
01:00:02,360 --> 01:00:05,200
It will have cached that result someplace.

582
01:00:05,200 --> 01:00:06,550
And here's an implementation of memo-proc.

583
01:00:11,210 --> 01:00:12,710
Once you have the idea, it's easy to implement.

584
01:00:12,710 --> 01:00:17,390
Memo-proc is this little thing that has two little flags in there.

585
01:00:17,390 --> 01:00:20,320
It says, have I already been run?

586
01:00:20,320 --> 01:00:23,620
And initially it says, no, I haven't already been run.

587
01:00:23,620 --> 01:00:29,070
And what was the result I got the last time I was run?

588
01:00:29,070 --> 01:00:34,360
So memo-proc takes a procedure called proc, and it returns a new procedure of no arguments.

589
01:00:34,360 --> 01:00:38,610
Proc is supposed to be a procedure of no arguments.

590
01:00:38,610 --> 01:00:44,430
And it says, oh, if I'm not already run, then I'm going to do a sequence of things.

591
01:00:44,430 --> 01:00:48,450
I'm going to compute proc, I'm going to save that.

592
01:00:48,450 --> 01:00:51,140
I'm going to stash that in the variable result.

593
01:00:51,140 --> 01:00:56,610
I'm going to make a note to myself that I've already been run, and then I'll return the result.

594
01:00:56,610 --> 01:00:59,010
So that's if you compute it if it's not already run.

595
01:00:59,010 --> 01:01:03,420
If you call it and it's already been run, it just returns the result.

596
01:01:03,420 --> 01:01:08,400
So that's a little clever hack called memorization.

597
01:01:08,400 --> 01:01:15,270
And in this case, it short circuits having to re-compute the tail of the tail of the tail of the tail of the tail.

598
01:01:15,270 --> 01:01:17,810
So there isn't even that kind of inefficiency.

599
01:01:17,810 --> 01:01:24,210
And in fact, the streams will run with pretty much the same efficiency as the other programs precisely.

600
01:01:24,210 --> 01:01:33,610
And remember, again, the whole idea of this is that we've used the fact that there's no really good dividing line between procedures and data.

601
01:01:33,610 --> 01:01:38,760
We've written data structures that, in fact, are sort of like procedures.

602
01:01:38,760 --> 01:01:49,620
And what that's allowed us to do is take an example of a common control structure, in this place iteration.

603
01:01:49,620 --> 01:01:55,496
And we've built a data structure which, since itself is a procedure, kind of has this iteration control structure in it.

604
01:01:55,496 --> 01:01:58,650
And that's really what streams are.

605
01:01:58,650 --> 01:01:59,900
OK, questions?

606
01:02:03,950 --> 01:02:13,052
AUDIENCE: Your description of tail-tail-tail, if I understand it correctly, force is actually execution of a procedure, if it's done without this memo-proc thing.

607
01:02:13,052 --> 01:02:16,380
And you implied that memo-proc gets around that problem.

608
01:02:16,380 --> 01:02:23,910
Doesn't it only get around it if tail-tail-tail is always executing exactly the same-- PROFESSOR: Oh, that's-- sure.

609
01:02:23,910 --> 01:02:26,050
PROFESSOR: I guess I missed that point.

610
01:02:26,050 --> 01:02:26,540
PROFESSOR: Oh, sure.

611
01:02:26,540 --> 01:02:31,290
I mean the point is--  yeah.

612
01:02:31,290 --> 01:02:34,160
I mean I have to do a computation to get the answer.

613
01:02:34,160 --> 01:02:42,980
But the point is, once I've found the tail of the stream, to get the tail of the tail, I shouldn't have had to re-compute the first tail.

614
01:02:42,980 --> 01:02:46,460
See, and if I didn't use memo-proc, that re-computation would have been done.

615
01:02:46,460 --> 01:02:47,710
AUDIENCE: I understand now.

616
01:02:50,830 --> 01:02:56,830
AUDIENCE: In one of your examples, you mentioned that we were able to use the substitution model because there are no side effects.

617
01:02:56,830 --> 01:03:03,620
What if we had a single processing unit-- if we had a side effect, if we had a state?

618
01:03:03,620 --> 01:03:09,120
Could we still practically build the stream model?

619
01:03:09,120 --> 01:03:09,530
PROFESSOR: Maybe.

620
01:03:09,530 --> 01:03:10,540
That's a hard question.

621
01:03:10,540 --> 01:03:18,960
I'm going to talk a little bit later about the places where substitution and side effects don't really mix very well.

622
01:03:18,960 --> 01:03:25,170
But in general, I think the answer is unless you're very careful, any amount of side effect is going to mess up everything.

623
01:03:35,490 --> 01:03:39,410
AUDIENCE: Sorry, I didn't quite understand the memo-proc operation.

624
01:03:39,410 --> 01:03:41,990
When do you execute the lambda?

625
01:03:41,990 --> 01:03:47,600
In other words, when memo-proc is executed, just this lambda expression is being generated.

626
01:03:47,600 --> 01:03:50,390
But it's not clear to me when it's executed.

627
01:03:50,390 --> 01:03:51,350
PROFESSOR: Right.

628
01:03:51,350 --> 01:03:57,930
What memo-proc does-- remember, the thing that's going into memo-proc, the thing proc, is a procedure of no arguments.

629
01:03:57,930 --> 01:04:00,390
And someday, you're going to call it.

630
01:04:00,390 --> 01:04:06,620
Memo-proc translates that procedure into another procedure of no arguments, which someday you're going to call.

631
01:04:06,620 --> 01:04:09,890
That's that lambda.

632
01:04:09,890 --> 01:04:24,100
So here, where I initially built as my tail of the stream, say, this procedure of no arguments, which someday I'll call.

633
01:04:24,100 --> 01:04:30,650
Instead, I'm going to have the tail of the stream be memo-proc of it, which someday I'll call.

634
01:04:30,650 --> 01:04:47,642
So that lambda of nil, that gets called when you call the memo-proc, when you call the result of that memo-proc, which would be ordinarily when you would have called the original thing that you set it.

635
01:04:47,642 --> 01:04:52,610
AUDIENCE: OK, the reason I ask is I had a feeling that when you call memo-proc, you just return this lambda.

636
01:04:52,610 --> 01:04:53,770
PROFESSOR: That's right.

637
01:04:53,770 --> 01:04:58,100
When you call memo-proc, you return the lambda.

638
01:04:58,100 --> 01:05:02,270
You never evaluate the expression at all, until the first time that you would have evaluated it.

639
01:05:07,590 --> 01:05:14,240
AUDIENCE: Do I understand it right that you actually have to build the list up, but the elements of the list don't get evaluated?

640
01:05:14,240 --> 01:05:15,630
The expressions don't get evaluated?

641
01:05:15,630 --> 01:05:18,540
But at each stage, you actually are building a list.

642
01:05:18,540 --> 01:05:20,700
PROFESSOR: That's-- I really should have said this.

643
01:05:20,700 --> 01:05:22,270
That's a really good point.

644
01:05:22,270 --> 01:05:23,660
No, it's not quite right.

645
01:05:23,660 --> 01:05:25,080
Because what happens is this.

646
01:05:25,080 --> 01:05:26,890
Let me draw this as pairs.

647
01:05:26,890 --> 01:05:32,740
Suppose I'm going to make a big stream, like enumerate interval, 1 through 1 billion.

648
01:05:32,740 --> 01:05:43,045
What that is, is a pair with a 1 and a promise.

649
01:05:46,520 --> 01:05:47,890
That's exactly what it is.

650
01:05:47,890 --> 01:05:49,140
Nothing got built up.

651
01:05:51,600 --> 01:05:56,370
When I go and force this, and say, what happens?

652
01:05:56,370 --> 01:06:00,530
Well, this thing is now also recursively a CONS.

653
01:06:00,530 --> 01:06:11,350
So that this promise now is the next thing, which is a 2 and a promise to do more.

654
01:06:11,350 --> 01:06:14,470
And so on and so on and so on.

655
01:06:14,470 --> 01:06:18,200
So nothing gets built up until you walk down the stream.

656
01:06:18,200 --> 01:06:25,500
Because what's sitting here is not the list, but a promise to generate the list. And by promise, technically I mean procedure.

657
01:06:28,050 --> 01:06:30,485
So it doesn't get built up.

658
01:06:30,485 --> 01:06:34,280
Yeah, I should have said that before this point.

659
01:06:34,280 --> 01:06:34,490
OK.

660
01:06:34,490 --> 01:06:34,790
Thank you.

661
01:06:34,790 --> 01:06:36,340
Let's take a break.

