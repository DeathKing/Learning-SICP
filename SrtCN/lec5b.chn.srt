1
00:00:21,170 --> 00:00:36,630
现在，我们已经拥有了通过改变局部状态进行对象建模的力量，我想我们应该找点复杂的东西来演示一下这种力量是多么强大

2
00:00:40,430 --> 00:00:52,060
假设，我们处在这样一个物理系统中，系统中的事物驱动彼此，全部的这些事物组成了世界

3
00:00:52,060 --> 00:00:58,830
每一个事物都有其独立的局部状态

4
00:00:58,830 --> 00:01:01,280
这决定了它属于一个事物

5
00:01:01,280 --> 00:01:10,940
这个模型存在于我们的大脑里，当然它也可以存在于计算机中

6
00:01:10,940 --> 00:01:28,570
我要做的是，把真实世界中事物，相应地在计算机中建立对象，真实世界中事物的联系，相应地在计算机建立对象间的关系，对象与关系与现实世界的事物与联系一一对应

7
00:01:30,840 --> 00:01:34,740
这也就指引了我们如何去模块化

8
00:01:34,740 --> 00:01:50,450
如果我们真的把世界想象成这样，由许多小的事物组成，我们就可以一一对其建模，这样就把世界的模块性传递到了我们的程序这中

9
00:01:50,450 --> 00:01:55,420
这就是面向对象编程的原理所在

10
00:01:55,420 --> 00:01:58,890
我所见过的最完美的对象

11
00:01:58,890 --> 00:02:14,220
非常非常完美，那就是电气系统。电气系统真的是物理学家构造的非常非常好的一种对象

12
00:02:14,220 --> 00:02:16,760
这里我有一些机器零件

13
00:02:16,760 --> 00:02:20,040
确实是机器零件

14
00:02:20,040 --> 00:02:27,190
有一个电线连接起了零件的两个部分

15
00:02:27,190 --> 00:02:38,310
电气世界中有一个非常棒的特性，就是我可以说这是一个对象，这是一个对象，这两个对象连接起来，所有关系一目了然

16
00:02:38,310 --> 00:02:44,740
而且，如果我没有用电线连接，它们便没有关系

17
00:02:44,740 --> 00:02:51,370
比如我有一个灯泡，一个已经接在插座上的电源

18
00:02:51,370 --> 00:02:53,620
关系非常明了

19
00:02:53,620 --> 00:02:56,220
没有另外的关系表现形式

20
00:02:56,220 --> 00:03:04,040
就算我把电线打个结，灯仍然是亮着的

21
00:03:04,040 --> 00:03:05,290
没什么影响

22
00:03:08,300 --> 00:03:15,270
在物理上，这种连接可以被抽象出来，至少在低频状态下是可以的

23
00:03:17,840 --> 00:03:22,350
而且这就是全部的连接方式了

24
00:03:22,350 --> 00:03:30,951
当然，我们来进一步讨论一种在电气系统中最为广泛的抽象，数字电路

25
00:03:30,951 --> 00:03:34,610
这有一些对象元件

26
00:03:34,610 --> 00:03:41,092
例如，在数字电路里我们有像非门这样的东西

27
00:03:41,092 --> 00:03:43,990
还有与门

28
00:03:43,990 --> 00:03:47,210
或门

29
00:03:47,210 --> 00:03:55,610
我们用电线把它们连接起来，电线就是对01信号的抽象

30
00:03:55,610 --> 00:04:05,160
我们不关心具体的物理因素，像电压啊，电流啊，元件怎么组合啊 等等

31
00:04:05,160 --> 00:04:09,420
这些因素统一抽象为信号

32
00:04:09,420 --> 00:04:14,070
我们用电路连接元件，构建系统

33
00:04:14,070 --> 00:04:32,700
一会儿我要向你们介绍一种新的语言，像之前讲过的图形语言一样，都嵌入在LISP中，不是昨天那种模式匹配替换的语言

34
00:04:32,700 --> 00:04:38,160
模式匹配替换的语言还需要用LISP编写另外的程序来解释

35
00:04:38,160 --> 00:04:45,480
但是之前那种绘图语言我们可以随意使用，不管构造过程还是组合数据

36
00:04:45,480 --> 00:04:53,026
举例来说，首先我要有一些原子对象，比如这个，这个

37
00:04:53,026 --> 00:04:55,810
然后用电线去组合它们

38
00:04:55,810 --> 00:04:59,870
(make-wire)构造一个电线

39
00:04:59,870 --> 00:05:01,740
a就代表了一根电线

40
00:05:01,740 --> 00:05:02,690
b也是

41
00:05:02,690 --> 00:05:03,460
c也是

42
00:05:03,460 --> 00:05:04,230
d也是

43
00:05:04,230 --> 00:05:04,830
还有e

44
00:05:04,830 --> 00:05:06,880
还有s

45
00:05:06,880 --> 00:05:17,940
再来看元件，或门有两个输入a和b，一个输出d，就像这样

46
00:05:17,940 --> 00:05:24,820
与门，a和b两个输入，一个输出c

47
00:05:24,820 --> 00:05:32,750
就像这样来声明，我可以组合出任意的电路

48
00:05:32,750 --> 00:05:43,690
我已经说明了原子元素，组合方法，然后就轮到抽象方法了

49
00:05:43,690 --> 00:05:52,240
举例来说，这是一个半加器

50
00:05:52,240 --> 00:05:56,930
如果你学过电路设计肯定知道这个东西

51
00:05:56,930 --> 00:06:03,956
输入两个数a和b，输出“和”和进位

52
00:06:03,956 --> 00:06:07,450
事实上，完全可以用我刚刚说的来组合电路

53
00:06:07,450 --> 00:06:14,790
把半加器看成一个盒子，盒子的边界，抽象出的永远都是一个盒子

54
00:06:14,790 --> 00:06:19,700
从盒子里引出A B S C四根线

55
00:06:19,700 --> 00:06:28,270
这些是已经声明了的变量，我们就用它们来定义半加器

56
00:06:31,400 --> 00:06:48,790
为了连接半加器里面的线路，我构造了电线D和E，E是这个，D是这个，内部连接的线路并没有引出盒子之外，就像这样连起来

57
00:06:48,790 --> 00:06:53,890
你可以看的出来，这个语言非常有层次性

58
00:06:53,890 --> 00:07:06,300
如果一个语言没有层次性，如果你不能把一个复合对象当成原子对象来使用，这个语言肯定是有问题的 -- 至少我这样觉得

59
00:07:06,300 --> 00:07:23,350
之前我们都是从计算一些数字上的函数开始的，现在我们不那样做，我们从一些电路对象开始，构建更多的电路对象

60
00:07:23,350 --> 00:07:30,500
用LISP里的lambda将其粘合起来

61
00:07:30,500 --> 00:07:32,930
lambda是很有用的粘合剂

62
00:07:32,930 --> 00:08:05,900
当然，两个半加器可以组成结构更为复杂的全加器，就像这里这个，把线路连在一起，还需要另外的电线如S，C1和C2，还有一个或门。全加器输入两个数，一个进位值，输出“和”和一个进位值

63
00:08:05,900 --> 00:08:12,990
除此之外，还可以把全加器链起来组成更大的加法器

64
00:08:12,990 --> 00:08:22,270
现在我们的语言有了原子元素，组合方法和抽象方法，才算完整

65
00:08:22,270 --> 00:08:25,000
现在问题来了，如何实现这套语言？

66
00:08:25,000 --> 00:08:27,070
其实并不难

67
00:08:27,070 --> 00:08:28,610
首先来看原子元素

68
00:08:28,610 --> 00:08:31,160
实现原子元素也是整个问题的根本所在

69
00:08:31,160 --> 00:08:43,417
至于组合方法与抽象方法完全不用亲自实现，因为语言嵌入在LISP中可以直接使用LISP中的这种机制

70
00:08:43,417 --> 00:08:45,860
好的，我们先来看一个原子元素

71
00:08:45,860 --> 00:08:47,400
非门吧

72
00:08:51,540 --> 00:08:54,900
非门有两个引脚，一个输入，一个输出

73
00:08:57,440 --> 00:09:04,300
有信号输入的时候它要做点什么

74
00:09:04,300 --> 00:09:20,120
它和输入的电线说 -- 我们开始讨论一些关于对象的东西，细节之处以后再谈 -- 它需要对作为输入的电线的说 “当你的值变的时候，告诉我一声”

75
00:09:20,120 --> 00:09:26,870
所以非门可能会这样和这个输入对象交流， “Hi，我是George”

76
00:09:26,870 --> 00:09:31,720
“我的工作就是，当你变化的时候对结果做一点修改”

77
00:09:31,720 --> 00:09:34,730
“所以当你变化的时候，告诉我一声”

78
00:09:34,730 --> 00:09:37,010
“因为我需要这个去做点别的”

79
00:09:37,010 --> 00:09:56,130
我们在这里为in添加一个动作invert-in，它在这里定义，是一个无参数的过程，对线路上的信号取反

80
00:09:56,130 --> 00:10:07,140
在一段延时之后，就是inverter-delay -- 每个电路对象都有延时 -- 我们再把输出设置为新的值

81
00:10:10,160 --> 00:10:12,400
非常简单

82
00:10:12,400 --> 00:10:23,840
你可以这样理解，这个作为输出的电线很有灵性，当信号改变的时候，它就奔走相告

83
00:10:23,840 --> 00:10:26,050
“我的值已经改变啦”

84
00:10:26,050 --> 00:10:36,810
所以当你把非门和与门或者其它的什么连在一起的时候，其中会有很多类似“奔走相告”的过程，确保信号以正确的方式传递

85
00:10:36,810 --> 00:10:38,620
到了这里反而很平常

86
00:10:38,620 --> 00:10:46,240
logical-not只是把0，1换成1，0罢了

87
00:10:46,240 --> 00:10:49,780
与门就相对复杂一些

88
00:10:49,780 --> 00:10:56,950
与门有两个输入A1，A2，输出是output

89
00:10:56,950 --> 00:11:00,860
但是其结构和非门没有什么大的不同

90
00:11:00,860 --> 00:11:10,910
当输入信号改变的时候，就执行过程and-action

91
00:11:10,910 --> 00:11:15,900
And what it does, of course, is nothing more than compute the logical and of the signals on the inputs.

92
00:11:15,900 --> 00:11:25,470
And after some delay, called the and-gate delay, calls this procedure, which sets a signal on the output to a new value.

93
00:11:25,470 --> 00:11:28,350
Now, how I implement these things is all wishful thinking.

94
00:11:28,350 --> 00:11:32,020
As you see here, I have an assignment operation.

95
00:11:32,020 --> 00:11:34,570
It's not set.

96
00:11:34,570 --> 00:11:46,340
It's a derived assignment operation in the same way we had functions that were derived from CAR and CDR. So I, by convention, label that with an exclamation point.

97
00:11:46,340 --> 00:12:03,350
And over here, you see there's an action, which is to inform the wire, called A1 locally in this and-gate, to call the and-action procedure when it gets changed, and the wire A2 to call the and-action procedure when it gets changed.

98
00:12:06,310 --> 00:12:09,510
All very simple.

99
00:12:09,510 --> 00:12:18,310
Well, let's talk a little bit about this communication that must occur between these various parts.

100
00:12:18,310 --> 00:12:47,360
Suppose, for example, I have a very simple circuit which contains an and with wires A and B. And that connects through a wire called C to an inverter which has a wire output called D. What are the comput...--here's the physical world.

101
00:12:47,360 --> 00:12:49,860
It's an abstraction of the physical world.

102
00:12:49,860 --> 00:12:54,880
Now I can buy these out of little pieces that you get at Radio Shack for a few cents.

103
00:12:54,880 --> 00:13:01,530
And there are boxes that act like this, which have little numbers on them like LS04 or something.

104
00:13:01,530 --> 00:13:09,010
Now supposing I were to try to say what's the computational model.

105
00:13:09,010 --> 00:13:15,850
What is the thing that corresponds to that, that part of reality in the mind of us and in the computer?

106
00:13:15,850 --> 00:13:25,750
Well, I have to assign for every object in the world an object in the computer, and for every relationship in the world between them a relationship in the computer.

107
00:13:25,750 --> 00:13:28,560
That's my goal.

108
00:13:28,560 --> 00:13:30,900
So let's do that.

109
00:13:30,900 --> 00:13:35,401
Well, I have some sort of thing called the signal, A.

110
00:13:35,401 --> 00:13:37,940
This is A. It's a signal.

111
00:13:37,940 --> 00:13:39,900
It's a cloudy thing like that.

112
00:13:39,900 --> 00:13:49,140
And I have another one down here which I'm going to call B. It's another signal.

113
00:13:49,140 --> 00:14:00,320
Now this signal--these two signals are somehow going to have to hook together into a box, let's call it this, which is the and-gate, action procedure.

114
00:14:00,320 --> 00:14:02,040
That's the and-gate's action procedure.

115
00:14:07,660 --> 00:14:30,195
And it's going to produce--well, it's going to interact with a signal object, which we call C--a wire object, excuse me, we call C. And then the-- this is going to put out again, or connect to, another action procedure which is one associated with the inverter in the world, not.

116
00:14:32,860 --> 00:14:42,970
And I'm going to have another--another wire, which we'll call D.

117
00:14:42,970 --> 00:14:45,770
So here's my layout of stuff.

118
00:14:45,770 --> 00:14:51,500
Now we have to say what's inside them and what they have to know to compute.

119
00:14:51,500 --> 00:14:57,340
Well, every--every one of these wires has to know what the value of the signal that's on that wire is.

120
00:14:57,340 --> 00:15:00,680
So there's going to be some variable inside here, we'll call it signal.

121
00:15:02,670 --> 00:15:05,840
And he owns a value.

122
00:15:05,840 --> 00:15:08,656
So there must be some environment associated with this.

123
00:15:08,656 --> 00:15:11,800
And for each one of these, there must be an environment that binds signal.

124
00:15:15,400 --> 00:15:16,880
And there must be a signal here, therefore.

125
00:15:19,400 --> 00:15:24,170
And presumably, signal's a value that's either 1 or 0, and signal.

126
00:15:28,000 --> 00:15:34,390
Now, we also have to have some list of people to inform if the signal here changes.

127
00:15:36,660 --> 00:15:39,300
We're going to have to inform this.

128
00:15:39,300 --> 00:15:44,500
So I've got that list. We'll call it the Action Procedures, AP.

129
00:15:44,500 --> 00:15:50,500
And it's presumably a list. But the first thing on the list, in this case, is this guy.

130
00:15:50,500 --> 00:15:54,810
And the action procedures of this one happens to have some list of stuff.

131
00:15:54,810 --> 00:15:59,020
There might be other people who are sharing A, who are looking at it.

132
00:15:59,020 --> 00:16:03,630
So there might be other guys on this list, like somebody over there that we don't know about.

133
00:16:03,630 --> 00:16:07,200
It's the other guy attached to A.

134
00:16:07,200 --> 00:16:13,070
And the action procedure here also has to point to that, the list of action procedures.

135
00:16:13,070 --> 00:16:18,530
And of course, that means this one, its action procedures has to point up to here.

136
00:16:18,530 --> 00:16:21,770
This is the things-- the people it has to inform.

137
00:16:21,770 --> 00:16:24,280
And this guy has some too.

138
00:16:24,280 --> 00:16:27,190
But I don't know what they are because I didn't draw it in my diagram.

139
00:16:27,190 --> 00:16:30,320
It's the things connected to D.

140
00:16:30,320 --> 00:16:52,790
Now, it's also the case that when the and-action procedure is awakened, saying one of the people who know that you've told--one of the people you've told to wake you up if their signal changes, you have to go look and ask them what's their signal so you can do the and, and produce a signal for this one.

141
00:16:57,090 --> 00:17:06,400
So there has to be, for example, information here saying A1, my A1 is this guy, and my A2 is this guy.

142
00:17:08,930 --> 00:17:16,170
And not only that, when I do my and, I'm going to have to tell this guy something.

143
00:17:16,170 --> 00:17:21,160
So I need an output--  being this guy.

144
00:17:25,800 --> 00:17:43,520
And similarly, this guy's going to have a thing called the input that he interrogates to find out what the value of the signal on the input is, when the signal wakes up and says, I've changed, and sends a message this way saying, I've changed.

145
00:17:43,520 --> 00:17:46,900
This guy says, OK, what's your value now?

146
00:17:46,900 --> 00:17:55,860
When he gets that value, then he's going to have to say, OK, output changes this guy, changes this guy.

147
00:18:00,600 --> 00:18:02,481
And so on.

148
00:18:02,481 --> 00:18:06,240
And so I have to have at least that much connected-ness.

149
00:18:06,240 --> 00:18:10,260
Now, let's go back and look, for example, at the and-gate.

150
00:18:10,260 --> 00:18:13,670
Here we are back on this slide.

151
00:18:13,670 --> 00:18:16,040
And we can see some of these parts.

152
00:18:16,040 --> 00:18:21,030
For any particular and-gate, there is an A1, there is an A2, and the output.

153
00:18:21,030 --> 00:18:46,240
And those are, those are an environment that was created at the--those produce a frame at the time and-gate was called, a frame where A1, A2, and output are--have as their values, they're bound to the wires which, they are--which were passed in.

154
00:18:46,240 --> 00:18:54,590
In that environment, I constructed a procedure-- this one right there.

155
00:18:54,590 --> 00:18:57,780
And-action procedure was constructed in that environment.

156
00:18:57,780 --> 00:19:01,620
That was the result of evaluating a lambda expression.

157
00:19:01,620 --> 00:19:07,620
So it hangs onto the frame where these were defined.

158
00:19:07,620 --> 00:19:11,700
Local--part of its local state is that.

159
00:19:11,700 --> 00:19:17,310
The and-action procedure, therefore, has access to A1, A2, and output as we see here.

160
00:19:17,310 --> 00:19:19,645
A1, A2, and output.

161
00:19:22,360 --> 00:19:26,030
Now, we haven't looked inside of a wire yet.

162
00:19:26,030 --> 00:19:29,030
That's all that remains.

163
00:19:29,030 --> 00:19:30,280
Let's look at a wire.

164
00:19:33,520 --> 00:19:36,160
Like the overhead, very good.

165
00:19:39,500 --> 00:19:43,090
Well, the wire, again, is a, is a somewhat complicated mess.

166
00:19:43,090 --> 00:19:46,840
Ooh, wrong one.

167
00:19:46,840 --> 00:19:49,780
It's a big complicated mess, like that.

168
00:19:49,780 --> 00:19:54,720
But let's look at it in detail and see what's going on.

169
00:19:54,720 --> 00:19:57,760
Well, the wire is one of these.

170
00:19:57,760 --> 00:20:05,010
And it has to have two things that are part of it, that it's state.

171
00:20:05,010 --> 00:20:07,390
One of them is the signal we see here.

172
00:20:07,390 --> 00:20:19,270
In other words, when we call make-wire to make a wire, then the first thing we do is we create some variables which are the signal and the action procedures for this wire.

173
00:20:22,042 --> 00:20:27,840
And in that context, we define various functions--or procedures, excuse me, procedures.

174
00:20:27,840 --> 00:20:32,850
One of them is called set-my-signal to a new value.

175
00:20:32,850 --> 00:20:37,930
And what that does is takes a new value in.

176
00:20:37,930 --> 00:20:40,360
If that's equal to my current value of my signal, I'm done.

177
00:20:40,360 --> 00:20:54,630
Otherwise, I set the signal to the new value and call each of the action procedures that I've been, that I've been--what's the right word?--  introduced to.

178
00:20:54,630 --> 00:21:01,530
I get introduced when the and-gate was applied to me.

179
00:21:04,130 --> 00:21:07,410
I add action procedure at the bottom.

180
00:21:07,410 --> 00:21:27,780
Also, I have to define a way of accepting an action procedure-- which is what you see here--- which increments my action procedures using set to the result of CONSing up a new process--a procedure, which is passed to me, on to my actions procedures list. And for technical reasons, I have to call that procedure one.

181
00:21:27,780 --> 00:21:36,950
So I'm not going to tell you anything about that, that has to do with event-driven simulations and getting them started, which takes a little bit of thinking.

182
00:21:36,950 --> 00:21:53,820
And finally, I'm going to define a thing called the dispatcher, which is a way of passing a message to a wire, which is going to be used to extract from it various information, like what is the current signal value?

183
00:21:53,820 --> 00:21:57,180
What is the method of setting your signal?

184
00:21:57,180 --> 00:22:00,100
I want to get that out of it.

185
00:22:00,100 --> 00:22:02,600
How do I--how do I add another action procedure?

186
00:22:05,510 --> 00:22:09,940
And I'm going to return that dispatch, that procedure as a value.

187
00:22:09,940 --> 00:22:19,790
So the wire that I've constructed is a message accepting object which accepts a message like, like what's your method of adding action procedures?

188
00:22:19,790 --> 00:22:29,010
In fact, it'll give me a procedure, which is the add action procedure, which I can then apply to an action procedure to create another action procedure in the wire.

189
00:22:31,620 --> 00:22:32,820
So that's a permission.

190
00:22:32,820 --> 00:22:37,450
So it's given me permission to change your action procedures.

191
00:22:37,450 --> 00:22:41,710
And in fact, you can see that over here.

192
00:22:41,710 --> 00:22:43,278
Next slide.

193
00:22:43,278 --> 00:22:44,528
Ah.

194
00:22:47,760 --> 00:22:49,120
This is nothing very interesting.

195
00:22:49,120 --> 00:22:54,990
The call each of the action procedures is just a CDRing down a list. And I'm not going to even talk about that anymore.

196
00:22:54,990 --> 00:22:57,560
We're too advanced for that.

197
00:22:57,560 --> 00:23:03,090
However, if I want to get a signal from a wire, I ask the wire-- which is, what is the wire?

198
00:23:03,090 --> 00:23:05,860
The wire is the dispatch returned by creating the wire.

199
00:23:05,860 --> 00:23:06,830
It's a procedure.

200
00:23:06,830 --> 00:23:12,590
I call that dispatch on the message get-signal.

201
00:23:12,590 --> 00:23:16,900
And what I should expect to get is a method of getting a signal.

202
00:23:16,900 --> 00:23:19,220
Or actually, I get the signal.

203
00:23:19,220 --> 00:23:38,700
If I want to set a signal, I want to change a signal, then what I'm going to do is take a wire as an argument and a new value for the signal, I'm going to ask the wire for permission to set its signal and use that permission, which is a procedure, on the new value.

204
00:23:38,700 --> 00:24:13,010
And if we go back to the overhead here, thank you, if we go back to the overhead here, we see that the method-- if I ask for the method of setting the signal, that's over here, it's set-my-signal, a procedure that's defined inside the wire, which if we look over here is the thing that says set my internal value called the signal, my internal variable, which is the signal, to the new value, which is passed to me as an argument, and then call each of the action procedures waking them up.

205
00:24:16,340 --> 00:24:19,400
Very simple.

206
00:24:19,400 --> 00:24:30,100
Going back to that slide, we also have the one last thing-- which I suppose now you can easily work out for yourself-- is the way you add an action.

207
00:24:30,100 --> 00:24:36,470
You take a wire--a wire and an action procedure.

208
00:24:36,470 --> 00:24:40,050
And I ask the wire for permission to add an action.

209
00:24:40,050 --> 00:24:45,020
Getting that permission, I use that permission to give it an action procedure.

210
00:24:45,020 --> 00:24:48,570
So that's a real object.

211
00:24:48,570 --> 00:24:52,460
There's a few more details about this.

212
00:24:52,460 --> 00:24:58,390
For example, how am I going to control this thing?

213
00:24:58,390 --> 00:25:01,290
How do I do these delays?

214
00:25:01,290 --> 00:25:02,540
Let's look at that for a second.

215
00:25:05,275 --> 00:25:08,360
The next one here.

216
00:25:08,360 --> 00:25:09,570
Let's see.

217
00:25:09,570 --> 00:25:18,770
We know when we looked at the and-gate or the not-gate that when a signal changed on the input, there was a delay.

218
00:25:18,770 --> 00:25:23,310
And then it was going to call the procedure, which was going to change the output.

219
00:25:26,040 --> 00:25:28,120
Well, how are we going to do this?

220
00:25:28,120 --> 00:25:34,720
We're going to make up some mechanism, a fairly complicated mechanism at that, which we're going to have to be very careful about.

221
00:25:34,720 --> 00:25:37,390
But after a delay, we're going to do an action.

222
00:25:37,390 --> 00:25:40,590
A delay is a number, and an action is a procedure.

223
00:25:40,590 --> 00:25:49,510
What that's going to be is they're going to have a special structure called an agenda, which is a thing that organizes time and actions.

224
00:25:49,510 --> 00:25:50,880
And we're going to see that in a while.

225
00:25:50,880 --> 00:25:53,070
I don't want to get into that right now.

226
00:25:53,070 --> 00:25:59,130
But the agenda has a moment at which--at which something happens.

227
00:25:59,130 --> 00:26:08,460
We're setting up for later at some moment, which is the sum of the time, which is the delay time plus the current time, which the agenda thinks is now.

228
00:26:08,460 --> 00:26:13,090
We're going to set up to do this action, and add that to the agenda.

229
00:26:15,280 --> 00:26:18,660
And the way this machine will now run is very simple.

230
00:26:18,660 --> 00:26:22,710
We have a thing called propagate, which is the way things run.

231
00:26:22,710 --> 00:26:27,440
If the agenda is empty, we're done--if there's nothing more to be done.

232
00:26:27,440 --> 00:26:34,200
Otherwise, we're going to take the first item off the agenda, and that's a procedure of no arguments.

233
00:26:34,200 --> 00:26:36,030
So that we're going to see extra parentheses here.

234
00:26:36,030 --> 00:26:39,190
We call that on no arguments.

235
00:26:39,190 --> 00:26:42,200
That takes the action.

236
00:26:42,200 --> 00:26:48,395
Then we remove that first item from the agenda, and we go around the propagation loop.

237
00:26:48,395 --> 00:26:50,750
So that's the overall structure of this thing.

238
00:26:53,380 --> 00:26:57,430
Now, there's a, a few other things we can look at.

239
00:26:57,430 --> 00:27:00,410
And then we're going to look into the agenda a little while from now.

240
00:27:00,410 --> 00:27:02,800
Now the overhead again.

241
00:27:02,800 --> 00:27:07,410
Well, in order to set this thing going, I just want to show you some behavior out of this simulator.

242
00:27:07,410 --> 00:27:12,370
By the way, you may think this simulator is very simple, and probably too simple to be useful.

243
00:27:12,370 --> 00:27:18,680
The fact of the matter is that this simulator has been used to manufacture a fairly large computer.

244
00:27:18,680 --> 00:27:22,360
So this is a real live example.

245
00:27:22,360 --> 00:27:25,560
Actually, not exactly this simulator, because I'll tell you the difference.

246
00:27:25,560 --> 00:27:29,820
The difference is that there were many more different kinds of primitives.

247
00:27:29,820 --> 00:27:33,200
There's not just the word inverter or and-gate.

248
00:27:33,200 --> 00:27:45,170
There were things like edge-triggered, flip-flops, and latches, transparent latches, and adders, and things like that.

249
00:27:45,170 --> 00:27:54,690
And the difficulty with that is that there's pages and pages of the definitions of all these primitives with numbers like LS04.

250
00:27:54,690 --> 00:27:56,740
And then there's many more parameters for them.

251
00:27:56,740 --> 00:27:58,480
It's not just one delay.

252
00:27:58,480 --> 00:28:01,220
There's things like set up times and hold times and all that.

253
00:28:01,220 --> 00:28:15,110
But with the exception of that part of the complexity, the structure of the simulator that we use for building a real computer, that works is exactly what you're seeing here.

254
00:28:15,110 --> 00:28:19,270
Well in any case, what we have here is a few simple things.

255
00:28:19,270 --> 00:28:23,030
Like, there's inverter delays being set up and making a new agenda.

256
00:28:23,030 --> 00:28:26,470
And then we can make some inputs.

257
00:28:26,470 --> 00:28:29,460
There's input-1, input-2, a sum and a carry, which are wires.

258
00:28:29,460 --> 00:28:37,810
I'm going to put a special kind of object called a probe onto, onto some of the wires, onto sum and onto carry.

259
00:28:37,810 --> 00:28:46,120
A probe is a, can object that has the property that when you change a wire it's attached to, it types out a message.

260
00:28:46,120 --> 00:28:47,970
It's an easy thing to do.

261
00:28:47,970 --> 00:28:59,400
And then once we have that, of course, the way you put the probe on, the first thing it does, it says, the current value of the sum at time 0 is 0 because I just noticed it.

262
00:28:59,400 --> 00:29:05,556
And the value of the carry at time 0, this is the time, is 0.

263
00:29:05,556 --> 00:29:09,620
And then we go off and we build some structure.

264
00:29:09,620 --> 00:29:18,420
Like, we can build a structure here that says you have a half-adder on input-1, input-2, sum, and carry.

265
00:29:18,420 --> 00:29:20,420
And we're going to set the signal on input-1 to 1.

266
00:29:20,420 --> 00:29:21,880
We do some propagation.

267
00:29:21,880 --> 00:29:29,520
At time 8, which you could see going through this thing if you wanted to, the new value of sum became 1.

268
00:29:29,520 --> 00:29:31,150
And the thing says I'm done.

269
00:29:31,150 --> 00:29:32,630
That wasn't very interesting.

270
00:29:32,630 --> 00:29:34,150
But we can send it some more signals.

271
00:29:34,150 --> 00:29:36,590
Like, we set-signal on input-2 to be one.

272
00:29:36,590 --> 00:29:45,040
And at that time if we propagate, then it carried at 11, the carry becomes 1, and at 16, the sum's new value becomes 0.

273
00:29:45,040 --> 00:29:48,990
And you might want to work out that, if you like, about the digital circuitry.

274
00:29:48,990 --> 00:29:50,620
It's true, and it works.

275
00:29:50,620 --> 00:29:51,535
And it's not very interesting.

276
00:29:51,535 --> 00:29:54,580
But that's the kind of behavior we get out of this thing.

277
00:30:01,830 --> 00:30:12,952
So what I've shown you right now is a large-scale picture, how you, at a bigger, big scale, you implement an event-driven simulation of some sort.

278
00:30:12,952 --> 00:30:21,225
And how you might organize it to have nice hierarchical structure allowing you to build abstract boxes that you can instantiate.

279
00:30:21,225 --> 00:30:25,780
But I haven't told you any of the details about how this agenda and things like that work.

280
00:30:25,780 --> 00:30:28,630
That we'll do next.

281
00:30:28,630 --> 00:30:34,310
And that's going to involve change and mutation of data and things like that.

282
00:30:34,310 --> 00:30:35,860
Are there any questions now, before I go on?

283
00:30:47,160 --> 00:30:47,550
Thank you.

284
00:30:47,550 --> 00:30:48,800
Let's take a break.

285
00:31:28,940 --> 00:31:35,060
Well, we've been making a simulation.

286
00:31:35,060 --> 00:31:43,920
And the simulation is an event-driven simulation where the objects in the world are the objects in the computer.

287
00:31:43,920 --> 00:32:04,420
And the changes of state that are happening in the world in time are organized to be time in the computer, so that if something happens after something else in the world, then we have it happen after, after the corresponding events happen in the same order in the computer.

288
00:32:04,420 --> 00:32:08,220
That's where we have assignments, when we make that alignment.

289
00:32:08,220 --> 00:32:16,040
Right now I want to show you a way of organizing time, which is an agenda or priority queue, it's sometimes called.

290
00:32:16,040 --> 00:32:21,230
We'll do some--we'll do a little bit of just understanding what are the things we need to be able to do to make agendas.

291
00:32:28,330 --> 00:32:35,960
And so we're going to have--and so right now over here, I'm going to write down a bunch of primitive operations for manipulating agendas.

292
00:32:35,960 --> 00:32:43,680
I'm not going to show you the code for them because they're all very simple, and you've got listings of all that anyway.

293
00:32:43,680 --> 00:32:44,380
So what do we have?

294
00:32:44,380 --> 00:32:54,130
We have things like make-agenda which produces a new agenda.

295
00:32:59,860 --> 00:33:12,625
We can ask--we get the current-time of an agenda, which gives me a number, a time.

296
00:33:16,990 --> 00:33:21,900
We can get--we can ask whether an agenda is empty, empty-agenda.

297
00:33:30,200 --> 00:33:32,570
And that produces either a true or a false.

298
00:33:42,590 --> 00:33:44,720
We can add an object to an agenda.

299
00:33:52,710 --> 00:33:56,910
Actually, what we add to an agenda is an operation--an action to be done.

300
00:33:56,910 --> 00:34:04,810
And that takes a time, the action itself, and the agenda I want to add it to.

301
00:34:07,850 --> 00:34:10,719
That inserts it in the appropriate place in the agenda.

302
00:34:10,719 --> 00:34:23,259
I can get the first item off an agenda, the first thing I have to do, which is going to give me an action.

303
00:34:26,085 --> 00:34:29,540
And I can remove the first item from an agenda.

304
00:34:29,540 --> 00:34:31,409
That's what I have to be able to do with agendas.

305
00:34:31,409 --> 00:34:33,020
That is a big complicated mess.

306
00:34:42,530 --> 00:34:43,780
From an agenda.

307
00:34:45,530 --> 00:34:52,528
Well, let's see how we can organize this thing as a data structure a bit.

308
00:34:52,528 --> 00:35:01,570
Well, an agenda is going to be some kind of list. And it's going to be a list that I'm going to have to be able to modify.

309
00:35:01,570 --> 00:35:11,070
So we have to talk about modifying of lists, because I'm going to add things to it, and delete things from it, and things like that.

310
00:35:11,070 --> 00:35:13,820
It's organized by time.

311
00:35:13,820 --> 00:35:15,570
It's probably good to keep it in sorted order.

312
00:35:18,330 --> 00:35:23,420
But sometimes there are lots of things that happen at the same time--approximate same time.

313
00:35:23,420 --> 00:35:29,040
What I have to do is say, group things by the time at which they're supposed to happen.

314
00:35:29,040 --> 00:35:32,780
So I'm going to make an agenda as a list of segments.

315
00:35:32,780 --> 00:35:39,620
And so I'm going to draw you a data structure for an agenda, a perfectly reasonable one.

316
00:35:39,620 --> 00:35:41,110
Here's an agenda.

317
00:35:41,110 --> 00:35:42,870
It's a thing that begins with a name.

318
00:35:47,630 --> 00:35:49,940
I'm going to do it right now out of list structure.

319
00:35:52,620 --> 00:35:53,980
It's got a header.

320
00:35:53,980 --> 00:35:55,840
There's a reason for the header.

321
00:35:55,840 --> 00:35:57,630
We're going to see the reason soon.

322
00:36:00,680 --> 00:36:03,750
And it will have a segment.

323
00:36:03,750 --> 00:36:05,620
It will have--it will be a list of segments.

324
00:36:08,310 --> 00:36:33,320
Supposing this agenda has two segments, they're the car's-- successive car's of this list. Each segment is going to have a time--  say for example, 10-- that says that the things that happen in this segment are at time 10.

325
00:36:33,320 --> 00:36:42,240
And what I'm going to have in here is another data structure which I'm not going to describe, which is a queue of things to do at time 10.

326
00:36:42,240 --> 00:36:43,330
It's a queue.

327
00:36:43,330 --> 00:36:45,130
And we'll talk about that in a second.

328
00:36:45,130 --> 00:36:50,200
But abstractly, the queue is just a list of things to do at a particular time.

329
00:36:50,200 --> 00:36:53,100
And I can add things to a queue.

330
00:36:53,100 --> 00:36:56,140
This is a queue.

331
00:36:56,140 --> 00:36:59,115
There's a time, there's a segment.

332
00:37:02,889 --> 00:37:06,035
Now, I may have another segment in this agenda.

333
00:37:08,940 --> 00:37:13,410
Supposing this is stuff that happens at time 30.

334
00:37:13,410 --> 00:37:23,210
It has, of course, another queue of things that are queued up to be done at time 30.

335
00:37:23,210 --> 00:37:27,090
Well, there are various things I have to be able to do to an agenda.

336
00:37:27,090 --> 00:37:33,030
Supposing I want to add to an agenda another thing to be done at time 10.

337
00:37:33,030 --> 00:37:34,700
Well, that's not very hard.

338
00:37:34,700 --> 00:37:39,730
I'm going to walk down here, looking for the segment of time 10.

339
00:37:39,730 --> 00:37:42,930
It is possible that there is no segment of time 10.

340
00:37:42,930 --> 00:37:45,420
We'll cover that case in a second.

341
00:37:45,420 --> 00:37:56,290
But if I find a segment of time 10, then if I want to add another thing to be done at time 10, I just increase that queue-- "just increase" isn't such an obvious idea.

342
00:37:56,290 --> 00:38:01,430
But I increase the things to be done at that time.

343
00:38:01,430 --> 00:38:05,140
Now, supposing I want to add something to be done at time 20.

344
00:38:05,140 --> 00:38:08,680
There is no segment for time 20.

345
00:38:08,680 --> 00:38:11,340
I'm going to have to create a new segment.

346
00:38:11,340 --> 00:38:17,610
I want my time 20 segment to exist between time 10 and time 30.

347
00:38:17,610 --> 00:38:20,170
Well, that takes a little work.

348
00:38:20,170 --> 00:38:21,525
I'm going to have to do a CONS.

349
00:38:24,260 --> 00:38:29,940
I'm going to have to make a new element of the agenda list--list of segments.

350
00:38:33,600 --> 00:38:35,400
I'm going to have to change.

351
00:38:35,400 --> 00:38:37,540
Here's change.

352
00:38:37,540 --> 00:38:56,657
I'm going to have to change the CDR of the CDR of the agenda to point that a new CONS of the new segment and the CDR of the CDR of the CDR of the agenda, the CD-D-D-DR.

353
00:38:56,657 --> 00:39:06,290
And this is going to have a new segment now of time 20 with its own queue, which now has one element in it.

354
00:39:10,730 --> 00:39:20,770
If I wanted to add something at the end, I'm going to have to replace the CDR of this, of this list with something.

355
00:39:20,770 --> 00:39:24,040
We're going to have to change that piece of data structure.

356
00:39:24,040 --> 00:39:27,210
So I'm going to need new primitives for doing this.

357
00:39:27,210 --> 00:39:29,550
But I'm just showing you why I need them.

358
00:39:29,550 --> 00:39:49,400
And finally, if I wanted to add a thing to be done at time 5, I'm going to have to change this one, because I'm going to have to add it in over here, which is why I planned ahead and had a header cell, which has a place.

359
00:39:49,400 --> 00:39:53,420
If I'm going to change things, I have to have places for the change.

360
00:39:53,420 --> 00:39:58,600
I have to have a place to make the change.

361
00:39:58,600 --> 00:40:02,540
If I remove things from the agenda, that's not so hard.

362
00:40:02,540 --> 00:40:11,220
Removing them from the beginning is pretty easy, which is the only case I have. I can go looking for the first, the first segment.

363
00:40:11,220 --> 00:40:14,510
I see if it has a non-empty queue.

364
00:40:14,510 --> 00:40:20,100
If it has a non-empty queue, well, I'm going to delete one element from the queue, like that.

365
00:40:20,100 --> 00:40:24,220
If the queue ever becomes empty, then I have to delete the whole segment.

366
00:40:24,220 --> 00:40:28,220
And then this, this changes to point to here.

367
00:40:28,220 --> 00:40:36,440
So it's quite a complicated data structure manipulation going on, the details of which are not really very exciting.

368
00:40:36,440 --> 00:40:38,920
Now, let's talk about queues.

369
00:40:38,920 --> 00:40:41,160
They're similar.

370
00:40:41,160 --> 00:40:44,340
Because each of these agendas has a queue in it.

371
00:40:44,340 --> 00:40:45,590
What's a queue?

372
00:40:49,079 --> 00:40:52,350
A queue is going to have the following primitive operations.

373
00:40:52,350 --> 00:41:02,170
To make a queue, this gives me a new queue.

374
00:41:07,274 --> 00:41:16,850
I'm going to have to be able to insert into a queue a new item.

375
00:41:24,510 --> 00:41:28,740
I'm going to have to be able to delete from a queue the first item in the queue.

376
00:41:39,988 --> 00:41:52,890
And I want to be able to get the first thing in the queue from some queue.

377
00:41:52,890 --> 00:41:55,140
I also have to be able to test whether a queue is empty.

378
00:42:07,110 --> 00:42:15,120
And when you invent things like this, I want you to be very careful to use the kinds of conventions I use for naming things.

379
00:42:15,120 --> 00:42:19,870
Notice that I'm careful to say these change something and that tests it.

380
00:42:19,870 --> 00:42:24,335
And presumably, I did the same thing over here.

381
00:42:24,335 --> 00:42:29,240
OK, and there should be an empty test over here.

382
00:42:29,240 --> 00:42:31,720
OK, well, how would I make a queue?

383
00:42:31,720 --> 00:42:37,840
A queue wants to be something I can add to at the end of, and pick up the thing at the beginning of.

384
00:42:37,840 --> 00:42:41,230
I should be able to delete from the beginning and add to the end.

385
00:42:41,230 --> 00:42:43,740
Well, I'm going to show you a very simple structure for that.

386
00:42:43,740 --> 00:42:47,080
We can make this out of CONSes as well.

387
00:42:47,080 --> 00:42:49,910
Here's a queue.

388
00:42:49,910 --> 00:42:59,610
It has--it has a queue header, which contains two parts-- a front pointer and a rear pointer.

389
00:43:02,930 --> 00:43:09,000
And here I have a queue with two items in it.

390
00:43:09,000 --> 00:43:12,095
The first item, I don't know, it's perhaps a 1.

391
00:43:12,095 --> 00:43:16,530
And the second item, I don't know, let's give it a 2.

392
00:43:21,160 --> 00:43:31,850
The reason why I want two pointers in here, a front pointer and a rear pointer, is so I can add to the end without having to chase down from the beginning.

393
00:43:31,850 --> 00:43:47,530
So for example, if I wanted to add one more item to this queue, if I want to add on another item to be worried about later, all I have to do is make a CONS, which contains that item, say a 3.

394
00:43:47,530 --> 00:43:51,340
That's for inserting 3 into the queue.

395
00:43:51,340 --> 00:44:00,100
Then I have to change this pointer here to here.

396
00:44:00,100 --> 00:44:04,320
And I have to change this one to point to the new rear.

397
00:44:09,120 --> 00:44:18,890
If I wish to take the first element of the queue, the first item, I just go chasing down the front pointer until I find the first one and pick it up.

398
00:44:18,890 --> 00:44:27,450
If I wish to delete the first item from the queue, delete-queue, all I do is move the front pointer along this way.

399
00:44:27,450 --> 00:44:31,700
The new front of the queue is now this.

400
00:44:31,700 --> 00:44:34,390
So queues are very simple too.

401
00:44:34,390 --> 00:44:41,350
So what you see now is that I need a certain number of new primitive operations.

402
00:44:41,350 --> 00:44:42,560
And I'm going to give them some names.

403
00:44:42,560 --> 00:44:47,350
And then we're going to look into how they work, and how they're used.

404
00:44:47,350 --> 00:44:58,940
We have set the CAR of some pair, or a thing produced by CONSing, to a new value.

405
00:45:02,370 --> 00:45:09,920
And set the CDR of a pair to a new value.

406
00:45:12,680 --> 00:45:16,030
And then we're going to look into how they work.

407
00:45:16,030 --> 00:45:20,960
I needed setting CAR over here to delete the first element of the queue.

408
00:45:20,960 --> 00:45:23,470
This is the CAR, and I had to set it.

409
00:45:23,470 --> 00:45:30,160
I had to be able to set the CDR to be able to move the rear pointer, or to be able to increment the queue here.

410
00:45:30,160 --> 00:45:35,515
All of the operations I did were made out of those that I just showed you on the, on the last blackboard.

411
00:45:38,230 --> 00:45:38,430
Good.

412
00:45:38,430 --> 00:45:40,357
Let's pause the time, and take a little break then.

413
00:46:38,346 --> 00:47:21,850
When we originally introduced pairs made out of CONS, made by CONS, we only said a few axioms about them, which were of the form-- what were they-- for all X and Y, the CAR of the CONS of X and Y is X and the CDR of the CONS of X and Y is Y. Now, these say nothing about whether a CONS has an identity like a person.

414
00:47:21,850 --> 00:47:29,740
In fact, all they say is something sort of abstract, that a CONS is the parts it's made out of.

415
00:47:29,740 --> 00:47:37,390
And of course, two things are made out of the same parts, they're the same, at least from the point of view of these axioms.

416
00:47:37,390 --> 00:47:49,830
But by introducing assignment-- in fact, mutable data is a kind of assignment, we have a set CAR and a set CDR-- by introducing those, these axioms no longer tell the whole story.

417
00:47:49,830 --> 00:47:53,250
And they're still true if written exactly like this.

418
00:47:53,250 --> 00:47:56,070
But they don't tell the whole story.

419
00:47:56,070 --> 00:48:10,090
Because if I'm going to set a particular CAR in a particular CONS, the questions are, well, is that setting all CARs and all CONSes of the same two things or not?

420
00:48:10,090 --> 00:48:21,570
If I--if we use CONSes to make up things like rational numbers, or things like 3 over 4, supposing I had two three-fourths.

421
00:48:21,570 --> 00:48:25,340
Are they the same one-- or are they different?

422
00:48:25,340 --> 00:48:27,860
Well, in the case of numbers, it doesn't matter.

423
00:48:27,860 --> 00:48:33,020
Because there's no meaning to changing the denominator of a number.

424
00:48:33,020 --> 00:48:36,840
What you could do is make a number which has a different denominator.

425
00:48:36,840 --> 00:48:44,770
But the concept of changing a number which has to have a different denominator is sort of a very weird, and sort of not supported by what you think of as mathematics.

426
00:48:44,770 --> 00:48:53,690
However, when these CONSes represent things in the physical world, then changing something like the CAR is like removing a piece of the fingernail.

427
00:48:53,690 --> 00:48:57,770
And so CONSes have an identity.

428
00:48:57,770 --> 00:49:01,280
Let me show you what I mean about identity, first of all.

429
00:49:01,280 --> 00:49:04,320
Let's do some little example here.

430
00:49:04,320 --> 00:49:15,200
Supposing I define A to the CONS of 1 and 2.

431
00:49:18,040 --> 00:49:38,120
Well, what that means, first of all, is that somewhere in some environment I've made a symbol A to have a value which is a pair consisting of pointers to a 1 and a pointer to a 2, just like that.

432
00:49:38,120 --> 00:50:03,970
Now, supposing I also say define B to be the CONS--  it doesn't matter, but I like it better, it's prettier-- of A and A.

433
00:50:03,970 --> 00:50:07,840
Well, first of all, I'm using the name A twice.

434
00:50:07,840 --> 00:50:11,300
At this moment, I'm going to think of CONSes as having identity.

435
00:50:11,300 --> 00:50:13,690
This is the same one.

436
00:50:13,690 --> 00:50:33,260
And so what that means is I make another pair, which I'm going to call B. And it contains two pointers to A. At this point, I have three names for this object.

437
00:50:33,260 --> 00:50:34,790
A is its name.

438
00:50:34,790 --> 00:50:37,230
The CAR of B is its name.

439
00:50:37,230 --> 00:50:39,360
And the CDR of B is its name.

440
00:50:39,360 --> 00:50:41,150
It has several aliases, they're called.

441
00:50:44,230 --> 00:51:07,880
Now, supposing I do something like set-the-CAR, the CAR of the CAR of B to 3.

442
00:51:12,750 --> 00:51:17,830
What that means is I find the CAR of B, that's this.

443
00:51:17,830 --> 00:51:20,935
I set the CAR of that to be 3, changing this.

444
00:51:24,760 --> 00:51:35,340
I've changed A. If I were to ask what's the CAR of A--of A now?

445
00:51:35,340 --> 00:51:45,290
I would get out 3, even though here we see that A was the CONS of 1 and 2.

446
00:51:45,290 --> 00:51:48,400
I caused A to change by changing B.

447
00:51:48,400 --> 00:51:52,010
There is sharing here.

448
00:51:52,010 --> 00:51:54,240
That's sometimes what we want.

449
00:51:54,240 --> 00:52:04,350
Surely in the queues and things like that, that's exactly what we defined our--organized our data structures to facilitate-- sharing.

450
00:52:04,350 --> 00:52:25,190
But inadvertent sharing, unanticipated interactions between objects, is the source of most of the bugs that occur in complicated programs. So by introducing this possibility of things having identity and sharing and having multiple names for the same thing, we get a lot of power.

451
00:52:25,190 --> 00:52:28,640
But we're going to pay for it with lots of complexity and bugs.

452
00:52:32,190 --> 00:52:46,560
So also, for example, if I just looked at this just to drive that home, the CADR of B, which has nothing to do with even the CAR of B, apparently.

453
00:52:46,560 --> 00:52:49,350
The CADR of B, what's that?

454
00:52:49,350 --> 00:52:53,560
Take that CDR of B and now take the CAR of that.

455
00:52:53,560 --> 00:52:56,480
Oh, that's 3 also.

456
00:52:56,480 --> 00:53:01,120
So I can have non-local interactions by sharing.

457
00:53:01,120 --> 00:53:02,480
And I have to be very careful of that.

458
00:53:06,640 --> 00:53:22,820
Well, so far, of course, it seems I've introduced several different assignment operators-- set, set CAR, set CDR. Well, maybe I should just get rid of set CAR and set CDR. Maybe they're not worthwhile.

459
00:53:22,820 --> 00:53:27,170
Well, the answer is that once you let the camel's nose into the tent, the rest of him follows.

460
00:53:30,160 --> 00:53:35,850
All I have to have is set, and I can make all of the--all of the bad things that can happen.

461
00:53:38,550 --> 00:53:40,690
Let's play with that a little bit.

462
00:53:40,690 --> 00:53:52,480
A couple of days ago, when we introduced compound data, you saw Hal show you a definition of CONS in terms of a message acceptor.

463
00:53:52,480 --> 00:54:04,440
I'm going to show you even a more horrible thing, a definition of CONS in terms of nothing but air, hot air.

464
00:54:04,440 --> 00:54:14,580
What is the definition of CONS, of the old functional kind, in terms of purely lambdic expressions, procedures?

465
00:54:17,190 --> 00:54:28,580
Because I'm going to then modify this definition to get assignment to be only one kind of assignment, to get rid of the set CAR and set CDR in terms of set.

466
00:54:28,580 --> 00:54:46,320
So what if I define CONS of X and Y to be a procedure of one argument called a message M, which calls that message on X and Y?

467
00:54:51,120 --> 00:54:57,870
This [? idea ?] was invented by Alonzo Church, who was the greatest programmer of the 20th century, although he never saw a computer.

468
00:54:57,870 --> 00:54:59,130
It was done in the 1930s.

469
00:54:59,130 --> 00:55:02,220
He was a logician, I suppose at Princeton at the time.

470
00:55:08,660 --> 00:55:46,670
Define CAR of X to be the result of applying X to that procedure of two arguments, A and D, which selects A. I will define CDR of X to be that procedure, to be the result of applying X to that procedure of A and D, which selects D.

471
00:55:46,670 --> 00:55:50,510
Now, you may not recognize this as CAR, CDR, and CONS.

472
00:55:50,510 --> 00:55:55,210
But I'm going to demonstrate to you that it satisfies the original axioms, just once.

473
00:55:55,210 --> 00:55:58,290
And then we're going to do some playing of games.

474
00:55:58,290 --> 00:56:09,695
Consider the problem CAR of CONS of, say, 35 and 47.

475
00:56:09,695 --> 00:56:11,120
Well, what is that?

476
00:56:11,120 --> 00:56:19,710
It is the result of taking car of the result of substituting 35 and 47 for X and Y in the body of this.

477
00:56:19,710 --> 00:56:20,690
Well, that's easy enough.

478
00:56:20,690 --> 00:56:35,750
That's CAR of the result of substituting into lambda of M, M of 35 and 47.

479
00:56:35,750 --> 00:56:42,830
Well, what this is, is the result of substituting this object for X in the body of that.

480
00:56:42,830 --> 00:57:15,840
So that's just lambda of M-- that's substituted, because this object is being substituted for X, which is the beginning of a list, lambda of M-- M of 35 and 47, applied to that procedure of A and D, which gives me A. Well, that's the result of substituting this for M here.

481
00:57:15,840 --> 00:57:26,026
So that's the same thing as lambda of A, D, A, applied to 35 and 47.

482
00:57:26,026 --> 00:57:27,560
Oh, well that's 35.

483
00:57:27,560 --> 00:57:40,720
That's substituting 35 for A and for 47 for D in A. So I don't need any data at all, not even numbers.

484
00:57:40,720 --> 00:57:42,640
This is Alonso Church's hack.

485
00:57:52,420 --> 00:57:56,760
Well, now we're going to do something nasty to him.

486
00:57:56,760 --> 00:57:58,860
Being a logician, he wouldn't like this.

487
00:57:58,860 --> 00:58:03,260
But as programmers, let's look at the overhead.

488
00:58:03,260 --> 00:58:05,390
And here we go.

489
00:58:05,390 --> 00:58:09,570
I'm going to change the definition of CONS.

490
00:58:09,570 --> 00:58:14,520
It's almost the same as Alonzo Church's, but not quite.

491
00:58:14,520 --> 00:58:16,070
What do we have here?

492
00:58:16,070 --> 00:58:40,940
The CONS of two arguments, X and Y, is going to be that procedure of one argument M, which supplies M to X and Y as before, but also to two permissions, the permission to set X to N and the permission to set Y to N, given that I have an N.

493
00:58:40,940 --> 00:59:03,365
So besides the things that I had here in Church's definition, what I have is that the thing that CONS returns will apply its argument to not just the values of the X and Y that the CONS is made of, but also permissions to set X and Y to new values.

494
00:59:06,540 --> 00:59:11,690
Now, of course, just as before, CAR is exactly the same.

495
00:59:11,690 --> 00:59:22,550
The CAR of X is nothing more than applying X, as in Church's definition, to a procedure, in this case, of four arguments, which selects out the first one.

496
00:59:22,550 --> 00:59:37,920
And just as we did before, that will be the value of X that was contained in the procedure which is the result of evaluating this lambda expression in the environment where X and Y are defined over here.

497
00:59:41,940 --> 00:59:45,640
That's the value of CONS.

498
00:59:45,640 --> 00:59:47,730
Now, however, the exciting part.

499
00:59:47,730 --> 00:59:48,960
CDR, of course, is the same.

500
00:59:48,960 --> 00:59:55,800
The exciting part, set CAR and set CDR. Well, they're nothing very complicated anymore.

501
00:59:55,800 --> 01:00:26,150
Set CAR of a CONS X to a new value Y is nothing more than applying that CONS, which is the procedure of four--the procedure of one argument which applies its argument to four things, to a procedure which is of four arguments-- the value of X, the value of Y, permission to set X, the permission to set Y-- and using it--using that permission to set X to the new value.

502
01:00:31,650 --> 01:00:33,540
And similarly, set-cdr is the same thing.

503
01:00:36,120 --> 01:00:40,470
So what you've just seen is that I didn't introduce any new primitives at all.

504
01:00:40,470 --> 01:00:45,340
Whether or not I want to implement it this way is a matter of engineering.

505
01:00:45,340 --> 01:00:51,680
And the answer is of course I don't implement it this way for reasons that have to do with engineering.

506
01:00:51,680 --> 01:00:58,765
However in principle, logically, once I introduced one assignment operator, I've assigned--I've introduced them all.

507
01:01:05,420 --> 01:01:06,670
Are there any questions?

508
01:01:09,200 --> 01:01:12,040
Yes, David.

509
01:01:12,040 --> 01:01:15,740
AUDIENCE: I can follow you up until you get--I can follow all of that.

510
01:01:15,740 --> 01:01:24,210
But when we bring in the permissions, defining CONS in terms of the lambda N, I don't follow where N gets passed.

511
01:01:24,210 --> 01:01:25,100
PROFESSOR: Oh, I'm sorry.

512
01:01:25,100 --> 01:01:26,340
I'll show you.

513
01:01:26,340 --> 01:01:27,360
Let's follow it.

514
01:01:27,360 --> 01:01:29,180
Of course, we could do it on the blackboard.

515
01:01:29,180 --> 01:01:30,170
It's not so hard.

516
01:01:30,170 --> 01:01:32,450
But it's also easy here.

517
01:01:32,450 --> 01:01:38,520
Supposing I wish to set-cdr of X to Y. See that right there.

518
01:01:38,520 --> 01:01:46,890
set-cdr of X to Y. X is presumably a CONS, a thing resulting from evaluating CONS.

519
01:01:46,890 --> 01:01:58,110
Therefore X comes from a place over here, that that X is of the result of evaluating this lambda expression.

520
01:01:58,110 --> 01:01:59,380
Right?

521
01:01:59,380 --> 01:02:08,950
That when I evaluated that lambda expression, I evaluated it in an environment where the arguments to CONS were defined.

522
01:02:11,750 --> 01:02:29,250
That means that as free variables in this lambda expression, there is the--there are in the frame, which is the parent frame of this lambda expression, the procedure resulting from this lambda expression, X and Y have places.

523
01:02:29,250 --> 01:02:31,910
And it's possible to set them.

524
01:02:31,910 --> 01:02:37,010
I set them to an N, which is the argument of the permission.

525
01:02:37,010 --> 01:02:47,940
The permission is a procedure which is passed to M, which is the argument that the CONS object gets passed.

526
01:02:47,940 --> 01:02:57,480
Now, let's go back here in the set-cdr The CONS object, which is the first argument of set-cdr gets passed an argument.

527
01:03:00,260 --> 01:03:07,920
That--there's a procedure of four things, indeed, because that's the same thing as this M over here, which is applied to four objects.

528
01:03:07,920 --> 01:03:12,970
The object over here, SD, is, in fact, this permission.

529
01:03:15,470 --> 01:03:19,930
When I use SD, I apply it to Y, right there.

530
01:03:22,910 --> 01:03:25,740
So that comes from this.

531
01:03:25,740 --> 01:03:34,160
AUDIENCE: So what do you-- PROFESSOR: So to finish that, the N that was here is the Y which is here.

532
01:03:34,160 --> 01:03:34,810
How's that?

533
01:03:34,810 --> 01:03:35,750
AUDIENCE: Right, OK.

534
01:03:35,750 --> 01:03:41,970
Now, when you do a set-cdr, X is the value the CDR is going to become.

535
01:03:41,970 --> 01:03:44,742
PROFESSOR: The X over here.

536
01:03:44,742 --> 01:03:46,200
I'm sorry, that's not true.

537
01:03:46,200 --> 01:03:56,150
The X is--set-cdr has two arguments-- The CONS I'm changing and the value I'm changing it to.

538
01:03:56,150 --> 01:03:58,320
So you have them backwards, that's all.

539
01:04:01,750 --> 01:04:03,000
Are there any other questions?

540
01:04:07,880 --> 01:04:08,640
Well, thank you.

541
01:04:08,640 --> 01:04:09,890
It's time for lunch.

