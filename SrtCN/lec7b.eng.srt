1
00:00:00,994 --> 00:00:16,401
[MUSIC PLAYING]

2
00:00:16,401 --> 00:00:19,520
PROFESSOR: Well, let's see.

3
00:00:19,520 --> 00:00:23,050
What we did so far was a lot of fun, was it useful for anything?

5
00:00:26,330 --> 00:00:29,380
I suppose the answer is going to be yes.

6
00:00:29,380 --> 00:00:35,180
If these metacircular interpreters are a valuable thing to play with.

8
00:00:38,050 --> 00:00:52,570
Well, there have been times I spend 50% of my time, over a year, trying various design alternatives by experimenting with them with metacircular interpreters-- metacircular interpreters like the sort you just saw.

12
00:00:52,570 --> 00:01:01,270
Metacircular is because they are defined in terms of themselves in such a way that the language they interpret contains itself.

15
00:01:01,270 --> 00:01:06,800
Such interpreters are a convenient medium for exploring language issues.

17
00:01:06,800 --> 00:01:15,490
If you want to try adding a new feature, it's sort of a snap, it's easy, you just do it and see what happens.

19
00:01:15,490 --> 00:01:21,090
You play with that language for a while you say, gee, I'm didn't like that, you throw it away.

21
00:01:21,090 --> 00:01:33,720
Or you might want to see what the difference is if you'd make a slight difference in the binding strategy, or some more complicated things that might occur.

24
00:01:33,720 --> 00:01:49,690
In fact, these metacircular interpreters are an excellent medium for people exchanging ideas about language design, because they're pretty easy to understand, and they're short, and compact, and simple.

28
00:01:49,690 --> 00:02:05,450
If I have some idea that I want somebody to criticize like say, Dan Friedman at Indiana, I'd write a little metacircular interpreter and send him some network mail with this interpreter in it.

32
00:02:05,450 --> 00:02:11,940
He could whip it up on his machine and play with it and say, that's no good.

34
00:02:11,940 --> 00:02:16,880
And then send it back to me and say, well, why don't you try this one, it's a little better.

36
00:02:16,880 --> 00:02:20,160
So I want to show you some of that technology.

37
00:02:20,160 --> 00:02:30,790
See, because, really, it's the essential, simple technology for getting started in designing your own languages for particular purposes.

40
00:02:30,790 --> 00:02:34,210
Let's start by adding a very simple feature to a Lisp.

41
00:02:40,640 --> 00:02:44,370
Now, one thing I want to tell you about is features, before I start.

43
00:02:49,560 --> 00:02:56,620
There are many languages that have made a mess of themselves by adding huge numbers of features.

45
00:02:56,620 --> 00:03:02,520
Computer scientists have a joke about bugs that transform it to features all the time.

47
00:03:05,030 --> 00:03:12,820
But I like to think of it is that many systems suffer from what's called creeping featurism.

49
00:03:12,820 --> 00:03:20,170
Which is that George has a pet feature he'd like in the system, so he adds it.

51
00:03:20,170 --> 00:03:26,640
And then Harry says, gee, this system is no longer what exactly I like, so I'm going to add my favorite feature.

53
00:03:26,640 --> 00:03:30,710
And then Jim adds his favorite feature.

54
00:03:30,710 --> 00:03:37,790
And, after a while, the thing has a manual 500 pages long that no one can understand.

56
00:03:37,790 --> 00:03:44,830
And sometimes it's the same person who writes all of these features and produces this terribly complicated thing.

58
00:03:44,830 --> 00:03:55,730
In some cases, like editors, it's sort of reasonable to have lots of features, because there are a lot of things you want to be able to do and many of them arbitrary.

61
00:03:55,730 --> 00:04:01,690
But in computer languages, I think it's a disaster to have too much stuff in them.

63
00:04:04,110 --> 00:04:21,010
The other alternative you get into is something called feeping creaturism, which is where you have a box which has a display, a fancy display, and a mouse, and there is all sorts of complexity associated with all this fancy IO.

67
00:04:21,010 --> 00:04:30,080
And your computer language becomes a dismal, little, tiny thing that barely works because of all the swapping, and disk twitching, and so on, caused by your Windows system.

70
00:04:30,080 --> 00:04:37,440
And every time you go near the computer, the mouse process wakes up and says, gee do you have something for me to do, and then it goes back to sleep.

73
00:04:37,440 --> 00:04:42,940
And if you accidentally push mouse with you elbow, a big puff of smoke comes out of your computer and things like that.

76
00:04:42,940 --> 00:04:47,500
So two ways to disastrously destroy a system by adding features.

78
00:04:47,500 --> 00:04:49,730
But try right now to add a little, simple feature.

79
00:04:52,300 --> 00:04:57,250
This actually is a good one, and in fact, real Lisps have it.

81
00:04:57,250 --> 00:05:05,430
As you've seen, there are procedures like plus and times that take any number of arguments.

83
00:05:05,430 --> 00:05:17,540
So we can write things like the sum of the product of a and x and x, and the product of b and x and c.

85
00:05:17,540 --> 00:05:30,000
As you can see here, addition takes three arguments or two arguments, multiplication takes two arguments or three arguments, taking numbers of arguments all of which are to be treated in the same way.

89
00:05:30,000 --> 00:05:34,960
This is a valuable thing, indefinite numbers of arguments.

91
00:05:34,960 --> 00:05:47,850
Yet the particular Lisp system that I showed you is one where the numbers of arguments is fixed, because I had to match the arguments against the formal parameters in the binder, where there's a pairup.

95
00:05:50,810 --> 00:05:58,590
Well, I'd like to be able to define new procedures like this that can have any number of arguments.

97
00:05:58,590 --> 00:06:01,150
Well there's several parts to this problem.

98
00:06:01,150 --> 00:06:15,480
The first part is coming up with the syntactic specification, some way of notating the additional arguments, of which you don't know how many there are.

101
00:06:15,480 --> 00:06:26,980
And then there's the other thing, which is once we've notated it, how are we going to interpret that notation so as to do the right thing, whatever the right thing is?

104
00:06:26,980 --> 00:06:30,480
So let's consider an example of a sort of thing we might want to be able to do.

106
00:06:33,070 --> 00:06:49,090
So an example might be, that I might want to be able to define a procedure which is a procedure of one required argument x and a bunch of arguments, I don't know how many there are, called y.

110
00:06:49,090 --> 00:07:05,990
So x is required, and there are many y's, many argument-- y will be the list of them.

112
00:07:14,480 --> 00:07:36,890
Now, with such a thing, we might be able to say something like, map-- I'm going to do something to every one-- of that procedure of one argument u, which multiplies x by u, and we'll apply that to y.

117
00:07:36,890 --> 00:07:46,300
I've used a dot here to indicate that the thing after this is a list of all the rest of the arguments.

119
00:07:46,300 --> 00:07:47,745
I'm making a syntactic specification.

120
00:07:53,320 --> 00:08:08,631
Now, what this depends upon, the reason why this is sort of a reasonable thing to do, is because this happens to be a syntax that's used in the Lisp reader for representing conses.

124
00:08:08,631 --> 00:08:11,080
We've never introduced that before.

125
00:08:11,080 --> 00:08:26,980
You may have seen when playing with the system that if you cons two things together, you get the first, space, dot, the second, space-- the first, space, dot, space, the second with parentheses around the whole thing.

130
00:08:26,980 --> 00:08:41,870
So that, for example, this x dot y corresponds to a pair, which has got an x in it and a y in it.

132
00:08:41,870 --> 00:09:18,280
The other notations that you've seen so far are things like a procedure of arguments x and y and z which do things, and that looks like-- Just looking at the bound variable list, it looks like this, x, y, z, and the empty thing.

137
00:09:18,280 --> 00:09:46,380
If I have a list of arguments I wish to match this against, supposing, I have a list of arguments one, two, three, I want to match these against. So I might have here a list of three things, one, two, three.

141
00:09:48,990 --> 00:09:54,220
And I want to match x, y, z against one, two, three.

142
00:09:54,220 --> 00:10:05,480
Well, it's clear that the one matches the x, because I can just sort of follow the structure, and the two matches the y, and the three matches the z.

145
00:10:05,480 --> 00:10:18,510
But now, supposing I were to compare this x dot y-- this is x dot y-- supposing I compare that with a list of three arguments, one, two, three.

149
00:10:18,510 --> 00:10:20,000
Let's look at that again.

150
00:10:28,000 --> 00:10:43,740
One, two, three-- Well, I can walk along here and say, oh yes, x matches the one, the y matches the list, which is two and three.

153
00:10:43,740 --> 00:10:50,160
So the notation I'm choosing here is one that's very natural for Lisp system.

155
00:10:52,660 --> 00:10:56,040
But I'm going to choose this as a notation for representing a bunch of arguments.

157
00:10:58,290 --> 00:11:00,770
Now, there's an alternative possibility.

158
00:11:00,770 --> 00:11:25,140
If I don't want to take one special out, or two special ones out or something like that, if I don't want to do that, if I want to talk about just the list of all the arguments like in addition, well then the argument list I'm going to choose to be that procedure of all the arguments x which does something with x.

164
00:11:25,140 --> 00:11:45,850
And which, for example, if I take the procedure, which takes all the arguments x and returned the list of them, that's list. That's the procedure list.

167
00:11:45,850 --> 00:11:46,840
How does this work?

168
00:11:46,840 --> 00:11:55,140
Well, indeed what I had as the bound variable list in this case, whatever it is, is being matched against a list of arguments.

171
00:11:55,140 --> 00:11:57,145
This symbol now is all of the arguments.

172
00:12:01,490 --> 00:12:10,285
And so this is the choice I'm making for a particular syntactic specification, for the description of procedures which take indefinite numbers of arguments.

175
00:12:13,190 --> 00:12:18,420
There are two cases of it, this one and this one.

176
00:12:18,420 --> 00:12:31,100
When you make syntactic specifications, it's important that it's unambiguous, that neither of these can be confused with a representation we already have, this one.

179
00:12:33,610 --> 00:12:58,465
I can always tell whether I have a fixed number of explicitly named arguments made by these formal parameters, or a fixed number of named formal parameters followed by a thing which picks up all the rest of them, or a list of all the arguments which will be matched against this particular formal parameter called x, because these are syntactically distinguishable.

186
00:13:02,250 --> 00:13:14,560
Many languages make terrible errors in that form where whole segments of interpretation are cut off, because there are syntactic ambiguities in the language.

189
00:13:14,560 --> 00:13:25,060
They are the traditional problems with ALGOL like languages having to do with the nesting of ifs in the predicate part.

192
00:13:25,060 --> 00:13:35,250
In any case, now, so I've told you about the syntax, now, what are we going to do about the semantics of this?

194
00:13:35,250 --> 00:13:36,590
How do we interpret it?

195
00:13:36,590 --> 00:13:38,440
Well this is just super easy.

196
00:13:38,440 --> 00:13:43,396
I'm going to modify the metacircular interpreter to do it.

198
00:13:43,396 --> 00:13:46,020
And that's a one liner.

199
00:13:46,020 --> 00:13:47,590
There it is.

200
00:13:47,590 --> 00:13:49,560
I'm changing the way you pair things up.

201
00:13:56,390 --> 00:14:16,080
Here's the procedure that pairs the variables, the formal parameters, with the arguments that were passed from the last description of the metacircular interpreter.

204
00:14:18,960 --> 00:14:22,670
And here's some things that are the same as they were before.

206
00:14:22,670 --> 00:14:31,050
In other words, if the list of variables is empty, then if the list of values is empty, then I have an empty list.

208
00:14:31,050 --> 00:14:41,580
Otherwise, I have too many arguments, that is, if I have empty variables but not empty values.

210
00:14:41,580 --> 00:14:50,090
If I have empty values, but the variables are not empty, I have too few arguments.

212
00:14:50,090 --> 00:15:06,255
The variables are a symbol-- interesting case-- then, what I should do is say, oh yes, this is the special case that I have a symbolic tail.

216
00:15:09,010 --> 00:15:14,900
I have here a thing just like we looked over here.

217
00:15:14,900 --> 00:15:18,630
This is a tail which is a symbol, y.

218
00:15:18,630 --> 00:15:20,730
It's not a nil.

219
00:15:20,730 --> 00:15:25,600
It's not the empty list. Here's a symbolic tail that is just the very beginning of the tail.

221
00:15:25,600 --> 00:15:27,790
There is nothing else.

222
00:15:27,790 --> 00:15:44,500
In that case, I wish to match that variable with all the values and add that to the pairing that I'm making.

224
00:15:44,500 --> 00:15:48,910
Otherwise, I go through the normal arrangement of making up the whole pairing.

226
00:15:52,020 --> 00:15:54,510
I suppose that's very simple.

227
00:15:54,510 --> 00:15:57,080
And that's all there is to it.

228
00:15:57,080 --> 00:15:58,330
And now I'll answer some questions.

229
00:16:02,620 --> 00:16:06,600
The first one-- Are there any questions?

231
00:16:06,600 --> 00:16:06,950
Yes?

232
00:16:06,950 --> 00:16:10,450
AUDIENCE: Could you explain that third form?

233
00:16:10,450 --> 00:16:12,590
PROFESSOR: This one?

234
00:16:12,590 --> 00:16:18,570
Well, maybe we should look at the thing as a piece of list structure.

236
00:16:18,570 --> 00:16:22,400
This is a procedure which contains a lambda.

237
00:16:25,970 --> 00:16:31,090
I'm just looking at the list structure which represents this.

239
00:16:31,090 --> 00:16:32,730
Here's x.

240
00:16:32,730 --> 00:16:33,980
These are our symbols.

241
00:16:37,410 --> 00:16:39,580
And then the body is nothing but x.

242
00:16:44,840 --> 00:16:54,010
If I were looking for the bound variable list part of this procedure, I would go looking at the CADR, and I'd find a symbol.

245
00:16:54,010 --> 00:17:05,760
So the, naturally, which is this pairup thing I just showed you, is going to be matching a symbolic object against a list of arguments that were passed.

248
00:17:05,760 --> 00:17:09,559
And it will bind that symbol to the list of arguments.

249
00:17:13,910 --> 00:17:20,920
In this case, if I'm looking for it, the match will be against this in the bound variable list position.

251
00:17:24,140 --> 00:17:31,450
Now, if what this does is it gets a list of arguments and returns it, that's list. That's what the procedure is.

253
00:17:34,510 --> 00:17:36,140
Oh well, thank you.

254
00:17:36,140 --> 00:17:37,830
Let's take a break.

255
00:17:37,830 --> 00:18:20,358
[MUSIC PLAYING]

256
00:18:20,358 --> 00:18:23,260
PROFESSOR: Well let's see.

257
00:18:23,260 --> 00:18:38,250
Now, I'm going to tell you about a rather more substantial variation, one that's a famous variation that many early Lisps had.

260
00:18:38,250 --> 00:18:41,770
It's called dynamic binding of variables.

261
00:18:41,770 --> 00:18:44,680
And we'll investigate a little bit about that right now.

262
00:18:47,620 --> 00:18:53,740
I'm going to first introduce this by showing you the sort of thing that would make someone want this idea.

264
00:18:53,740 --> 00:18:58,640
I'm not going to tell what it is yet, I'm going to show you why you might want it.

266
00:18:58,640 --> 00:19:08,140
Suppose, for example, we looked at the sum procedure again for summing up a bunch of things.

268
00:19:08,140 --> 00:20:08,220
To be that procedure, of a term, lower bound, method of computing the next index, and upper bound, such that, if a is greater than b then the result is 0, otherwise, it's the sum, of the term, procedure, applied to a and the result of adding up, terms, with the next a being the a, the next procedure passed along, and the upper bound being passed along.

275
00:20:14,510 --> 00:20:25,450
Blink, blink, blink-- Now, when I use this sum procedure, I can use it, for example, like this.

278
00:20:25,450 --> 00:21:11,440
We can define the sum of the powers to be, for example, sum of a bunch of powers x to the n, to be that procedure of a, b, and n-- lower bound, the upper bound, and n-- which is sum, of lambda of x, the procedure of one argument x, which exponentiates x to the n, with the a, the incrementer, and b, being passed along.

285
00:21:11,440 --> 00:21:16,340
So we're adding up x to n, given an x.

286
00:21:16,340 --> 00:21:19,740
x takes on values from a to b, incrementing by one.

287
00:21:22,940 --> 00:21:29,780
I can also write the-- That's right.

289
00:21:29,780 --> 00:21:31,910
Product, excuse me.

290
00:21:31,910 --> 00:21:33,220
The product of a bunch of powers.

291
00:21:38,080 --> 00:21:40,020
It's a strange name.

292
00:21:40,020 --> 00:21:41,960
I'm going to leave it there.

293
00:21:41,960 --> 00:21:50,890
Weird-- I write up what I have. I'm sure that's right.

295
00:21:50,890 --> 00:22:03,400
And if I want the product of a bunch of powers-- That was 12 brain cells, that double-take.

297
00:22:03,400 --> 00:22:11,450
I can for example use the procedure which is like sum, which is for making products, but it's similar to that, that you've seen before.

300
00:22:11,450 --> 00:22:16,725
There's a procedure of three arguments again.

301
00:22:16,725 --> 00:22:37,850
Which is the product of terms that are constructed, or factors in this case, constructed from exponentiating x to the n, where I start with a, I increment, and I go to b.

305
00:22:41,530 --> 00:22:50,750
Now, there's some sort of thing here that should disturb you immediately.

307
00:22:50,750 --> 00:22:53,180
These look the same.

308
00:22:53,180 --> 00:22:56,590
Why am I writing this code so many times?

309
00:22:56,590 --> 00:23:01,270
Here I am, in the same boat I've been in before.

310
00:23:01,270 --> 00:23:03,810
Wouldn't it be nice to make an abstraction here?

311
00:23:03,810 --> 00:23:05,980
What's an example of a good abstraction to make?

312
00:23:05,980 --> 00:23:08,470
Well, I see some codes that's identical.

313
00:23:08,470 --> 00:23:11,080
Here's one, and here's another.

314
00:23:14,450 --> 00:23:17,090
And so maybe I should be able to pull that out.

315
00:23:17,090 --> 00:23:25,710
I should be able to say, oh yes, the sum of the powers could be written in terms of something called the nth power procedure.

318
00:23:25,710 --> 00:23:30,030
Imagine somebody wanted to write a slightly different procedure that looks like this.

320
00:23:37,630 --> 00:23:53,556
The sum powers to be a procedure of a, b, and n, as the result of summing up the nth power.

322
00:23:53,556 --> 00:24:02,170
We're going to give a name to that idea, for starting at a, going by one, and ending at b.

324
00:24:06,000 --> 00:24:16,270
And similarly, I might want to write the product powers this way, abstracting out this idea.

326
00:24:16,270 --> 00:24:17,520
I might want this.

327
00:24:22,100 --> 00:24:58,380
Product powers, to be a procedure of a, b, and n, which is the product of the nth power operation on a with the incrementation and b being my arguments for the analogous-thing product.

331
00:24:58,380 --> 00:25:05,930
And I'd like to be able to define, I'd like to be able to define nth power-- I'll put it over here.

334
00:25:11,215 --> 00:25:12,990
I'll put it at the top.

335
00:25:25,410 --> 00:25:35,390
--to be, in fact, my procedure of one argument x which is the result of exponentiating x to the n.

337
00:25:35,390 --> 00:25:38,640
But I have a problem.

338
00:25:38,640 --> 00:25:48,810
My environment model, that is my means of interpretation for the language that we've defined so far, does not give me a meaning for this n.

341
00:25:52,520 --> 00:26:06,410
Because, as you know, this n is free in this procedure.

342
00:26:06,410 --> 00:26:16,640
The environment model tells us that the meaning of a free variable is determined in the environment in which this procedure is defined.

345
00:26:16,640 --> 00:26:25,850
In a way I have written it, assuming these things are defined on the blackboard as is, this is defined in the global environment, where there is no end.

348
00:26:25,850 --> 00:26:28,720
Therefore, n is unbound variable.

349
00:26:28,720 --> 00:26:36,220
But it's perfectly clear, to most of us, that we would like it to be this n and this n.

351
00:26:38,990 --> 00:26:42,840
On the other hand, it would be nice.

352
00:26:42,840 --> 00:26:52,900
Certainly we've got to be careful here of keeping this to be this, and this one over here, wherever it is to be this one.

355
00:26:57,390 --> 00:27:04,040
Well, the desire to make this work has led to a very famous bug.

357
00:27:04,040 --> 00:27:07,310
I'll tell you about the famous bug.

358
00:27:07,310 --> 00:27:10,660
Look at this slide.

359
00:27:10,660 --> 00:27:13,990
This is an idea called dynamic binding.

360
00:27:13,990 --> 00:27:29,125
Where, instead of the free variable being interpreted in the environment of definition of a procedure, the free variable is interpreted as having its value in the environment of the caller of the procedure.

364
00:27:31,850 --> 00:28:04,470
So what you have is a system where you search up the chain of callers of a particular procedure, and, of course, in this case, since nth power is called from inside product whatever it is-- I had to write our own sum which is the analogous procedure-- and product is presumably called from product powers, as you see over here, then since product powers bind with variable n , then nth powers n would be derived through that chain.

374
00:28:08,140 --> 00:28:15,800
Similarly, this n, the nth power in n in this case, would come through nth power here being called from inside sum.

376
00:28:15,800 --> 00:28:19,730
You can see it being called from inside sum here.

377
00:28:19,730 --> 00:28:22,900
It's called term here.

378
00:28:22,900 --> 00:28:28,930
But sum was called from inside of sum powers, which bound n.

379
00:28:28,930 --> 00:28:36,495
Therefore, there would be an n available for that n to get it's value from.

381
00:28:39,430 --> 00:28:46,540
What we have below this white line plus over here, is what's called a dynamic binding view of the world.

383
00:28:46,540 --> 00:28:50,850
If that works, that's a dynamic binding view.

384
00:28:50,850 --> 00:28:55,990
Now, let's take a look, for example, at just what it takes to implement that.

386
00:28:55,990 --> 00:28:57,480
That's real easy.

387
00:28:57,480 --> 00:29:06,490
In fact, the very first Lisps that had any interpretations of the free variables at all, had dynamic binding interpretations for the free variables.

390
00:29:06,490 --> 00:29:15,220
APL has dynamic binding interpretation for the free variables, not lexical or static binding.

392
00:29:15,220 --> 00:29:18,790
So, of course, the change is in eval.

393
00:29:18,790 --> 00:29:22,780
And it's really in two places.

394
00:29:22,780 --> 00:29:29,010
First of all, one thing we see, is that things become a little simpler.

396
00:29:32,460 --> 00:29:42,030
If I don't have to have the environment be the environment of definition for procedure, the procedure need not capture the environment at the time it's defined.

399
00:29:42,030 --> 00:30:01,290
And so if we look here at this slide, we see that the clause for a lambda expression, which is the way a procedure is defined, does not make up a thing which has a type closure and a attached environment structure.

403
00:30:01,290 --> 00:30:02,540
It's just the expression itself.

404
00:30:02,540 --> 00:30:06,440
And we'll decompose that some other way somewhere else.

405
00:30:06,440 --> 00:30:14,290
The other thing we see is the applicator must be able to get the environment of the caller.

407
00:30:14,290 --> 00:30:19,560
The caller of a procedure is right here.

408
00:30:19,560 --> 00:30:26,980
If the expression we're evaluating is anpplication or a combination, then we're going to call a procedure which is the value of the operator.

411
00:30:29,840 --> 00:30:35,890
The environment of the caller is the environment we have right here, available now.

413
00:30:35,890 --> 00:30:41,490
So all I have to do is pass that environment to the applicator, to apply.

415
00:30:41,490 --> 00:31:06,810
And if we look at that here, the only change we have to make is that fellow takes that environment and uses that environment for the purpose of extending that environment when abiding the formal parameters of the procedure to the arguments that were passed, not an environment that was captured in the procedure.

421
00:31:06,810 --> 00:31:14,130
The reason why the first Lisps were implemented this way, is the sort of the obvious, accidental implementation.

423
00:31:14,130 --> 00:31:17,250
And, of course, as usual, people got used to it and liked it.

425
00:31:17,250 --> 00:31:21,590
And there were some people said, this is the way to do it.

427
00:31:21,590 --> 00:31:35,460
Unfortunately that causes some serious problems. The most important, serious problem in using dynamic binding is there's a modularity crisis that's involved it.

430
00:31:35,460 --> 00:31:44,580
If two people are working together on some big system, then an important thing to want is that the names used by each one don't interfere with the names of the other.

433
00:31:47,930 --> 00:31:59,850
It's important that when I invent some segment of code that no one can make my code stop working by using my names that I use internal to my code, internal to his code.

436
00:31:59,850 --> 00:32:06,670
However, dynamic binding violates that particular modularity constraint in a clear way.

438
00:32:06,670 --> 00:32:12,540
Consider, for example, what happens over here.

439
00:32:12,540 --> 00:32:19,810
Suppose it was the case that I decided to change the word next.

441
00:32:19,810 --> 00:32:28,970
Supposing somebody is writing sum, and somebody else is going to use sum.

443
00:32:28,970 --> 00:32:33,790
The writer of sum has a choice of what names he may use.

444
00:32:33,790 --> 00:32:36,760
Let's say, I'm that writer.

445
00:32:36,760 --> 00:32:39,300
Well, by gosh, just happens I didn't want to call this next.

446
00:32:39,300 --> 00:32:41,500
I called it n.

447
00:32:41,500 --> 00:32:48,140
So all places where you see next, I called it n.

448
00:32:48,140 --> 00:32:49,940
Whoops.

449
00:32:49,940 --> 00:32:56,110
I changed nothing about the specifications of this program, but this program stops working.

451
00:32:56,110 --> 00:32:59,730
Not only that, unfortunately, this one does too.

452
00:32:59,730 --> 00:33:02,260
Why do these programs stop working?

453
00:33:02,260 --> 00:33:04,480
Well, it's sort of clear.

454
00:33:04,480 --> 00:33:24,370
Instead of chasing out the value of the n that occurs in nth power over here or over here, through the environment of definition, where this one is always linked to this one, if it was through the environment of definition, because here is the definition.

459
00:33:24,370 --> 00:33:30,700
This lambda expression was executed in the environment where that n was defined.

461
00:33:30,700 --> 00:33:37,320
If instead of doing that, I have to chase through the call chain, then look what horrible thing happens.

463
00:33:37,320 --> 00:33:44,780
Well, this was called from inside sum as term, term a.

464
00:33:44,780 --> 00:33:47,350
I'm looking for a value of n.

465
00:33:47,350 --> 00:33:50,700
Instead of getting this one, I get that one.

466
00:33:50,700 --> 00:33:54,680
So by changing the insides of this program, this program stops working.

468
00:33:56,770 --> 00:34:00,020
So I no longer have a quantifier, as I described before.

470
00:34:02,700 --> 00:34:05,430
The lambda symbol is supposed to be a quantifier.

471
00:34:05,430 --> 00:34:24,040
A thing which has the property that the names that are bound by it are unimportant, that I can uniformly substitute any names for these throughout this thing, so long as they don't occur in here, the new names, and the meaning of this expression should remain unchanged.

476
00:34:24,040 --> 00:34:28,690
I've just changed the meaning of the expression by changing the one of the names.

478
00:34:28,690 --> 00:34:32,170
So lambda is no longer a well defined idea.

479
00:34:32,170 --> 00:34:34,550
It's a very serious problem.

480
00:34:34,550 --> 00:34:48,090
So for that reason, I and my buddies have given up this particular kind of abstraction, which I would like to have, in favor of a modularity principle.

483
00:34:48,090 --> 00:34:54,530
But this is the kind of experiment you can do if you want to play with these interpreters.

485
00:34:54,530 --> 00:34:58,270
You can try them out this way, that way, and the other way.

486
00:34:58,270 --> 00:35:00,070
You see what makes a nicer language.

487
00:35:02,680 --> 00:35:04,990
So that's a very important thing to be able to do.

488
00:35:04,990 --> 00:35:10,880
Now, I would like to give you a feeling for I think the right thing to do is here.

490
00:35:10,880 --> 00:35:16,280
How are you going to I get this kind of power in a lexical system?

492
00:35:16,280 --> 00:35:23,690
And the answer is, of course, what I really want is a something that makes up for me an exponentiator for a particular n.

495
00:35:23,690 --> 00:35:26,280
Given an n, it will make me an exponentiator.

496
00:35:26,280 --> 00:35:28,170
Oh, but that's easy too.

497
00:35:28,170 --> 00:35:30,570
In other words, I can write my program this way.

498
00:35:35,450 --> 00:35:45,240
I'm going to define a thing called PGEN, which is a procedure of n which produces for me an exponentiator.

500
00:35:50,240 --> 00:35:51,490
--x to the n.

501
00:35:56,900 --> 00:36:07,890
Given that I have that, then I can capture the abstraction I wanted even better, because now it's encapsulated in a way where I can't be destroyed by a change of names.

504
00:36:07,890 --> 00:36:37,590
I can define some powers to be a procedure again of a, b, and n which is the sum of the term function generated by using this generator, PGEN, n, with a, incrementer, and b.

507
00:36:42,490 --> 00:37:11,150
And I can define the product of powers to be a procedure of a, b, and n which is the product PGEN, n, with a, increment, and b.

510
00:37:11,150 --> 00:37:17,280
Now, of course, this is a very simple example where this object that I'm trying to abstract over is small.

512
00:37:17,280 --> 00:37:20,100
But it could be a 100 lines of code.

513
00:37:20,100 --> 00:37:23,670
And so, the purpose of this is, of course, to make it simple.

515
00:37:23,670 --> 00:37:28,200
I'd give a name to it, it's just that here it's a parameterized name.

517
00:37:28,200 --> 00:37:34,050
It's a name that depends upon, explicitly, the lexically apparent value of n.

519
00:37:37,130 --> 00:37:40,210
So you can think of this as a long name.

520
00:37:40,210 --> 00:37:49,220
And here, I've solved my problem by naming the term generation procedures within an n in them.

522
00:37:55,080 --> 00:37:57,140
Are there any questions?

523
00:37:57,140 --> 00:37:58,380
Oh, yes, David.

524
00:37:58,380 --> 00:38:06,470
AUDIENCE: Is the only solution to the problem you raise to create another procedure?

526
00:38:06,470 --> 00:38:12,402
In other words, can this only work in languages that are capable of defining objects as procedures?

528
00:38:12,402 --> 00:38:13,765
PROFESSOR: Oh, I see.

529
00:38:16,530 --> 00:38:28,190
My solution to making this abstraction, when I didn't want include the procedure inside the body, depends upon my ability to return a procedure or export one.

532
00:38:28,190 --> 00:38:30,410
And that's right.

533
00:38:30,410 --> 00:38:43,000
If I don't have that, then I just don't have this ability to make an abstraction in a way where I don't have possibilities of symbol conflicts that were unanticipated.

537
00:38:43,000 --> 00:38:45,610
That's right.

538
00:38:45,610 --> 00:39:03,700
I consider being able to return the procedural value and, therefore, to sort of have first class procedures, in general, as being essential to doing very good modular programming.

542
00:39:03,700 --> 00:39:07,440
Now, indeed there are many other ways to skin this cat.

543
00:39:07,440 --> 00:39:15,840
What you can do is take for each of the bad things that you have to worry about, you can make a special feature that covers that thing.

546
00:39:15,840 --> 00:39:17,930
You can make a package system.

547
00:39:17,930 --> 00:39:22,240
You can make a module system as in Ada, et cetera.

548
00:39:22,240 --> 00:39:26,440
And all of those work, or they cover little regions of it.

549
00:39:26,440 --> 00:39:45,590
The thing is that returning procedures as values cover all of those problems. And so it's the simplest mechanism that gives you the best modularity, gives you all of the known modularity mechanisms.

553
00:39:45,590 --> 00:39:48,248
Well, I suppose it's time for the next break, thank you.

554
00:39:48,248 --> 00:40:41,871
[MUSIC PLAYING]

555
00:40:41,871 --> 00:40:55,420
PROFESSOR: Well, yesterday when you learned about streams, Hal worried to you about the order of evaluation and delayed arguments to procedures.

558
00:40:55,420 --> 00:41:15,250
The way we played with streams yesterday, it was the responsibility of the caller and the callee to both agree that an argument was delayed, and the callee must force the argument if it needs the answer.

562
00:41:15,250 --> 00:41:26,100
So there had to be a lot of hand shaking between the designer of a procedure and user of it over delayedness.

564
00:41:26,100 --> 00:41:45,900
That turns out, of course, to be a fairly bad thing, it works all right with streams. But as a general thing, what you want is an idea to have a locus, a decision, a design decision in general, to have a place where it's made, explicitly, and notated in a clear way.

569
00:41:45,900 --> 00:41:59,500
And so it's not a very good idea to have to have an agreement, between the person who writes a procedure and the person who calls it, about such details as, maybe, the arguments of evaluation, the order of evaluation.

573
00:41:59,500 --> 00:42:00,750
Although, that's not so bad.

574
00:42:00,750 --> 00:42:04,540
I mean, we have other such agreements like, the input's a number.

576
00:42:04,540 --> 00:42:11,020
But it would be nice if only one of these guys could take responsibility, completely.

578
00:42:11,020 --> 00:42:15,510
Now this is not a new idea.

579
00:42:15,510 --> 00:42:22,020
ALGOL 60 had two different ways of calling a procedure.

580
00:42:22,020 --> 00:42:25,590
The arguments could be passed by name or by value.

581
00:42:25,590 --> 00:42:31,110
And what that meant was that a name argument was delayed.

582
00:42:31,110 --> 00:42:39,620
That when you passed an argument by name, that its value would only be obtained if you accessed that argument.

584
00:42:42,290 --> 00:42:50,320
So what I'd like to do now is show you, first of all, a little bit about, again, we're going to make a modification to a language.

587
00:42:50,320 --> 00:42:53,370
In this case, we're going to add a feature.

588
00:42:53,370 --> 00:43:00,430
We're going to add the feature of, by name parameters, if you will, or delayed parameters.

590
00:43:00,430 --> 00:43:08,220
Because, in fact, the default in our Lisp system is by the value of a pointer.

592
00:43:08,220 --> 00:43:13,410
A pointer is copied, but the data structure it points at is not.

594
00:43:13,410 --> 00:43:19,990
But I'd like to, in fact, show you is how you add name arguments as well.

596
00:43:19,990 --> 00:43:23,100
Now again, why would we need such a thing?

597
00:43:23,100 --> 00:43:29,720
Well supposing we wanted to invent certain kinds of what otherwise would be special forms, reserve words?

599
00:43:29,720 --> 00:43:32,180
But I'd rather not take up reserve words.

600
00:43:32,180 --> 00:43:36,360
I want procedures that can do things like if.

601
00:43:36,360 --> 00:43:39,420
If is special, or cond, or whatever it is.

602
00:43:39,420 --> 00:43:40,600
It's the same thing.

603
00:43:40,600 --> 00:43:50,840
It's special in that it determines whether or not to evaluate the consequent or the alternative based on the value of the predicate part of an expression.

606
00:43:50,840 --> 00:43:57,270
So taking the value of one thing determines whether or not to do something else.

608
00:43:57,270 --> 00:44:08,670
Whereas all the procedures like plus, the ones that we can define right now, evaluate all of their arguments before application.

611
00:44:08,670 --> 00:44:19,452
So, for example, supposing I wish to be able to define something like the reverse of if in terms of if.

613
00:44:19,452 --> 00:44:20,702
Call it unless.

614
00:44:24,890 --> 00:44:28,190
We've a predicate, a consequent, and an alternative.

616
00:44:28,190 --> 00:44:32,440
Now what I would like to sort of be able to do is say-- oh, I'll do it in terms of cond.

618
00:44:32,440 --> 00:44:45,350
Cond, if not the predicate, then take the consequent, otherwise, take the alternative.

620
00:44:51,290 --> 00:44:56,920
Now, what I'd like this to mean, is supposing I do something like this.

622
00:44:56,920 --> 00:45:11,350
I'd like this unless say if equals one, 0, then the answer is two, otherwise, the quotient of one and 0.

624
00:45:15,980 --> 00:45:25,580
What I'd like that to mean is the result of substituting equal one, 0, and two, and the quotient of one, 0 for p, c, and a.

627
00:45:25,580 --> 00:45:51,160
I'd like that to mean, and this is funny, I'd like it to transform into or mean cond not equal one, 0, then the result is two, otherwise I want it to be the quotient one and 0.

631
00:45:54,480 --> 00:45:59,970
Now, you know that if I were to type this into Lisp, I'd get a two.

633
00:45:59,970 --> 00:46:02,910
There's no problem with that.

634
00:46:02,910 --> 00:46:10,840
However, if I were to type this into Lisp, because all the arguments are evaluated before I start, then I'm going to get an error out of this.

637
00:46:13,380 --> 00:46:16,880
So that if the substitutions work at all, of course, I would get the right answer.

639
00:46:16,880 --> 00:46:20,160
But here's a case where the substitutions don't work.

640
00:46:22,920 --> 00:46:23,860
I don't get the wrong answer.

641
00:46:23,860 --> 00:46:24,670
I get no answer.

642
00:46:24,670 --> 00:46:25,920
I get an error.

643
00:46:28,420 --> 00:46:34,270
Now, however, I'd like to be able to make my definition so that this kind of thing works.

645
00:46:34,270 --> 00:46:39,930
What I want to do is say something special about c and a.

647
00:46:39,930 --> 00:46:42,715
I want them to be delayed automatically.

648
00:46:46,300 --> 00:46:51,520
I don't want them to be evaluated at the time I call.

649
00:46:51,520 --> 00:46:55,600
So I'm going to make a declaration, and then I'm going to see how to implement such a declaration.

651
00:46:55,600 --> 00:47:02,140
But again, I want you to say to yourself, oh, this is an interesting kluge he's adding in here.

653
00:47:02,140 --> 00:47:05,750
The piles of kluges make a big complicated mess.

654
00:47:05,750 --> 00:47:10,120
And is this going to foul up something else that might occur.

656
00:47:10,120 --> 00:47:13,860
First of all, is it syntactically unambiguous?

657
00:47:13,860 --> 00:47:17,840
Well, it will be syntactically unambiguous with what we've seen so far.

659
00:47:17,840 --> 00:47:21,670
But what I'm going to do may, in fact, cause trouble.

660
00:47:21,670 --> 00:47:34,300
It may be that the thing I had will conflict with type declarations I might want to add in the future for giving some system, some compiler or something, the ability to optimize given the types are known.

664
00:47:34,300 --> 00:47:40,570
Or it might conflict with other types of declarations I might want to make about the formal parameters.

666
00:47:40,570 --> 00:47:44,925
So I'm not making a general mechanism here where I can add declarations.

668
00:47:44,925 --> 00:47:46,750
And I would like to be able to do that.

669
00:47:46,750 --> 00:47:51,010
But I don't want to talk about that right now.

670
00:47:51,010 --> 00:47:53,680
So here I'm going to do, I'm going to build a kluge.

671
00:47:57,050 --> 00:48:14,930
So we're going to define unless of a predicate-- and I'm going to call these by name-- the consequent, and name the alternative.

674
00:48:19,850 --> 00:48:25,280
Huh, huh-- I got caught in the corner.

676
00:48:31,240 --> 00:48:41,360
If not p then the result is c, else-- that's what I'd like.

678
00:48:44,670 --> 00:48:51,650
Where I can explicitly declare certain of the parameters to be delayed, to be computed later.

680
00:48:55,008 --> 00:49:00,450
Now, this is actually a very complicated modification to an interpreter rather than a simple one.

682
00:49:00,450 --> 00:49:09,280
The ones you saw before, dynamic binding or adding indefinite argument procedures, is relatively simple.

685
00:49:09,280 --> 00:49:12,120
But this one changes a basic strategy.

686
00:49:12,120 --> 00:49:36,110
The problem here is that our interpreter, as written, evaluates a combination by evaluating the procedure, the operator producing the procedure, and evaluating the operands producing the arguments, and then doing apply of the procedure to the arguments.

691
00:49:36,110 --> 00:49:46,810
However, here, I don't want to evaluate the operands to produce the arguments until after I examined the procedure to see what the procedure's declarations look like.

694
00:49:49,590 --> 00:49:52,680
So let's look at that.

695
00:49:52,680 --> 00:49:57,480
Here we have a changed evaluator.

696
00:49:57,480 --> 00:50:09,750
I'm starting with the simple lexical evaluator, not dynamic, but we're going to have to do something sort of similar in some ways.

699
00:50:09,750 --> 00:50:19,360
Because of the fact that, if I delay a procedure-- I'm sorry-- delay an argument to a procedure, I'm going to have to attach and environment to it.

702
00:50:19,360 --> 00:50:23,380
Remember how Hal implemented delay.

703
00:50:23,380 --> 00:50:31,180
Hal implemented delay as being a procedure of no arguments which does some expression.

705
00:50:31,180 --> 00:50:32,670
That's what delay of the expression is.

706
00:50:35,370 --> 00:50:36,620
--of that expression.

707
00:50:39,180 --> 00:50:40,950
This turned into something like this.

708
00:50:44,520 --> 00:50:49,010
Now, however, if I evaluate a lambda expression, I have to capture the environment.

710
00:50:51,410 --> 00:51:01,530
The reason why is because there are variables in there who's meaning I wish to derive from the context where this was written.

713
00:51:04,010 --> 00:51:06,095
So that's why a lambda does the job.

714
00:51:06,095 --> 00:51:08,070
It's the right thing.

715
00:51:08,070 --> 00:51:21,090
And such that the forcing of a delayed expression was same thing as calling that with no arguments.

717
00:51:21,090 --> 00:51:24,100
It's just the opposite of this.

718
00:51:24,100 --> 00:51:33,132
Producing an environment of the call which is, in fact, the environment where this was defined with an extra frame in it that's empty.

721
00:51:33,132 --> 00:51:36,240
I don't care about that.

722
00:51:36,240 --> 00:51:51,980
Well, if we go back to this slide, since it's the case, if we look at this for a second, everything is the same as it was before except the case of applications or combinations.

725
00:51:51,980 --> 00:51:54,680
And combinations are going to do two things.

726
00:51:54,680 --> 00:52:00,425
One, is I have to evaluate the procedure-- forget the procedure-- by evaluating the operator.

728
00:52:00,425 --> 00:52:02,380
That's what you see right here.

729
00:52:02,380 --> 00:52:10,730
I have to make sure that that's current, that is not a delayed object, and evaluate that to the point where it's forced now.

732
00:52:10,730 --> 00:52:18,460
And then I have to somehow apply that to the operands.

733
00:52:18,460 --> 00:52:21,530
But I have to keep the environment, pass that environmental along.

735
00:52:21,530 --> 00:52:23,710
So some of those operands I may have to delay.

736
00:52:23,710 --> 00:52:29,302
I may have to attach that environment to those operands.

737
00:52:29,302 --> 00:52:32,990
This is a rather complicated thing happening here.

738
00:52:32,990 --> 00:52:34,240
Looking at that in apply.

739
00:52:36,400 --> 00:52:42,610
Apply, well it has a primitive procedure thing just like before.

741
00:52:42,610 --> 00:52:44,390
But the compound one is a little more interesting.

742
00:52:47,250 --> 00:53:00,290
I have to evaluate the body, just as before, in an environment which is the result of binding some formal parameters to arguments in the environment.

745
00:53:00,290 --> 00:53:01,530
That's true.

746
00:53:01,530 --> 00:53:03,820
The environment is the one that comes from the procedure now.

748
00:53:03,820 --> 00:53:08,040
It's a lexical language, statically bound.

749
00:53:08,040 --> 00:53:12,960
However, one thing I have to do is strip off the declarations to get the names of the variables.

751
00:53:12,960 --> 00:53:15,450
That's what this guy does, vnames.

752
00:53:15,450 --> 00:53:33,770
And the other thing I have to do is process these declarations, deciding which of these operands-- that's the operands now, as opposed to the arguments-- which of these operands to evaluate, and which of them are to be encapsulated in delays of some sort.

757
00:53:37,280 --> 00:53:45,820
The other thing you see here is that we got a primitive, a primitive like plus, had better get at the real operands.

760
00:53:45,820 --> 00:53:47,690
So here is a place where we're going to have to force them.

761
00:53:47,690 --> 00:53:51,340
And we're going to look at what evlist is going to have to do a bunch of forces.

763
00:53:51,340 --> 00:53:52,780
So we have two different kinds of evlist now.

764
00:53:52,780 --> 00:53:59,870
We have evlist and gevlist. Gevlist is going to wrap delays around some things and force others, evaluate others.

766
00:53:59,870 --> 00:54:07,900
And this guy's going to do some forcing of things.

767
00:54:07,900 --> 00:54:12,250
Just looking at this a little bit, this is a game you must play for yourself, you know.

769
00:54:12,250 --> 00:54:19,730
It's not something that you're going to see all possible variations on an evaluator talking to me.

771
00:54:19,730 --> 00:54:21,410
What you have to do is do this for yourself.

772
00:54:21,410 --> 00:54:29,930
And after you feel this, you play this a bit, you get to see all the possible design decisions and what they might mean, and how they interact with each other.

775
00:54:29,930 --> 00:54:33,160
So what languages might have in them.

776
00:54:33,160 --> 00:54:37,200
And what are some of the consistent sets that make a legitimate language.

778
00:54:37,200 --> 00:54:41,850
Whereas what things are complicated kluges that are just piles of junk.

780
00:54:41,850 --> 00:54:50,750
So evlist of course, over here, just as I said, is a list of operands which are going to be undelayed after evaluation.

783
00:54:50,750 --> 00:54:56,050
So these are going to be forced, whatever that's going to mean.

785
00:54:56,050 --> 00:55:04,040
And gevlist, which is the next thing-- Thank you.

787
00:55:04,040 --> 00:55:09,810
What we see here, well there's a couple of possibilities.

788
00:55:09,810 --> 00:55:19,390
Either it's a normal, ordinary thing, a symbol sitting there like the predicate in the unless, and that's what we have here.

791
00:55:19,390 --> 00:55:23,340
In which case, this is intended to be evaluated in applicative order.

793
00:55:23,340 --> 00:55:25,630
And it's, essentially, just what we had before.

794
00:55:25,630 --> 00:55:37,900
It's mapping eval down the list. In other words, I evaluate the first expression and continue gevlisting the CDR of the expression in the environment.

797
00:55:37,900 --> 00:55:43,600
However, it's possible that this is a name parameter.

798
00:55:43,600 --> 00:56:02,790
If it's a name parameter, I want to put a delay in which combines that expression, which I'm calling by name, with the environment that's available at this time and passing that as the parameter.

802
00:56:02,790 --> 00:56:05,600
And this is part of the mapping process that you see here.

804
00:56:09,070 --> 00:56:14,700
The only other interesting place in this interpreter is cond.

806
00:56:14,700 --> 00:56:18,550
People tend to write this thing, and then they leave this one out.

808
00:56:18,550 --> 00:56:20,510
There's a place where you have to force.

809
00:56:20,510 --> 00:56:25,990
Conditionals have to know whether or not the answer is true or false.

811
00:56:25,990 --> 00:56:28,550
It's like a primitive.

812
00:56:28,550 --> 00:56:31,890
When you do a conditional, you have to force.

813
00:56:31,890 --> 00:56:34,350
Now, I'm not going to look at any more of this in any detail.

815
00:56:34,350 --> 00:56:36,750
It isn't very exciting.

816
00:56:36,750 --> 00:56:38,990
And what's left is how you make delays.

817
00:56:38,990 --> 00:56:44,840
Well, delays are data structures which contain an expression, an environment, and a type on them.

819
00:56:44,840 --> 00:56:46,680
And it says they're a thunk.

820
00:56:46,680 --> 00:56:52,970
That comes from ALGOL language, and it's claimed to be the sound of something being pushed on a stack.

822
00:56:52,970 --> 00:56:53,410
I don't know.

823
00:56:53,410 --> 00:56:58,740
I was not an ALGOLician or an ALGOLite or whatever, so I don't know.

825
00:56:58,740 --> 00:57:00,270
But that's what was claimed.

826
00:57:00,270 --> 00:57:07,860
And undelay is something which will recursively undelay thunks until the thunk becomes something which isn't a thunk.

828
00:57:07,860 --> 00:57:12,050
This is the way you implement a call by name like thing in ALGOL.

830
00:57:12,050 --> 00:57:15,210
And that's about all there is.

831
00:57:15,210 --> 00:57:16,460
Are there any questions?

832
00:57:26,840 --> 00:57:27,560
AUDIENCE: Gerry?

833
00:57:27,560 --> 00:57:29,626
PROFESSOR: Yes, Vesko?

834
00:57:29,626 --> 00:57:39,350
AUDIENCE: I noticed you avoided calling by name in the primitive procedures, I was wondering what cause you have on that?

837
00:57:39,350 --> 00:57:40,070
You never need that?

838
00:57:40,070 --> 00:57:47,140
PROFESSOR: Vesko is asking if it's ever reasonable to call a primitive procedure by name?

840
00:57:47,140 --> 00:57:49,270
The answer is, yes.

841
00:57:49,270 --> 00:57:52,930
There's one particular case where it's reasonable, actually two.

843
00:57:56,050 --> 00:58:03,690
Construction of a data structure like cons where making an array if you have arrays with any number of elements.

846
00:58:03,690 --> 00:58:07,440
It's unnecessary to evaluate those arguments.

847
00:58:07,440 --> 00:58:11,160
All you need is promises to evaluate those arguments if you look at them.

849
00:58:11,160 --> 00:58:21,830
If I cons together two things, then I could cons together the promises just as easily as I can cons together the things.

851
00:58:21,830 --> 00:58:24,840
And it's not even when I CAR CDR them that I have to look at them.

853
00:58:24,840 --> 00:58:28,260
That just gets out the promises and passes them to somebody.

855
00:58:28,260 --> 00:58:34,420
That's why the lambda calculus definition, the Alonzo Church definition of CAR, CDR, and cons makes sense.

857
00:58:34,420 --> 00:58:40,760
It's because no work is done in CAR, CDR, and cons, it's just shuffling data, it's just routing, if you will.

859
00:58:40,760 --> 00:58:45,280
However, the things that do have to look at data are things like plus.

861
00:58:45,280 --> 00:58:52,460
Because they have a look at the bits that the numbers are made out of, unless they're lambda calculus numbers which are funny.

864
00:58:52,460 --> 00:58:55,880
They have to look at the bits to be able to crunch them together to do the add.

866
00:58:59,210 --> 00:59:13,300
So, in fact, data constructors, data selectors, and, in fact, things that side-effect data objects don't need to do any forcing in the laziest possible interpreters.

869
00:59:16,460 --> 00:59:18,700
On the other hand predicates on data structures have to.

870
00:59:21,710 --> 00:59:23,560
Is this a pair?

871
00:59:23,560 --> 00:59:24,640
Or is it a symbol?

872
00:59:24,640 --> 00:59:25,690
Well, you better find out.

873
00:59:25,690 --> 00:59:26,940
You got to look at it then.

874
00:59:30,300 --> 00:59:31,550
Any other questions?

875
00:59:40,050 --> 00:59:41,610
Oh, well, I suppose it's time for a break.

876
00:59:41,610 --> 00:59:42,106
Thank you.

877
00:59:42,106 --> 01:00:02,950
[MUSIC PLAYING]

