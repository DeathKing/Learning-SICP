1
00:00:21,170 --> 00:00:36,630
PROFESSOR: Well, now that we've given you some power to make independent local state and to model objects, I thought we'd do a bit of programming of a very complicated kind, just to illustrate what you can do with this sort of thing.

2
00:00:40,430 --> 00:00:52,060
I suppose, as I said, we were motivated by physical systems and the ways we like to think about physical systems, which is that there are these things that the world is made out of.

3
00:00:52,060 --> 00:00:58,830
And each of these things has particular independent local state, and therefore it is a thing.

4
00:00:58,830 --> 00:01:01,280
That's what makes it a thing.

5
00:01:01,280 --> 00:01:10,940
And then we're going to say that in the model in the world--we have a world and a model in our minds and in the computer of that world.

6
00:01:10,940 --> 00:01:28,570
And what I want to make is a correspondence between the objects in the world and the objects in the computer, the relationships between the objects in the world and the relationships between those same obj...--the model objects in the computer, and the functions that relate things in the world to the functions that relate things in the computer.

7
00:01:30,840 --> 00:01:34,740
This buys us modularity.

8
00:01:34,740 --> 00:01:50,450
If we really believe the world is like that, that it's made out of these little pieces, and of course we could arrange our world to be like that, we could only model those things that are like that, then we can inherit the modularity in the world into our programming.

9
00:01:50,450 --> 00:01:55,420
That's why we would invent some of this object-oriented programming.

10
00:01:55,420 --> 00:01:58,890
Well, let's take the best kind of objects I know.

11
00:01:58,890 --> 00:02:14,220
They're completely--they're completely wonderful: electrical systems. Electrical systems really are the physicist's best, best objects.

12
00:02:14,220 --> 00:02:16,760
You see over here I have some piece of machinery.

13
00:02:16,760 --> 00:02:20,040
Right here's a piece of machinery.

14
00:02:20,040 --> 00:02:27,190
And it's got an electrical wire connecting one part of the machinery with another part of the machinery.

15
00:02:27,190 --> 00:02:38,310
And one of the wonderful properties of the electrical world is that I can say this is an object, and this is an object, and they're-- the connection between them is clear.

16
00:02:38,310 --> 00:02:44,740
In principle, there is no connection that I didn't describe with these wires.

17
00:02:44,740 --> 00:02:51,370
Let's say if I have light bulbs, a light bulb and a power supply that's plugged into the outlet.

18
00:02:51,370 --> 00:02:53,620
Then the connection is perfectly clear.

19
00:02:53,620 --> 00:02:56,220
There's no other connections that we know of.

20
00:02:56,220 --> 00:03:04,040
If I were to tie a knot in the wire that connects the light bulb to the power supply, the light remains lit up.

21
00:03:04,040 --> 00:03:05,290
It doesn't care.

22
00:03:08,300 --> 00:03:15,270
That the way the physics is arranged is such that the connection can be made abstract, at least for low frequencies and things like that.

23
00:03:17,840 --> 00:03:22,350
So in fact, we have captured all of the connections there really are.

24
00:03:22,350 --> 00:03:30,951
Well, as you can go one step further and talk about the most abstract types of electrical systems we have, digital to dual circuits.

25
00:03:30,951 --> 00:03:34,610
And here there are certain kinds of objects.

26
00:03:34,610 --> 00:03:41,092
For example, in digital circuits we have things like inverters.

27
00:03:41,092 --> 00:03:43,990
We have things like and-gates.

28
00:03:43,990 --> 00:03:47,210
We have things like or-gates.

29
00:03:47,210 --> 00:03:55,610
We connect them together by sort-of wires which represent abstract signals.

30
00:03:55,610 --> 00:04:05,160
We don't really care as physical variables whether these are voltages or currents or some combination or anything like that, or water, water pressure.

31
00:04:05,160 --> 00:04:09,420
These abstract variables represent certain signals.

32
00:04:09,420 --> 00:04:14,070
And we build systems by wiring these things together with wires.

33
00:04:14,070 --> 00:04:32,700
So today what I'm going to show you, right now, we're going to build up an invented language in Lisp, embedded in the same sense that Henderson's picture language was embedded, which is not the same sense as the language of pattern match and substitution was done yesterday.

34
00:04:32,700 --> 00:04:38,160
The pattern match/substitution language was interpreted by a Lisp program.

35
00:04:38,160 --> 00:04:45,480
But the embedding of Henderson's program is that we just build up more and more procedures that encapsulate the structure we want.

36
00:04:45,480 --> 00:04:53,026
So for example here, I'm going to have some various primitive kinds of objects, as you see, that one and that one.

37
00:04:53,026 --> 00:04:55,810
I'm going to use wires to combine them.

38
00:04:55,810 --> 00:04:59,870
The way I represent attaching-- I can make wires.

39
00:04:59,870 --> 00:05:01,740
So let's say A is a wire.

40
00:05:01,740 --> 00:05:02,690
And B is a wire.

41
00:05:02,690 --> 00:05:03,460
And C is a wire.

42
00:05:03,460 --> 00:05:04,230
And D is a wire.

43
00:05:04,230 --> 00:05:04,830
And E is wire.

44
00:05:04,830 --> 00:05:06,880
And S is a wire.

45
00:05:06,880 --> 00:05:17,940
Well, an or-gate that has both inputs, the inputs being A and B, and the output being Y or D, you notate like this.

46
00:05:17,940 --> 00:05:24,820
An and-gate, which has inputs A and B and output C, we notate like that.

47
00:05:24,820 --> 00:05:32,750
By making such a sequence of declarations, like this, I can wire together an arbitrary circuit.

48
00:05:32,750 --> 00:05:43,690
So I've just told you a set of primitives and means of combination for building digital circuits, when I need more in a real language than abstraction.

49
00:05:43,690 --> 00:05:52,240
And so for example, here I have--here I have a half adder.

50
00:05:52,240 --> 00:05:56,930
It's something you all know if you've done any digital design.

51
00:05:56,930 --> 00:06:03,956
It's used for adding numbers together on A and B and putting out a sum and a carry.

52
00:06:03,956 --> 00:06:07,450
And in fact, the wiring diagram is exactly what I told you.

53
00:06:07,450 --> 00:06:14,790
A half adder with things that come out of the box-- you see the box, the boundary, the abstraction is always a box.

54
00:06:14,790 --> 00:06:19,700
And there are things that come out of it, A, B, S, and C.

55
00:06:19,700 --> 00:06:28,270
Those are the declared variables--declared variables of a lambda expression, which is the one that defines half adder.

56
00:06:31,400 --> 00:06:48,790
And internal to that, I make up some more wires, D and E, which I'm going to use for the interconnect-- here E is this one and D is this wire, the interconnect that doesn't come through the walls of the box-- and wire things together as you just saw.

57
00:06:48,790 --> 00:06:53,890
And the nice thing about this that I've just shown you is this language is hierarchical in the right way.

58
00:06:53,890 --> 00:07:06,300
If a language isn't hierarchical in the right way, if it turns out that a compound object doesn't look like a primitive, there's something wrong with the language-- at least the way I feel about that.

59
00:07:06,300 --> 00:07:23,350
So here we have--here, instead of starting with mathematical functions, or things that compute mathematical functions, which is what we've been doing up until now, instead of starting with things that look like mathematical functions, or compute such things, we are starting with things that are electrical objects and we build up more electrical objects.

60
00:07:23,350 --> 00:07:30,500
And the glue we're using is basically the Lisp structure: lambdas.

61
00:07:30,500 --> 00:07:32,930
Lambda is the ultimate glue, if you will.

62
00:07:32,930 --> 00:08:05,900
And of course, half adder itself can be used in a more complicated abstraction called a full adder, which in fact involves two half adders, as you see here, hooked together with some extra wires, that you see here, S, C1, and C2, and an or-gate, to manufacture a full adder, which takes a input number, another input number, a carry in, and produces output, a sum and a carry out.

63
00:08:05,900 --> 00:08:12,990
And out of full adders, you can make real adder chains and big adders.

64
00:08:12,990 --> 00:08:22,270
So we have here a language so far that has primitives, means of combination, and means of abstraction to real language.

65
00:08:22,270 --> 00:08:25,000
Now, how are we going to implement this?

66
00:08:25,000 --> 00:08:27,070
Well, let's do it easily.

67
00:08:27,070 --> 00:08:28,610
Let's look at the primitives.

68
00:08:28,610 --> 00:08:31,160
The only problem is we have to implement the primitives.

69
00:08:31,160 --> 00:08:43,417
Nothing else has to be implemented, because we're picking up the means of combination and abstraction from Lisp, inheriting them in the embedding.

70
00:08:43,417 --> 00:08:45,860
OK, so let's look at a particular primitive.

71
00:08:45,860 --> 00:08:47,400
An inverter is a nice one.

72
00:08:51,540 --> 00:08:54,900
Now, inverter has two wires coming in, an in and an out.

73
00:08:57,440 --> 00:09:04,300
And somehow, it's going to have to know what to do when a signal comes in.

74
00:09:04,300 --> 00:09:20,120
So somehow it's going to have to tell its input wire-- and now we're going to talk about objects and we're going to see this in a little more detail soon-- but it's going to have to tell its input wire that when you change, tell me.

75
00:09:20,120 --> 00:09:26,870
So this object, the object which is the inverter has to tell the object which is the input wire, hi, my name is George.

76
00:09:26,870 --> 00:09:31,720
And my, my job is to do something with results when you change.

77
00:09:31,720 --> 00:09:34,730
So when you change, you get a change, tell me about it.

78
00:09:34,730 --> 00:09:37,010
Because I've got to do something with that.

79
00:09:37,010 --> 00:09:56,130
Well, that's done down here by adding an action on the input wire called invert-in, where invert-in is defined over here to be a procedure of no arguments, which gets the logical not of the signal on the input wire.

80
00:09:56,130 --> 00:10:07,140
And after some delay, which is the inverter delay, all these electrical objects have delays, we'll do the following thing-- set the signal on the output wire to the new value.

81
00:10:10,160 --> 00:10:12,400
A very simple program.

82
00:10:12,400 --> 00:10:23,840
Now, you have to imagine that the output wire has to be sensitive and know that when its signal changes, it may have to tell other guys, hey, wake up.

83
00:10:23,840 --> 00:10:26,050
My value has changed.

84
00:10:26,050 --> 00:10:36,810
So when you hook together inverter with an and-gate or something like that, there has to be a lot of communication going on in order to make sure that the signal propagates right.

85
00:10:36,810 --> 00:10:38,620
And down here is nothing very exciting.

86
00:10:38,620 --> 00:10:46,240
This is just the definition of logical not for some particular representations of the logical values-- 1, 0 in this case.

87
00:10:46,240 --> 00:10:49,780
And we can look at things more complicated like and-gates.

88
00:10:49,780 --> 00:10:56,950
And-gates take two inputs, A1 and A2, we'll call them, and produce an output.

89
00:10:56,950 --> 00:11:00,860
But the structure of the and-gate is identical to the one we just saw.

90
00:11:00,860 --> 00:11:10,910
There's one called an and-action procedure that's defined, which is the thing that gets called when an input is changed.

91
00:11:10,910 --> 00:11:15,900
And what it does, of course, is nothing more than compute the logical and of the signals on the inputs.

92
00:11:15,900 --> 00:11:25,470
And after some delay, called the and-gate delay, calls this procedure, which sets a signal on the output to a new value.

93
00:11:25,470 --> 00:11:28,350
Now, how I implement these things is all wishful thinking.

94
00:11:28,350 --> 00:11:32,020
As you see here, I have an assignment operation.

95
00:11:32,020 --> 00:11:34,570
It's not set.

96
00:11:34,570 --> 00:11:46,340
It's a derived assignment operation in the same way we had functions that were derived from CAR and CDR. So I, by convention, label that with an exclamation point.

97
00:11:46,340 --> 00:12:03,350
And over here, you see there's an action, which is to inform the wire, called A1 locally in this and-gate, to call the and-action procedure when it gets changed, and the wire A2 to call the and-action procedure when it gets changed.

98
00:12:06,310 --> 00:12:09,510
All very simple.

99
00:12:09,510 --> 00:12:18,310
Well, let's talk a little bit about this communication that must occur between these various parts.

100
00:12:18,310 --> 00:12:47,360
Suppose, for example, I have a very simple circuit which contains an and with wires A and B. And that connects through a wire called C to an inverter which has a wire output called D. What are the comput...--here's the physical world.

101
00:12:47,360 --> 00:12:49,860
It's an abstraction of the physical world.

102
00:12:49,860 --> 00:12:54,880
Now I can buy these out of little pieces that you get at Radio Shack for a few cents.

103
00:12:54,880 --> 00:13:01,530
And there are boxes that act like this, which have little numbers on them like LS04 or something.

104
00:13:01,530 --> 00:13:09,010
Now supposing I were to try to say what's the computational model.

105
00:13:09,010 --> 00:13:15,850
What is the thing that corresponds to that, that part of reality in the mind of us and in the computer?

106
00:13:15,850 --> 00:13:25,750
Well, I have to assign for every object in the world an object in the computer, and for every relationship in the world between them a relationship in the computer.

107
00:13:25,750 --> 00:13:28,560
That's my goal.

108
00:13:28,560 --> 00:13:30,900
So let's do that.

109
00:13:30,900 --> 00:13:35,401
Well, I have some sort of thing called the signal, A.

110
00:13:35,401 --> 00:13:37,940
This is A. It's a signal.

111
00:13:37,940 --> 00:13:39,900
It's a cloudy thing like that.

112
00:13:39,900 --> 00:13:49,140
And I have another one down here which I'm going to call B. It's another signal.

113
00:13:49,140 --> 00:14:00,320
Now this signal--these two signals are somehow going to have to hook together into a box, let's call it this, which is the and-gate, action procedure.

114
00:14:00,320 --> 00:14:02,040
That's the and-gate's action procedure.

115
00:14:07,660 --> 00:14:30,195
And it's going to produce--well, it's going to interact with a signal object, which we call C--a wire object, excuse me, we call C. And then the-- this is going to put out again, or connect to, another action procedure which is one associated with the inverter in the world, not.

116
00:14:32,860 --> 00:14:42,970
And I'm going to have another--another wire, which we'll call D.

117
00:14:42,970 --> 00:14:45,770
So here's my layout of stuff.

118
00:14:45,770 --> 00:14:51,500
Now we have to say what's inside them and what they have to know to compute.

119
00:14:51,500 --> 00:14:57,340
Well, every--every one of these wires has to know what the value of the signal that's on that wire is.

120
00:14:57,340 --> 00:15:00,680
So there's going to be some variable inside here, we'll call it signal.

121
00:15:02,670 --> 00:15:05,840
And he owns a value.

122
00:15:05,840 --> 00:15:08,656
So there must be some environment associated with this.

123
00:15:08,656 --> 00:15:11,800
And for each one of these, there must be an environment that binds signal.

124
00:15:15,400 --> 00:15:16,880
And there must be a signal here, therefore.

125
00:15:19,400 --> 00:15:24,170
And presumably, signal's a value that's either 1 or 0, and signal.

126
00:15:28,000 --> 00:15:34,390
Now, we also have to have some list of people to inform if the signal here changes.

127
00:15:36,660 --> 00:15:39,300
We're going to have to inform this.

128
00:15:39,300 --> 00:15:44,500
So I've got that list. We'll call it the Action Procedures, AP.

129
00:15:44,500 --> 00:15:50,500
And it's presumably a list. But the first thing on the list, in this case, is this guy.

130
00:15:50,500 --> 00:15:54,810
And the action procedures of this one happens to have some list of stuff.

131
00:15:54,810 --> 00:15:59,020
There might be other people who are sharing A, who are looking at it.

132
00:15:59,020 --> 00:16:03,630
So there might be other guys on this list, like somebody over there that we don't know about.

133
00:16:03,630 --> 00:16:07,200
It's the other guy attached to A.

134
00:16:07,200 --> 00:16:13,070
And the action procedure here also has to point to that, the list of action procedures.

135
00:16:13,070 --> 00:16:18,530
And of course, that means this one, its action procedures has to point up to here.

136
00:16:18,530 --> 00:16:21,770
This is the things-- the people it has to inform.

137
00:16:21,770 --> 00:16:24,280
And this guy has some too.

138
00:16:24,280 --> 00:16:27,190
But I don't know what they are because I didn't draw it in my diagram.

139
00:16:27,190 --> 00:16:30,320
It's the things connected to D.

140
00:16:30,320 --> 00:16:52,790
Now, it's also the case that when the and-action procedure is awakened, saying one of the people who know that you've told--one of the people you've told to wake you up if their signal changes, you have to go look and ask them what's their signal so you can do the and, and produce a signal for this one.

141
00:16:57,090 --> 00:17:06,400
So there has to be, for example, information here saying A1, my A1 is this guy, and my A2 is this guy.

142
00:17:08,930 --> 00:17:16,170
And not only that, when I do my and, I'm going to have to tell this guy something.

143
00:17:16,170 --> 00:17:21,160
So I need an output--  being this guy.

144
00:17:25,800 --> 00:17:43,520
And similarly, this guy's going to have a thing called the input that he interrogates to find out what the value of the signal on the input is, when the signal wakes up and says, I've changed, and sends a message this way saying, I've changed.

145
00:17:43,520 --> 00:17:46,900
This guy says, OK, what's your value now?

146
00:17:46,900 --> 00:17:55,860
When he gets that value, then he's going to have to say, OK, output changes this guy, changes this guy.

147
00:18:00,600 --> 00:18:02,481
And so on.

148
00:18:02,481 --> 00:18:06,240
And so I have to have at least that much connected-ness.

149
00:18:06,240 --> 00:18:10,260
Now, let's go back and look, for example, at the and-gate.

150
00:18:10,260 --> 00:18:13,670
Here we are back on this slide.

151
00:18:13,670 --> 00:18:16,040
And we can see some of these parts.

152
00:18:16,040 --> 00:18:21,030
For any particular and-gate, there is an A1, there is an A2, and the output.

153
00:18:21,030 --> 00:18:46,240
And those are, those are an environment that was created at the--those produce a frame at the time and-gate was called, a frame where A1, A2, and output are--have as their values, they're bound to the wires which, they are--which were passed in.

154
00:18:46,240 --> 00:18:54,590
In that environment, I constructed a procedure-- this one right there.

155
00:18:54,590 --> 00:18:57,780
And-action procedure was constructed in that environment.

156
00:18:57,780 --> 00:19:01,620
That was the result of evaluating a lambda expression.

157
00:19:01,620 --> 00:19:07,620
So it hangs onto the frame where these were defined.

158
00:19:07,620 --> 00:19:11,700
Local--part of its local state is that.

159
00:19:11,700 --> 00:19:17,310
The and-action procedure, therefore, has access to A1, A2, and output as we see here.

160
00:19:17,310 --> 00:19:19,645
A1, A2, and output.

161
00:19:22,360 --> 00:19:26,030
Now, we haven't looked inside of a wire yet.

162
00:19:26,030 --> 00:19:29,030
That's all that remains.

163
00:19:29,030 --> 00:19:30,280
Let's look at a wire.

164
00:19:33,520 --> 00:19:36,160
Like the overhead, very good.

165
00:19:39,500 --> 00:19:43,090
Well, the wire, again, is a, is a somewhat complicated mess.

166
00:19:43,090 --> 00:19:46,840
Ooh, wrong one.

167
00:19:46,840 --> 00:19:49,780
It's a big complicated mess, like that.

168
00:19:49,780 --> 00:19:54,720
But let's look at it in detail and see what's going on.

169
00:19:54,720 --> 00:19:57,760
Well, the wire is one of these.

170
00:19:57,760 --> 00:20:05,010
And it has to have two things that are part of it, that it's state.

171
00:20:05,010 --> 00:20:07,390
One of them is the signal we see here.

172
00:20:07,390 --> 00:20:19,270
In other words, when we call make-wire to make a wire, then the first thing we do is we create some variables which are the signal and the action procedures for this wire.

173
00:20:22,042 --> 00:20:27,840
And in that context, we define various functions--or procedures, excuse me, procedures.

174
00:20:27,840 --> 00:20:32,850
One of them is called set-my-signal to a new value.

175
00:20:32,850 --> 00:20:37,930
And what that does is takes a new value in.

176
00:20:37,930 --> 00:20:40,360
If that's equal to my current value of my signal, I'm done.

177
00:20:40,360 --> 00:20:54,630
Otherwise, I set the signal to the new value and call each of the action procedures that I've been, that I've been--what's the right word?--  introduced to.

178
00:20:54,630 --> 00:21:01,530
I get introduced when the and-gate was applied to me.

179
00:21:04,130 --> 00:21:07,410
I add action procedure at the bottom.

180
00:21:07,410 --> 00:21:27,780
Also, I have to define a way of accepting an action procedure-- which is what you see here--- which increments my action procedures using set to the result of CONSing up a new process--a procedure, which is passed to me, on to my actions procedures list. And for technical reasons, I have to call that procedure one.

181
00:21:27,780 --> 00:21:36,950
So I'm not going to tell you anything about that, that has to do with event-driven simulations and getting them started, which takes a little bit of thinking.

182
00:21:36,950 --> 00:21:53,820
And finally, I'm going to define a thing called the dispatcher, which is a way of passing a message to a wire, which is going to be used to extract from it various information, like what is the current signal value?

183
00:21:53,820 --> 00:21:57,180
What is the method of setting your signal?

184
00:21:57,180 --> 00:22:00,100
I want to get that out of it.

185
00:22:00,100 --> 00:22:02,600
How do I--how do I add another action procedure?

186
00:22:05,510 --> 00:22:09,940
And I'm going to return that dispatch, that procedure as a value.

187
00:22:09,940 --> 00:22:19,790
So the wire that I've constructed is a message accepting object which accepts a message like, like what's your method of adding action procedures?

188
00:22:19,790 --> 00:22:29,010
In fact, it'll give me a procedure, which is the add action procedure, which I can then apply to an action procedure to create another action procedure in the wire.

189
00:22:31,620 --> 00:22:32,820
So that's a permission.

190
00:22:32,820 --> 00:22:37,450
So it's given me permission to change your action procedures.

191
00:22:37,450 --> 00:22:41,710
And in fact, you can see that over here.

192
00:22:41,710 --> 00:22:43,278
Next slide.

193
00:22:43,278 --> 00:22:44,528
Ah.

194
00:22:47,760 --> 00:22:49,120
This is nothing very interesting.

195
00:22:49,120 --> 00:22:54,990
The call each of the action procedures is just a CDRing down a list. And I'm not going to even talk about that anymore.

196
00:22:54,990 --> 00:22:57,560
We're too advanced for that.

197
00:22:57,560 --> 00:23:03,090
However, if I want to get a signal from a wire, I ask the wire-- which is, what is the wire?

198
00:23:03,090 --> 00:23:05,860
The wire is the dispatch returned by creating the wire.

199
00:23:05,860 --> 00:23:06,830
It's a procedure.

200
00:23:06,830 --> 00:23:12,590
I call that dispatch on the message get-signal.

201
00:23:12,590 --> 00:23:16,900
And what I should expect to get is a method of getting a signal.

202
00:23:16,900 --> 00:23:19,220
Or actually, I get the signal.

203
00:23:19,220 --> 00:23:38,700
If I want to set a signal, I want to change a signal, then what I'm going to do is take a wire as an argument and a new value for the signal, I'm going to ask the wire for permission to set its signal and use that permission, which is a procedure, on the new value.

204
00:23:38,700 --> 00:24:13,010
And if we go back to the overhead here, thank you, if we go back to the overhead here, we see that the method-- if I ask for the method of setting the signal, that's over here, it's set-my-signal, a procedure that's defined inside the wire, which if we look over here is the thing that says set my internal value called the signal, my internal variable, which is the signal, to the new value, which is passed to me as an argument, and then call each of the action procedures waking them up.

205
00:24:16,340 --> 00:24:19,400
Very simple.

206
00:24:19,400 --> 00:24:30,100
Going back to that slide, we also have the one last thing-- which I suppose now you can easily work out for yourself-- is the way you add an action.

207
00:24:30,100 --> 00:24:36,470
You take a wire--a wire and an action procedure.

208
00:24:36,470 --> 00:24:40,050
And I ask the wire for permission to add an action.

209
00:24:40,050 --> 00:24:45,020
Getting that permission, I use that permission to give it an action procedure.

210
00:24:45,020 --> 00:24:48,570
So that's a real object.

211
00:24:48,570 --> 00:24:52,460
There's a few more details about this.

212
00:24:52,460 --> 00:24:58,390
For example, how am I going to control this thing?

213
00:24:58,390 --> 00:25:01,290
How do I do these delays?

214
00:25:01,290 --> 00:25:02,540
Let's look at that for a second.

215
00:25:05,275 --> 00:25:08,360
The next one here.

216
00:25:08,360 --> 00:25:09,570
Let's see.

217
00:25:09,570 --> 00:25:18,770
We know when we looked at the and-gate or the not-gate that when a signal changed on the input, there was a delay.

218
00:25:18,770 --> 00:25:23,310
And then it was going to call the procedure, which was going to change the output.

219
00:25:26,040 --> 00:25:28,120
Well, how are we going to do this?

220
00:25:28,120 --> 00:25:34,720
We're going to make up some mechanism, a fairly complicated mechanism at that, which we're going to have to be very careful about.

221
00:25:34,720 --> 00:25:37,390
But after a delay, we're going to do an action.

222
00:25:37,390 --> 00:25:40,590
A delay is a number, and an action is a procedure.

223
00:25:40,590 --> 00:25:49,510
What that's going to be is they're going to have a special structure called an agenda, which is a thing that organizes time and actions.

224
00:25:49,510 --> 00:25:50,880
And we're going to see that in a while.

225
00:25:50,880 --> 00:25:53,070
I don't want to get into that right now.

226
00:25:53,070 --> 00:25:59,130
But the agenda has a moment at which--at which something happens.

227
00:25:59,130 --> 00:26:08,460
We're setting up for later at some moment, which is the sum of the time, which is the delay time plus the current time, which the agenda thinks is now.

228
00:26:08,460 --> 00:26:13,090
We're going to set up to do this action, and add that to the agenda.

229
00:26:15,280 --> 00:26:18,660
And the way this machine will now run is very simple.

230
00:26:18,660 --> 00:26:22,710
We have a thing called propagate, which is the way things run.

231
00:26:22,710 --> 00:26:27,440
If the agenda is empty, we're done--if there's nothing more to be done.

232
00:26:27,440 --> 00:26:34,200
Otherwise, we're going to take the first item off the agenda, and that's a procedure of no arguments.

233
00:26:34,200 --> 00:26:36,030
So that we're going to see extra parentheses here.

234
00:26:36,030 --> 00:26:39,190
We call that on no arguments.

235
00:26:39,190 --> 00:26:42,200
That takes the action.

236
00:26:42,200 --> 00:26:48,395
Then we remove that first item from the agenda, and we go around the propagation loop.

237
00:26:48,395 --> 00:26:50,750
So that's the overall structure of this thing.

238
00:26:53,380 --> 00:26:57,430
Now, there's a, a few other things we can look at.

239
00:26:57,430 --> 00:27:00,410
And then we're going to look into the agenda a little while from now.

240
00:27:00,410 --> 00:27:02,800
Now the overhead again.

241
00:27:02,800 --> 00:27:07,410
Well, in order to set this thing going, I just want to show you some behavior out of this simulator.

242
00:27:07,410 --> 00:27:12,370
By the way, you may think this simulator is very simple, and probably too simple to be useful.

243
00:27:12,370 --> 00:27:18,680
The fact of the matter is that this simulator has been used to manufacture a fairly large computer.

244
00:27:18,680 --> 00:27:22,360
So this is a real live example.

245
00:27:22,360 --> 00:27:25,560
Actually, not exactly this simulator, because I'll tell you the difference.

246
00:27:25,560 --> 00:27:29,820
The difference is that there were many more different kinds of primitives.

247
00:27:29,820 --> 00:27:33,200
There's not just the word inverter or and-gate.

248
00:27:33,200 --> 00:27:45,170
There were things like edge-triggered, flip-flops, and latches, transparent latches, and adders, and things like that.

249
00:27:45,170 --> 00:27:54,690
And the difficulty with that is that there's pages and pages of the definitions of all these primitives with numbers like LS04.

250
00:27:54,690 --> 00:27:56,740
And then there's many more parameters for them.

251
00:27:56,740 --> 00:27:58,480
It's not just one delay.

252
00:27:58,480 --> 00:28:01,220
There's things like set up times and hold times and all that.

253
00:28:01,220 --> 00:28:15,110
But with the exception of that part of the complexity, the structure of the simulator that we use for building a real computer, that works is exactly what you're seeing here.

254
00:28:15,110 --> 00:28:19,270
Well in any case, what we have here is a few simple things.

255
00:28:19,270 --> 00:28:23,030
Like, there's inverter delays being set up and making a new agenda.

256
00:28:23,030 --> 00:28:26,470
And then we can make some inputs.

257
00:28:26,470 --> 00:28:29,460
There's input-1, input-2, a sum and a carry, which are wires.

258
00:28:29,460 --> 00:28:37,810
I'm going to put a special kind of object called a probe onto, onto some of the wires, onto sum and onto carry.

259
00:28:37,810 --> 00:28:46,120
A probe is a, can object that has the property that when you change a wire it's attached to, it types out a message.

260
00:28:46,120 --> 00:28:47,970
It's an easy thing to do.

261
00:28:47,970 --> 00:28:59,400
And then once we have that, of course, the way you put the probe on, the first thing it does, it says, the current value of the sum at time 0 is 0 because I just noticed it.

262
00:28:59,400 --> 00:29:05,556
And the value of the carry at time 0, this is the time, is 0.

263
00:29:05,556 --> 00:29:09,620
And then we go off and we build some structure.

264
00:29:09,620 --> 00:29:18,420
Like, we can build a structure here that says you have a half-adder on input-1, input-2, sum, and carry.

265
00:29:18,420 --> 00:29:20,420
And we're going to set the signal on input-1 to 1.

266
00:29:20,420 --> 00:29:21,880
We do some propagation.

267
00:29:21,880 --> 00:29:29,520
At time 8, which you could see going through this thing if you wanted to, the new value of sum became 1.

268
00:29:29,520 --> 00:29:31,150
And the thing says I'm done.

269
00:29:31,150 --> 00:29:32,630
That wasn't very interesting.

270
00:29:32,630 --> 00:29:34,150
But we can send it some more signals.

271
00:29:34,150 --> 00:29:36,590
Like, we set-signal on input-2 to be one.

272
00:29:36,590 --> 00:29:45,040
And at that time if we propagate, then it carried at 11, the carry becomes 1, and at 16, the sum's new value becomes 0.

273
00:29:45,040 --> 00:29:48,990
And you might want to work out that, if you like, about the digital circuitry.

274
00:29:48,990 --> 00:29:50,620
It's true, and it works.

275
00:29:50,620 --> 00:29:51,535
And it's not very interesting.

276
00:29:51,535 --> 00:29:54,580
But that's the kind of behavior we get out of this thing.

277
00:30:01,830 --> 00:30:12,952
So what I've shown you right now is a large-scale picture, how you, at a bigger, big scale, you implement an event-driven simulation of some sort.

278
00:30:12,952 --> 00:30:21,225
And how you might organize it to have nice hierarchical structure allowing you to build abstract boxes that you can instantiate.

279
00:30:21,225 --> 00:30:25,780
But I haven't told you any of the details about how this agenda and things like that work.

280
00:30:25,780 --> 00:30:28,630
That we'll do next.

281
00:30:28,630 --> 00:30:34,310
And that's going to involve change and mutation of data and things like that.

282
00:30:34,310 --> 00:30:35,860
Are there any questions now, before I go on?

283
00:30:47,160 --> 00:30:47,550
Thank you.

284
00:30:47,550 --> 00:30:48,800
Let's take a break.

285
00:31:28,940 --> 00:31:35,060
Well, we've been making a simulation.

286
00:31:35,060 --> 00:31:43,920
And the simulation is an event-driven simulation where the objects in the world are the objects in the computer.

287
00:31:43,920 --> 00:32:04,420
And the changes of state that are happening in the world in time are organized to be time in the computer, so that if something happens after something else in the world, then we have it happen after, after the corresponding events happen in the same order in the computer.

288
00:32:04,420 --> 00:32:08,220
That's where we have assignments, when we make that alignment.

289
00:32:08,220 --> 00:32:16,040
Right now I want to show you a way of organizing time, which is an agenda or priority queue, it's sometimes called.

290
00:32:16,040 --> 00:32:21,230
We'll do some--we'll do a little bit of just understanding what are the things we need to be able to do to make agendas.

291
00:32:28,330 --> 00:32:35,960
And so we're going to have--and so right now over here, I'm going to write down a bunch of primitive operations for manipulating agendas.

292
00:32:35,960 --> 00:32:43,680
I'm not going to show you the code for them because they're all very simple, and you've got listings of all that anyway.

293
00:32:43,680 --> 00:32:44,380
So what do we have?

294
00:32:44,380 --> 00:32:54,130
We have things like make-agenda which produces a new agenda.

295
00:32:59,860 --> 00:33:12,625
We can ask--we get the current-time of an agenda, which gives me a number, a time.

296
00:33:16,990 --> 00:33:21,900
We can get--we can ask whether an agenda is empty, empty-agenda.

297
00:33:30,200 --> 00:33:32,570
And that produces either a true or a false.

298
00:33:42,590 --> 00:33:44,720
We can add an object to an agenda.

299
00:33:52,710 --> 00:33:56,910
Actually, what we add to an agenda is an operation--an action to be done.

300
00:33:56,910 --> 00:34:04,810
And that takes a time, the action itself, and the agenda I want to add it to.

301
00:34:07,850 --> 00:34:10,719
That inserts it in the appropriate place in the agenda.

302
00:34:10,719 --> 00:34:23,259
I can get the first item off an agenda, the first thing I have to do, which is going to give me an action.

303
00:34:26,085 --> 00:34:29,540
And I can remove the first item from an agenda.

304
00:34:29,540 --> 00:34:31,409
That's what I have to be able to do with agendas.

305
00:34:31,409 --> 00:34:33,020
That is a big complicated mess.

306
00:34:42,530 --> 00:34:43,780
From an agenda.

307
00:34:45,530 --> 00:34:52,528
Well, let's see how we can organize this thing as a data structure a bit.

308
00:34:52,528 --> 00:35:01,570
Well, an agenda is going to be some kind of list. And it's going to be a list that I'm going to have to be able to modify.

309
00:35:01,570 --> 00:35:11,070
So we have to talk about modifying of lists, because I'm going to add things to it, and delete things from it, and things like that.

310
00:35:11,070 --> 00:35:13,820
It's organized by time.

311
00:35:13,820 --> 00:35:15,570
It's probably good to keep it in sorted order.

312
00:35:18,330 --> 00:35:23,420
But sometimes there are lots of things that happen at the same time--approximate same time.

313
00:35:23,420 --> 00:35:29,040
What I have to do is say, group things by the time at which they're supposed to happen.

314
00:35:29,040 --> 00:35:32,780
So I'm going to make an agenda as a list of segments.

315
00:35:32,780 --> 00:35:39,620
And so I'm going to draw you a data structure for an agenda, a perfectly reasonable one.

316
00:35:39,620 --> 00:35:41,110
Here's an agenda.

317
00:35:41,110 --> 00:35:42,870
It's a thing that begins with a name.

318
00:35:47,630 --> 00:35:49,940
I'm going to do it right now out of list structure.

319
00:35:52,620 --> 00:35:53,980
It's got a header.

320
00:35:53,980 --> 00:35:55,840
There's a reason for the header.

321
00:35:55,840 --> 00:35:57,630
We're going to see the reason soon.

322
00:36:00,680 --> 00:36:03,750
And it will have a segment.

323
00:36:03,750 --> 00:36:05,620
It will have--it will be a list of segments.

324
00:36:08,310 --> 00:36:33,320
Supposing this agenda has two segments, they're the car's-- successive car's of this list. Each segment is going to have a time--  say for example, 10-- that says that the things that happen in this segment are at time 10.

325
00:36:33,320 --> 00:36:42,240
And what I'm going to have in here is another data structure which I'm not going to describe, which is a queue of things to do at time 10.

326
00:36:42,240 --> 00:36:43,330
It's a queue.

327
00:36:43,330 --> 00:36:45,130
And we'll talk about that in a second.

328
00:36:45,130 --> 00:36:50,200
But abstractly, the queue is just a list of things to do at a particular time.

329
00:36:50,200 --> 00:36:53,100
And I can add things to a queue.

330
00:36:53,100 --> 00:36:56,140
This is a queue.

331
00:36:56,140 --> 00:36:59,115
There's a time, there's a segment.

332
00:37:02,889 --> 00:37:06,035
Now, I may have another segment in this agenda.

333
00:37:08,940 --> 00:37:13,410
Supposing this is stuff that happens at time 30.

334
00:37:13,410 --> 00:37:23,210
It has, of course, another queue of things that are queued up to be done at time 30.

335
00:37:23,210 --> 00:37:27,090
Well, there are various things I have to be able to do to an agenda.

336
00:37:27,090 --> 00:37:33,030
Supposing I want to add to an agenda another thing to be done at time 10.

337
00:37:33,030 --> 00:37:34,700
Well, that's not very hard.

338
00:37:34,700 --> 00:37:39,730
I'm going to walk down here, looking for the segment of time 10.

339
00:37:39,730 --> 00:37:42,930
It is possible that there is no segment of time 10.

340
00:37:42,930 --> 00:37:45,420
We'll cover that case in a second.

341
00:37:45,420 --> 00:37:56,290
But if I find a segment of time 10, then if I want to add another thing to be done at time 10, I just increase that queue-- "just increase" isn't such an obvious idea.

342
00:37:56,290 --> 00:38:01,430
But I increase the things to be done at that time.

343
00:38:01,430 --> 00:38:05,140
Now, supposing I want to add something to be done at time 20.

344
00:38:05,140 --> 00:38:08,680
There is no segment for time 20.

345
00:38:08,680 --> 00:38:11,340
I'm going to have to create a new segment.

346
00:38:11,340 --> 00:38:17,610
I want my time 20 segment to exist between time 10 and time 30.

347
00:38:17,610 --> 00:38:20,170
Well, that takes a little work.

348
00:38:20,170 --> 00:38:21,525
I'm going to have to do a CONS.

349
00:38:24,260 --> 00:38:29,940
I'm going to have to make a new element of the agenda list--list of segments.

350
00:38:33,600 --> 00:38:35,400
I'm going to have to change.

351
00:38:35,400 --> 00:38:37,540
Here's change.

352
00:38:37,540 --> 00:38:56,657
I'm going to have to change the CDR of the CDR of the agenda to point that a new CONS of the new segment and the CDR of the CDR of the CDR of the agenda, the CD-D-D-DR.

353
00:38:56,657 --> 00:39:06,290
And this is going to have a new segment now of time 20 with its own queue, which now has one element in it.

354
00:39:10,730 --> 00:39:20,770
If I wanted to add something at the end, I'm going to have to replace the CDR of this, of this list with something.

355
00:39:20,770 --> 00:39:24,040
We're going to have to change that piece of data structure.

356
00:39:24,040 --> 00:39:27,210
So I'm going to need new primitives for doing this.

357
00:39:27,210 --> 00:39:29,550
But I'm just showing you why I need them.

358
00:39:29,550 --> 00:39:49,400
And finally, if I wanted to add a thing to be done at time 5, I'm going to have to change this one, because I'm going to have to add it in over here, which is why I planned ahead and had a header cell, which has a place.

359
00:39:49,400 --> 00:39:53,420
If I'm going to change things, I have to have places for the change.

360
00:39:53,420 --> 00:39:58,600
I have to have a place to make the change.

361
00:39:58,600 --> 00:40:02,540
If I remove things from the agenda, that's not so hard.

362
00:40:02,540 --> 00:40:11,220
Removing them from the beginning is pretty easy, which is the only case I have. I can go looking for the first, the first segment.

363
00:40:11,220 --> 00:40:14,510
I see if it has a non-empty queue.

364
00:40:14,510 --> 00:40:20,100
If it has a non-empty queue, well, I'm going to delete one element from the queue, like that.

365
00:40:20,100 --> 00:40:24,220
If the queue ever becomes empty, then I have to delete the whole segment.

366
00:40:24,220 --> 00:40:28,220
And then this, this changes to point to here.

367
00:40:28,220 --> 00:40:36,440
So it's quite a complicated data structure manipulation going on, the details of which are not really very exciting.

368
00:40:36,440 --> 00:40:38,920
Now, let's talk about queues.

369
00:40:38,920 --> 00:40:41,160
They're similar.

370
00:40:41,160 --> 00:40:44,340
Because each of these agendas has a queue in it.

371
00:40:44,340 --> 00:40:45,590
What's a queue?

372
00:40:49,079 --> 00:40:52,350
A queue is going to have the following primitive operations.

373
00:40:52,350 --> 00:41:02,170
To make a queue, this gives me a new queue.

374
00:41:07,274 --> 00:41:16,850
I'm going to have to be able to insert into a queue a new item.

375
00:41:24,510 --> 00:41:28,740
I'm going to have to be able to delete from a queue the first item in the queue.

376
00:41:39,988 --> 00:41:52,890
And I want to be able to get the first thing in the queue from some queue.

377
00:41:52,890 --> 00:41:55,140
I also have to be able to test whether a queue is empty.

378
00:42:07,110 --> 00:42:15,120
And when you invent things like this, I want you to be very careful to use the kinds of conventions I use for naming things.

379
00:42:15,120 --> 00:42:19,870
Notice that I'm careful to say these change something and that tests it.

380
00:42:19,870 --> 00:42:24,335
And presumably, I did the same thing over here.

381
00:42:24,335 --> 00:42:29,240
OK, and there should be an empty test over here.

382
00:42:29,240 --> 00:42:31,720
OK, well, how would I make a queue?

383
00:42:31,720 --> 00:42:37,840
A queue wants to be something I can add to at the end of, and pick up the thing at the beginning of.

384
00:42:37,840 --> 00:42:41,230
I should be able to delete from the beginning and add to the end.

385
00:42:41,230 --> 00:42:43,740
Well, I'm going to show you a very simple structure for that.

386
00:42:43,740 --> 00:42:47,080
We can make this out of CONSes as well.

387
00:42:47,080 --> 00:42:49,910
Here's a queue.

388
00:42:49,910 --> 00:42:59,610
It has--it has a queue header, which contains two parts-- a front pointer and a rear pointer.

389
00:43:02,930 --> 00:43:09,000
And here I have a queue with two items in it.

390
00:43:09,000 --> 00:43:12,095
The first item, I don't know, it's perhaps a 1.

391
00:43:12,095 --> 00:43:16,530
And the second item, I don't know, let's give it a 2.

392
00:43:21,160 --> 00:43:31,850
The reason why I want two pointers in here, a front pointer and a rear pointer, is so I can add to the end without having to chase down from the beginning.

393
00:43:31,850 --> 00:43:47,530
So for example, if I wanted to add one more item to this queue, if I want to add on another item to be worried about later, all I have to do is make a CONS, which contains that item, say a 3.

394
00:43:47,530 --> 00:43:51,340
That's for inserting 3 into the queue.

395
00:43:51,340 --> 00:44:00,100
Then I have to change this pointer here to here.

396
00:44:00,100 --> 00:44:04,320
And I have to change this one to point to the new rear.

397
00:44:09,120 --> 00:44:18,890
If I wish to take the first element of the queue, the first item, I just go chasing down the front pointer until I find the first one and pick it up.

398
00:44:18,890 --> 00:44:27,450
If I wish to delete the first item from the queue, delete-queue, all I do is move the front pointer along this way.

399
00:44:27,450 --> 00:44:31,700
The new front of the queue is now this.

400
00:44:31,700 --> 00:44:34,390
So queues are very simple too.

401
00:44:34,390 --> 00:44:41,350
So what you see now is that I need a certain number of new primitive operations.

402
00:44:41,350 --> 00:44:42,560
And I'm going to give them some names.

403
00:44:42,560 --> 00:44:47,350
And then we're going to look into how they work, and how they're used.

404
00:44:47,350 --> 00:44:58,940
We have set the CAR of some pair, or a thing produced by CONSing, to a new value.

405
00:45:02,370 --> 00:45:09,920
And set the CDR of a pair to a new value.

406
00:45:12,680 --> 00:45:16,030
And then we're going to look into how they work.

407
00:45:16,030 --> 00:45:20,960
I needed setting CAR over here to delete the first element of the queue.

408
00:45:20,960 --> 00:45:23,470
This is the CAR, and I had to set it.

409
00:45:23,470 --> 00:45:30,160
I had to be able to set the CDR to be able to move the rear pointer, or to be able to increment the queue here.

410
00:45:30,160 --> 00:45:35,515
All of the operations I did were made out of those that I just showed you on the, on the last blackboard.

411
00:45:38,230 --> 00:45:38,430
Good.

412
00:45:38,430 --> 00:45:40,357
Let's pause the time, and take a little break then.

413
00:46:38,346 --> 00:47:21,850
When we originally introduced pairs made out of CONS, made by CONS, we only said a few axioms about them, which were of the form-- what were they-- for all X and Y, the CAR of the CONS of X and Y is X and the CDR of the CONS of X and Y is Y. Now, these say nothing about whether a CONS has an identity like a person.

414
00:47:21,850 --> 00:47:29,740
In fact, all they say is something sort of abstract, that a CONS is the parts it's made out of.

415
00:47:29,740 --> 00:47:37,390
And of course, two things are made out of the same parts, they're the same, at least from the point of view of these axioms.

416
00:47:37,390 --> 00:47:49,830
But by introducing assignment-- in fact, mutable data is a kind of assignment, we have a set CAR and a set CDR-- by introducing those, these axioms no longer tell the whole story.

417
00:47:49,830 --> 00:47:53,250
And they're still true if written exactly like this.

418
00:47:53,250 --> 00:47:56,070
But they don't tell the whole story.

419
00:47:56,070 --> 00:48:10,090
Because if I'm going to set a particular CAR in a particular CONS, the questions are, well, is that setting all CARs and all CONSes of the same two things or not?

420
00:48:10,090 --> 00:48:21,570
If I--if we use CONSes to make up things like rational numbers, or things like 3 over 4, supposing I had two three-fourths.

421
00:48:21,570 --> 00:48:25,340
Are they the same one-- or are they different?

422
00:48:25,340 --> 00:48:27,860
Well, in the case of numbers, it doesn't matter.

423
00:48:27,860 --> 00:48:33,020
Because there's no meaning to changing the denominator of a number.

424
00:48:33,020 --> 00:48:36,840
What you could do is make a number which has a different denominator.

425
00:48:36,840 --> 00:48:44,770
But the concept of changing a number which has to have a different denominator is sort of a very weird, and sort of not supported by what you think of as mathematics.

426
00:48:44,770 --> 00:48:53,690
However, when these CONSes represent things in the physical world, then changing something like the CAR is like removing a piece of the fingernail.

427
00:48:53,690 --> 00:48:57,770
And so CONSes have an identity.

428
00:48:57,770 --> 00:49:01,280
Let me show you what I mean about identity, first of all.

429
00:49:01,280 --> 00:49:04,320
Let's do some little example here.

430
00:49:04,320 --> 00:49:15,200
Supposing I define A to the CONS of 1 and 2.

431
00:49:18,040 --> 00:49:38,120
Well, what that means, first of all, is that somewhere in some environment I've made a symbol A to have a value which is a pair consisting of pointers to a 1 and a pointer to a 2, just like that.

432
00:49:38,120 --> 00:50:03,970
Now, supposing I also say define B to be the CONS--  it doesn't matter, but I like it better, it's prettier-- of A and A.

433
00:50:03,970 --> 00:50:07,840
Well, first of all, I'm using the name A twice.

434
00:50:07,840 --> 00:50:11,300
At this moment, I'm going to think of CONSes as having identity.

435
00:50:11,300 --> 00:50:13,690
This is the same one.

436
00:50:13,690 --> 00:50:33,260
And so what that means is I make another pair, which I'm going to call B. And it contains two pointers to A. At this point, I have three names for this object.

437
00:50:33,260 --> 00:50:34,790
A is its name.

438
00:50:34,790 --> 00:50:37,230
The CAR of B is its name.

439
00:50:37,230 --> 00:50:39,360
And the CDR of B is its name.

440
00:50:39,360 --> 00:50:41,150
It has several aliases, they're called.

441
00:50:44,230 --> 00:51:07,880
Now, supposing I do something like set-the-CAR, the CAR of the CAR of B to 3.

442
00:51:12,750 --> 00:51:17,830
What that means is I find the CAR of B, that's this.

443
00:51:17,830 --> 00:51:20,935
I set the CAR of that to be 3, changing this.

444
00:51:24,760 --> 00:51:35,340
I've changed A. If I were to ask what's the CAR of A--of A now?

445
00:51:35,340 --> 00:51:45,290
I would get out 3, even though here we see that A was the CONS of 1 and 2.

446
00:51:45,290 --> 00:51:48,400
I caused A to change by changing B.

447
00:51:48,400 --> 00:51:52,010
There is sharing here.

448
00:51:52,010 --> 00:51:54,240
That's sometimes what we want.

449
00:51:54,240 --> 00:52:04,350
Surely in the queues and things like that, that's exactly what we defined our--organized our data structures to facilitate-- sharing.

450
00:52:04,350 --> 00:52:25,190
But inadvertent sharing, unanticipated interactions between objects, is the source of most of the bugs that occur in complicated programs. So by introducing this possibility of things having identity and sharing and having multiple names for the same thing, we get a lot of power.

451
00:52:25,190 --> 00:52:28,640
But we're going to pay for it with lots of complexity and bugs.

452
00:52:32,190 --> 00:52:46,560
So also, for example, if I just looked at this just to drive that home, the CADR of B, which has nothing to do with even the CAR of B, apparently.

453
00:52:46,560 --> 00:52:49,350
The CADR of B, what's that?

454
00:52:49,350 --> 00:52:53,560
Take that CDR of B and now take the CAR of that.

455
00:52:53,560 --> 00:52:56,480
Oh, that's 3 also.

456
00:52:56,480 --> 00:53:01,120
So I can have non-local interactions by sharing.

457
00:53:01,120 --> 00:53:02,480
And I have to be very careful of that.

458
00:53:06,640 --> 00:53:22,820
Well, so far, of course, it seems I've introduced several different assignment operators-- set, set CAR, set CDR. Well, maybe I should just get rid of set CAR and set CDR. Maybe they're not worthwhile.

459
00:53:22,820 --> 00:53:27,170
Well, the answer is that once you let the camel's nose into the tent, the rest of him follows.

460
00:53:30,160 --> 00:53:35,850
All I have to have is set, and I can make all of the--all of the bad things that can happen.

461
00:53:38,550 --> 00:53:40,690
Let's play with that a little bit.

462
00:53:40,690 --> 00:53:52,480
A couple of days ago, when we introduced compound data, you saw Hal show you a definition of CONS in terms of a message acceptor.

463
00:53:52,480 --> 00:54:04,440
I'm going to show you even a more horrible thing, a definition of CONS in terms of nothing but air, hot air.

464
00:54:04,440 --> 00:54:14,580
What is the definition of CONS, of the old functional kind, in terms of purely lambdic expressions, procedures?

465
00:54:17,190 --> 00:54:28,580
Because I'm going to then modify this definition to get assignment to be only one kind of assignment, to get rid of the set CAR and set CDR in terms of set.

466
00:54:28,580 --> 00:54:46,320
So what if I define CONS of X and Y to be a procedure of one argument called a message M, which calls that message on X and Y?

467
00:54:51,120 --> 00:54:57,870
This [? idea ?] was invented by Alonzo Church, who was the greatest programmer of the 20th century, although he never saw a computer.

468
00:54:57,870 --> 00:54:59,130
It was done in the 1930s.

469
00:54:59,130 --> 00:55:02,220
He was a logician, I suppose at Princeton at the time.

470
00:55:08,660 --> 00:55:46,670
Define CAR of X to be the result of applying X to that procedure of two arguments, A and D, which selects A. I will define CDR of X to be that procedure, to be the result of applying X to that procedure of A and D, which selects D.

471
00:55:46,670 --> 00:55:50,510
Now, you may not recognize this as CAR, CDR, and CONS.

472
00:55:50,510 --> 00:55:55,210
But I'm going to demonstrate to you that it satisfies the original axioms, just once.

473
00:55:55,210 --> 00:55:58,290
And then we're going to do some playing of games.

474
00:55:58,290 --> 00:56:09,695
Consider the problem CAR of CONS of, say, 35 and 47.

475
00:56:09,695 --> 00:56:11,120
Well, what is that?

476
00:56:11,120 --> 00:56:19,710
It is the result of taking car of the result of substituting 35 and 47 for X and Y in the body of this.

477
00:56:19,710 --> 00:56:20,690
Well, that's easy enough.

478
00:56:20,690 --> 00:56:35,750
That's CAR of the result of substituting into lambda of M, M of 35 and 47.

479
00:56:35,750 --> 00:56:42,830
Well, what this is, is the result of substituting this object for X in the body of that.

480
00:56:42,830 --> 00:57:15,840
So that's just lambda of M-- that's substituted, because this object is being substituted for X, which is the beginning of a list, lambda of M-- M of 35 and 47, applied to that procedure of A and D, which gives me A. Well, that's the result of substituting this for M here.

481
00:57:15,840 --> 00:57:26,026
So that's the same thing as lambda of A, D, A, applied to 35 and 47.

482
00:57:26,026 --> 00:57:27,560
Oh, well that's 35.

483
00:57:27,560 --> 00:57:40,720
That's substituting 35 for A and for 47 for D in A. So I don't need any data at all, not even numbers.

484
00:57:40,720 --> 00:57:42,640
This is Alonso Church's hack.

485
00:57:52,420 --> 00:57:56,760
Well, now we're going to do something nasty to him.

486
00:57:56,760 --> 00:57:58,860
Being a logician, he wouldn't like this.

487
00:57:58,860 --> 00:58:03,260
But as programmers, let's look at the overhead.

488
00:58:03,260 --> 00:58:05,390
And here we go.

489
00:58:05,390 --> 00:58:09,570
I'm going to change the definition of CONS.

490
00:58:09,570 --> 00:58:14,520
It's almost the same as Alonzo Church's, but not quite.

491
00:58:14,520 --> 00:58:16,070
What do we have here?

492
00:58:16,070 --> 00:58:40,940
The CONS of two arguments, X and Y, is going to be that procedure of one argument M, which supplies M to X and Y as before, but also to two permissions, the permission to set X to N and the permission to set Y to N, given that I have an N.

493
00:58:40,940 --> 00:59:03,365
So besides the things that I had here in Church's definition, what I have is that the thing that CONS returns will apply its argument to not just the values of the X and Y that the CONS is made of, but also permissions to set X and Y to new values.

494
00:59:06,540 --> 00:59:11,690
Now, of course, just as before, CAR is exactly the same.

495
00:59:11,690 --> 00:59:22,550
The CAR of X is nothing more than applying X, as in Church's definition, to a procedure, in this case, of four arguments, which selects out the first one.

496
00:59:22,550 --> 00:59:37,920
And just as we did before, that will be the value of X that was contained in the procedure which is the result of evaluating this lambda expression in the environment where X and Y are defined over here.

497
00:59:41,940 --> 00:59:45,640
That's the value of CONS.

498
00:59:45,640 --> 00:59:47,730
Now, however, the exciting part.

499
00:59:47,730 --> 00:59:48,960
CDR, of course, is the same.

500
00:59:48,960 --> 00:59:55,800
The exciting part, set CAR and set CDR. Well, they're nothing very complicated anymore.

501
00:59:55,800 --> 01:00:26,150
Set CAR of a CONS X to a new value Y is nothing more than applying that CONS, which is the procedure of four--the procedure of one argument which applies its argument to four things, to a procedure which is of four arguments-- the value of X, the value of Y, permission to set X, the permission to set Y-- and using it--using that permission to set X to the new value.

502
01:00:31,650 --> 01:00:33,540
And similarly, set-cdr is the same thing.

503
01:00:36,120 --> 01:00:40,470
So what you've just seen is that I didn't introduce any new primitives at all.

504
01:00:40,470 --> 01:00:45,340
Whether or not I want to implement it this way is a matter of engineering.

505
01:00:45,340 --> 01:00:51,680
And the answer is of course I don't implement it this way for reasons that have to do with engineering.

506
01:00:51,680 --> 01:00:58,765
However in principle, logically, once I introduced one assignment operator, I've assigned--I've introduced them all.

507
01:01:05,420 --> 01:01:06,670
Are there any questions?

508
01:01:09,200 --> 01:01:12,040
Yes, David.

509
01:01:12,040 --> 01:01:15,740
AUDIENCE: I can follow you up until you get--I can follow all of that.

510
01:01:15,740 --> 01:01:24,210
But when we bring in the permissions, defining CONS in terms of the lambda N, I don't follow where N gets passed.

511
01:01:24,210 --> 01:01:25,100
PROFESSOR: Oh, I'm sorry.

512
01:01:25,100 --> 01:01:26,340
I'll show you.

513
01:01:26,340 --> 01:01:27,360
Let's follow it.

514
01:01:27,360 --> 01:01:29,180
Of course, we could do it on the blackboard.

515
01:01:29,180 --> 01:01:30,170
It's not so hard.

516
01:01:30,170 --> 01:01:32,450
But it's also easy here.

517
01:01:32,450 --> 01:01:38,520
Supposing I wish to set-cdr of X to Y. See that right there.

518
01:01:38,520 --> 01:01:46,890
set-cdr of X to Y. X is presumably a CONS, a thing resulting from evaluating CONS.

519
01:01:46,890 --> 01:01:58,110
Therefore X comes from a place over here, that that X is of the result of evaluating this lambda expression.

520
01:01:58,110 --> 01:01:59,380
Right?

521
01:01:59,380 --> 01:02:08,950
That when I evaluated that lambda expression, I evaluated it in an environment where the arguments to CONS were defined.

522
01:02:11,750 --> 01:02:29,250
That means that as free variables in this lambda expression, there is the--there are in the frame, which is the parent frame of this lambda expression, the procedure resulting from this lambda expression, X and Y have places.

523
01:02:29,250 --> 01:02:31,910
And it's possible to set them.

524
01:02:31,910 --> 01:02:37,010
I set them to an N, which is the argument of the permission.

525
01:02:37,010 --> 01:02:47,940
The permission is a procedure which is passed to M, which is the argument that the CONS object gets passed.

526
01:02:47,940 --> 01:02:57,480
Now, let's go back here in the set-cdr The CONS object, which is the first argument of set-cdr gets passed an argument.

527
01:03:00,260 --> 01:03:07,920
That--there's a procedure of four things, indeed, because that's the same thing as this M over here, which is applied to four objects.

528
01:03:07,920 --> 01:03:12,970
The object over here, SD, is, in fact, this permission.

529
01:03:15,470 --> 01:03:19,930
When I use SD, I apply it to Y, right there.

530
01:03:22,910 --> 01:03:25,740
So that comes from this.

531
01:03:25,740 --> 01:03:34,160
AUDIENCE: So what do you-- PROFESSOR: So to finish that, the N that was here is the Y which is here.

532
01:03:34,160 --> 01:03:34,810
How's that?

533
01:03:34,810 --> 01:03:35,750
AUDIENCE: Right, OK.

534
01:03:35,750 --> 01:03:41,970
Now, when you do a set-cdr, X is the value the CDR is going to become.

535
01:03:41,970 --> 01:03:44,742
PROFESSOR: The X over here.

536
01:03:44,742 --> 01:03:46,200
I'm sorry, that's not true.

537
01:03:46,200 --> 01:03:56,150
The X is--set-cdr has two arguments-- The CONS I'm changing and the value I'm changing it to.

538
01:03:56,150 --> 01:03:58,320
So you have them backwards, that's all.

539
01:04:01,750 --> 01:04:03,000
Are there any other questions?

540
01:04:07,880 --> 01:04:08,640
Well, thank you.

541
01:04:08,640 --> 01:04:09,890
It's time for lunch.

