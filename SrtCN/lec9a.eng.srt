1
00:00:02,190 --> 00:00:03,800
[MUSIC PLAYING - "JESU, JOY OF MAN'S DESIRING" BY JOHANN SEBASTIAN BACH]

2
00:00:17,260 --> 00:00:49,900
PROFESSOR: Well, up 'til now, I suppose, we've been learning about a lot of techniques for organizing big programs, symbolic manipulation a bit, some of the technology that you use for establishing languages, one in terms of another, which is used for organizing very large programs. In fact, the nicest programs I know look more like a pile of languages than like a decomposition of a problem into parts.

3
00:00:49,900 --> 00:00:56,260
Well, I suppose at this point, there are still, however, a few mysteries about how this sort of stuff works.

4
00:00:56,260 --> 00:01:12,196
And so what we'd like to do now is diverge from the plan of telling you how to organize big programs, and rather tell you something about the mechanisms by which these things can be made to work.

5
00:01:12,196 --> 00:01:32,430
The main reason for this is demystification, if you will, that we have a lot of mysteries left, like exactly how it is the case that a program is controlled, how a computer knows what the next thing to do is, or something like that.

6
00:01:32,430 --> 00:01:47,650
And what I'd like to do now is make that clear to you, that even if you've never played with a physical computer before, the mechanism is really very simple, and that you can understand it completely with no trouble.

7
00:01:47,650 --> 00:02:02,160
So I'd like to start by imagining that we-- well, the way we're going to do this, by the way, is we're going to take some very simple Lisp programs, very simple Lisp programs, and transform them into hardware.

8
00:02:02,160 --> 00:02:12,750
I'm not going to worry about some intermediate step of going through some existing computer machine language and then showing you how that computer works, because that's not as illuminating.

9
00:02:12,750 --> 00:02:22,040
So what I'm really going to show you is how a piece of machinery can be built to do a job that you have written down as a program.

10
00:02:22,040 --> 00:02:25,760
That program is, in fact, a description of a machine.

11
00:02:25,760 --> 00:02:41,230
We're going to start with a very simple program, proceed to show you some simple mechanisms, proceed to a few more complicated programs, and then later show you a not very complicated program, how the evaluator transforms into a piece of hardware.

12
00:02:41,230 --> 00:02:48,800
And of course at that point, you have made the universal transition and can execute any program imaginable with a piece of well-defined hardware.

13
00:02:51,392 --> 00:02:55,440
Well, let's start up now, give you a real concrete feeling for this sort of thing.

14
00:02:55,440 --> 00:02:59,600
Let's start with a very simple program.

15
00:02:59,600 --> 00:03:00,850
Here's Euclid's algorithm.

16
00:03:03,880 --> 00:03:06,770
It's actually a little bit more modern than Euclid's algorithm.

17
00:03:06,770 --> 00:03:14,300
Euclid's algorithm for computing the greatest common divisor of two numbers was invented 350 BC, I think.

18
00:03:14,300 --> 00:03:15,550
It's the oldest known algorithm.

19
00:03:19,320 --> 00:03:29,500
But here we're going to talk about GCD of A and B, the Greatest Common Divisor or two numbers, A and B. And the algorithm is extremely simple.

20
00:03:29,500 --> 00:03:58,530
If B is 0, then the result is going to be A. Otherwise, the result is the GCD of B and the remainder when A is divided by B.

21
00:03:58,530 --> 00:04:02,030
So this we have here is a very simple iterative process.

22
00:04:02,030 --> 00:04:09,990
This a simple recursive procedure, recursively defined procedure, recursive definition, which yields an iterative process.

23
00:04:09,990 --> 00:04:15,996
And the way it works is that every step, it determines whether B was zero.

24
00:04:15,996 --> 00:04:31,110
And if B is 0, we got the answer in A. Otherwise, we make another step where A is the old B, and B is the remainder of the old A divided by the old B. Very simple.

25
00:04:31,110 --> 00:04:34,860
Now this, I've already told you some of the mechanism by just saying it that way.

26
00:04:34,860 --> 00:04:36,360
I set it in time.

27
00:04:36,360 --> 00:04:49,490
I said there are certain steps, and that, in fact, one of the things you can see here is that one of the reasons why this is iterative is nothing is needed of the last step to get the answer.

28
00:04:49,490 --> 00:04:57,540
All of the information that's needed to run this algorithm is in A and B. It has two well-defined state variables.

29
00:05:00,470 --> 00:05:06,560
So I'm going to define a machine for you that can compute you GCDs.

30
00:05:06,560 --> 00:05:07,120
Now let's see.

31
00:05:07,120 --> 00:05:17,840
Every computer that's ever been made that's a single-process computer, as opposed to a multiprocessor of some sort, is made according to the same plan.

32
00:05:17,840 --> 00:05:25,910
The plan is the computer has two parts, a part called the datapaths, and a part called the controller.

33
00:05:25,910 --> 00:05:33,560
The datapaths correspond to a calculator that you might have. It contains certain registers that remember things, and you've all used calculators.

34
00:05:33,560 --> 00:05:37,030
It has some buttons on it and some lights.

35
00:05:37,030 --> 00:05:45,160
And so by pushing the various buttons, you can cause operations to happen inside there among the registers, and some of the results to be displayed.

36
00:05:45,160 --> 00:05:46,250
That's completely mechanical.

37
00:05:46,250 --> 00:05:50,900
You could imagine that box has no intelligence in it.

38
00:05:50,900 --> 00:05:58,970
Now it might be very impressive that it can produce the sine of a number, but that at least is apparently possibly mechanical.

39
00:05:58,970 --> 00:06:02,690
At least, I could open that up in the same way I'm about to open GCD.

40
00:06:02,690 --> 00:06:05,940
So this may have a whole computer inside of it, but that's not interesting.

41
00:06:05,940 --> 00:06:08,200
Addition is certainly simple.

42
00:06:08,200 --> 00:06:10,890
That can be done without any further mechanism.

43
00:06:10,890 --> 00:06:18,190
Now also, if we were to look at the other half, the controller, that's a part that's dumb, too.

44
00:06:18,190 --> 00:06:20,350
It pushes the buttons.

45
00:06:20,350 --> 00:06:26,290
It pushes them according to the sequence, which is written down on a piece of paper, and observes the lights.

46
00:06:26,290 --> 00:06:32,370
And every so often, it comes to a place in a sequence that says, if light A is on, do this sequence.

47
00:06:32,370 --> 00:06:34,620
Otherwise, do that sequence.

48
00:06:34,620 --> 00:06:37,950
And thereby, there's no complexity there either.

49
00:06:37,950 --> 00:06:42,510
Well, let's just draw that and see what we feel about that.

50
00:06:42,510 --> 00:06:50,310
So for computing GCDs, what I want you to think about is that there are these registers.

51
00:06:50,310 --> 00:06:53,240
A register is a place where I store a number, in this case.

52
00:06:53,240 --> 00:06:56,810
And this one's called a.

53
00:06:56,810 --> 00:06:58,700
And then there's another one for storing b.

54
00:07:03,170 --> 00:07:09,840
Now we have to see what things we can do with these registers, and they're not entirely obvious what you can do with them.

55
00:07:09,840 --> 00:07:11,890
Well, we have to see what things we need to do with them.

56
00:07:11,890 --> 00:07:14,030
We're looking at the problem we're trying to solve.

57
00:07:14,030 --> 00:07:32,140
One of the important things for designing a computer, which I think most designers don't do, is you study the problem you want to solve and then use what you learn from studying the problem you want to solve to put in the mechanisms needed to solve it in the computer you're building, no more no less.

58
00:07:32,140 --> 00:07:40,190
Now it may be that the problem you're trying to solve is everybody's problem, in which case you have to build in a universal interpreter of some language.

59
00:07:40,190 --> 00:07:44,540
But you shouldn't put any more in than required to build the universal interpreter of some language.

60
00:07:44,540 --> 00:07:47,025
We'll worry about that in a second.

61
00:07:47,025 --> 00:07:49,930
OK, going back to here, let's see.

62
00:07:49,930 --> 00:07:51,640
What do we have to be able to do?

63
00:07:51,640 --> 00:08:07,390
Well, somehow, we have to be able to get B into A. We have to be able to get the old value of B into the value of A. So we have to have some path by which stuff can flow, whatever this information is, from b to a.

64
00:08:07,390 --> 00:08:15,120
I'm going to draw that with by an arrow saying that it is possible to move the contents of b into a, replacing the value of a.

65
00:08:15,120 --> 00:08:19,710
And there's a little button here which you push which allows that to happen.

66
00:08:19,710 --> 00:08:23,070
That's what the little x is here.

67
00:08:23,070 --> 00:08:27,000
Now it's also the case that I have to be able to compute the remainder of a and b.

68
00:08:27,000 --> 00:08:28,860
Now that may be a complicated mess.

69
00:08:28,860 --> 00:08:31,960
On the other hand, I'm going to make it a small box.

70
00:08:31,960 --> 00:08:37,740
If we have to, we may open up that box and look inside and see what it is.

71
00:08:37,740 --> 00:08:46,440
So here, I'm going to have a little box, which I'm going to draw this way, which we'll call the remainder.

72
00:08:46,440 --> 00:08:48,265
And it's going to take in a.

73
00:08:50,910 --> 00:08:54,370
That's going to take in b.

74
00:08:54,370 --> 00:09:02,290
And it's going to put out something, the remainder of a divided by b.

75
00:09:02,290 --> 00:09:08,000
Another thing we have to see here is that we have to be able to test whether b is equal to 0.

76
00:09:08,000 --> 00:09:13,390
Well, that means somebody's got to be looking at-- a thing that's looking at the value of b.

77
00:09:13,390 --> 00:09:17,390
I have a light bulb here which lights up if b equals 0.

78
00:09:21,110 --> 00:09:24,030
That's its job.

79
00:09:24,030 --> 00:09:46,300
And finally, I suppose, because of the fact that we want the new value of a to be the old value of b, and simultaneously the new value of b to be something I've done with a, and if I plan to make my machine such that everything happens one at a time, one motion at a time, and I can't put two numbers in a register, then I have to have another place to put one while I'm interchanging.

80
00:09:49,534 --> 00:09:50,000
OK?

81
00:09:50,000 --> 00:10:08,850
I can't interchange the two things in my hands, unless I either put two in one hand and then pull it back the other way, or unless I put one down, pick it up, and put the other one, like that, unless I'm a juggler, which I'm not, as you can see, in which case I have a possibility of timing errors.

82
00:10:08,850 --> 00:10:17,840
In fact, much of the type of computer design people do involves timing errors, of some potential timing errors, which I don't much like.

83
00:10:17,840 --> 00:10:23,410
So for that reason, I have to have a place to put the second one of them down.

84
00:10:23,410 --> 00:10:30,470
So I have a place called t, which is a register just for temporary, t, with a button on it.

85
00:10:30,470 --> 00:10:39,300
And then I'll take the result of that, since I have to take that and put into b, over here, we'll take the result of that and go like this, and a button here.

86
00:10:42,430 --> 00:10:47,600
So that's the datapaths of a GCD machine.

87
00:10:47,600 --> 00:10:49,740
Now what's the controller?

88
00:10:49,740 --> 00:10:52,280
Controller's a very simple thing, too.

89
00:10:52,280 --> 00:10:53,710
The machine has a state.

90
00:10:53,710 --> 00:10:59,010
The way I like to visualize that is that I've got a maze.

91
00:10:59,010 --> 00:11:04,430
And the maze has a bunch of places connected by directed arrows.

92
00:11:04,430 --> 00:11:10,740
And what I have is a marble, which represents the state of the controller.

93
00:11:10,740 --> 00:11:13,256
The marble rolls around in the maze.

94
00:11:13,256 --> 00:11:17,150
Of course, this analogy breaks down for energy reasons.

95
00:11:17,150 --> 00:11:22,000
I sometimes have to pump the marble up to the top, because it's going to otherwise be a perpetual motion machine.

96
00:11:22,000 --> 00:11:26,080
But not worrying about that, this is not a physical analogy.

97
00:11:26,080 --> 00:11:27,680
This marble rolls around.

98
00:11:27,680 --> 00:11:34,830
And every time it rolls around certain bumpers, like in a pinball machine, it pushes one of these buttons.

99
00:11:34,830 --> 00:11:40,250
And every so often, it comes to a place, which is a division, where it has to make a choice.

100
00:11:40,250 --> 00:11:42,360
And there's a flap, which is controlled by this.

101
00:11:46,000 --> 00:11:48,820
So that's a really mechanical way of thinking about it.

102
00:11:48,820 --> 00:11:51,840
Of course, controllers these days, are not built that way in real computers.

103
00:11:51,840 --> 00:11:56,610
They're built with a little bit of ROM and a state register.

104
00:11:56,610 --> 00:12:01,400
But there was a time, like the DEC PDP-6, where that's how you built the controller of a machine.

105
00:12:01,400 --> 00:12:08,580
There was a bit that ran around the delay line, and it triggered things as it went by.

106
00:12:08,580 --> 00:12:11,990
And it would come back to the beginning and get fed round again.

107
00:12:11,990 --> 00:12:17,670
And of course, there were all sorts of great bugs you could have like two bits going around, two marbles.

108
00:12:17,670 --> 00:12:19,260
And then the machine has lost its marbles.

109
00:12:19,260 --> 00:12:20,980
That happens, too.

110
00:12:20,980 --> 00:12:21,935
Oh, well.

111
00:12:21,935 --> 00:12:25,940
So anyway, for this machine, what I have to do is the following.

112
00:12:25,940 --> 00:12:27,690
I'm going to start my maze here.

113
00:12:30,520 --> 00:12:41,540
And the first thing I've got to do, in a notation which many of you are familiar with, is b equal to zero, a test.

114
00:12:41,540 --> 00:12:45,790
And there's a possibility, either yes, in which case I'm done.

115
00:12:49,790 --> 00:12:54,725
Otherwise, if no, then I'm going have to roll over some bumpers.

116
00:12:54,725 --> 00:12:57,420
I'm going to do it in the following order.

117
00:12:57,420 --> 00:13:04,050
I want to do this interchange game.

118
00:13:04,050 --> 00:13:11,070
Now first, since I need both a and b, but then the first-- and this is not necessary-- I want to collect this.

119
00:13:11,070 --> 00:13:13,240
This is the thing that's going to go into b.

120
00:13:13,240 --> 00:13:19,150
So I'm going to say, take this, which depends upon both a and b, and put the remainder into here.

121
00:13:19,150 --> 00:13:32,030
So I'm going to push this button first. Then, I'm going to transfer b to a, push that button, and then I transfer the temporary into b, push that button.

122
00:13:32,030 --> 00:13:37,750
So a very sequential machine, it's very inefficient.

123
00:13:37,750 --> 00:13:39,810
But that's fine right now.

124
00:13:39,810 --> 00:13:42,305
We're going to name the buttons, t gets remainder.

125
00:13:46,750 --> 00:13:50,036
a gets b.

126
00:13:50,036 --> 00:13:55,470
And b gets t.

127
00:13:55,470 --> 00:14:01,620
And then I'm going to go around here and it's to go back to start.

128
00:14:01,620 --> 00:14:03,870
And if you look, what are we seeing here?

129
00:14:03,870 --> 00:14:13,620
We're seeing the various-- what I really have is some sort of mechanical connection, where t gets r controls this thing.

130
00:14:16,830 --> 00:14:28,120
And I have here that a gets b controls this fellow over here, and this fellow over here.

131
00:14:28,120 --> 00:14:32,630
Boy, that's absolutely pessimal, the inverse of optimal.

132
00:14:32,630 --> 00:14:34,590
Every line heads across every other line the way I drew it.

133
00:14:38,540 --> 00:14:41,150
I suppose this goes here, b gets t.

134
00:14:45,690 --> 00:14:48,040
Now I'd like to run this machine.

135
00:14:48,040 --> 00:15:00,710
But before I run the machine, I want to write down a description of this controller, just so you can see that these things, of course, as usual, can be written down in some nice language, so that we don't have to always draw these diagrams. One of the problems with diagrams is that they take up a lot of space.

136
00:15:00,710 --> 00:15:03,220
And for a machine this small, it takes two blackboards.

137
00:15:03,220 --> 00:15:09,900
For a machine that's the evaluator machine, I have trouble putting it into this room, even though it isn't very big.

138
00:15:09,900 --> 00:15:24,420
So I'm going to make a little language for this that's just a description of that, saying define a machine we'll call GCD.

139
00:15:24,420 --> 00:15:27,220
Of course, once we have something like this, we have a simulator for it.

140
00:15:27,220 --> 00:15:33,210
And the reason why we want to build a language in this form, is because all of a sudden we can manipulate these expressions that I'm writing down.

141
00:15:33,210 --> 00:15:43,630
And then of course I can write things that can algebraically manipulate these things, simulate them, all that sort of things that I might want to do, perhaps transform them as a layout, who knows.

142
00:15:43,630 --> 00:15:56,326
Once I have a nice representation of registers, it has certain registers, which we can call A, B, and T.

143
00:15:56,326 --> 00:15:57,576
And there's a controller.

144
00:16:02,190 --> 00:16:10,420
Actually, a better language, which would be more explicit, would be one which named every button also and said what it did.

145
00:16:10,420 --> 00:16:19,510
Like, this button causes the contents of T to go to the contents of B. Well I don't want to do that, because it's actually harder to read to do that, and it takes up more space.

146
00:16:19,510 --> 00:16:23,290
So I'm going to have that in the instructions written in the controller.

147
00:16:23,290 --> 00:16:26,460
It's going to be implicit what the operations are.

148
00:16:26,460 --> 00:16:33,500
They can be deduced by reading these and collecting together all the different things that can be done.

149
00:16:33,500 --> 00:16:35,482
Well, let's just look at what these things are.

150
00:16:35,482 --> 00:17:03,640
There's a little loop that we go around which says branch, this is the representation of the little flap that decides which way you go here, if 0 fetch of B, the contents of B, and if the contents of B is 0, then go to a place called done.

151
00:17:03,640 --> 00:17:08,170
Now, one thing you're seeing here, this looks very much like a traditional computer language.

152
00:17:08,170 --> 00:17:17,609
And what you're seeing here is things like labels that represent places in a sequence written down as a sequence.

153
00:17:17,609 --> 00:17:23,329
The reason why they're needed is because over here, I've written something with loops.

154
00:17:23,329 --> 00:17:28,580
But if I'm writing English text, or something like that, it's hard to refer to a place.

155
00:17:28,580 --> 00:17:31,440
I don't have arrows.

156
00:17:31,440 --> 00:17:37,620
Arrows are represented by giving names to the places where the arrows terminate, and then referring to them by those names.

157
00:17:37,620 --> 00:17:39,860
Now this is just an encoding.

158
00:17:39,860 --> 00:17:43,150
There's nothing magical about things like that.

159
00:17:43,150 --> 00:17:46,840
Next thing we're going to do is we're going to say, how do we do T gets R?

160
00:17:46,840 --> 00:17:49,030
Oh, that's easy enough, assign.

161
00:17:51,930 --> 00:17:56,400
We assign to T the remainder.

162
00:17:56,400 --> 00:18:01,470
Assign is the name of the button.

163
00:18:01,470 --> 00:18:03,140
That's the button-pusher.

164
00:18:03,140 --> 00:18:23,478
Assign to T the remainder, and here's the representation of the operation, when we divide the fetch of A by the fetch of B.

165
00:18:23,478 --> 00:18:53,280
And we're also going to assign to A the fetch of B, assign to B the result of getting the contents of T. And now I have to refer to the beginning here.

166
00:18:53,280 --> 00:18:55,760
I see, why don't I call that loop like I have here?

167
00:19:05,390 --> 00:19:07,610
So that's that reference to that arrow.

168
00:19:07,610 --> 00:19:08,950
And when we're done, we're done.

169
00:19:08,950 --> 00:19:14,340
We go to here, which is the end of the thing.

170
00:19:14,340 --> 00:19:21,660
So here's just a written representation of this fragment of machinery that we've drawn here.

171
00:19:21,660 --> 00:19:25,490
Now the next thing I'd like to do is run this.

172
00:19:25,490 --> 00:19:27,620
I want us to feel it running.

173
00:19:27,620 --> 00:19:31,010
Never done this before, you got to do it once.

174
00:19:31,010 --> 00:19:33,100
So let's take a particular problem.

175
00:19:33,100 --> 00:19:42,210
Suppose we want to compute the GCD of a equals 30 and b equals 42.

176
00:19:42,210 --> 00:19:45,860
I have no idea what that is right now.

177
00:19:45,860 --> 00:19:50,530
But a 30 and b is 42.

178
00:19:50,530 --> 00:19:52,410
So that's how I start this thing up.

179
00:19:52,410 --> 00:19:54,240
Well, what's the first thing I do?

180
00:19:54,240 --> 00:19:57,590
I say is B equal to 0, no.

181
00:19:57,590 --> 00:20:11,130
Then assign to T the remainder of the fetch of A and the fetch of B. Well the remainder of 30 when divided by 42 is itself 30.

182
00:20:11,130 --> 00:20:12,920
Push that button.

183
00:20:12,920 --> 00:20:17,100
Now the marble has rolled to here.

184
00:20:17,100 --> 00:20:21,220
A gets B. That pushes this button.

185
00:20:21,220 --> 00:20:26,360
So 42 moves into here.

186
00:20:26,360 --> 00:20:29,870
B gets C. Push that button.

187
00:20:29,870 --> 00:20:32,225
The 30 goes here.

188
00:20:32,225 --> 00:20:34,660
Let met just interchange them.

189
00:20:34,660 --> 00:20:38,280
Now let's see, go back to the beginning.

190
00:20:38,280 --> 00:20:40,200
B 0, no.

191
00:20:40,200 --> 00:20:43,230
T gets the remainder.

192
00:20:43,230 --> 00:20:47,240
I suppose the remainder when dividing 42 by 30 is 12.

193
00:20:47,240 --> 00:20:48,530
I push that one.

194
00:20:48,530 --> 00:20:55,950
Next thing I do is allow the 30 to go to here, push this one, allow the 12 to go to here.

195
00:20:59,550 --> 00:21:00,380
Go around this thing.

196
00:21:00,380 --> 00:21:01,530
Is that done?

197
00:21:01,530 --> 00:21:02,360
No.

198
00:21:02,360 --> 00:21:08,850
How about-- so now I have to find out the remainder of 30 divided by 12.

199
00:21:08,850 --> 00:21:12,420
And I believe that's 6.

200
00:21:12,420 --> 00:21:15,916
So 6 goes here on this button push.

201
00:21:15,916 --> 00:21:23,730
Then the next thing I push is this one, which the 12 goes into here.

202
00:21:23,730 --> 00:21:25,090
Then I push this button.

203
00:21:25,090 --> 00:21:26,340
The 6 gets into here.

204
00:21:29,850 --> 00:21:32,100
Is 6 equal to 0?

205
00:21:32,100 --> 00:21:33,420
No.

206
00:21:33,420 --> 00:21:34,380
OK.

207
00:21:34,380 --> 00:21:38,380
So then at that point, the next thing to do is divide it.

208
00:21:38,380 --> 00:21:40,660
Ooh, this has got a remainder of 0.

209
00:21:40,660 --> 00:21:42,360
Looks like we're almost done.

210
00:21:42,360 --> 00:21:44,360
Move the 6 over here next.

211
00:21:47,230 --> 00:21:49,090
0 over here.

212
00:21:49,090 --> 00:21:50,200
Is the answer 0?

213
00:21:50,200 --> 00:21:51,340
Yes.

214
00:21:51,340 --> 00:21:54,470
B is 0, therefore the answer is in A.

215
00:21:54,470 --> 00:21:56,610
The answer is 6.

216
00:21:56,610 --> 00:22:11,670
And indeed that's right, because if we look at the original problem, what we have is 30 is 2 times 3 times 5, and 42 is 2 times 3 times 7.

217
00:22:11,670 --> 00:22:15,090
So the greatest common divisor is 2 times 3, which is 6.

218
00:22:18,380 --> 00:22:31,010
Now normally, we write one other little line here, just to make it a little bit clearer, which is that we leave in a connection saying that this light is the guy that that flap looks at.

219
00:22:34,050 --> 00:22:41,350
Of course, any real machine has a lot more complicated things in it than what I've just shown you.

220
00:22:41,350 --> 00:22:47,980
Let's look for a second at the first still store.

221
00:22:47,980 --> 00:22:50,190
Wow.

222
00:22:50,190 --> 00:22:56,840
Well you see, for example, one thing we might want to do is worry about the operations that are of IO form.

223
00:22:56,840 --> 00:23:01,980
And we may have to collect something from the outside.

224
00:23:01,980 --> 00:23:13,490
So a state machine that we might have, the controller may have to, for example, get a value from something and put register a to load it up.

225
00:23:13,490 --> 00:23:17,070
I have to master load up register b with another value.

226
00:23:17,070 --> 00:23:20,970
And then later, when I'm done, I might want to print the answer out.

227
00:23:20,970 --> 00:23:26,250
And of course, that might be either simple or complicated.

228
00:23:26,250 --> 00:23:29,880
I'm writing, assuming print is very simple, and read is very simple.

229
00:23:29,880 --> 00:23:38,330
But in fact, in the real world, those are very complicated operations, usually much, much larger and more complicated than the thing you're doing as your problem you're trying to solve.

230
00:23:41,670 --> 00:23:59,065
On the other hand, I can remember a time when, I remember using IBM 7090 computer of sorts, where things like read and write of a single object, a single number, a number, is a primitive operation of the IO controller.

231
00:23:59,065 --> 00:24:00,400
OK?

232
00:24:00,400 --> 00:24:02,330
And so we have that kind of thing in there.

233
00:24:02,330 --> 00:24:08,360
And in such a machine, well, what are we really doing?

234
00:24:08,360 --> 00:24:14,660
We're just saying that there's a source over here called "read," which is an operation which always has a value.

235
00:24:14,660 --> 00:24:21,660
We have to think about this as always having a value which can be gated into either register a or b.

236
00:24:21,660 --> 00:24:31,660
And print is some sort of thing which when you gate it appropriately, when you push the button on it, will cause a print of the value that's currently in register a.

237
00:24:31,660 --> 00:24:33,050
Nothing very exciting.

238
00:24:33,050 --> 00:24:38,320
So that's one sort of thing you might want to have. But these are also other things that are a little bit worrisome.

239
00:24:38,320 --> 00:24:41,050
Like I've used here some complicated mechanisms.

240
00:24:41,050 --> 00:24:43,850
What you see here is remainder.

241
00:24:43,850 --> 00:24:44,690
What is that?

242
00:24:44,690 --> 00:24:46,920
That may not be so obvious how to compute.

243
00:24:46,920 --> 00:24:51,880
It may be something which when you open it up, you get a whole machine.

244
00:24:51,880 --> 00:24:52,720
OK?

245
00:24:52,720 --> 00:24:54,540
In fact, that's true.

246
00:24:54,540 --> 00:25:04,480
For example, if I write down the program for remainder, the simplest program for it is by repeated subtraction.

247
00:25:04,480 --> 00:25:09,800
Because of course, division can be done by repeated subtraction of numbers, of integers.

248
00:25:09,800 --> 00:25:56,890
So the remainder of N divided by D is nothing more than if N is less than D, then the result is N. Otherwise, it's the remainder when we subtract D from N with respect to D, when divided by D. Gee, this looks just like the GCD program.

249
00:25:56,890 --> 00:25:59,750
Of course, it's not a very nice way to do remainders.

250
00:25:59,750 --> 00:26:05,550
You'd really want to use something like binary notation and shift and things like that in a practical computer.

251
00:26:05,550 --> 00:26:11,880
But the point of that is that if I open this thing up, I might find inside of it a computer.

252
00:26:11,880 --> 00:26:13,510
Oh, we know how to do that.

253
00:26:13,510 --> 00:26:15,640
We just made one.

254
00:26:15,640 --> 00:26:17,400
And it could be another thing just like this.

255
00:26:17,400 --> 00:26:29,250
On the other hand, we might want to make a more efficient or better-structured machine, or maybe make use of some of the registers more than once, or some horrible mess like that that hardware designers like to do, and for very good reasons.

256
00:26:29,250 --> 00:26:35,050
So for example, here's a machine that you see, which you're not supposed to be able to read.

257
00:26:35,050 --> 00:26:37,520
It's a little bit complicated.

258
00:26:37,520 --> 00:26:44,210
But what it is is the integration of the remainder into the GCD machine.

259
00:26:44,210 --> 00:26:46,020
And it takes, in fact, no more registers.

260
00:26:46,020 --> 00:26:48,360
There are three registers in the datapaths.

261
00:26:48,360 --> 00:26:49,050
OK?

262
00:26:49,050 --> 00:26:51,550
But now there's a subtractor.

263
00:26:51,550 --> 00:26:53,020
There are two things that are tested.

264
00:26:53,020 --> 00:26:57,250
Is b equal to 0, or is t less than b?

265
00:26:57,250 --> 00:27:01,850
And then the controller, which you see over here, is not much more complicated.

266
00:27:01,850 --> 00:27:14,030
But it has two loops in it, one of which is the main one for doing the GCD, and one of which is the subtraction loop for doing the remainder sub-operation.

267
00:27:14,030 --> 00:27:19,920
And there are ways, of course, of, if you think about it, taking the remainder program.

268
00:27:19,920 --> 00:27:36,630
If I take remainder, as you see over there, as a lambda expression, substitute it in for remainder over here in the GCD program, then do some simplification by substituting a and b for remainder in there, then I can unwind this loop.

269
00:27:36,630 --> 00:27:45,950
And I can get this piece of machinery by basically, a little bit of algebraic simplification on the lambda expressions.

270
00:27:48,550 --> 00:27:52,280
So I suppose you've seen your first very simple machines now.

271
00:27:52,280 --> 00:27:53,530
Are there any questions?

272
00:28:02,700 --> 00:28:05,360
Good.

273
00:28:05,360 --> 00:28:06,610
This looks easy, doesn't it?

274
00:28:10,200 --> 00:28:10,550
Thank you.

275
00:28:10,550 --> 00:28:11,350
I suppose, take a break.

276
00:28:11,350 --> 00:28:13,010
[MUSIC PLAYING - "JESU, JOY OF MAN'S DESIRING" BY JOHANN SEBASTIAN BACH]

277
00:28:47,310 --> 00:28:49,480
PROFESSOR: Well, let's see.

278
00:28:49,480 --> 00:28:57,770
Now you know how to make an iterative procedure, or a procedure that yields an iterative process, turn into a machine.

279
00:28:57,770 --> 00:29:02,690
I suppose the next thing we want to do is worry about things that reveal recursive processes.

280
00:29:02,690 --> 00:29:04,695
So let's play with a simple factorial procedure.

281
00:29:10,894 --> 00:29:33,940
We define factorial of N to be if n is 1, the result is 1, using 1 right now to decrease the amount of work I have to do to simulate it, else it's times N factorial N minus 1.

282
00:29:42,520 --> 00:29:52,260
And what's different with this program, as you know, is that after I've computed factorial of N minus 1 here, I have to do something to the result.

283
00:29:52,260 --> 00:29:56,000
I have to multiply it by N.

284
00:29:56,000 --> 00:30:09,320
So the only way I can visualize what this machine is doing, because of the fact-- think of it this way, that I have a machine out here which somehow needs a factorial machine in order to compute its answer.

285
00:30:09,320 --> 00:30:16,800
But this machine, the outer machine, has to exist before and after the factorial machine, which is inside.

286
00:30:16,800 --> 00:30:28,640
Whereas in the iterative case, the outer machine doesn't need to exist after the inner machine is running, because you never need to go back to the outer machine to do anything.

287
00:30:28,640 --> 00:30:35,340
So here we have a problem where we have a machine which has the same machine inside of it, an infinitely large machine.

288
00:30:40,390 --> 00:30:50,690
And it's got other things inside of it, like a multiplier, which takes some inputs, and there's a minus 1 box, and things like that.

289
00:30:50,690 --> 00:30:54,370
You can imagine that's what it looks like.

290
00:30:54,370 --> 00:31:02,540
But the important thing is that here I have something that happens before and after, in the outer machine, the execution of the inner machine.

291
00:31:02,540 --> 00:31:05,570
So this machine has to have a life.

292
00:31:05,570 --> 00:31:13,490
It has to exist on both times sides of this machine.

293
00:31:13,490 --> 00:31:20,030
So somehow, I have to have a place to store the things that this thing needs to run.

294
00:31:20,030 --> 00:31:24,140
Infinite objects don't exist in the real world.

295
00:31:24,140 --> 00:31:31,830
What we have to do is arrange an illusion that we have an infinite object, we have an infinite amount of hardware somewhere.

296
00:31:31,830 --> 00:31:36,280
Now of course, illusion's all that really matters.

297
00:31:36,280 --> 00:31:47,390
If we can arrange that every time you look at some infinite object, the part of it that you look at is there, then it's as infinite as you need it to be.

298
00:31:47,390 --> 00:32:09,170
And of course, one of the things we might want to do, just look at this thing over here, is the organization that we've had so far involves having a part of the machine, which is the controller, which sits right over here, which is perfectly finite and very simple.

299
00:32:09,170 --> 00:32:13,080
We have some datapaths, which consist of registers and operators.

300
00:32:13,080 --> 00:32:24,230
And what I propose to do here is decompose the machine into two parts, such that there is a part which is fundamentally finite, and some part where a certain amount of infinite stuff can be kept.

301
00:32:24,230 --> 00:32:29,430
On the other hand this is very simple and really isn't infinite, but it's just very large.

302
00:32:29,430 --> 00:32:48,340
But it's so simple that it could be cheaply reproduced in such large amounts, we call it memory, that we can make a structure called a stack out of it which will allow us to, in fact, simulate the existence of an infinite machine which is made out of a recursive nest of many machines.

303
00:32:48,340 --> 00:33:01,650
And the way it's going to work is that we're going to store in this place called the stack the information required after the inner machine runs to resume the operation of the outer machine.

304
00:33:03,840 --> 00:33:11,390
So it will remember the important things about the life of the outer machine that will be needed for this computation.

305
00:33:11,390 --> 00:33:26,580
Since, of course, these machines are nested in a recursive manner, then in fact the stack will only be accessed in a manner which is the last thing that goes in is the first thing that comes out.

306
00:33:29,330 --> 00:33:34,930
So we'll only need to access some little part of this stack memory.

307
00:33:34,930 --> 00:33:36,810
OK, well, let's do it.

308
00:33:36,810 --> 00:33:40,370
I'm going to build you a datapath now, and I'm going to write the controller.

309
00:33:40,370 --> 00:33:43,510
And then we're going to execute this to see how you do it.

310
00:33:43,510 --> 00:33:47,900
So the factorial machine isn't so bad.

311
00:33:47,900 --> 00:34:04,165
It's going to have a register called the value, where the answer is going to be stored, and a registered called N, which is where the number I'm taking factorial will be stored, factorial of.

312
00:34:04,165 --> 00:34:11,760
And it will be necessary in some instances to connect VAL to N.

313
00:34:11,760 --> 00:34:19,139
In fact, one nice case of this is if I just said over here, N, because that would be right for N equal 1N.

314
00:34:19,139 --> 00:34:23,909
And I could just move the answer over there if that's important.

315
00:34:23,909 --> 00:34:26,980
I'm not worried about that right now.

316
00:34:26,980 --> 00:34:29,060
And there are things I have to be able to do.

317
00:34:29,060 --> 00:34:38,290
Like I have to be able to, as we see here, multiply N by something in VAL, because VAL is the result of computing factorial.

318
00:34:38,290 --> 00:34:41,429
And I have to put the result back into VAL.

319
00:34:41,429 --> 00:34:50,690
So here we can see that the result of computing a factorial is N times the result of computing a factorial.

320
00:34:50,690 --> 00:34:55,199
VAL will be the representation of the answer of the inner factorial.

321
00:34:55,199 --> 00:35:17,170
And so I'm going to have to have a multiplier here, which is going to sample the value of N and the value of VAL and put the result back into VAL like that.

322
00:35:17,170 --> 00:35:20,618
I'm also going to have to be able to see if N is 1.

323
00:35:20,618 --> 00:35:22,230
So I need a light bulb.

324
00:35:28,200 --> 00:35:46,620
And I suppose the other thing I'm going to need to have is a way of decrementing N. So I'm going to have a decrementer, which takes N and is going to put back the result into N.

325
00:35:46,620 --> 00:35:49,550
That's pretty much what I need in my machine.

326
00:35:49,550 --> 00:35:51,985
Now, there's a little bit else I need.

327
00:35:51,985 --> 00:36:06,250
It's a little bit more complicated, because I'm also going to need a way to store, to save away, the things that are going to be needed for resuming the computation of a factorial after I've done a sub-factorial.

328
00:36:06,250 --> 00:36:07,230
What's that?

329
00:36:07,230 --> 00:36:09,850
One thing I need is N.

330
00:36:09,850 --> 00:36:11,870
So I'm going to build here a thing called a stack.

331
00:36:14,700 --> 00:36:25,380
The stack is a bunch of stuff that I'm going to write in sequentially.

332
00:36:27,410 --> 00:36:28,916
I don't how long it is.

333
00:36:28,916 --> 00:36:32,890
The longer it is, the better my illusion of infinity.

334
00:36:32,890 --> 00:36:39,515
And I'm going to have to have a way of getting stuff out of N and into the stack and vice versa.

335
00:36:39,515 --> 00:36:55,820
So I'm going to need a connection like this, which is two-way, whereby I can save the value of N and then restore it some other time through that connection.

336
00:36:55,820 --> 00:36:58,100
This is the stack.

337
00:36:58,100 --> 00:37:08,530
I also need a way of remembering where I was in the computation of factorial in the outer program.

338
00:37:08,530 --> 00:37:14,090
Now in the case of this machine, it isn't very much a problem.

339
00:37:14,090 --> 00:37:25,660
Factorial always returns, has to go back to the place where we multiply by N, except for the last time, when it has to return to whatever needs the factorial or go to done or stop.

340
00:37:25,660 --> 00:37:31,770
However, in general, I'm going to have to remember where I have been, because I might have computed factorial from somewhere else.

341
00:37:31,770 --> 00:37:36,070
I have to go back to that place and continue there.

342
00:37:36,070 --> 00:37:47,400
So I'm going to have to have some way of taking the place where the marble is in the finite state controller, the state of the controller, and storing that in the stack as well.

343
00:37:47,400 --> 00:37:51,870
And I'm going to have to have ways of restoring that back to the state of the-- the marble.

344
00:37:51,870 --> 00:37:54,310
So I have to have something that moves the marble to the right place.

345
00:37:54,310 --> 00:37:57,462
Well, we're going to have a place which is the marble now.

346
00:37:57,462 --> 00:38:14,260
And it's called the continue register, called continue, which is the place to put the marble next time I go to continue.

347
00:38:14,260 --> 00:38:16,140
That's what that's for.

348
00:38:16,140 --> 00:38:19,240
And so there's got to be some path from that into the controller.

349
00:38:22,910 --> 00:38:29,074
I also have to have some way of saving that on the stack.

350
00:38:29,074 --> 00:38:36,860
And I have to have some way of setting that up to have various constants, a certain fixed number of constants.

351
00:38:36,860 --> 00:38:38,840
And that's very easy to arrange.

352
00:38:38,840 --> 00:38:40,180
So let's have some constants here.

353
00:38:40,180 --> 00:38:41,430
We'll call this one after-fact.

354
00:38:47,430 --> 00:38:54,010
And that's a constant which we'll get into the continue register, and also another one called fact-done.

355
00:39:05,210 --> 00:39:08,130
So this is the machine I want to build.

356
00:39:08,130 --> 00:39:17,300
That's its datapaths, at least. And it mixes a little with the controller here, because of the fact that I have to remember where I was and restore myself to that place.

357
00:39:17,300 --> 00:39:20,390
But let's write the program now which represents the controller.

358
00:39:20,390 --> 00:39:24,890
I'm not going to write the define machine thing and the register list, because that's not very interesting.

359
00:39:24,890 --> 00:39:30,920
I'm just going to write down the sequence of instructions that constitute the controller.

360
00:39:30,920 --> 00:39:41,510
So we have assign, to set up, continue to done.

361
00:39:44,476 --> 00:40:08,050
We have a loop which says branch if equal 1 fetch N, if N is 1, then go to the base step of the induction, the simple case.

362
00:40:08,050 --> 00:40:14,265
Otherwise, I have to remember the things that are necessary to perform a sub-factorial.

363
00:40:14,265 --> 00:40:17,570
I'm going to go over here, and I have to perform a sub-factorial.

364
00:40:17,570 --> 00:40:24,000
So I have to remember what's needed after I will be done with that.

365
00:40:24,000 --> 00:40:25,510
See, I'm about to do something terrible.

366
00:40:25,510 --> 00:40:38,000
I'm about to change the value of N. But this guy has to know the old value of N. But in order to make the sub-factorial work, I have to change the value of N. So I have to remember the old value.

367
00:40:38,000 --> 00:40:40,850
And I also have to remember where I've been.

368
00:40:40,850 --> 00:40:42,100
So I save up continue.

369
00:40:47,705 --> 00:40:53,580
And this is an instruction that says, put something in the stack.

370
00:40:53,580 --> 00:41:03,550
Save the contents of the continuation register, which in this case is done, because later I'm going to change that, too, because I need to go back to after-fact, as well.

371
00:41:03,550 --> 00:41:05,040
We'll see that.

372
00:41:05,040 --> 00:41:10,380
We save N, because I'm going to need that for later.

373
00:41:10,380 --> 00:41:37,690
Assign to N the decrement of fetch N. Assign continue, we're going to look at this now, to after, we'll call it.

374
00:41:37,690 --> 00:41:41,140
That's a good name for this, a little bit easier and shorter, and fits in here.

375
00:41:52,772 --> 00:41:55,330
Now look what I'm doing here.

376
00:41:55,330 --> 00:42:00,065
I'm saying, if the answer is 1, I'm done.

377
00:42:00,065 --> 00:42:02,150
I'm going to have to just get the answer.

378
00:42:02,150 --> 00:42:11,780
Otherwise, I'm going to save the continuation, save N, make N one less than N, remember I'm going to come back to someplace else, and go back and start doing another factorial.

379
00:42:13,980 --> 00:42:16,050
However, I've got a different machine [? in me ?] now.

380
00:42:16,050 --> 00:42:18,380
N is 1, and continue is something else.

381
00:42:22,160 --> 00:42:23,590
N is N minus 1.

382
00:42:23,590 --> 00:42:28,660
Now after I'm done with that, I can go there.

383
00:42:28,660 --> 00:42:38,360
I will restore the old value of N, which is the opposite of this save over here.

384
00:42:38,360 --> 00:42:39,610
I will restore the continuation.

385
00:42:49,660 --> 00:42:54,320
I will then go to here.

386
00:42:54,320 --> 00:43:08,130
I will assign to the VAL register the product of N and fetch VAL.

387
00:43:13,520 --> 00:43:19,790
VAL fetch product assign.

388
00:43:19,790 --> 00:43:21,440
And then I will be done.

389
00:43:21,440 --> 00:43:26,570
I will have my answer to the sub-factorial in VAL.

390
00:43:26,570 --> 00:43:33,640
At that point, I'm going to return by going to the place where the continuation is pointing.

391
00:43:33,640 --> 00:43:35,300
That says, go to fetch continue.

392
00:43:45,870 --> 00:43:50,730
And then I have finally a base step, which is the immediate answer.

393
00:43:50,730 --> 00:44:02,570
Assign to VAL fetch N, and go to fetch continue.

394
00:44:12,670 --> 00:44:13,920
And then I'm done.

395
00:44:18,640 --> 00:44:26,890
Now let's see how this executes on a very simple case, because then we'll see the use of this stack to do the job we need.

396
00:44:26,890 --> 00:44:31,340
This is statically what it's doing, but we have look dynamically at this.

397
00:44:31,340 --> 00:44:32,300
So let's see.

398
00:44:32,300 --> 00:44:36,730
First thing we do is continue gets done.

399
00:44:36,730 --> 00:44:38,300
The way that happened is I pushed this.

400
00:44:38,300 --> 00:44:40,122
Let's call that done the way I have it.

401
00:44:46,390 --> 00:44:47,030
I push that button.

402
00:44:47,030 --> 00:44:48,950
Done goes into there.

403
00:44:48,950 --> 00:44:53,850
Now I also have to set this thing up to have an initial value.

404
00:44:53,850 --> 00:45:00,192
Let's consider a factorial of three, a simple case.

405
00:45:00,192 --> 00:45:05,900
And we're going to start out with our stack growing over here.

406
00:45:05,900 --> 00:45:12,770
Stacks have their own little internal state saying where they are, where the next place I'm going to write is.

407
00:45:12,770 --> 00:45:14,590
So now we say, is N 1?

408
00:45:14,590 --> 00:45:16,110
The answer is no.

409
00:45:16,110 --> 00:45:19,066
So now I'm going to save continue, bang.

410
00:45:19,066 --> 00:45:22,080
Now that done goes in here.

411
00:45:22,080 --> 00:45:26,660
And this moves to here, the next place I'm going to write.

412
00:45:26,660 --> 00:45:29,950
Save N 3.

413
00:45:29,950 --> 00:45:30,750
OK?

414
00:45:30,750 --> 00:45:35,940
Assign to N the decrement of N. That means I've pushed this button.

415
00:45:35,940 --> 00:45:37,320
This becomes 2.

416
00:45:40,400 --> 00:45:42,580
Assign to continue aft.

417
00:45:42,580 --> 00:45:43,610
So I've pushed that button.

418
00:45:43,610 --> 00:45:44,860
Aft goes in here.

419
00:45:49,140 --> 00:45:54,830
OK, now go to loop, bang, so up to here.

420
00:45:54,830 --> 00:45:56,570
Is N 1?

421
00:45:56,570 --> 00:45:57,780
No.

422
00:45:57,780 --> 00:45:59,490
So I have to save continue.

423
00:45:59,490 --> 00:46:00,600
What's continue?

424
00:46:00,600 --> 00:46:01,530
Continue is aft.

425
00:46:01,530 --> 00:46:02,780
Push this button.

426
00:46:02,780 --> 00:46:04,030
So this moves to here.

427
00:46:08,490 --> 00:46:11,460
I have to save N. N is over here.

428
00:46:11,460 --> 00:46:12,280
I got to 2.

429
00:46:12,280 --> 00:46:13,655
Push that button.

430
00:46:13,655 --> 00:46:16,050
So a 2 gets written there.

431
00:46:16,050 --> 00:46:20,060
And then this thing moves down here.

432
00:46:20,060 --> 00:46:24,214
OK, save N. Assign N to the decrement of N.

433
00:46:24,214 --> 00:46:25,464
This becomes a 1.

434
00:46:29,240 --> 00:46:31,370
Assign continue to aft.

435
00:46:31,370 --> 00:46:34,960
A-F-T gets written there again.

436
00:46:34,960 --> 00:46:36,520
Go to loop.

437
00:46:36,520 --> 00:46:37,930
Is N equal to 1?

438
00:46:37,930 --> 00:46:41,160
Oh, yes, the answer is 1.

439
00:46:41,160 --> 00:46:44,160
OK, go to base step.

440
00:46:44,160 --> 00:46:51,100
Assign to VAL fetch of N. Bang, 1 gets put in there.

441
00:46:51,100 --> 00:46:52,200
Go to fetch continue.

442
00:46:52,200 --> 00:46:53,680
So we look in continue.

443
00:46:53,680 --> 00:46:57,130
Basically, I'm pushing a button over here that goes to the controller.

444
00:46:57,130 --> 00:47:02,640
The continue becomes aft, and all of a sudden, the program's running here.

445
00:47:02,640 --> 00:47:06,650
I now have to restore the outer version of factorial.

446
00:47:06,650 --> 00:47:07,550
So we go here.

447
00:47:07,550 --> 00:47:13,940
We say, restore N. So restore N means take the contents that's here.

448
00:47:13,940 --> 00:47:22,230
Push this button, and it goes into here, 2, and the pointer moves up.

449
00:47:22,230 --> 00:47:24,810
Restore continue, pretty easy.

450
00:47:24,810 --> 00:47:27,020
Go push this button.

451
00:47:27,020 --> 00:47:31,280
And then aft gets written in here again.

452
00:47:31,280 --> 00:47:32,640
That means this thing moves up.

453
00:47:32,640 --> 00:47:35,190
I've gotten rid of something else on my stack.

454
00:47:42,240 --> 00:47:47,850
Right, then I go to here, which says, assign to VAL the product of N an VAL.

455
00:47:47,850 --> 00:47:50,970
So I push this button over here, bang.

456
00:47:50,970 --> 00:47:55,920
2 times 1 gives me a 2, get written there.

457
00:47:55,920 --> 00:47:57,540
Go to fetch continue.

458
00:47:57,540 --> 00:47:59,190
Continue is aft.

459
00:47:59,190 --> 00:48:01,290
I go to aft.

460
00:48:01,290 --> 00:48:17,715
Aft says restore N. Do your restore N, means I take the value over here, which is 3, push this up to here, and move it into here, N. Now it's pushing that button.

461
00:48:17,715 --> 00:48:20,200
The next thing I do is restore continue.

462
00:48:20,200 --> 00:48:22,830
Continue is now going to become done.

463
00:48:22,830 --> 00:48:27,260
So this moves up here when I push this button.

464
00:48:27,260 --> 00:48:31,720
Done may or may be there anymore, I'm not interested, but it certainly is here.

465
00:48:35,800 --> 00:48:41,440
Next thing I do is assign to VAL the product of the fetch of N and the fetch of VAL.

466
00:48:41,440 --> 00:48:44,300
That's pushing this button over here, bang.

467
00:48:44,300 --> 00:48:46,520
2 times 3 is 6.

468
00:48:46,520 --> 00:48:47,870
So I get a 6 over here.

469
00:48:52,020 --> 00:48:55,020
And go to fetch continue, whoops, I go to done, and I'm done.

470
00:48:55,020 --> 00:48:58,950
And my answer is 6, as you can see in the VAL register.

471
00:48:58,950 --> 00:49:03,630
And in fact, the stack is in the state it originally was in.

472
00:49:07,735 --> 00:49:13,620
Now there's a bit of discipline in using these things like stacks that we have to be careful of.

473
00:49:13,620 --> 00:49:16,260
And we'll see that in the next segment.

474
00:49:16,260 --> 00:49:18,590
But first I want to ask if there are any questions for this.

475
00:49:28,560 --> 00:49:30,170
Are there any questions?

476
00:49:30,170 --> 00:49:30,630
Yes, Ron.

477
00:49:30,630 --> 00:49:35,030
AUDIENCE: What happens when you roll off the end of the stack with-- PROFESSOR: What do you mean, roll off of?

478
00:49:35,030 --> 00:49:38,860
AUDIENCE: Well, the largest number-- a larger starting point of N requires more memory, correct?

479
00:49:38,860 --> 00:49:39,440
PROFESSOR: Oh, yes.

480
00:49:39,440 --> 00:49:41,530
Well, I need to have a long enough stack.

481
00:49:41,530 --> 00:49:43,843
You say, what if I violate my illusion?

482
00:49:43,843 --> 00:49:44,550
AUDIENCE: Yes.

483
00:49:44,550 --> 00:49:48,210
PROFESSOR: Well, then the magic doesn't work.

484
00:49:48,210 --> 00:49:51,640
The truth of the matter is that every machine is finite.

485
00:49:51,640 --> 00:49:59,950
And for a procedure like this, there's a limit to the number of sub-factorials I could have.

486
00:49:59,950 --> 00:50:08,350
Remember when we were doing the y-operator a while ago, we pointed out that there was a sequence of exponentiation procedures, each of which was a little better than the previous one.

487
00:50:08,350 --> 00:50:13,090
Well, we're now seeing how we implement that mathematical idea.

488
00:50:13,090 --> 00:50:17,990
The limiting process is only so good as as far as you take the limit.

489
00:50:17,990 --> 00:50:19,420
If you think about it, what am I using here?

490
00:50:19,420 --> 00:50:29,100
I'm using about two pieces of memory for every recursion of this process.

491
00:50:29,100 --> 00:50:33,180
If we try to compute factorial of 10,000, that's not a lot of memory.

492
00:50:33,180 --> 00:50:36,080
On the other hand, it's an awful big number.

493
00:50:36,080 --> 00:50:39,180
So the question is, is that a valuable thing in this case.

494
00:50:39,180 --> 00:50:45,085
But it really turns out not to be a terrible limit, because memory is el cheapo, and people are pretty expensive.

495
00:50:48,130 --> 00:50:51,050
OK, thank you, let's take a break.

496
00:50:51,050 --> 00:50:52,660
[MUSIC PLAYING - "JESU, JOY OF MAN'S DESIRING" BY JOHANN SEBASTIAN BACH]

497
00:51:55,176 --> 00:51:58,351
PROFESSOR: Well, let's see.

498
00:51:58,351 --> 00:52:05,640
What I've shown you now is how to do a simple iterative process and a simple recursive process.

499
00:52:05,640 --> 00:52:26,400
I just want to summarize the design of simple machines for specific applications by showing you a little bit more complicated design, that of a thing that does doubly recursive Fibonacci, because it will indicate to us, and we'll understand, a bit about the conventions required for making stacks operate correctly.

500
00:52:26,400 --> 00:52:27,110
So let's see.

501
00:52:27,110 --> 00:52:30,080
I'm just going to write down, first of all, the program I'm going to translate.

502
00:52:34,150 --> 00:52:59,965
I need a Fibonacci procedure, it's very simple, which says, if N is less than 2, the result is N, otherwise it's the sum of Fib of N minus 1 and Fib of N minus 2.

503
00:53:07,240 --> 00:53:09,290
That's the plan I have here.

504
00:53:09,290 --> 00:53:13,070
And we're just going to write down the controller for such a machine.

505
00:53:13,070 --> 00:53:26,810
We're going to assume that there are registers, N, which holds the number we're taking Fibonacci of, VAL, which is where the answer is going to get put, and continue, which is the thing that's linked to the controller, like before.

506
00:53:26,810 --> 00:53:34,360
But I'm not going to draw another physical datapath, because it's pretty much the same as the last one you've seen.

507
00:53:34,360 --> 00:53:44,860
And of course, one of the most amazing things about computation is that after a while, you build up a little more features and a few more features, and all of the sudden, you've got everything you need.

508
00:53:44,860 --> 00:53:51,810
So it's remarkable that it just gets there so fast. I don't need much more to make a universal computer.

509
00:53:51,810 --> 00:53:55,060
But in any case, let's look at the controller for the Fibonacci thing.

510
00:53:55,060 --> 00:54:10,230
First thing I want to do is start the thing up by assign to continue a place called done, called Fib-done here.

511
00:54:13,709 --> 00:54:24,120
So that means that somewhere over here, I'm going to have a label, Fib-done, which is the place where I go when I want the machine to stop.

512
00:54:24,120 --> 00:54:25,395
That's what that is.

513
00:54:25,395 --> 00:54:26,795
And I'm going to make up a loop.

514
00:54:31,110 --> 00:54:35,470
It's a place I'm going to go to in order to start up computing a Fib.

515
00:54:35,470 --> 00:54:42,570
Whatever is in N at this point, Fibonacci will be computed of, and we will return to the place specified by continue.

516
00:54:46,070 --> 00:55:02,100
So what you're going to see here at this place, what I want here is the contract that says, I'm going to write this with a comment syntax, the contract is N contains arg, the argument.

517
00:55:02,100 --> 00:55:09,325
Continue is the recipient.

518
00:55:12,812 --> 00:55:14,290
And that's where it is.

519
00:55:17,370 --> 00:55:24,820
At this point, if I ever go to this place, I'm expecting this to be true, the argument for computing the Fibonacci.

520
00:55:24,820 --> 00:55:26,450
Now the next thing I want to do is to branch.

521
00:55:30,220 --> 00:55:38,730
And if N is less than 2--  by the way, I'm using what looks like Lisp syntax.

522
00:55:38,730 --> 00:55:41,310
This is not Lisp.

523
00:55:41,310 --> 00:55:42,750
This does not run.

524
00:55:42,750 --> 00:55:46,120
What I'm writing here does not run as a simple Lisp program.

525
00:55:46,120 --> 00:55:49,710
This is a representation of another language.

526
00:55:49,710 --> 00:56:03,380
The reason I'm using the syntax of parentheses and so on is because I tend to use a Lisp system to write an interpreter for this which allows me to simulate the machine I'm trying to build.

527
00:56:03,380 --> 00:56:06,940
I don't want to confuse this to think that this is Lisp code.

528
00:56:06,940 --> 00:56:09,510
It's just I'm using a lot of the pieces of Lisp.

529
00:56:09,510 --> 00:56:16,620
I'm embedding a language in Lisp, using Lisp as pieces to make my process of making my simulator easy.

530
00:56:16,620 --> 00:56:18,900
So I'm inheriting from Lisp all of its properties.

531
00:56:18,900 --> 00:56:25,985
Fetch of N 2, I want to go to a place called immediate answer.

532
00:56:25,985 --> 00:56:27,235
It's the base step.

533
00:56:33,150 --> 00:56:37,750
Now, that's somewhere over here, just above done.

534
00:56:37,750 --> 00:56:39,330
And we'll see it later.

535
00:56:39,330 --> 00:56:44,860
Now, in the general case, which is the part I'm going to write down now, let's just do it.

536
00:56:44,860 --> 00:56:49,420
Well, first of all, I'm going to have to call Fibonacci twice.

537
00:56:49,420 --> 00:56:56,310
In each case-- well, in one case at least, I'm going to have to know what to do to come back and do the next one.

538
00:56:56,310 --> 00:57:04,500
I have to remember, have I done the first Fib, or have I done the second one?

539
00:57:04,500 --> 00:57:09,490
Do I have to come back to the place where I do the second Fib, or do I have to come back to the place where I do the add?

540
00:57:12,140 --> 00:57:16,980
In the first case, over the first Fibonacci, I'm going to need the value of N for computing for the second one.

541
00:57:20,010 --> 00:57:22,996
So I have to store some of these things up.

542
00:57:22,996 --> 00:57:25,820
So first I'm going to save continue.

543
00:57:25,820 --> 00:57:27,265
That's who needs the answer.

544
00:57:31,320 --> 00:57:44,130
And the reason I'm doing that is because I'm about to assign continue to the place which is the place I want to go to after.

545
00:57:46,870 --> 00:57:53,760
Let's call it Fib-N-minus-1, big long name, classic Lisp name.

546
00:57:57,700 --> 00:58:03,960
Because I'm going to compute the first Fib of N minus 1, and then after that, I want to come back and do something else.

547
00:58:03,960 --> 00:58:11,106
That's the place I want to go to after I've done the first Fibonacci calculation.

548
00:58:11,106 --> 00:58:19,130
And I want to do a save of N, because I'm going to need it later, after that.

549
00:58:19,130 --> 00:58:23,230
Now I'm going to, at this point, get ready to do the Fibonacci of N minus 1.

550
00:58:23,230 --> 00:58:33,950
So assign to N the difference of the fetch of N and 1.

551
00:58:38,110 --> 00:58:40,270
Now I'm ready to go back to doing the Fib loop.

552
00:58:47,630 --> 00:58:50,195
Have I satisfied my contract?

553
00:58:50,195 --> 00:58:51,770
And the answer is yes.

554
00:58:51,770 --> 00:58:57,210
N contains N minus 1, which is what I need.

555
00:58:57,210 --> 00:59:04,100
Continue contains a place I want to go to when I'm done with calculating N minus 1.

556
00:59:04,100 --> 00:59:05,440
So I've satisfied the contract.

557
00:59:05,440 --> 00:59:12,830
And therefore, I can write down here a label, after-Fib-N-minus-1.

558
00:59:20,490 --> 00:59:22,690
Now what am I going to do here?

559
00:59:22,690 --> 00:59:26,910
Here's a place where I now have to get ready to do Fib of N minus 2.

560
00:59:29,270 --> 00:59:31,780
But in order to do a Fib of N minus 2, look, I don't know.

561
00:59:31,780 --> 00:59:33,810
I've clobbered my N over here.

562
00:59:33,810 --> 00:59:39,780
And presumably my N is counted down all the way to 1 or 0 or something at this point.

563
00:59:39,780 --> 00:59:43,030
So I don't know what the value of N in the N register is.

564
00:59:43,030 --> 00:59:49,520
I want the value of N that was on the stack that I saved over here so that could restore it over here.

565
00:59:49,520 --> 01:00:01,810
I saved up the value of N, which is this value of N at this point, so that I could restore it after computing Fib of N minus 1, so that I could count that down to N minus 2 and then compute Fib of N minus 2.

566
01:00:01,810 --> 01:00:03,060
So let's restore that.

567
01:00:08,830 --> 01:00:11,130
Restore of N.

568
01:00:11,130 --> 01:00:18,520
Now I'm about to do something which is superstitious, and we will remove it shortly.

569
01:00:18,520 --> 01:00:24,800
I am about to finish the sequence of doing the subroutine call, if you will.

570
01:00:24,800 --> 01:00:31,600
I'm going to say, well, I also saved up the continuation, since I'm going to restore it now.

571
01:00:31,600 --> 01:00:34,610
But actually, I don't have to, because I'm not going to need it.

572
01:00:34,610 --> 01:00:36,260
We'll fix that in a second.

573
01:00:36,260 --> 01:00:48,020
So we'll do a restore of continue, which is what I would in general need to do.

574
01:00:48,020 --> 01:00:55,420
And we're just going to see what you would call in the compiler world a peephole optimization, which says, whoops, you didn't have to do that.

575
01:00:55,420 --> 01:01:02,770
OK, so the next thing I see here is that I have to get ready now to do Fibonacci of N minus 2.

576
01:01:02,770 --> 01:01:05,050
But I don't have to save N anymore.

577
01:01:05,050 --> 01:01:13,540
The reason why I don't have to save N anymore is because I don't need N after I've done Fib of N minus 2, because the next thing I do is add.

578
01:01:13,540 --> 01:01:16,500
So I'm just going to set up my N that way.

579
01:01:16,500 --> 01:01:28,990
Assign N minus difference of fetch N and 2.

580
01:01:31,850 --> 01:01:36,950
Now I have to finish the setup for calling Fibonacci of N minus 2.

581
01:01:36,950 --> 01:02:05,320
Well, I have to save up continue and assign continue, continue, to the place which is after Fib N 2, that place over here somewhere.

582
01:02:05,320 --> 01:02:08,650
However, I've got to be very careful.

583
01:02:08,650 --> 01:02:15,300
The old value, the value of Fib of N minus 1, I'm going to need later.

584
01:02:15,300 --> 01:02:18,480
The value of Fibonacci of N minus 1, I'm going to need.

585
01:02:18,480 --> 01:02:24,150
And I can't clobber it, because I'm going to have to add it to the value of Fib of N minus 2.

586
01:02:24,150 --> 01:02:27,720
That's in the value register, so I'm going to save it.

587
01:02:27,720 --> 01:02:33,780
So I have to save this right now, save up VAL.

588
01:02:33,780 --> 01:02:39,547
And now I can go off to my subroutine, go to Fib loop.

589
01:02:44,220 --> 01:03:01,580
Now before I go any further and finish this program, I just want to look at this segment so far and see, oh yes, there's a sequence of instructions here, if you will, that I can do something about.

590
01:03:01,580 --> 01:03:10,640
Here I have a restore of continue, a save of continue, and then an assign of continue, with no other references to continue in between.

591
01:03:13,840 --> 01:03:16,770
The restore followed by the save leaves the stack unchanged.

592
01:03:19,090 --> 01:03:24,330
The only difference is that I set the continue register to a value, which is the value that was on the stack.

593
01:03:24,330 --> 01:03:31,710
Since I now clobber that value, as in it was never referenced, these instructions are unnecessary.

594
01:03:31,710 --> 01:03:35,390
So we will remove these.

595
01:03:38,550 --> 01:03:41,460
But I couldn't have seen that unless I had written them down.

596
01:03:43,780 --> 01:03:45,590
Was that really true?

597
01:03:45,590 --> 01:03:48,610
Well, I don't know.

598
01:03:48,610 --> 01:03:53,660
OK, so we've now gone off to compute Fibonacci of N minus 2.

599
01:03:53,660 --> 01:04:05,070
So after that, what are we going to do?

600
01:04:05,070 --> 01:04:07,960
Well, I suppose the first thing we have to do-- we've got two things.

601
01:04:07,960 --> 01:04:10,920
We've got a thing in the value register which is now valuable.

602
01:04:10,920 --> 01:04:14,815
We also have a thing on the stack that can be restored into the value register.

603
01:04:14,815 --> 01:04:19,470
And what I have to be careful with now is I want to shuffle this right so I can do the multiply.

604
01:04:19,470 --> 01:04:26,740
Now there are various conventions I might use, but I'm going to be very picky and say, I'm only going to restore into a register I've saved from.

605
01:04:26,740 --> 01:04:30,020
If that's the case, I have to do a shuffle here.

606
01:04:30,020 --> 01:04:47,340
It's the same problem with how many hands I have. So I'm going to assign to N, because I'm not going to need N anymore, N is useless, the current value of VAL, which was the value of Fib of N minus 2.

607
01:04:52,950 --> 01:04:56,180
And I'm going to restore the value register now.

608
01:05:01,850 --> 01:05:13,840
This restore matches this save. And if you're very careful and examine very carefully what goes on, restores and saves are always matched.

609
01:05:13,840 --> 01:05:19,000
Now there's an outstanding save, of course, that we have to get rid of soon.

610
01:05:19,000 --> 01:05:20,590
And so I restored the value register.

611
01:05:20,590 --> 01:05:42,860
Now I restore the continue one, which matches this one, dot, dot, dot, dot, dot, dot, dot, down to here, restoring that continuation.

612
01:05:42,860 --> 01:05:49,665
That continuation is a continuation of Fib of N, which is the problem I was trying to solve, a major problem I'm trying to solve.

613
01:05:49,665 --> 01:05:57,360
So that's the guy I have to go back to who wants Fib of N. I saved them all the way up here when I realized N was not less than 2.

614
01:05:57,360 --> 01:06:00,840
And so I had to do a complicated operation.

615
01:06:00,840 --> 01:06:03,240
Now I've got everything I need to do it.

616
01:06:03,240 --> 01:06:28,335
So I'm going to restore that, assign to VAL the sum of fetch VAL and fetch of N, and go to continue.

617
01:06:38,260 --> 01:06:47,110
So now I've returned from computing Fibonacci of N, the general case.

618
01:06:47,110 --> 01:07:36,130
Now what's left is we have to fix up a few details, like there's the base case of this induction, immediate answer, which is nothing more than assign to VAL fetch of N, because N was less than 2, and therefore, the answer is N in our original program, and return continue--  bobble, bobble almost-- and finally Fib done.

619
01:07:43,460 --> 01:07:45,640
So that's a fairly complicated program.

620
01:07:45,640 --> 01:07:52,965
And the reason I wanted you see to that is because I want you to see the particular flavors of stack discipline that I was obeying.

621
01:07:52,965 --> 01:08:00,395
It was first of all, I don't want to take anything that I'm not going to need later.

622
01:08:00,395 --> 01:08:01,850
I was being very careful.

623
01:08:01,850 --> 01:08:03,940
And it's very important.

624
01:08:03,940 --> 01:08:15,830
And there are all sorts of other disciplines people make with frames and things like that of some sort, where you save all sorts of junk you're not going to need later and restore it because, in some sense, it's easier to do that.

625
01:08:15,830 --> 01:08:21,740
That's going to lead to various disasters, which we'll see a little later.

626
01:08:21,740 --> 01:08:24,810
It's crucial to say exactly what you're going to need later.

627
01:08:26,899 --> 01:08:29,859
It's an important idea.

628
01:08:29,859 --> 01:08:36,930
And the responsibility of that is whoever saves something is the guy who restores it, because he needs it.

629
01:08:36,930 --> 01:08:46,940
And in such discipline, you can see what things are unnecessary, operations that are unimportant.

630
01:08:46,940 --> 01:08:55,350
Now, one other thing I want to tell you about that's very simple is that, of course, the picture you see is not the whole picture.

631
01:08:55,350 --> 01:09:10,000
Supposing I had systems that had things like other operations, CAR, CDR, cons, building a vector and referencing the nth element of it, or things like that.

632
01:09:10,000 --> 01:09:18,299
Well, at this level of detail, whatever it is, we can conceptualize those as primitive operations in the datapath.

633
01:09:18,299 --> 01:09:33,630
In other words, we could say that some machine that, for example, has the append machine, which has to do cons of the CAR of x with the append of the CDR of x and y, well, gee, that's exactly the same as the factorial structure.

634
01:09:33,630 --> 01:09:36,133
Well, it's got about the same structure.

635
01:09:36,133 --> 01:09:37,270
And what do we have?

636
01:09:37,270 --> 01:09:46,939
We have some sort of things in it which may be registers, x and y, and then x has to somehow move to y sometimes, x has to get the value of y.

637
01:09:46,939 --> 01:09:51,700
And then we may have to be able to do something which is a cons.

638
01:09:51,700 --> 01:10:01,420
I don't remember if I need to like this is in this system, but cons is sort of like subtract or add or something.

639
01:10:01,420 --> 01:10:07,600
It combines two things, producing a thing which is the cons, which we may then think goes into there.

640
01:10:07,600 --> 01:10:16,920
And then maybe a thing called the CAR, which will produce-- I can get the CAR or something.

641
01:10:16,920 --> 01:10:20,150
And maybe I can get the CDR of something, and so on.

642
01:10:20,150 --> 01:10:31,770
But we shouldn't be too afraid of saying things this way, because the worst that could happen is if we open up cons, what we're going to find is some machine.

643
01:10:31,770 --> 01:10:41,210
And cons may in fact overlap with CAR and CDR, and it always does, in the same way that plus and minus overlap, and really the same business.

644
01:10:41,210 --> 01:10:53,300
Cons, CAR, and CDR are going to overlap, and we're going to find a little controller, a little datapath, which may have some registers in it, some stuff like that.

645
01:10:53,300 --> 01:11:02,030
And maybe inside it, there may also be an infinite part, a part that's semi-infinite or something, which is a lot of very uniform stuff, which we'll call memory.

646
01:11:06,570 --> 01:11:09,330
And I wouldn't be so horrified if that were the way it works.

647
01:11:09,330 --> 01:11:13,320
In fact, it does, and we'll talk about that later.

648
01:11:13,320 --> 01:11:14,570
So are there any questions?

649
01:11:24,340 --> 01:11:25,665
Gee, what an unquestioning audience.

650
01:11:28,670 --> 01:11:30,330
Suppose I tell you a horrible pile of lies.

651
01:11:39,690 --> 01:11:41,990
OK.

652
01:11:41,990 --> 01:11:42,520
Well, thank you.

653
01:11:42,520 --> 01:11:44,230
Let's take our break.

654
01:11:44,230 --> 01:11:48,780
[MUSIC PLAYING - "JESU, JOY OF MAN'S DESIRING" BY JOHANN SEBASTIAN BACH]

