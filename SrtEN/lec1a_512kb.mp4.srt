0
00:00:00,000 --> 00:00:03,880


1
00:00:03,880 --> 00:00:14,550
[MUSIC PLAYING]

2
00:00:14,550 --> 00:00:15,790
PROFESSOR: I'd like to
welcome you to this

3
00:00:15,790 --> 00:00:17,270
course on computer science.

4
00:00:17,270 --> 00:00:28,370


5
00:00:28,370 --> 00:00:29,990
Actually, that's a terrible
way to start.

6
00:00:29,990 --> 00:00:32,740
Computer science is a terrible
name for this business.

7
00:00:32,740 --> 00:00:35,572
First of all, it's
not a science.

8
00:00:35,572 --> 00:00:40,300
It might be engineering or it
might be art, but we'll

9
00:00:40,300 --> 00:00:43,470
actually see that computer
so-called science actually has

10
00:00:43,470 --> 00:00:45,350
a lot in common with magic,
and we'll see

11
00:00:45,350 --> 00:00:47,210
that in this course.

12
00:00:47,210 --> 00:00:48,040
So it's not a science.

13
00:00:48,040 --> 00:00:53,340
It's also not really very
much about computers.

14
00:00:53,340 --> 00:00:57,140
And it's not about computers in
the same sense that physics

15
00:00:57,140 --> 00:01:02,920
is not really about particle
accelerators, and biology is

16
00:01:02,920 --> 00:01:06,350
not really about microscopes
and petri dishes.

17
00:01:06,350 --> 00:01:10,400
And it's not about computers
in the same sense that

18
00:01:10,400 --> 00:01:16,480
geometry is not really about
using surveying instruments.

19
00:01:16,480 --> 00:01:20,320
In fact, there's a lot of
commonality between computer

20
00:01:20,320 --> 00:01:21,240
science and geometry.

21
00:01:21,240 --> 00:01:23,830
Geometry, first of all,
is another subject

22
00:01:23,830 --> 00:01:25,680
with a lousy name.

23
00:01:25,680 --> 00:01:28,130
The name comes from Gaia,
meaning the Earth, and metron,

24
00:01:28,130 --> 00:01:29,770
meaning to measure.

25
00:01:29,770 --> 00:01:31,350
Geometry originally
meant measuring

26
00:01:31,350 --> 00:01:34,260
the Earth or surveying.

27
00:01:34,260 --> 00:01:37,260
And the reason for that was
that, thousands of years ago,

28
00:01:37,260 --> 00:01:40,930
the Egyptian priesthood
developed the rudiments of

29
00:01:40,930 --> 00:01:45,320
geometry in order to figure
out how to restore the

30
00:01:45,320 --> 00:01:47,430
boundaries of fields that were
destroyed in the annual

31
00:01:47,430 --> 00:01:49,390
flooding of the Nile.

32
00:01:49,390 --> 00:01:52,360
And to the Egyptians who did
that, geometry really was the

33
00:01:52,360 --> 00:01:55,600
use of surveying instruments.

34
00:01:55,600 --> 00:01:57,850
Now, the reason that we think
computer science is about

35
00:01:57,850 --> 00:02:01,770
computers is pretty much the
same reason that the Egyptians

36
00:02:01,770 --> 00:02:04,520
thought geometry was about
surveying instruments.

37
00:02:04,520 --> 00:02:07,340
And that is, when some field
is just getting started and

38
00:02:07,340 --> 00:02:11,790
you don't really understand it
very well, it's very easy to

39
00:02:11,790 --> 00:02:15,280
confuse the essence of what
you're doing with the tools

40
00:02:15,280 --> 00:02:17,590
that you use.

41
00:02:17,590 --> 00:02:20,960
And indeed, on some absolute
scale of things, we probably

42
00:02:20,960 --> 00:02:25,100
know less about the essence of
computer science than the

43
00:02:25,100 --> 00:02:26,955
ancient Egyptians really
knew about geometry.

44
00:02:26,955 --> 00:02:29,970


45
00:02:29,970 --> 00:02:32,570
Well, what do I mean by the
essence of computer science?

46
00:02:32,570 --> 00:02:34,300
What do I mean by the
essence of geometry?

47
00:02:34,300 --> 00:02:36,380
See, it's certainly true that
these Egyptians went off and

48
00:02:36,380 --> 00:02:40,190
used surveying instruments, but
when we look back on them

49
00:02:40,190 --> 00:02:42,240
after a couple of thousand
years, we say, gee, what they

50
00:02:42,240 --> 00:02:45,910
were doing, the important stuff
they were doing, was to

51
00:02:45,910 --> 00:02:52,510
begin to formalize notions about
space and time, to start

52
00:02:52,510 --> 00:02:57,490
a way of talking about
mathematical truths formally.

53
00:02:57,490 --> 00:02:59,420
That led to the axiomatic
method.

54
00:02:59,420 --> 00:03:04,420
That led to sort of all of
modern mathematics, figuring

55
00:03:04,420 --> 00:03:08,350
out a way to talk precisely
about so-called declarative

56
00:03:08,350 --> 00:03:10,000
knowledge, what is true.

57
00:03:10,000 --> 00:03:12,550


58
00:03:12,550 --> 00:03:15,680
Well, similarly, I think in the
future people will look

59
00:03:15,680 --> 00:03:18,520
back and say, yes, those
primitives in the 20th century

60
00:03:18,520 --> 00:03:20,190
were fiddling around with
these gadgets called

61
00:03:20,190 --> 00:03:25,790
computers, but really what they
were doing is starting to

62
00:03:25,790 --> 00:03:32,730
learn how to formalize
intuitions about process, how

63
00:03:32,730 --> 00:03:47,100
to do things, starting to
develop a way to talk

64
00:03:47,100 --> 00:03:52,190
precisely about how-to
knowledge, as opposed to

65
00:03:52,190 --> 00:03:56,470
geometry that talks about
what is true.

66
00:03:56,470 --> 00:03:57,810
Let me give you an
example of that.

67
00:03:57,810 --> 00:04:01,650


68
00:04:01,650 --> 00:04:02,550
Let's take a look.

69
00:04:02,550 --> 00:04:08,250
Here is a piece of mathematics
that says what

70
00:04:08,250 --> 00:04:10,250
a square root is.

71
00:04:10,250 --> 00:04:17,019
The square root of X is the
number Y, such that Y squared

72
00:04:17,019 --> 00:04:20,290
is equal to X and Y
is greater than 0.

73
00:04:20,290 --> 00:04:23,510
Now, that's a fine piece of
mathematics, but just telling

74
00:04:23,510 --> 00:04:26,900
you what a square root is
doesn't really say anything

75
00:04:26,900 --> 00:04:31,420
about how you might go
out and find one.

76
00:04:31,420 --> 00:04:37,410
So let's contrast that with a
piece of imperative knowledge,

77
00:04:37,410 --> 00:04:39,840
how you might go out and
find a square root.

78
00:04:39,840 --> 00:04:44,660
This, in fact, also comes
from Egypt, not

79
00:04:44,660 --> 00:04:45,640
ancient, ancient Egypt.

80
00:04:45,640 --> 00:04:50,050
This is an algorithm due to
Heron of Alexandria, called

81
00:04:50,050 --> 00:04:52,910
how to find a square root
by successive averaging.

82
00:04:52,910 --> 00:05:03,370
And what it says is that, in
order to find a square root,

83
00:05:03,370 --> 00:05:07,560
you make a guess, you
improve that guess--

84
00:05:07,560 --> 00:05:10,070


85
00:05:10,070 --> 00:05:12,670
and the way you improve the
guess is to average the guess

86
00:05:12,670 --> 00:05:15,170
and X over the guess, and we'll
talk a little bit later

87
00:05:15,170 --> 00:05:17,080
about why that's a reasonable
thing--

88
00:05:17,080 --> 00:05:19,740
and you keep improving the guess
until it's good enough.

89
00:05:19,740 --> 00:05:20,800
That's a method.

90
00:05:20,800 --> 00:05:25,070
That's how to do something
as opposed to declarative

91
00:05:25,070 --> 00:05:28,270
knowledge that says what
you're looking for.

92
00:05:28,270 --> 00:05:29,520
That's a process.

93
00:05:29,520 --> 00:05:34,130


94
00:05:34,130 --> 00:05:38,850
Well, what's a process
in general?

95
00:05:38,850 --> 00:05:40,000
It's kind of hard to say.

96
00:05:40,000 --> 00:05:45,350
You can think of it as like a
magical spirit that sort of

97
00:05:45,350 --> 00:05:47,870
lives in the computer
and does something.

98
00:05:47,870 --> 00:05:56,250
And the thing that directs a
process is a pattern of rules

99
00:05:56,250 --> 00:05:57,500
called a procedure.

100
00:05:57,500 --> 00:06:01,690


101
00:06:01,690 --> 00:06:05,940
So procedures are the spells,
if you like, that control

102
00:06:05,940 --> 00:06:10,700
these magical spirits that
are the processes.

103
00:06:10,700 --> 00:06:12,650
I guess you know everyone needs
a magical language, and

104
00:06:12,650 --> 00:06:17,310
sorcerers, real sorcerers, use
ancient Arcadian or Sumerian

105
00:06:17,310 --> 00:06:18,670
or Babylonian or whatever.

106
00:06:18,670 --> 00:06:21,540
We're going to conjure our
spirits in a magical language

107
00:06:21,540 --> 00:06:26,750
called Lisp, which is a language
designed for talking

108
00:06:26,750 --> 00:06:31,120
about, for casting the spells
that are procedures to direct

109
00:06:31,120 --> 00:06:32,040
the processes.

110
00:06:32,040 --> 00:06:33,780
Now, it's very easy
to learn Lisp.

111
00:06:33,780 --> 00:06:35,810
In fact, in a few minutes,
I'm going to teach you,

112
00:06:35,810 --> 00:06:36,960
essentially, all of Lisp.

113
00:06:36,960 --> 00:06:40,660
I'm going to teach you,
essentially, all of the rules.

114
00:06:40,660 --> 00:06:43,440
And you shouldn't find that
particularly surprising.

115
00:06:43,440 --> 00:06:46,150
That's sort of like saying it's
very easy to learn the

116
00:06:46,150 --> 00:06:46,940
rules of chess.

117
00:06:46,940 --> 00:06:48,860
And indeed, in a few minutes,
you can tell somebody the

118
00:06:48,860 --> 00:06:50,710
rules of chess.

119
00:06:50,710 --> 00:06:53,490
But of course, that's very
different from saying you

120
00:06:53,490 --> 00:06:55,740
understand the implications of
those rules and how to use

121
00:06:55,740 --> 00:06:58,420
those rules to become a
masterful chess player.

122
00:06:58,420 --> 00:07:00,380
Well, Lisp is the same way.

123
00:07:00,380 --> 00:07:02,610
We're going to state the rules
in a few minutes, and it'll be

124
00:07:02,610 --> 00:07:03,360
very easy to see.

125
00:07:03,360 --> 00:07:06,210
But what's really hard is going
to be the implications

126
00:07:06,210 --> 00:07:09,310
of those rules, how you exploit
those rules to be a

127
00:07:09,310 --> 00:07:12,080
master programmer.

128
00:07:12,080 --> 00:07:15,260
And the implications of those
rules are going to take us

129
00:07:15,260 --> 00:07:17,770
the, well, the whole rest of
the subject and, of course,

130
00:07:17,770 --> 00:07:19,020
way beyond.

131
00:07:19,020 --> 00:07:21,420


132
00:07:21,420 --> 00:07:26,070
OK, so in computer science,
we're in the business of

133
00:07:26,070 --> 00:07:30,910
formalizing this sort of how-to
imperative knowledge,

134
00:07:30,910 --> 00:07:33,330
how to do stuff.

135
00:07:33,330 --> 00:07:35,120
And the real issues of computer
science are, of

136
00:07:35,120 --> 00:07:38,620
course, not telling people
how to do square roots.

137
00:07:38,620 --> 00:07:40,050
Because if that was
all it was, there

138
00:07:40,050 --> 00:07:41,760
wouldn't be no big deal.

139
00:07:41,760 --> 00:07:45,550
The real problems come when we
try to build very, very large

140
00:07:45,550 --> 00:07:49,270
systems, computer programs that
are thousands of pages

141
00:07:49,270 --> 00:07:52,640
long, so long that nobody can
really hold them in their

142
00:07:52,640 --> 00:07:54,640
heads all at once.

143
00:07:54,640 --> 00:07:58,770
And the only reason that that's
possible is because

144
00:07:58,770 --> 00:08:17,830
there are techniques for
controlling the complexity of

145
00:08:17,830 --> 00:08:21,590
these large systems. And these
techniques that are

146
00:08:21,590 --> 00:08:22,950
controlling complexity
are what this

147
00:08:22,950 --> 00:08:24,700
course is really about.

148
00:08:24,700 --> 00:08:26,030
And in some sense, that's
really what

149
00:08:26,030 --> 00:08:29,650
computer science is about.

150
00:08:29,650 --> 00:08:31,740
Now, that may seem like a very
strange thing to say.

151
00:08:31,740 --> 00:08:34,960
Because after all, a lot of
people besides computer

152
00:08:34,960 --> 00:08:37,970
scientists deal with controlling
complexity.

153
00:08:37,970 --> 00:08:41,860
A large airliner is an extremely
complex system, and

154
00:08:41,860 --> 00:08:44,760
the aeronautical engineers who
design that are dealing with

155
00:08:44,760 --> 00:08:47,030
immense complexity.

156
00:08:47,030 --> 00:08:49,380
But there's a difference
between that kind of

157
00:08:49,380 --> 00:08:52,205
complexity and what we deal
with in computer science.

158
00:08:52,205 --> 00:08:55,090


159
00:08:55,090 --> 00:08:57,750
And that is that computer
science, in some

160
00:08:57,750 --> 00:08:59,700
sense, isn't real.

161
00:08:59,700 --> 00:09:02,670


162
00:09:02,670 --> 00:09:07,070
You see, when an engineer is
designing a physical system,

163
00:09:07,070 --> 00:09:09,520
that's made out of real parts.

164
00:09:09,520 --> 00:09:12,820
The engineers who worry about
that have to address problems

165
00:09:12,820 --> 00:09:16,540
of tolerance and approximation
and noise in the system.

166
00:09:16,540 --> 00:09:19,280
So for example, as an electrical
engineer, I can go

167
00:09:19,280 --> 00:09:21,885
off and easily build a one-stage
amplifier or a

168
00:09:21,885 --> 00:09:25,090
two-stage amplifier, and I can
imagine cascading a lot of

169
00:09:25,090 --> 00:09:26,760
them to build a million-stage
amplifier.

170
00:09:26,760 --> 00:09:30,900
But it's ridiculous to build
such a thing, because long

171
00:09:30,900 --> 00:09:33,160
before the millionth stage,
the thermal noise in those

172
00:09:33,160 --> 00:09:34,740
components way at the beginning
is going to get

173
00:09:34,740 --> 00:09:36,200
amplified and make the whole
thing meaningless.

174
00:09:36,200 --> 00:09:38,880


175
00:09:38,880 --> 00:09:44,070
Computer science deals with
idealized components.

176
00:09:44,070 --> 00:09:47,430
We know as much as we want about
these little program and

177
00:09:47,430 --> 00:09:51,820
data pieces that we're fitting
things together.

178
00:09:51,820 --> 00:09:53,090
We don't have to worry
about tolerance.

179
00:09:53,090 --> 00:09:57,960
And that means that, in building
a large program,

180
00:09:57,960 --> 00:10:01,720
there's not all that much
difference between what I can

181
00:10:01,720 --> 00:10:06,520
build and what I can imagine,
because the parts are these

182
00:10:06,520 --> 00:10:10,250
abstract entities that I
know as much as I want.

183
00:10:10,250 --> 00:10:13,430
I know about them as precisely
as I'd like.

184
00:10:13,430 --> 00:10:15,920
So as opposed to other kinds
of engineering, where the

185
00:10:15,920 --> 00:10:17,830
constraints on what you can
build are the constraints of

186
00:10:17,830 --> 00:10:19,810
physical systems, the
constraints of physics and

187
00:10:19,810 --> 00:10:24,160
noise and approximation, the
constraints imposed in

188
00:10:24,160 --> 00:10:26,640
building large software systems
are the limitations of

189
00:10:26,640 --> 00:10:28,930
our own minds.

190
00:10:28,930 --> 00:10:32,460
So in that sense, computer
science is like an abstract

191
00:10:32,460 --> 00:10:33,530
form of engineering.

192
00:10:33,530 --> 00:10:35,680
It's the kind of engineering
where you ignore the

193
00:10:35,680 --> 00:10:37,645
constraints that are
imposed by reality.

194
00:10:37,645 --> 00:10:42,050


195
00:10:42,050 --> 00:10:46,400
Well, what are some of
these techniques?

196
00:10:46,400 --> 00:10:47,830
They're not special to
computer science.

197
00:10:47,830 --> 00:10:50,360


198
00:10:50,360 --> 00:10:54,140
First technique, which is used
in all of engineering, is a

199
00:10:54,140 --> 00:10:57,785
kind of abstraction called
black-box abstraction.

200
00:10:57,785 --> 00:11:07,670


201
00:11:07,670 --> 00:11:14,340
Take something and build
a box about it.

202
00:11:14,340 --> 00:11:19,220
Let's see, for example, if we
looked at that square root

203
00:11:19,220 --> 00:11:29,678
method, I might want to take
that and build a box.

204
00:11:29,678 --> 00:11:38,980
That sort of says, to find the
square root of X. And that

205
00:11:38,980 --> 00:11:42,560
might be a whole complicated
set of rules.

206
00:11:42,560 --> 00:11:46,280
And that might end up being a
kind of thing where I can put

207
00:11:46,280 --> 00:11:50,270
in, say, 36 and say, what's
the square root of 36?

208
00:11:50,270 --> 00:11:51,520
And out comes 6.

209
00:11:51,520 --> 00:11:53,880


210
00:11:53,880 --> 00:11:59,630
And the important thing is that
I'd like to design that

211
00:11:59,630 --> 00:12:05,080
so that if George comes along
and would like to compute,

212
00:12:05,080 --> 00:12:11,580
say, the square root of A plus
the square root of B, he can

213
00:12:11,580 --> 00:12:14,930
take this thing and use it as
a module without having to

214
00:12:14,930 --> 00:12:16,760
look inside and build something
that looks like

215
00:12:16,760 --> 00:12:24,960
this, like an A and a B and a
square root box and another

216
00:12:24,960 --> 00:12:32,660
square root box and then
something that adds that would

217
00:12:32,660 --> 00:12:33,870
put out the answer.

218
00:12:33,870 --> 00:12:38,830
And you can see, just from the
fact that I want to do that,

219
00:12:38,830 --> 00:12:41,560
is from George's point of view,
the internals of what's

220
00:12:41,560 --> 00:12:44,170
in here should not
be important.

221
00:12:44,170 --> 00:12:46,940
So for instance, it shouldn't
matter that, when I wrote

222
00:12:46,940 --> 00:12:50,750
this, I said I want to find the
square root of X. I could

223
00:12:50,750 --> 00:12:54,840
have said the square root of Y,
or the square root of A, or

224
00:12:54,840 --> 00:12:56,890
anything at all.

225
00:12:56,890 --> 00:13:03,480
That's the fundamental notion of
putting something in a box

226
00:13:03,480 --> 00:13:07,520
using black-box abstraction
to suppress detail.

227
00:13:07,520 --> 00:13:10,070
And the reason for that is you
want to go off and build

228
00:13:10,070 --> 00:13:11,990
bigger boxes.

229
00:13:11,990 --> 00:13:13,880
Now, there's another reason
for doing black-box

230
00:13:13,880 --> 00:13:17,340
abstraction other than you want
to suppress detail for

231
00:13:17,340 --> 00:13:18,310
building bigger boxes.

232
00:13:18,310 --> 00:13:24,880
Sometimes you want to say that
your way of doing something,

233
00:13:24,880 --> 00:13:30,210
your how-to method, is an
instance of a more general

234
00:13:30,210 --> 00:13:33,430
thing, and you'd like your
language to be able to express

235
00:13:33,430 --> 00:13:35,560
that generality.

236
00:13:35,560 --> 00:13:37,800
Let me show you another example

237
00:13:37,800 --> 00:13:38,740
sticking with square roots.

238
00:13:38,740 --> 00:13:42,260
Let's go back and take another
look at that slide with the

239
00:13:42,260 --> 00:13:44,380
square root algorithm on it.

240
00:13:44,380 --> 00:13:45,460
Remember what that says.

241
00:13:45,460 --> 00:13:50,700
That says, in order to do
something, I make a guess, and

242
00:13:50,700 --> 00:13:53,800
I improve that guess,
and I sort of keep

243
00:13:53,800 --> 00:13:56,970
improving that guess.

244
00:13:56,970 --> 00:13:59,560
So there's the general strategy
of, I'm looking for

245
00:13:59,560 --> 00:14:02,440
something, and the way
I find it is that I

246
00:14:02,440 --> 00:14:04,280
keep improving it.

247
00:14:04,280 --> 00:14:10,930
Now, that's a particular case
of another kind of strategy

248
00:14:10,930 --> 00:14:14,176
for finding a fixed point
of something.

249
00:14:14,176 --> 00:14:17,660
So you have a fixed point
of a function.

250
00:14:17,660 --> 00:14:26,090
A fixed point of a function
is something, is a value.

251
00:14:26,090 --> 00:14:30,710
A fixed point of a function F is
a value Y, such that F of Y

252
00:14:30,710 --> 00:14:41,592
equals Y. And the way I might do
that is start with a guess.

253
00:14:41,592 --> 00:14:44,630
And then if I want something
that doesn't change when I

254
00:14:44,630 --> 00:14:47,800
keep applying F, is I'll keep
applying F over and over until

255
00:14:47,800 --> 00:14:50,150
that result doesn't
change very much.

256
00:14:50,150 --> 00:14:52,290
So there's a general strategy.

257
00:14:52,290 --> 00:14:56,250
And then, for example, to
compute the square root of X,

258
00:14:56,250 --> 00:15:00,780
I can try and find a fixed point
of the function which

259
00:15:00,780 --> 00:15:05,020
takes Y to the average of X/Y.
And the idea that is that if I

260
00:15:05,020 --> 00:15:09,300
really had Y equal to the square
root of X, then Y and

261
00:15:09,300 --> 00:15:12,080
X/Y would be the same value.

262
00:15:12,080 --> 00:15:16,370
They'd both be the square root
of X, because X over the

263
00:15:16,370 --> 00:15:19,080
square root of X is the
square root of X.

264
00:15:19,080 --> 00:15:23,860
And so the average if Y were
equal to the square of X, then

265
00:15:23,860 --> 00:15:26,230
the average wouldn't change.

266
00:15:26,230 --> 00:15:27,530
So the square root of X
is a fixed point of

267
00:15:27,530 --> 00:15:30,250
that particular function.

268
00:15:30,250 --> 00:15:34,010
Now, what I'd like to have,
I'd like to express the

269
00:15:34,010 --> 00:15:36,430
general strategy for finding
fixed points.

270
00:15:36,430 --> 00:15:37,210
So what I might imagine doing,
is to find, is to be able to

271
00:15:37,210 --> 00:15:37,309
use my language to define a box
that says "fixed point,"

272
00:15:37,309 --> 00:15:37,417
just like I could make a box
that says "square root." And

273
00:15:37,417 --> 00:15:38,667
I'd like to be able to express
this in my language.

274
00:15:38,667 --> 00:15:56,350


275
00:15:56,350 --> 00:16:00,870
So I'd like to express not only
the imperative how-to

276
00:16:00,870 --> 00:16:03,620
knowledge of a particular thing
like square root, but

277
00:16:03,620 --> 00:16:05,600
I'd like to be able to express
the imperative knowledge of

278
00:16:05,600 --> 00:16:09,930
how to do a general thing like
how to find fixed point.

279
00:16:09,930 --> 00:16:12,090
And in fact, let's go back and
look at that slide again.

280
00:16:12,090 --> 00:16:15,010


281
00:16:15,010 --> 00:16:23,380
See, not only is this a piece
of imperative knowledge, how

282
00:16:23,380 --> 00:16:27,190
to find a fixed point, but
over here on the bottom,

283
00:16:27,190 --> 00:16:29,890
there's another piece of
imperative knowledge which

284
00:16:29,890 --> 00:16:34,350
says, one way to compute square
root is to apply this

285
00:16:34,350 --> 00:16:36,140
general fixed point method.

286
00:16:36,140 --> 00:16:37,710
So I'd like to also
be able to express

287
00:16:37,710 --> 00:16:39,700
that imperative knowledge.

288
00:16:39,700 --> 00:16:40,650
What would that look like?

289
00:16:40,650 --> 00:16:46,010
That would say, this fixed point
box is such that if I

290
00:16:46,010 --> 00:16:56,980
input to it the function that
takes Y to the average of Y

291
00:16:56,980 --> 00:17:04,300
and X/Y, then what should come
out of that fixed point box is

292
00:17:04,300 --> 00:17:06,200
a method for finding
square roots.

293
00:17:06,200 --> 00:17:08,800


294
00:17:08,800 --> 00:17:10,829
So in these boxes we're
building, we're not only

295
00:17:10,829 --> 00:17:16,369
building boxes that you input
numbers and output numbers,

296
00:17:16,369 --> 00:17:19,410
we're going to be building in
boxes that, in effect, compute

297
00:17:19,410 --> 00:17:22,250
methods like finding
square root.

298
00:17:22,250 --> 00:17:27,480
And my take is their inputs
functions, like Y goes to the

299
00:17:27,480 --> 00:17:32,360
average of Y and X/Y. The reason
we want to do that, the

300
00:17:32,360 --> 00:17:35,425
reason this is a procedure, will
end up being a procedure,

301
00:17:35,425 --> 00:17:39,640
as we'll see, whose value is
another procedure, the reason

302
00:17:39,640 --> 00:17:42,630
we want to do that is because
procedures are going to be our

303
00:17:42,630 --> 00:17:47,960
ways of talking about imperative
knowledge.

304
00:17:47,960 --> 00:17:50,560
And the way to make that very
powerful is to be able to talk

305
00:17:50,560 --> 00:17:53,260
about other kinds
of knowledge.

306
00:17:53,260 --> 00:17:55,930
So here is a procedure that, in
effect, talks about another

307
00:17:55,930 --> 00:17:59,450
procedure, a general strategy
that itself talks about

308
00:17:59,450 --> 00:18:00,700
general strategies.

309
00:18:00,700 --> 00:18:04,290


310
00:18:04,290 --> 00:18:08,370
Well, our first topic in this
course-- there'll be three

311
00:18:08,370 --> 00:18:11,070
major topics-- will be black-box
abstraction.

312
00:18:11,070 --> 00:18:15,150
Let's look at that in a little
bit more detail.

313
00:18:15,150 --> 00:18:23,910
What we're going to do is we
will start out talking about

314
00:18:23,910 --> 00:18:27,480
how Lisp is built up out
of primitive objects.

315
00:18:27,480 --> 00:18:29,580
What does the language
supply with us?

316
00:18:29,580 --> 00:18:32,690
And we'll see that there are
primitive procedures and

317
00:18:32,690 --> 00:18:35,620
primitive data.

318
00:18:35,620 --> 00:18:38,510
Then we're going to see, how do
you take those primitives

319
00:18:38,510 --> 00:18:41,940
and combine them to make more
complicated things, means of

320
00:18:41,940 --> 00:18:42,860
combination?

321
00:18:42,860 --> 00:18:44,824
And what we'll see is that
there are ways of putting

322
00:18:44,824 --> 00:18:47,850
things together, putting
primitive procedures together

323
00:18:47,850 --> 00:18:50,960
to make more complicated
procedures.

324
00:18:50,960 --> 00:18:53,250
And we'll see how to put
primitive data together to

325
00:18:53,250 --> 00:18:55,830
make compound data.

326
00:18:55,830 --> 00:18:59,700
Then we'll say, well, having
made those compounds things,

327
00:18:59,700 --> 00:19:02,830
how do you abstract them?

328
00:19:02,830 --> 00:19:05,290
How do you put those black boxes
around them so you can

329
00:19:05,290 --> 00:19:08,090
use them as components in
more complex things?

330
00:19:08,090 --> 00:19:11,640
And we'll see that's done by
defining procedures and a

331
00:19:11,640 --> 00:19:13,740
technique for dealing with
compound data called data

332
00:19:13,740 --> 00:19:15,540
abstraction.

333
00:19:15,540 --> 00:19:19,150
And then, what's maybe the most
important thing, is going

334
00:19:19,150 --> 00:19:21,650
from just the rules to how
does an expert work?

335
00:19:21,650 --> 00:19:25,800
How do you express common
patterns of doing things, like

336
00:19:25,800 --> 00:19:28,580
saying, well, there's a general
method of fixed point

337
00:19:28,580 --> 00:19:32,822
and square root is a particular
case of that?

338
00:19:32,822 --> 00:19:34,290
And we're going to use--

339
00:19:34,290 --> 00:19:36,640
I've already hinted at it--
something called higher-order

340
00:19:36,640 --> 00:19:40,770
procedures, namely procedures
whose inputs and outputs are

341
00:19:40,770 --> 00:19:43,230
themselves procedures.

342
00:19:43,230 --> 00:19:44,900
And then we'll also see
something very interesting.

343
00:19:44,900 --> 00:19:47,730
We'll see, as we go further and
further on and become more

344
00:19:47,730 --> 00:19:50,310
abstract, there'll be very--

345
00:19:50,310 --> 00:19:53,700
well, the line between what we
consider to be data and what

346
00:19:53,700 --> 00:19:56,920
we consider to be procedures
is going to blur at an

347
00:19:56,920 --> 00:19:58,170
incredible rate.

348
00:19:58,170 --> 00:20:03,270


349
00:20:03,270 --> 00:20:06,300
Well, that's our first
subject, black-box

350
00:20:06,300 --> 00:20:07,020
abstraction.

351
00:20:07,020 --> 00:20:08,270
Let's look at the
second topic.

352
00:20:08,270 --> 00:20:10,640


353
00:20:10,640 --> 00:20:13,510
I can introduce it like this.

354
00:20:13,510 --> 00:20:19,590
See, suppose I want to
express the idea--

355
00:20:19,590 --> 00:20:22,790
remember, we're talking
about ideas--

356
00:20:22,790 --> 00:20:30,950
suppose I want to express the
idea that I can take something

357
00:20:30,950 --> 00:20:36,070
and multiply it by the sum
of two other things.

358
00:20:36,070 --> 00:20:40,180
So for example, I might say, if
I had 1 and 3 and multiply

359
00:20:40,180 --> 00:20:41,920
that by 2, I get 8.

360
00:20:41,920 --> 00:20:43,930
But I'm talking about the
general idea of what's called

361
00:20:43,930 --> 00:20:46,470
linear combination, that you
can add two things and

362
00:20:46,470 --> 00:20:49,170
multiply them by
something else.

363
00:20:49,170 --> 00:20:51,040
It's very easy when I think
about it for numbers, but

364
00:20:51,040 --> 00:20:56,060
suppose I also want to use that
same idea to think about,

365
00:20:56,060 --> 00:21:00,920
I could add two vectors, a1 and
a2, and then scale them by

366
00:21:00,920 --> 00:21:03,060
some factor x and get
another vector.

367
00:21:03,060 --> 00:21:08,570
Or I might say, I want to think
about a1 and a2 as being

368
00:21:08,570 --> 00:21:13,720
polynomials, and I might want
to add those two polynomials

369
00:21:13,720 --> 00:21:16,680
and then multiply them by 2 to
get a more complicated one.

370
00:21:16,680 --> 00:21:20,020


371
00:21:20,020 --> 00:21:24,650
Or a1 and a2 might be electrical
signals, and I

372
00:21:24,650 --> 00:21:26,870
might want to think about
summing those two electrical

373
00:21:26,870 --> 00:21:29,350
signals and then putting the
whole thing through an

374
00:21:29,350 --> 00:21:33,890
amplifier, multiplying it by
some factor of 2 or something.

375
00:21:33,890 --> 00:21:34,850
The idea is I want to
think about the

376
00:21:34,850 --> 00:21:38,530
general notion of that.

377
00:21:38,530 --> 00:21:42,880
Now, if our language is going
to be good language for

378
00:21:42,880 --> 00:21:47,960
expressing those kind of general
ideas, if I really,

379
00:21:47,960 --> 00:21:55,190
really can do that, I'd like to
be able to say I'm going to

380
00:21:55,190 --> 00:22:03,660
multiply by x the sum of a1 and
a2, and I'd like that to

381
00:22:03,660 --> 00:22:07,470
express the general idea of all
different kinds of things

382
00:22:07,470 --> 00:22:09,980
that a1 and a2 could be.

383
00:22:09,980 --> 00:22:11,690
Now, if you think about that,
there's a problem, because

384
00:22:11,690 --> 00:22:16,370
after all, the actual primitive
operations that go

385
00:22:16,370 --> 00:22:17,870
on in the machine are obviously
going to be

386
00:22:17,870 --> 00:22:22,070
different if I'm adding two
numbers than if I'm adding two

387
00:22:22,070 --> 00:22:25,790
polynomials, or if I'm adding
the representation of two

388
00:22:25,790 --> 00:22:27,940
electrical signals
or wave forms.

389
00:22:27,940 --> 00:22:30,950
Somewhere, there has to be the
knowledge of the kinds of

390
00:22:30,950 --> 00:22:33,140
various things that you
can add and the

391
00:22:33,140 --> 00:22:34,390
ways of adding them.

392
00:22:34,390 --> 00:22:37,110


393
00:22:37,110 --> 00:22:39,430
Now, to construct such a system,
the question is, where

394
00:22:39,430 --> 00:22:41,090
do I put that knowledge?

395
00:22:41,090 --> 00:22:43,280
How do I think about
the different kinds

396
00:22:43,280 --> 00:22:44,480
of choices I have?

397
00:22:44,480 --> 00:22:48,310
And if tomorrow George comes up
with a new kind of object

398
00:22:48,310 --> 00:22:51,770
that might be added and
multiplied, how do I add

399
00:22:51,770 --> 00:22:54,280
George's new object to the
system without screwing up

400
00:22:54,280 --> 00:22:57,690
everything that was
already there?

401
00:22:57,690 --> 00:23:00,790
Well, that's going to be the
second big topic, the way of

402
00:23:00,790 --> 00:23:03,720
controlling that kind
of complexity.

403
00:23:03,720 --> 00:23:07,480
And the way you do that is by
establishing conventional

404
00:23:07,480 --> 00:23:20,230
interfaces, agreed upon ways of
plugging things together.

405
00:23:20,230 --> 00:23:23,530
Just like in electrical
engineering, people have

406
00:23:23,530 --> 00:23:26,520
standard impedances for
connectors, and then you know

407
00:23:26,520 --> 00:23:28,080
if you build something with
one of those standard

408
00:23:28,080 --> 00:23:30,160
impedances, you can plug it
together with something else.

409
00:23:30,160 --> 00:23:32,720


410
00:23:32,720 --> 00:23:34,300
So that's going to be our
second large topic,

411
00:23:34,300 --> 00:23:35,690
conventional interfaces.

412
00:23:35,690 --> 00:23:39,000
What we're going to see is,
first, we're going to talk

413
00:23:39,000 --> 00:23:41,400
about the problem of generic
operations, which is the one I

414
00:23:41,400 --> 00:23:46,100
alluded to, things like "plus"
that have to work with all

415
00:23:46,100 --> 00:23:47,350
different kinds of data.

416
00:23:47,350 --> 00:23:52,149


417
00:23:52,149 --> 00:23:54,660
So we talk about generic
operations.

418
00:23:54,660 --> 00:23:58,270
Then we're going to talk about
really large-scale structures.

419
00:23:58,270 --> 00:24:01,820
How do you put together very
large programs that model the

420
00:24:01,820 --> 00:24:03,880
kinds of complex systems
in the real world that

421
00:24:03,880 --> 00:24:05,480
you'd like to model?

422
00:24:05,480 --> 00:24:08,990
And what we're going to see
is that there are two very

423
00:24:08,990 --> 00:24:11,770
important metaphors for putting
together such systems.

424
00:24:11,770 --> 00:24:14,730
One is called object-oriented
programming, where you sort of

425
00:24:14,730 --> 00:24:19,840
think of your system as a kind
of society full of little

426
00:24:19,840 --> 00:24:21,150
things that interact by sending

427
00:24:21,150 --> 00:24:23,300
information between them.

428
00:24:23,300 --> 00:24:26,540
And then the second one is
operations on aggregates,

429
00:24:26,540 --> 00:24:29,820
called streams, where you think
of a large system put

430
00:24:29,820 --> 00:24:33,530
together kind of like a signal
processing engineer puts

431
00:24:33,530 --> 00:24:35,020
together a large electrical
system.

432
00:24:35,020 --> 00:24:38,610


433
00:24:38,610 --> 00:24:40,240
That's going to be
our second topic.

434
00:24:40,240 --> 00:24:43,370


435
00:24:43,370 --> 00:24:47,000
Now, the third thing we're going
to come to, the third

436
00:24:47,000 --> 00:24:49,640
basic technique for controlling
complexity, is

437
00:24:49,640 --> 00:24:51,680
making new languages.

438
00:24:51,680 --> 00:24:54,370
Because sometimes, when you're
sort of overwhelmed by the

439
00:24:54,370 --> 00:24:56,640
complexity of a design, the
way that you control that

440
00:24:56,640 --> 00:25:01,330
complexity is to pick a
new design language.

441
00:25:01,330 --> 00:25:03,330
And the purpose of the new
design language will be to

442
00:25:03,330 --> 00:25:05,730
highlight different aspects
of the system.

443
00:25:05,730 --> 00:25:08,360
It will suppress some kinds of
details and emphasize other

444
00:25:08,360 --> 00:25:09,610
kinds of details.

445
00:25:09,610 --> 00:25:12,910


446
00:25:12,910 --> 00:25:15,910
This is going to be the most
magical part of the course.

447
00:25:15,910 --> 00:25:18,350
We're going to start out by
actually looking at the

448
00:25:18,350 --> 00:25:21,730
technology for building new
computer languages.

449
00:25:21,730 --> 00:25:25,770
The first thing we're going to
do is actually build in Lisp.

450
00:25:25,770 --> 00:25:29,210


451
00:25:29,210 --> 00:25:32,940
We're going to express in Lisp
the process of interpreting

452
00:25:32,940 --> 00:25:33,800
Lisp itself.

453
00:25:33,800 --> 00:25:36,840
And that's going to be a very
sort of self-circular thing.

454
00:25:36,840 --> 00:25:38,870
There's a little mystical
symbol that

455
00:25:38,870 --> 00:25:40,750
has to do with that.

456
00:25:40,750 --> 00:25:45,500
The process of interpreting Lisp
is sort of a giant wheel

457
00:25:45,500 --> 00:25:49,150
of two processes, apply and
eval, which sort of constantly

458
00:25:49,150 --> 00:25:52,031
reduce expressions
to each other.

459
00:25:52,031 --> 00:25:54,150
Then we're going to see all
sorts of other magical things.

460
00:25:54,150 --> 00:25:56,690
Here's another magical symbol.

461
00:25:56,690 --> 00:25:59,870


462
00:25:59,870 --> 00:26:02,260
This is sort of the Y operator,
which is, in some

463
00:26:02,260 --> 00:26:04,800
sense, the expression
of infinity inside

464
00:26:04,800 --> 00:26:06,390
our procedural language.

465
00:26:06,390 --> 00:26:08,610
We'll take a look at that.

466
00:26:08,610 --> 00:26:11,880
In any case, this section
of the course is called

467
00:26:11,880 --> 00:26:24,270
Metalinguistic Abstraction,
abstracting by talking about

468
00:26:24,270 --> 00:26:25,535
how you construct
new languages.

469
00:26:25,535 --> 00:26:30,270


470
00:26:30,270 --> 00:26:34,140
As I said, we're going to start
out by looking at the

471
00:26:34,140 --> 00:26:35,530
process of interpretation.

472
00:26:35,530 --> 00:26:38,270
We're going to look
at this apply-eval

473
00:26:38,270 --> 00:26:41,980
loop, and build Lisp.

474
00:26:41,980 --> 00:26:44,450
Then, just to show you that this
is very general, we're

475
00:26:44,450 --> 00:26:47,100
going to use exactly the same
technology to build a very

476
00:26:47,100 --> 00:26:49,780
different kind of language, a
so-called logic programming

477
00:26:49,780 --> 00:26:52,880
language, where you don't really
talk about procedures

478
00:26:52,880 --> 00:26:54,560
at all that have inputs
and outputs.

479
00:26:54,560 --> 00:26:57,290
What you do is talk about
relations between things.

480
00:26:57,290 --> 00:27:01,220
And then finally, we're going
to talk about how you

481
00:27:01,220 --> 00:27:04,140
implement these things very
concretely on the very

482
00:27:04,140 --> 00:27:06,830
simplest kind of machines.

483
00:27:06,830 --> 00:27:09,860
We'll see something like this.

484
00:27:09,860 --> 00:27:14,880
This is a picture of a chip,
which is the Lisp interpreter

485
00:27:14,880 --> 00:27:17,330
that we will be talking about
then in hardware.

486
00:27:17,330 --> 00:27:21,010


487
00:27:21,010 --> 00:27:24,840
Well, there's an outline of the
course, three big topics.

488
00:27:24,840 --> 00:27:28,120
Black-box abstraction,
conventional interfaces,

489
00:27:28,120 --> 00:27:31,590
metalinguistic abstraction.

490
00:27:31,590 --> 00:27:33,480
Now, let's take a break now and
then we'll get started.

491
00:27:33,480 --> 00:28:04,770
[MUSIC PLAYING]

492
00:28:04,770 --> 00:28:08,020
Let's actually start in
learning Lisp now.

493
00:28:08,020 --> 00:28:10,250
Actually, we'll start out by
learning something much more

494
00:28:10,250 --> 00:28:12,320
important, maybe the very most
important thing in this

495
00:28:12,320 --> 00:28:16,220
course, which is not Lisp, in
particular, of course, but

496
00:28:16,220 --> 00:28:20,320
rather a general framework for
thinking about languages that

497
00:28:20,320 --> 00:28:21,970
I already alluded to.

498
00:28:21,970 --> 00:28:24,420
When somebody tells you they're
going to show you a

499
00:28:24,420 --> 00:28:27,150
language, what you should say
is, what I'd like you to tell

500
00:28:27,150 --> 00:28:32,510
me is what are the primitive
elements?

501
00:28:32,510 --> 00:28:37,490


502
00:28:37,490 --> 00:28:38,930
What does the language
come with?

503
00:28:38,930 --> 00:28:43,650
Then, what are the ways you
put those together?

504
00:28:43,650 --> 00:28:46,720
What are the means
of combination?

505
00:28:46,720 --> 00:28:50,190


506
00:28:50,190 --> 00:28:53,400
What are the things that allow
you to take these primitive

507
00:28:53,400 --> 00:28:57,920
elements and build bigger
things out of them?

508
00:28:57,920 --> 00:29:01,280
What are the ways of putting
things together?

509
00:29:01,280 --> 00:29:04,890
And then, what are the
means of abstraction?

510
00:29:04,890 --> 00:29:08,110


511
00:29:08,110 --> 00:29:15,830
How do we take those complicated
things and draw

512
00:29:15,830 --> 00:29:16,750
those boxes around them?

513
00:29:16,750 --> 00:29:20,180
How do we name them so that we
can now use them as if they

514
00:29:20,180 --> 00:29:22,810
were primitive elements
in making still

515
00:29:22,810 --> 00:29:23,790
more complex things?

516
00:29:23,790 --> 00:29:26,850
And so on, and so
on, and so on.

517
00:29:26,850 --> 00:29:28,580
So when someone says to you,
gee, I have a great new

518
00:29:28,580 --> 00:29:32,900
computer language, you don't
say, how many characters does

519
00:29:32,900 --> 00:29:35,810
it take to invert a matrix?

520
00:29:35,810 --> 00:29:37,460
It's irrelevant.

521
00:29:37,460 --> 00:29:41,220
What you say is, if the language
did not come with

522
00:29:41,220 --> 00:29:43,470
matrices built in or with
something else built in, how

523
00:29:43,470 --> 00:29:45,910
could I then build that thing?

524
00:29:45,910 --> 00:29:47,590
What are the means of
combination which would allow

525
00:29:47,590 --> 00:29:48,610
me to do that?

526
00:29:48,610 --> 00:29:52,450
And then, what are the means of
abstraction which allow me

527
00:29:52,450 --> 00:29:55,750
then to use those as elements
in making more complicated

528
00:29:55,750 --> 00:29:57,000
things yet?

529
00:29:57,000 --> 00:29:58,960


530
00:29:58,960 --> 00:30:02,330
Well, we're going to see that
Lisp has some primitive data

531
00:30:02,330 --> 00:30:05,280
and some primitive procedures.

532
00:30:05,280 --> 00:30:08,410
In fact, let's really start.

533
00:30:08,410 --> 00:30:09,950
And here's a piece of
primitive data in

534
00:30:09,950 --> 00:30:16,710
Lisp, number 3.

535
00:30:16,710 --> 00:30:18,800
Actually, if I'm being
very pedantic, that's

536
00:30:18,800 --> 00:30:19,790
not the number 3.

537
00:30:19,790 --> 00:30:24,620
That's some symbol that
represents Plato's concept of

538
00:30:24,620 --> 00:30:27,060
the number 3.

539
00:30:27,060 --> 00:30:30,500
And here's another.

540
00:30:30,500 --> 00:30:35,370
Here's some more primitive
data in Lisp, 17.4.

541
00:30:35,370 --> 00:30:40,940
Or actually, some representation
of 17.4.

542
00:30:40,940 --> 00:30:43,795
And here's another one, 5.

543
00:30:43,795 --> 00:30:46,750


544
00:30:46,750 --> 00:30:48,490
Here's another primitive
object that's

545
00:30:48,490 --> 00:30:52,130
built in Lisp, addition.

546
00:30:52,130 --> 00:30:56,830
Actually, to use the same kind
of pedantic-- this is a name

547
00:30:56,830 --> 00:31:00,140
for the primitive method
of adding things.

548
00:31:00,140 --> 00:31:02,920
Just like this is a name for
Plato's number 3, this is a

549
00:31:02,920 --> 00:31:10,370
name for Plato's concept
of how you add things.

550
00:31:10,370 --> 00:31:12,370
So those are some primitive
elements.

551
00:31:12,370 --> 00:31:14,090
I can put them together.

552
00:31:14,090 --> 00:31:18,140
I can say, gee, what's the
sum of 3 and 17.4 and 5?

553
00:31:18,140 --> 00:31:25,580
And the way I do that is to
say, let's apply the sum

554
00:31:25,580 --> 00:31:27,600
operator to these
three numbers.

555
00:31:27,600 --> 00:31:28,310
And I should get, what?

556
00:31:28,310 --> 00:31:29,690
8, 17.

557
00:31:29,690 --> 00:31:34,390
25.4.

558
00:31:34,390 --> 00:31:37,590
So I should be able to ask Lisp
what the value of this

559
00:31:37,590 --> 00:31:43,050
is, and it will return 25.4.

560
00:31:43,050 --> 00:31:44,610
Let's introduce some names.

561
00:31:44,610 --> 00:31:50,950
This thing that I typed is
called a combination.

562
00:31:50,950 --> 00:31:56,830


563
00:31:56,830 --> 00:31:59,040
And a combination consists,
in general,

564
00:31:59,040 --> 00:32:02,790
of applying an operator--

565
00:32:02,790 --> 00:32:04,220
so this is an operator--

566
00:32:04,220 --> 00:32:09,500


567
00:32:09,500 --> 00:32:13,190
to some operands.

568
00:32:13,190 --> 00:32:14,440
These are the operands.

569
00:32:14,440 --> 00:32:21,760


570
00:32:21,760 --> 00:32:23,640
And of course, I can make
more complex things.

571
00:32:23,640 --> 00:32:25,950
The reason I can get complexity
out of this is

572
00:32:25,950 --> 00:32:30,290
because the operands themselves,
in general, can be

573
00:32:30,290 --> 00:32:31,200
combinations.

574
00:32:31,200 --> 00:32:37,770
So for instance, I could say,
what is the sum of 3 and the

575
00:32:37,770 --> 00:32:45,660
product of 5 and
6 and 8 and 2?

576
00:32:45,660 --> 00:32:47,520
And I should get-- let's see--

577
00:32:47,520 --> 00:32:52,355
30, 40, 43.

578
00:32:52,355 --> 00:32:56,520
So Lisp should tell
me that that's 43.

579
00:32:56,520 --> 00:33:01,610
Forming combinations is the
basic needs of combination

580
00:33:01,610 --> 00:33:04,690
that we'll be looking at.

581
00:33:04,690 --> 00:33:10,520
And then, well, you see
some syntax here.

582
00:33:10,520 --> 00:33:16,940
Lisp uses what's called prefix
notation, which means that the

583
00:33:16,940 --> 00:33:25,400
operator is written to the
left of the operands.

584
00:33:25,400 --> 00:33:27,810
It's just a convention.

585
00:33:27,810 --> 00:33:29,960
And notice, it's fully
parenthesized.

586
00:33:29,960 --> 00:33:32,170
And the parentheses make it
completely unambiguous.

587
00:33:32,170 --> 00:33:36,840
So by looking at this, I can see
that there's the operator,

588
00:33:36,840 --> 00:33:42,760
and there are 1, 2,
3, 4 operands.

589
00:33:42,760 --> 00:33:46,980
And I can see that the second
operand here is itself some

590
00:33:46,980 --> 00:33:52,500
combination that has one
operator and two operands.

591
00:33:52,500 --> 00:33:55,740
Parentheses in Lisp are a little
bit, or are very unlike

592
00:33:55,740 --> 00:33:57,630
parentheses in conventional
mathematics.

593
00:33:57,630 --> 00:34:01,400
In mathematics, we sort of use
them to mean grouping, and it

594
00:34:01,400 --> 00:34:03,140
sort of doesn't hurt if
sometimes you leave out

595
00:34:03,140 --> 00:34:04,610
parentheses if people
understand

596
00:34:04,610 --> 00:34:05,790
that that's a group.

597
00:34:05,790 --> 00:34:07,660
And in general, it doesn't
hurt if you put in extra

598
00:34:07,660 --> 00:34:09,760
parentheses, because that
maybe makes the

599
00:34:09,760 --> 00:34:10,570
grouping more distinct.

600
00:34:10,570 --> 00:34:13,010
Lisp is not like that.

601
00:34:13,010 --> 00:34:17,020
In Lisp, you cannot leave out
parentheses, and you cannot

602
00:34:17,020 --> 00:34:20,530
put in extra parentheses,
because putting in parentheses

603
00:34:20,530 --> 00:34:23,980
always means, exactly and
precisely, this is a

604
00:34:23,980 --> 00:34:27,260
combination which has
meaning, applying

605
00:34:27,260 --> 00:34:29,050
operators to operands.

606
00:34:29,050 --> 00:34:32,290
And if I left this out, if I
left those parentheses out, it

607
00:34:32,290 --> 00:34:35,469
would mean something else.

608
00:34:35,469 --> 00:34:38,100
In fact, the way to think about
this, is really what I'm

609
00:34:38,100 --> 00:34:42,280
doing when I write something
like this is writing a tree.

610
00:34:42,280 --> 00:34:48,909
So this combination is a tree
that has a plus and then a 3

611
00:34:48,909 --> 00:34:54,500
and then a something else
and an 8 and a 2.

612
00:34:54,500 --> 00:34:57,670
And then this something else
here is itself a little

613
00:34:57,670 --> 00:35:03,770
subtree that has a star
and a 5 and a 6.

614
00:35:03,770 --> 00:35:07,400
And the way to think of that
is, really, what's going on

615
00:35:07,400 --> 00:35:13,260
are we're writing these trees,
and parentheses are just a way

616
00:35:13,260 --> 00:35:16,390
to write this two-dimensional
structure as a linear

617
00:35:16,390 --> 00:35:19,130
character string.

618
00:35:19,130 --> 00:35:22,110
Because at least when Lisp first
started and people had

619
00:35:22,110 --> 00:35:24,630
teletypes or punch cards or
whatever, this was more

620
00:35:24,630 --> 00:35:25,890
convenient.

621
00:35:25,890 --> 00:35:29,590
Maybe if Lisp started today,
the syntax of Lisp

622
00:35:29,590 --> 00:35:31,900
would look like that.

623
00:35:31,900 --> 00:35:33,720
Well, let's look at
what that actually

624
00:35:33,720 --> 00:35:36,450
looks like on the computer.

625
00:35:36,450 --> 00:35:39,320
Here I have a Lisp interaction
set up.

626
00:35:39,320 --> 00:35:41,060
There's a editor.

627
00:35:41,060 --> 00:35:43,980
And on the top, I'm going to
type some values and ask Lisp

628
00:35:43,980 --> 00:35:45,050
what they are.

629
00:35:45,050 --> 00:35:46,750
So for instance, I can say
to Lisp, what's the

630
00:35:46,750 --> 00:35:49,370
value of that symbol?

631
00:35:49,370 --> 00:35:50,050
That's 3.

632
00:35:50,050 --> 00:35:51,850
And I ask Lisp to evaluate it.

633
00:35:51,850 --> 00:35:55,530
And there you see Lisp has
returned on the bottom, and

634
00:35:55,530 --> 00:35:57,690
said, oh yeah, that's 3.

635
00:35:57,690 --> 00:36:06,490
Or I can say, what's the
sum of 3 and 4 and 8?

636
00:36:06,490 --> 00:36:08,950
What's that combination?

637
00:36:08,950 --> 00:36:10,660
And ask Lisp to evaluate it.

638
00:36:10,660 --> 00:36:14,660


639
00:36:14,660 --> 00:36:16,246
That's 15.

640
00:36:16,246 --> 00:36:19,210
Or I can type in something
more complicated.

641
00:36:19,210 --> 00:36:29,510
I can say, what's the sum of the
product of 3 and the sum

642
00:36:29,510 --> 00:36:35,210
of 7 and 19.5?

643
00:36:35,210 --> 00:36:37,820
And you'll notice here that Lisp
has something built in

644
00:36:37,820 --> 00:36:39,660
that helps me keep track of
all these parentheses.

645
00:36:39,660 --> 00:36:42,260
Watch as I type the next closed
parentheses, which is

646
00:36:42,260 --> 00:36:45,620
going to close the combination
starting with the star.

647
00:36:45,620 --> 00:36:48,220
The opening one will flash.

648
00:36:48,220 --> 00:36:50,200
Here, I'll rub those out
and do it again.

649
00:36:50,200 --> 00:36:53,590
Type close, and you see
that closes the plus.

650
00:36:53,590 --> 00:36:57,910
Close again, that
closes the star.

651
00:36:57,910 --> 00:36:59,570
Now I'm back to the sum,
and maybe I'm going to

652
00:36:59,570 --> 00:37:01,480
add that all to 4.

653
00:37:01,480 --> 00:37:02,630
That closes the plus.

654
00:37:02,630 --> 00:37:05,750
Now I have a complete
combination, and I can ask

655
00:37:05,750 --> 00:37:07,170
Lisp for the value of that.

656
00:37:07,170 --> 00:37:11,310
That kind of paren balancing is
something that's built into

657
00:37:11,310 --> 00:37:13,630
a lot of Lisp systems to help
you keep track, because it is

658
00:37:13,630 --> 00:37:16,760
kind of hard just by hand doing
all these parentheses.

659
00:37:16,760 --> 00:37:20,520
There's another kind of
convention for keeping track

660
00:37:20,520 --> 00:37:21,100
of parentheses.

661
00:37:21,100 --> 00:37:24,800
Let me write another complicated
combination.

662
00:37:24,800 --> 00:37:33,170
Let's take the sum of the
product of 3 and 5 and add

663
00:37:33,170 --> 00:37:34,090
that to something.

664
00:37:34,090 --> 00:37:37,510
And now what I'm going to do is
I'm going to indent so that

665
00:37:37,510 --> 00:37:39,830
the operands are written
vertically.

666
00:37:39,830 --> 00:37:47,250
Which the sum of that and
the product of 47 and--

667
00:37:47,250 --> 00:37:50,340
let's say the product
of 47 with a

668
00:37:50,340 --> 00:37:54,520
difference of 20 and 6.8.

669
00:37:54,520 --> 00:37:58,236
That means subtract
6.8 from 20.

670
00:37:58,236 --> 00:38:00,050
And then you see the
parentheses close.

671
00:38:00,050 --> 00:38:01,890
Close the minus.

672
00:38:01,890 --> 00:38:03,572
Close the star.

673
00:38:03,572 --> 00:38:05,150
And now let's get another
operator.

674
00:38:05,150 --> 00:38:08,230
You see the Lisp editor here
is indenting to the right

675
00:38:08,230 --> 00:38:12,660
position automatically to
help me keep track.

676
00:38:12,660 --> 00:38:13,920
I'll do that again.

677
00:38:13,920 --> 00:38:16,220
I'll close that last
parentheses again.

678
00:38:16,220 --> 00:38:17,470
You see it balances the plus.

679
00:38:17,470 --> 00:38:20,340


680
00:38:20,340 --> 00:38:24,100
Now I can say, what's
the value of that?

681
00:38:24,100 --> 00:38:29,620
So those two things, indenting
to the right level, which is

682
00:38:29,620 --> 00:38:34,230
called pretty printing, and
flashing parentheses, are two

683
00:38:34,230 --> 00:38:37,120
things that a lot of Lisp
systems have built in to help

684
00:38:37,120 --> 00:38:37,660
you keep track.

685
00:38:37,660 --> 00:38:38,910
And you should learn
how to use them.

686
00:38:38,910 --> 00:38:42,020


687
00:38:42,020 --> 00:38:44,640
Well, those are the
primitives.

688
00:38:44,640 --> 00:38:46,190
There's a means of
combination.

689
00:38:46,190 --> 00:38:49,360
Now let's go up to the
means of abstraction.

690
00:38:49,360 --> 00:38:52,400
I'd like to be able to take
the idea that I do some

691
00:38:52,400 --> 00:38:54,820
combination like this, and
abstract it and give it a

692
00:38:54,820 --> 00:38:57,300
simple name, so I can use
that as an element.

693
00:38:57,300 --> 00:39:01,770
And I do that in Lisp with
"define." So I can say, for

694
00:39:01,770 --> 00:39:14,515
example, define A to be the
product of 5 and 5.

695
00:39:14,515 --> 00:39:17,936


696
00:39:17,936 --> 00:39:23,240
And now I could say, for
example, to Lisp, what is the

697
00:39:23,240 --> 00:39:26,742
product of A and A?

698
00:39:26,742 --> 00:39:31,980
And this should be 25, and
this should be 625.

699
00:39:31,980 --> 00:39:36,200
And then, crucial thing,
I can now use A--

700
00:39:36,200 --> 00:39:38,360
here I've used it in
a combination--

701
00:39:38,360 --> 00:39:41,770
but I could use that in other
more complicated things that I

702
00:39:41,770 --> 00:39:43,440
name in turn.

703
00:39:43,440 --> 00:39:53,970
So I could say, define B to be
the sum of, we'll say, A and

704
00:39:53,970 --> 00:40:00,260
the product of 5 and A. And
then close the plus.

705
00:40:00,260 --> 00:40:03,470


706
00:40:03,470 --> 00:40:04,920
Let's take a look at that
on the computer and

707
00:40:04,920 --> 00:40:07,850
see how that looks.

708
00:40:07,850 --> 00:40:10,515
So I'll just type what
I wrote on the board.

709
00:40:10,515 --> 00:40:21,165
I could say, define A to be
the product of 5 and 5.

710
00:40:21,165 --> 00:40:23,675


711
00:40:23,675 --> 00:40:25,640
And I'll tell that to Lisp.

712
00:40:25,640 --> 00:40:27,320
And notice what Lisp responded
there with

713
00:40:27,320 --> 00:40:29,120
was an A in the bottom.

714
00:40:29,120 --> 00:40:31,680
In general, when you type in
a definition in Lisp, it

715
00:40:31,680 --> 00:40:35,180
responds with the symbol
being defined.

716
00:40:35,180 --> 00:40:39,200
Now I could say to Lisp, what
is the product of A and A?

717
00:40:39,200 --> 00:40:42,266


718
00:40:42,266 --> 00:40:46,140
And it says that's 625.

719
00:40:46,140 --> 00:40:59,790
I can define B to be the sum of
A and the product of 5 and

720
00:40:59,790 --> 00:41:03,110
A. Close a paren closes
the star.

721
00:41:03,110 --> 00:41:04,600
Close the plus.

722
00:41:04,600 --> 00:41:11,030
Close the "define." Lisp says,
OK, B, there on the bottom.

723
00:41:11,030 --> 00:41:13,110
And now I can say to Lisp,
what's the value of B?

724
00:41:13,110 --> 00:41:17,100


725
00:41:17,100 --> 00:41:19,310
And I can say something more
complicated, like what's the

726
00:41:19,310 --> 00:41:26,600
sum of A and the quotient
of B and 5?

727
00:41:26,600 --> 00:41:30,430
That slash is divide, another
primitive operator.

728
00:41:30,430 --> 00:41:33,830
I've divided B by 5,
added it to A. Lisp

729
00:41:33,830 --> 00:41:36,830
says, OK, that's 55.

730
00:41:36,830 --> 00:41:39,810
So there's what it looks like.

731
00:41:39,810 --> 00:41:43,670
There's the basic means
of defining something.

732
00:41:43,670 --> 00:41:47,870
It's the simplest kind of
naming, but it's not really

733
00:41:47,870 --> 00:41:49,970
very powerful.

734
00:41:49,970 --> 00:41:51,760
See, what I'd really
like to name--

735
00:41:51,760 --> 00:41:53,510
remember, we're talking about
general methods--

736
00:41:53,510 --> 00:41:56,810
I'd like to name, oh, the
general idea that, for

737
00:41:56,810 --> 00:42:11,440
example, I could multiply 5 by
5, or 6 by 6, or 1,001 by

738
00:42:11,440 --> 00:42:18,240
1,001, 1,001.7 by 1,001.7.

739
00:42:18,240 --> 00:42:22,350
I'd like to be able to name
the general idea of

740
00:42:22,350 --> 00:42:23,970
multiplying something
by itself.

741
00:42:23,970 --> 00:42:28,400


742
00:42:28,400 --> 00:42:28,960
Well, you know what that is.

743
00:42:28,960 --> 00:42:31,146
That's called squaring.

744
00:42:31,146 --> 00:42:43,640
And the way I can do that in
Lisp is I can say, define to

745
00:42:43,640 --> 00:42:57,850
square something x, multiply
x by itself.

746
00:42:57,850 --> 00:43:01,260
And then having done that,
I could say to Lisp, for

747
00:43:01,260 --> 00:43:06,240
example, what's the
square of 10?

748
00:43:06,240 --> 00:43:10,240
And Lisp will say 100.

749
00:43:10,240 --> 00:43:14,796
So now let's actually look at
that a little more closely.

750
00:43:14,796 --> 00:43:17,040
Right, there's the definition
of square.

751
00:43:17,040 --> 00:43:23,730
To square something, multiply
it by itself.

752
00:43:23,730 --> 00:43:26,210
You see this x here.

753
00:43:26,210 --> 00:43:28,550
That x is kind of a pronoun,
which is the something that

754
00:43:28,550 --> 00:43:31,380
I'm going to square.

755
00:43:31,380 --> 00:43:35,220
And what I do with it
is I multiply x, I

756
00:43:35,220 --> 00:43:36,930
multiply it by itself.

757
00:43:36,930 --> 00:43:44,670


758
00:43:44,670 --> 00:43:44,775
OK.

759
00:43:44,775 --> 00:43:48,280
So there's the notation for
defining a procedure.

760
00:43:48,280 --> 00:43:52,500
Actually, this is a little bit
confusing, because this is

761
00:43:52,500 --> 00:43:53,830
sort of how I might
use square.

762
00:43:53,830 --> 00:43:57,790
And I say square root of x or
square root of 10, but it's

763
00:43:57,790 --> 00:44:00,300
not making it very clear that
I'm actually naming something.

764
00:44:00,300 --> 00:44:02,970


765
00:44:02,970 --> 00:44:05,790
So let me write this definition
in another way that

766
00:44:05,790 --> 00:44:06,770
makes it a little
bit more clear

767
00:44:06,770 --> 00:44:08,420
that I'm naming something.

768
00:44:08,420 --> 00:44:28,250
I'll say, "define" square to
be lambda of x times xx.

769
00:44:28,250 --> 00:44:36,550


770
00:44:36,550 --> 00:44:40,480
Here, I'm naming something
square, just like over here,

771
00:44:40,480 --> 00:44:44,390
I'm naming something A. The
thing that I'm naming square--

772
00:44:44,390 --> 00:44:49,290
here, the thing I named A was
the value of this combination.

773
00:44:49,290 --> 00:44:52,270
Here, the thing that I'm naming
square is this thing

774
00:44:52,270 --> 00:44:55,610
that begins with lambda, and
lambda is Lisp's way of saying

775
00:44:55,610 --> 00:44:56,860
make a procedure.

776
00:44:56,860 --> 00:45:00,150


777
00:45:00,150 --> 00:45:04,170
Let's look at that more
closely on the slide.

778
00:45:04,170 --> 00:45:07,410
The way I read that definition
is to say, I define square to

779
00:45:07,410 --> 00:45:09,910
be make a procedure--

780
00:45:09,910 --> 00:45:12,730


781
00:45:12,730 --> 00:45:14,010
that's what the lambda is--

782
00:45:14,010 --> 00:45:19,220
make a procedure with
an argument named x.

783
00:45:19,220 --> 00:45:22,030
And what it does is return
the results of

784
00:45:22,030 --> 00:45:24,920
multiplying x by itself.

785
00:45:24,920 --> 00:45:32,380
Now, in general, we're going to
be using this top form of

786
00:45:32,380 --> 00:45:35,050
defining, just because it's a
little bit more convenient.

787
00:45:35,050 --> 00:45:38,750
But don't lose sight of the fact
that it's really this.

788
00:45:38,750 --> 00:45:41,530
In fact, as far as the Lisp
interpreter's concerned,

789
00:45:41,530 --> 00:45:44,830
there's no difference between
typing this to it and typing

790
00:45:44,830 --> 00:45:46,460
this to it.

791
00:45:46,460 --> 00:45:54,380
And there's a word for that,
sort of syntactic sugar.

792
00:45:54,380 --> 00:45:58,400
What syntactic sugar means,
it's having somewhat more

793
00:45:58,400 --> 00:46:01,060
convenient surface forms
for typing something.

794
00:46:01,060 --> 00:46:04,470
So this is just really syntactic
sugar for this

795
00:46:04,470 --> 00:46:07,310
underlying Greek thing
with the lambda.

796
00:46:07,310 --> 00:46:09,710
And the reason you should
remember that is don't forget

797
00:46:09,710 --> 00:46:12,430
that, when I write something
like this, I'm

798
00:46:12,430 --> 00:46:14,380
really naming something.

799
00:46:14,380 --> 00:46:17,040
I'm naming something square,
and the something that I'm

800
00:46:17,040 --> 00:46:21,620
naming square is a procedure
that's getting constructed.

801
00:46:21,620 --> 00:46:24,820
Well, let's look at that
on the computer, too.

802
00:46:24,820 --> 00:46:30,660
So I'll come and I'll say,
define square of

803
00:46:30,660 --> 00:46:34,670
x to be times xx.

804
00:46:34,670 --> 00:46:49,570


805
00:46:49,570 --> 00:46:53,042
Now I'll tell Lisp that.

806
00:46:53,042 --> 00:46:56,580
It says "square." See, I've
named something "square." Now,

807
00:46:56,580 --> 00:47:00,760
having done that, I can
ask Lisp for, what's

808
00:47:00,760 --> 00:47:05,230
the square of 1,001?

809
00:47:05,230 --> 00:47:14,920
Or in general, I could say,
what's the square of the sum

810
00:47:14,920 --> 00:47:17,340
of 5 and 7?

811
00:47:17,340 --> 00:47:22,532


812
00:47:22,532 --> 00:47:25,190
The square of 12's 144.

813
00:47:25,190 --> 00:47:28,080
Or I can use square itself
as an element in some

814
00:47:28,080 --> 00:47:28,680
combination.

815
00:47:28,680 --> 00:47:36,240
I can say, what's the sum
of the square of 3 and

816
00:47:36,240 --> 00:47:37,490
the square of 4?

817
00:47:37,490 --> 00:47:42,480


818
00:47:42,480 --> 00:47:44,950
9 and 16 is 25.

819
00:47:44,950 --> 00:47:49,580
Or I can use square as an
element in some much more

820
00:47:49,580 --> 00:47:50,390
complicated thing.

821
00:47:50,390 --> 00:47:53,032
I can say, what's the square
of, the sqare of,

822
00:47:53,032 --> 00:48:07,016
the square of 1,001?

823
00:48:07,016 --> 00:48:11,160
And there's the square of the
square of the square of 1,001.

824
00:48:11,160 --> 00:48:15,620
Or I can say to Lisp, what
is square itself?

825
00:48:15,620 --> 00:48:17,040
What's the value of that?

826
00:48:17,040 --> 00:48:21,040
And Lisp returns some
conventional way of telling me

827
00:48:21,040 --> 00:48:22,200
that that's a procedure.

828
00:48:22,200 --> 00:48:24,990
It says, "compound procedure
square." Remember, the value

829
00:48:24,990 --> 00:48:30,050
of square is this procedure, and
the thing with the stars

830
00:48:30,050 --> 00:48:33,810
and the brackets are just Lisp's
conventional way of

831
00:48:33,810 --> 00:48:37,010
describing that.

832
00:48:37,010 --> 00:48:40,830
Let's look at two more
examples of defining.

833
00:48:40,830 --> 00:48:45,020


834
00:48:45,020 --> 00:48:47,210
Here are two more procedures.

835
00:48:47,210 --> 00:48:51,860
I can define the average of x
and y to be the sum of x and y

836
00:48:51,860 --> 00:48:54,460
divided by 2.

837
00:48:54,460 --> 00:49:00,830
Or having had average and mean
square, having had average and

838
00:49:00,830 --> 00:49:03,970
square, I can use that to talk
about the mean square of

839
00:49:03,970 --> 00:49:08,325
something, which is the average
of the square of x and

840
00:49:08,325 --> 00:49:10,790
the square of y.

841
00:49:10,790 --> 00:49:13,870
So for example, having done
that, I could say, what's the

842
00:49:13,870 --> 00:49:24,915
mean square of 2 and 3?

843
00:49:24,915 --> 00:49:29,530
And I should get the average
of 4 and 9, which is 6.5.

844
00:49:29,530 --> 00:49:32,970


845
00:49:32,970 --> 00:49:37,000
The key thing here is that,
having defined square, I can

846
00:49:37,000 --> 00:49:38,560
use it as if it were
primitive.

847
00:49:38,560 --> 00:49:41,410


848
00:49:41,410 --> 00:49:45,200
So if we look here on the
slide, if I look at mean

849
00:49:45,200 --> 00:49:50,910
square, the person defining mean
square doesn't have to

850
00:49:50,910 --> 00:49:54,660
know, at this point, whether
square was something built

851
00:49:54,660 --> 00:49:57,540
into the language or
whether it was a

852
00:49:57,540 --> 00:49:59,600
procedure that was defined.

853
00:49:59,600 --> 00:50:04,040
And that's a key thing in Lisp,
that you do not make

854
00:50:04,040 --> 00:50:08,230
arbitrary distinctions between
things that happen to be

855
00:50:08,230 --> 00:50:10,400
primitive in the language
and things that

856
00:50:10,400 --> 00:50:12,740
happen to be built in.

857
00:50:12,740 --> 00:50:14,750
A person using that shouldn't
even have to know.

858
00:50:14,750 --> 00:50:17,800
So the things you construct get
used with all the power

859
00:50:17,800 --> 00:50:19,700
and flexibility as if they
were primitives.

860
00:50:19,700 --> 00:50:21,470
In fact, you can drive that
home by looking on the

861
00:50:21,470 --> 00:50:24,750
computer one more time.

862
00:50:24,750 --> 00:50:26,680
We talked about plus.

863
00:50:26,680 --> 00:50:29,920
And in fact, if I come here on
the computer screen and say,

864
00:50:29,920 --> 00:50:31,745
what is the value of plus?

865
00:50:31,745 --> 00:50:34,380


866
00:50:34,380 --> 00:50:36,120
Notice what Lisp types out.

867
00:50:36,120 --> 00:50:38,230
On the bottom there, it typed
out, "compound procedure

868
00:50:38,230 --> 00:50:43,070
plus." Because, in this system,
it turns out that the

869
00:50:43,070 --> 00:50:45,770
addition operator is itself
a compound procedure.

870
00:50:45,770 --> 00:50:48,140
And if I didn't just type that
in, you'd never know that, and

871
00:50:48,140 --> 00:50:49,710
it wouldn't make any
difference anyway.

872
00:50:49,710 --> 00:50:50,240
We don't care.

873
00:50:50,240 --> 00:50:52,500
It's below the level of
the abstraction that

874
00:50:52,500 --> 00:50:54,120
we're dealing with.

875
00:50:54,120 --> 00:50:57,230
So the key thing is you cannot
tell, should not be able to

876
00:50:57,230 --> 00:51:00,910
tell, in general, the difference
between things that

877
00:51:00,910 --> 00:51:03,590
are built in and things
that are compound.

878
00:51:03,590 --> 00:51:04,160
Why is that?

879
00:51:04,160 --> 00:51:06,630
Because the things that are
compound have an abstraction

880
00:51:06,630 --> 00:51:09,420
wrapper wrapped around them.

881
00:51:09,420 --> 00:51:12,510
We've seen almost all the
elements of Lisp now.

882
00:51:12,510 --> 00:51:15,090
There's only one more we have to
look at, and that is how to

883
00:51:15,090 --> 00:51:16,510
make a case analysis.

884
00:51:16,510 --> 00:51:18,760
Let me show you what I mean.

885
00:51:18,760 --> 00:51:22,550
We might want to think about the
mathematical definition of

886
00:51:22,550 --> 00:51:23,740
the absolute value functions.

887
00:51:23,740 --> 00:51:30,520
I might say the absolute value
of x is the function which has

888
00:51:30,520 --> 00:51:35,670
the property that it's
negative of x.

889
00:51:35,670 --> 00:51:42,580
For x less than 0, it's
0 for x equal to 0.

890
00:51:42,580 --> 00:51:46,360
And it's x for x
greater than 0.

891
00:51:46,360 --> 00:51:49,190


892
00:51:49,190 --> 00:51:51,490
And Lisp has a way of making
case analyses.

893
00:51:51,490 --> 00:51:55,210
Let me define for you
absolute value.

894
00:51:55,210 --> 00:52:03,080
Say define the absolute value
of x is conditional.

895
00:52:03,080 --> 00:52:05,075
This means case analysis,
COND.

896
00:52:05,075 --> 00:52:08,773


897
00:52:08,773 --> 00:52:18,760
If x is less than 0, the
answer is negate x.

898
00:52:18,760 --> 00:52:22,990


899
00:52:22,990 --> 00:52:24,290
What I've written here
is a clause.

900
00:52:24,290 --> 00:52:29,490


901
00:52:29,490 --> 00:52:33,818
This whole thing is a
conditional clause,

902
00:52:33,818 --> 00:52:36,380
and it has two parts.

903
00:52:36,380 --> 00:52:44,760
This part here is a predicate
or a condition.

904
00:52:44,760 --> 00:52:45,640
That's a condition.

905
00:52:45,640 --> 00:52:47,680
And the condition is expressed
by something called a

906
00:52:47,680 --> 00:52:51,170
predicate, and a predicate in
Lisp is some sort of thing

907
00:52:51,170 --> 00:52:53,440
that returns either
true or false.

908
00:52:53,440 --> 00:52:55,490
And you see Lisp has a
primitive procedure,

909
00:52:55,490 --> 00:53:00,510
less-than, that tests whether
something is true or false.

910
00:53:00,510 --> 00:53:06,940
And the other part of a clause
is an action or a thing to do,

911
00:53:06,940 --> 00:53:07,930
in the case where that's true.

912
00:53:07,930 --> 00:53:12,130
And here, what I'm doing
is negating x.

913
00:53:12,130 --> 00:53:13,300
The negation operator, the
minus sign in Lisp is

914
00:53:13,300 --> 00:53:14,550
a little bit funny.

915
00:53:14,550 --> 00:53:17,880


916
00:53:17,880 --> 00:53:19,186
If there's two or more
arguments, if there's two

917
00:53:19,186 --> 00:53:21,740
arguments it subtracts the
second one from the first, and

918
00:53:21,740 --> 00:53:22,380
we saw that.

919
00:53:22,380 --> 00:53:25,280
And if there's one argument,
it negates it.

920
00:53:25,280 --> 00:53:27,700
So this corresponds to that.

921
00:53:27,700 --> 00:53:28,960
And then there's another
COND clause.

922
00:53:28,960 --> 00:53:34,630
It says, in the case where
x is equal to 0,

923
00:53:34,630 --> 00:53:37,482
the answer is 0.

924
00:53:37,482 --> 00:53:43,480
And in the case where
x is greater than 0,

925
00:53:43,480 --> 00:53:45,430
the answer is x.

926
00:53:45,430 --> 00:53:46,790
Close that clause.

927
00:53:46,790 --> 00:53:48,250
Close the COND.

928
00:53:48,250 --> 00:53:48,920
Close the definition.

929
00:53:48,920 --> 00:53:51,110
And there's the definition
of absolute value.

930
00:53:51,110 --> 00:53:53,560
And you see it's the case
analysis that looks very much

931
00:53:53,560 --> 00:53:55,265
like the case analysis you
use in mathematics.

932
00:53:55,265 --> 00:53:58,500


933
00:53:58,500 --> 00:54:02,300
There's a somewhat different
way of writing a restricted

934
00:54:02,300 --> 00:54:03,090
case analysis.

935
00:54:03,090 --> 00:54:05,520
Often, you have a case analysis
where you only have

936
00:54:05,520 --> 00:54:08,810
one case, where you test
something, and then depending

937
00:54:08,810 --> 00:54:11,000
on whether it's true or false,
you do something.

938
00:54:11,000 --> 00:54:16,150
And here's another definition of
absolute value which looks

939
00:54:16,150 --> 00:54:21,010
almost the same, which says,
if x is less than 0, the

940
00:54:21,010 --> 00:54:24,380
result is negate x.

941
00:54:24,380 --> 00:54:25,960
Otherwise, the answer is x.

942
00:54:25,960 --> 00:54:27,120
And we'll be using "if" a lot.

943
00:54:27,120 --> 00:54:30,650
But again, the thing to remember
is that this form of

944
00:54:30,650 --> 00:54:35,130
absolute value that you're
looking at here, and then this

945
00:54:35,130 --> 00:54:37,650
one over here that I wrote
on the board, are

946
00:54:37,650 --> 00:54:39,040
essentially the same.

947
00:54:39,040 --> 00:54:40,700
And "if" and COND are--

948
00:54:40,700 --> 00:54:42,020
well, whichever way
you like it.

949
00:54:42,020 --> 00:54:45,100
You can think of COND as
syntactic sugar for "if," or

950
00:54:45,100 --> 00:54:47,375
you can think of "if" as
syntactic sugar for COND, and

951
00:54:47,375 --> 00:54:48,810
it doesn't make any
difference.

952
00:54:48,810 --> 00:54:51,400
The person implementing a Lisp
system will pick one and

953
00:54:51,400 --> 00:54:52,840
implement the other
in terms of that.

954
00:54:52,840 --> 00:54:54,570
And it doesn't matter
which one you pick.

955
00:54:54,570 --> 00:55:02,660


956
00:55:02,660 --> 00:55:05,640
Why don't we break now, and
then take some questions.

957
00:55:05,640 --> 00:55:11,760
How come sometimes when I write
define, I put an open

958
00:55:11,760 --> 00:55:16,790
paren here and say, define open
paren something or other,

959
00:55:16,790 --> 00:55:19,480
and sometimes when
I write this, I

960
00:55:19,480 --> 00:55:22,330
don't put an open paren?

961
00:55:22,330 --> 00:55:27,550
The answer is, this particular
form of "define," where you

962
00:55:27,550 --> 00:55:30,850
say define some expression, is
this very special thing for

963
00:55:30,850 --> 00:55:33,630
defining procedures.

964
00:55:33,630 --> 00:55:37,900
But again, what it really means
is I'm defining this

965
00:55:37,900 --> 00:55:41,350
symbol, square, to be that.

966
00:55:41,350 --> 00:55:44,810
So the way you should think
about it is what "define" does

967
00:55:44,810 --> 00:55:48,330
is you write "define," and the
second thing you write is the

968
00:55:48,330 --> 00:55:49,830
symbol here-- no open paren--

969
00:55:49,830 --> 00:55:54,610
the symbol you're defining and
what you're defining it to be.

970
00:55:54,610 --> 00:55:57,300
That's like here
and like here.

971
00:55:57,300 --> 00:56:01,480
That's sort of the basic way
you use "define." And then,

972
00:56:01,480 --> 00:56:05,040
there's this special syntactic
trick which allows you to

973
00:56:05,040 --> 00:56:08,140
define procedures that
look like this.

974
00:56:08,140 --> 00:56:10,690
So the difference is, it's
whether or not you're defining

975
00:56:10,690 --> 00:56:11,755
a procedure.

976
00:56:11,755 --> 00:56:38,110
[MUSIC PLAYING]

977
00:56:38,110 --> 00:56:42,600
Well, believe it or not, you
actually now know enough Lisp

978
00:56:42,600 --> 00:56:46,610
to write essentially any
numerical procedure that you'd

979
00:56:46,610 --> 00:56:49,470
write in a language like FORTRAN
or Basic or whatever,

980
00:56:49,470 --> 00:56:51,656
or, essentially, any
other language.

981
00:56:51,656 --> 00:56:55,190
And you're probably saying,
that's not believable, because

982
00:56:55,190 --> 00:56:56,890
you know that these languages
have things like "for

983
00:56:56,890 --> 00:57:00,910
statements," and "do until
while" or something.

984
00:57:00,910 --> 00:57:04,745
But we don't really
need any of that.

985
00:57:04,745 --> 00:57:06,220
In fact, we're not going
to use any of

986
00:57:06,220 --> 00:57:08,180
that in this course.

987
00:57:08,180 --> 00:57:10,410
Let me show you.

988
00:57:10,410 --> 00:57:14,400
Again, looking back at square
root, let's go back to this

989
00:57:14,400 --> 00:57:18,505
square root algorithm of
Heron of Alexandria.

990
00:57:18,505 --> 00:57:20,000
Remember what that said.

991
00:57:20,000 --> 00:57:23,060
It said, to find an
approximation to the square

992
00:57:23,060 --> 00:57:28,730
root of X, you make a guess,
you improve that guess by

993
00:57:28,730 --> 00:57:32,900
averaging the guess and
X over the guess.

994
00:57:32,900 --> 00:57:36,382
You keep improving that until
the guess is good enough.

995
00:57:36,382 --> 00:57:38,460
I already alluded to the idea.

996
00:57:38,460 --> 00:57:44,650
The idea is that, if the initial
guess that you took

997
00:57:44,650 --> 00:57:48,430
was actually equal to the square
root of X, then G here

998
00:57:48,430 --> 00:57:52,760
would be equal to X/G.

999
00:57:52,760 --> 00:57:54,400
So if you hit the square
root, averaging them

1000
00:57:54,400 --> 00:57:55,630
wouldn't change it.

1001
00:57:55,630 --> 00:57:59,160
If the G that you picked was
larger than the square root of

1002
00:57:59,160 --> 00:58:03,280
X, then X/G will be smaller than
the square root of X, so

1003
00:58:03,280 --> 00:58:05,890
that when you average
G and X/G, you get

1004
00:58:05,890 --> 00:58:09,130
something in between.

1005
00:58:09,130 --> 00:58:11,790
So if you pick a G that's
too small, your

1006
00:58:11,790 --> 00:58:13,040
answer will be too large.

1007
00:58:13,040 --> 00:58:17,190
If you pick a G that's too
large, if your G is larger

1008
00:58:17,190 --> 00:58:19,420
than the square root of X and
X/G will be smaller than the

1009
00:58:19,420 --> 00:58:21,110
square root of X.

1010
00:58:21,110 --> 00:58:24,460
So averaging always gives you
something in between.

1011
00:58:24,460 --> 00:58:27,450
And then, it's not quite
trivial, but it's possible to

1012
00:58:27,450 --> 00:58:31,050
show that, in fact, if G misses
the square root of X by

1013
00:58:31,050 --> 00:58:34,220
a little bit, the average of G
and X/G will actually keep

1014
00:58:34,220 --> 00:58:37,800
getting closer to the square
root of X. So if you keep

1015
00:58:37,800 --> 00:58:40,140
doing this enough, you'll
eventually get as

1016
00:58:40,140 --> 00:58:41,680
close as you want.

1017
00:58:41,680 --> 00:58:44,170
And then there's another fact,
that you can always start out

1018
00:58:44,170 --> 00:58:49,210
this process by using 1
as an initial guess.

1019
00:58:49,210 --> 00:58:52,440
And it'll always converge to
the square root of X. So

1020
00:58:52,440 --> 00:58:55,610
that's this method of successive
averaging due to

1021
00:58:55,610 --> 00:58:56,660
Heron of Alexandria.

1022
00:58:56,660 --> 00:59:00,250
Let's write it in Lisp.

1023
00:59:00,250 --> 00:59:05,770
Well, the central idea is, what
does it mean to try a

1024
00:59:05,770 --> 00:59:07,940
guess for the square
root of X?

1025
00:59:07,940 --> 00:59:09,780
Let's write that.

1026
00:59:09,780 --> 00:59:24,310
So we'll say, define to try a
guess for the square root of

1027
00:59:24,310 --> 00:59:27,750
X, what do we do?

1028
00:59:27,750 --> 00:59:44,130
We'll say, if the guess is good
enough to be a guess for

1029
00:59:44,130 --> 00:59:48,330
the square root of X,
then, as an answer,

1030
00:59:48,330 --> 00:59:51,550
we'll take the guess.

1031
00:59:51,550 --> 00:59:58,620
Otherwise, we will try
the improved guess.

1032
00:59:58,620 --> 01:00:05,400
We'll improve that guess for
the square root of X, and

1033
01:00:05,400 --> 01:00:09,690
we'll try that as a guess for
the square root of X. Close

1034
01:00:09,690 --> 01:00:13,510
the "try." Close the "if." Close
the "define." So that's

1035
01:00:13,510 --> 01:00:15,820
how we try a guess.

1036
01:00:15,820 --> 01:00:18,050
And then, the next part of the
process said, in order to

1037
01:00:18,050 --> 01:00:28,370
compute square roots, we'll
say, define to compute the

1038
01:00:28,370 --> 01:00:35,290
square root of X, we will try
1 as a guess for the square

1039
01:00:35,290 --> 01:00:40,280
root of X. Well, we have to
define a couple more things.

1040
01:00:40,280 --> 01:00:43,770
We have to say, how is
a guess good enough?

1041
01:00:43,770 --> 01:00:45,545
And how do we improve a guess?

1042
01:00:45,545 --> 01:00:47,380
So let's look at that.

1043
01:00:47,380 --> 01:00:53,650
The algorithm to improve a guess
for the square root of

1044
01:00:53,650 --> 01:00:55,640
X, we average--

1045
01:00:55,640 --> 01:00:57,000
that was the algorithm--

1046
01:00:57,000 --> 01:01:00,680
we average the guess with
the quotient of

1047
01:01:00,680 --> 01:01:03,030
dividing X by the guess.

1048
01:01:03,030 --> 01:01:05,810
That's how we improve a guess.

1049
01:01:05,810 --> 01:01:07,720
And to tell whether a guess is
good enough, well, we have to

1050
01:01:07,720 --> 01:01:09,530
decide something.

1051
01:01:09,530 --> 01:01:11,510
This is supposed to be a guess
for the square root of X, so

1052
01:01:11,510 --> 01:01:14,700
one possible thing you can do
is say, when you take that

1053
01:01:14,700 --> 01:01:19,110
guess and square it, do you get
something very close to X?

1054
01:01:19,110 --> 01:01:22,870
So one way to say that is to
say, I square the guess,

1055
01:01:22,870 --> 01:01:26,900
subtract X from that, and see if
the absolute value of that

1056
01:01:26,900 --> 01:01:31,200
whole thing is less than some
small number, which depends on

1057
01:01:31,200 --> 01:01:32,450
my purposes.

1058
01:01:32,450 --> 01:01:35,080


1059
01:01:35,080 --> 01:01:40,410
So there's a complete procedure
for how to compute

1060
01:01:40,410 --> 01:01:42,830
the square root of X. Let's look
at the structure of that

1061
01:01:42,830 --> 01:01:44,080
a little bit.

1062
01:01:44,080 --> 01:01:47,970


1063
01:01:47,970 --> 01:01:49,100
I have the whole thing.

1064
01:01:49,100 --> 01:01:55,370
I have the notion of how to
compute a square root.

1065
01:01:55,370 --> 01:01:56,960
That's some kind of module.

1066
01:01:56,960 --> 01:01:58,580
That's some kind of black box.

1067
01:01:58,580 --> 01:02:07,340
It's defined in terms of how to
try a guess for the square

1068
01:02:07,340 --> 01:02:09,090
root of X.

1069
01:02:09,090 --> 01:02:15,110
"Try" is defined in terms of,
well, telling whether

1070
01:02:15,110 --> 01:02:16,640
something is good enough
and telling

1071
01:02:16,640 --> 01:02:18,680
how to improve something.

1072
01:02:18,680 --> 01:02:19,800
So good enough.

1073
01:02:19,800 --> 01:02:30,790
"Try" is defined in terms of
"good enough" and "improve."

1074
01:02:30,790 --> 01:02:32,170
And let's see what
else I fill in.

1075
01:02:32,170 --> 01:02:34,640
Well, I'll go down this tree.

1076
01:02:34,640 --> 01:02:36,040
"Good enough" was defined
in terms of

1077
01:02:36,040 --> 01:02:37,930
absolute value, and square.

1078
01:02:37,930 --> 01:02:40,910


1079
01:02:40,910 --> 01:02:43,290
And improve was defined in
terms of something called

1080
01:02:43,290 --> 01:02:47,340
averaging and then some other
primitive operator.

1081
01:02:47,340 --> 01:02:49,530
Square root's defined in terms
of "try." "Try" is defined in

1082
01:02:49,530 --> 01:02:53,860
terms of "good enough"
and "improve,"

1083
01:02:53,860 --> 01:02:55,410
but also "try" itself.

1084
01:02:55,410 --> 01:03:02,750
So "try" is also defined in
terms of how to try itself.

1085
01:03:02,750 --> 01:03:06,240
Well, that may give you some
problems. Your high school

1086
01:03:06,240 --> 01:03:10,680
geometry teacher probably told
you that it's naughty to try

1087
01:03:10,680 --> 01:03:13,360
and define things in terms of
themselves, because it doesn't

1088
01:03:13,360 --> 01:03:13,810
make sense.

1089
01:03:13,810 --> 01:03:16,440
But that's false.

1090
01:03:16,440 --> 01:03:18,730
Sometimes it makes perfect
sense to define things in

1091
01:03:18,730 --> 01:03:20,210
terms of themselves.

1092
01:03:20,210 --> 01:03:22,918
And this is the case.

1093
01:03:22,918 --> 01:03:24,150
And we can look at that.

1094
01:03:24,150 --> 01:03:28,140
We could write down what this
means, and say, suppose I

1095
01:03:28,140 --> 01:03:30,100
asked Lisp what the square
root of 2 is.

1096
01:03:30,100 --> 01:03:32,690


1097
01:03:32,690 --> 01:03:35,710
What's the square
root of 2 mean?

1098
01:03:35,710 --> 01:03:42,700
Well, that means I try
1 as a guess for the

1099
01:03:42,700 --> 01:03:43,950
square root of 2.

1100
01:03:43,950 --> 01:03:47,100


1101
01:03:47,100 --> 01:03:47,760
Now I look.

1102
01:03:47,760 --> 01:03:50,000
I say, gee, is 1 a good
enough guess for the

1103
01:03:50,000 --> 01:03:51,140
square root of 2?

1104
01:03:51,140 --> 01:03:54,140
And that depends on the test
that "good enough" does.

1105
01:03:54,140 --> 01:03:57,240
And in this case, "good enough"
will say, no, 1 is not

1106
01:03:57,240 --> 01:03:59,740
a good enough guess for
the square root of 2.

1107
01:03:59,740 --> 01:04:10,350
So that will reduce to saying,
I have to try an improved--

1108
01:04:10,350 --> 01:04:15,910
improve 1 as a guess for the
square root of 2, and try that

1109
01:04:15,910 --> 01:04:19,110
as a guess for the
square root of 2.

1110
01:04:19,110 --> 01:04:22,350
Improving 1 as a guess for the
square root of 2 means I

1111
01:04:22,350 --> 01:04:27,270
average 1 and 2 divided by 1.

1112
01:04:27,270 --> 01:04:29,550
So this is going
to be average.

1113
01:04:29,550 --> 01:04:37,830
This piece here will be the
average of 1 and the

1114
01:04:37,830 --> 01:04:40,930
quotient of 2 by 1.

1115
01:04:40,930 --> 01:04:44,910
That's this piece here.

1116
01:04:44,910 --> 01:04:46,160
And this is 1.5.

1117
01:04:46,160 --> 01:04:49,060


1118
01:04:49,060 --> 01:04:53,670
So this square root of 2 reduces
to trying 1 for the

1119
01:04:53,670 --> 01:05:03,370
square root of 2, which reduces
to trying 1.5 as a

1120
01:05:03,370 --> 01:05:06,220
guess for the square
root of 2.

1121
01:05:06,220 --> 01:05:07,880
So that makes sense.

1122
01:05:07,880 --> 01:05:09,650
Let's look at the rest
of the process.

1123
01:05:09,650 --> 01:05:14,890
If I try 1.5, that reduces.

1124
01:05:14,890 --> 01:05:18,210
1.5 turns out to be not good
enough as a guess for the

1125
01:05:18,210 --> 01:05:20,130
square root of 2.

1126
01:05:20,130 --> 01:05:23,340
So that reduces to trying the
average of 1.5 and 2 divided

1127
01:05:23,340 --> 01:05:28,200
by 1.5 as a guess for the
square root of 2.

1128
01:05:28,200 --> 01:05:31,110
That average turns
out to be 1.333.

1129
01:05:31,110 --> 01:05:34,215
So this whole thing reduces to
trying 1.333 as a guess for

1130
01:05:34,215 --> 01:05:35,130
the square root of 2.

1131
01:05:35,130 --> 01:05:37,910
And then so on.

1132
01:05:37,910 --> 01:05:40,750
That reduces to another called
a "good enough," 1.4

1133
01:05:40,750 --> 01:05:41,630
something or other.

1134
01:05:41,630 --> 01:05:45,160
And then it keeps going until
the process finally stops with

1135
01:05:45,160 --> 01:05:47,780
something that "good enough"
thinks is good enough, which,

1136
01:05:47,780 --> 01:05:52,500
in this case, is 1.4142
something or other.

1137
01:05:52,500 --> 01:05:55,890
So the process makes
perfect sense.

1138
01:05:55,890 --> 01:05:59,710


1139
01:05:59,710 --> 01:06:02,620
This, by the way, is called
a recursive definition.

1140
01:06:02,620 --> 01:06:14,410


1141
01:06:14,410 --> 01:06:19,470
And the ability to make
recursive definitions is a

1142
01:06:19,470 --> 01:06:20,710
source of incredible power.

1143
01:06:20,710 --> 01:06:24,040
And as you can already see I've
hinted at, it's the thing

1144
01:06:24,040 --> 01:06:27,160
that effectively allows you to
do these infinite computations

1145
01:06:27,160 --> 01:06:30,730
that go on until something is
true, without having any other

1146
01:06:30,730 --> 01:06:33,235
constricts other than the
ability to call a procedure.

1147
01:06:33,235 --> 01:06:35,890


1148
01:06:35,890 --> 01:06:37,970
Well, let's see, there's
one more thing.

1149
01:06:37,970 --> 01:06:43,210
Let me show you a variant of
this definition of square root

1150
01:06:43,210 --> 01:06:46,300
here on the slide.

1151
01:06:46,300 --> 01:06:48,320
Here's sort of the same thing.

1152
01:06:48,320 --> 01:06:51,430
What I've done here is packaged
the definitions of

1153
01:06:51,430 --> 01:06:55,340
"improve" and "good enough"
and "try" inside "square

1154
01:06:55,340 --> 01:06:59,760
root." So, in effect, what
I've done is I've built a

1155
01:06:59,760 --> 01:07:01,860
square root box.

1156
01:07:01,860 --> 01:07:07,320
So I've built a box that's the
square root procedure that

1157
01:07:07,320 --> 01:07:08,150
someone can use.

1158
01:07:08,150 --> 01:07:11,910
They might put in 36
and get out 6.

1159
01:07:11,910 --> 01:07:15,080
And then, packaged inside this
box are the definitions of

1160
01:07:15,080 --> 01:07:26,530
"try" and "good enough"
and "improve."

1161
01:07:26,530 --> 01:07:28,260
So they're hidden
inside this box.

1162
01:07:28,260 --> 01:07:32,010
And the reason for doing that
is that, if someone's using

1163
01:07:32,010 --> 01:07:34,920
this square root, if George is
using this square root, George

1164
01:07:34,920 --> 01:07:39,180
probably doesn't care very much
that, when I implemented

1165
01:07:39,180 --> 01:07:42,600
square root, I had things inside
there called "try" and

1166
01:07:42,600 --> 01:07:48,150
"good enough" and "improve." And
in fact, Harry might have

1167
01:07:48,150 --> 01:07:50,300
a cube root procedure that has
"try" and "good enough" and

1168
01:07:50,300 --> 01:07:53,260
"improve." And in order to not
get the whole system confused,

1169
01:07:53,260 --> 01:07:55,430
it'd be good for Harry to
package his internal

1170
01:07:55,430 --> 01:07:58,320
procedures inside his
cube root procedure.

1171
01:07:58,320 --> 01:08:00,970
Well, this is called block
structure, this particular way

1172
01:08:00,970 --> 01:08:09,940
of packaging internals inside
of a definition.

1173
01:08:09,940 --> 01:08:13,040
And let's go back and look
at the slide again.

1174
01:08:13,040 --> 01:08:17,720
The way to read this kind of
procedure is to say, to define

1175
01:08:17,720 --> 01:08:23,010
"square root," well, inside that
definition, I'll have the

1176
01:08:23,010 --> 01:08:26,479
definition of an "improve" and
the definition of "good

1177
01:08:26,479 --> 01:08:31,149
enough" and the definition of
"try." And then, subject to

1178
01:08:31,149 --> 01:08:36,010
those definitions, the way I
do square root is to try 1.

1179
01:08:36,010 --> 01:08:38,310
And notice here, I don't have
to say 1 as a guess for the

1180
01:08:38,310 --> 01:08:41,290
square root of X, because since
it's all inside the

1181
01:08:41,290 --> 01:08:44,270
square root, it sort of
has this X known.

1182
01:08:44,270 --> 01:08:54,770


1183
01:08:54,770 --> 01:08:56,510
Let me summarize.

1184
01:08:56,510 --> 01:08:59,890
We started out with the idea
that what we're going to be

1185
01:08:59,890 --> 01:09:04,960
doing is expressing imperative
knowledge.

1186
01:09:04,960 --> 01:09:08,960
And in fact, here's a slide
that summarizes the way we

1187
01:09:08,960 --> 01:09:09,680
looked at Lisp.

1188
01:09:09,680 --> 01:09:13,609
We started out by looking at
some primitive elements in

1189
01:09:13,609 --> 01:09:17,609
addition and multiplication,
some predicates for testing

1190
01:09:17,609 --> 01:09:19,630
whether something is less-than
or something's equal.

1191
01:09:19,630 --> 01:09:22,330
And in fact, we saw really
sneakily in the system we're

1192
01:09:22,330 --> 01:09:25,160
actually using, these aren't
actually primitives, but it

1193
01:09:25,160 --> 01:09:26,550
doesn't matter.

1194
01:09:26,550 --> 01:09:28,120
What matters is we're going
to use them as if they're

1195
01:09:28,120 --> 01:09:28,510
primitives.

1196
01:09:28,510 --> 01:09:30,220
We're not going to
look inside.

1197
01:09:30,220 --> 01:09:34,540
We also have some primitive
data and some numbers.

1198
01:09:34,540 --> 01:09:36,830
We saw some means of
composition, means of

1199
01:09:36,830 --> 01:09:41,300
combination, the basic one being
composing functions and

1200
01:09:41,300 --> 01:09:44,840
building combinations with
operators and operands.

1201
01:09:44,840 --> 01:09:47,600
And there were some other
things, like COND and "if" and

1202
01:09:47,600 --> 01:09:53,790
"define." But the main thing
about "define," in particular,

1203
01:09:53,790 --> 01:09:55,710
was that it was the means
of abstraction.

1204
01:09:55,710 --> 01:09:57,670
It was the way that
we name things.

1205
01:09:57,670 --> 01:09:59,770
You can also see from this slide
not only where we've

1206
01:09:59,770 --> 01:10:01,450
been, but holes we
have to fill in.

1207
01:10:01,450 --> 01:10:03,930
At some point, we'll have to
talk about how you combine

1208
01:10:03,930 --> 01:10:07,720
primitive data to get compound
data, and how you abstract

1209
01:10:07,720 --> 01:10:11,950
data so you can use large
globs of data as

1210
01:10:11,950 --> 01:10:13,900
if they were primitive.

1211
01:10:13,900 --> 01:10:16,370
So that's where we're going.

1212
01:10:16,370 --> 01:10:20,790
But before we do that, for the
next couple of lectures we're

1213
01:10:20,790 --> 01:10:25,720
going to be talking about, first
of all, how it is that

1214
01:10:25,720 --> 01:10:28,900
you make a link between these
procedures we write and the

1215
01:10:28,900 --> 01:10:32,040
processes that happen
in the machine.

1216
01:10:32,040 --> 01:10:36,210
And then, how it is that you
start using the power of Lisp

1217
01:10:36,210 --> 01:10:38,710
to talk not only about these
individual little

1218
01:10:38,710 --> 01:10:43,080
computations, but about general
conventional methods

1219
01:10:43,080 --> 01:10:45,200
of doing things.

1220
01:10:45,200 --> 01:10:46,730
OK, are there any questions?

1221
01:10:46,730 --> 01:10:47,640
AUDIENCE: Yes.

1222
01:10:47,640 --> 01:10:51,880
If we defined A using
parentheses instead of as we

1223
01:10:51,880 --> 01:10:53,400
did, what would be
the difference?

1224
01:10:53,400 --> 01:10:58,130
PROFESSOR: If I wrote this, if
I wrote that, what I would be

1225
01:10:58,130 --> 01:11:03,740
doing is defining a procedure
named A. In this case, a

1226
01:11:03,740 --> 01:11:07,950
procedure of no arguments,
which, when I ran it, would

1227
01:11:07,950 --> 01:11:10,274
give me back 5 times 5.

1228
01:11:10,274 --> 01:11:10,716
AUDIENCE: Right.

1229
01:11:10,716 --> 01:11:12,610
I mean, you come up with the
same thing, except for you

1230
01:11:12,610 --> 01:11:13,940
really got a different--

1231
01:11:13,940 --> 01:11:14,120
PROFESSOR: Right.

1232
01:11:14,120 --> 01:11:16,330
And the difference would
be, in the old one--

1233
01:11:16,330 --> 01:11:19,180
Let me be a little
bit clearer here.

1234
01:11:19,180 --> 01:11:24,070
Let's call this A, like here.

1235
01:11:24,070 --> 01:11:35,060
And pretend here, just for
contrast, I wrote, define D to

1236
01:11:35,060 --> 01:11:37,300
be the product of 5 and 5.

1237
01:11:37,300 --> 01:11:40,200


1238
01:11:40,200 --> 01:11:42,450
And the difference between
those, let's think about

1239
01:11:42,450 --> 01:11:45,770
interactions with the
Lisp interpreter.

1240
01:11:45,770 --> 01:11:52,860
I could type in A and Lisp
would return 25.

1241
01:11:52,860 --> 01:12:01,240
I could type in D, if I just
typed in D, Lisp would return

1242
01:12:01,240 --> 01:12:08,000
compound procedure D, because
that's what it is.

1243
01:12:08,000 --> 01:12:09,670
It's a procedure.

1244
01:12:09,670 --> 01:12:12,500
I could run D. I could say,
what's the value of running D?

1245
01:12:12,500 --> 01:12:16,520
Here is a combination
with no operands.

1246
01:12:16,520 --> 01:12:17,570
I see there are no operands.

1247
01:12:17,570 --> 01:12:22,940
I didn't put any after D. And
it would say, oh, that's 25.

1248
01:12:22,940 --> 01:12:28,070
Or I could say, just for
completeness, if I typed in,

1249
01:12:28,070 --> 01:12:29,310
what's the value of running A?

1250
01:12:29,310 --> 01:12:31,690
I get an error.

1251
01:12:31,690 --> 01:12:35,150
The error would be the same
one as over there.

1252
01:12:35,150 --> 01:12:40,010
It'd be the error would say,
sorry, 25, which is the value

1253
01:12:40,010 --> 01:12:43,720
of A, is not an operator that
I can apply to something.

1254
01:12:43,720 --> 01:12:53,076

