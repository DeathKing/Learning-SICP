[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 640
PlayResY: 480

[Aegisub Project Garbage]
Scroll Position: 1258
Active Line: 1269
Video Position: 128947

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: EN,Calisto MT,21,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,1,0,2,10,10,30,1
Style: Declare,微软雅黑,30,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,2,0,8,10,10,10,1
Style: staff,微软雅黑,30,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,0,2,5,10,10,10,1
Style: title,微软雅黑,35,&H001D64D9,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,0,1,5,10,10,10,1
Style: Default,雅黑宋体,20,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,1,0,2,10,10,30,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.03,0:00:02.04,Declare,,0,0,0,,{\an2\fad(500,500)}Learning-SICP 学习小组\N倾情制作
Dialogue: 0,0:00:02.04,0:00:09.09,title,,0,0,0,,{\fad(600,800)\pos(324,32)}《计算机程序的构造和解释》
Dialogue: 0,0:00:02.04,0:00:09.09,staff,,0,0,0,,{\fad(600,800)\pos(110.666,403.334)}翻译&&时间轴\N邓雄飞\N（Dysprosium）
Dialogue: 0,0:00:02.04,0:00:09.09,staff,,0,0,0,,{\fad(600,800)\pos(534.666,404)}压制&&特效\N邓雄飞\N（Dysprosium）
Dialogue: 0,0:00:02.04,0:00:09.09,staff,,0,0,0,,{\fad(600,800)\pos(574.667,277.333)}校对\N邓雄飞
Dialogue: 0,0:00:02.04,0:00:09.09,staff,,0,0,0,,{\fad(600,800)\pos(89.334,273.333)}特别感谢\N裘宗燕教授
Dialogue: 0,0:00:09.21,0:00:13.12,Declare,,0,0,0,,{\an2\fad(500,500)}寄存机器
Dialogue: 0,0:00:17.26,0:00:19.07,Default,,0,0,0,,教授：我认为 到目前为止
Dialogue: 0,0:00:19.32,0:00:23.93,Default,,0,0,0,,我们已经学习了很多关于
Dialogue: 0,0:00:24.09,0:00:28.83,Default,,0,0,0,,组织程序以及操纵符号的技术
Dialogue: 0,0:00:30.84,0:00:35.60,Default,,0,0,0,,以及用来构建语言的技术
Dialogue: 0,0:00:35.63,0:00:36.78,Default,,0,0,0,,用一门语言去创建另一门语言
Dialogue: 0,0:00:37.10,0:00:39.92,Default,,0,0,0,,这在组织大型程序时非常有用
Dialogue: 0,0:00:39.96,0:00:42.30,Default,,0,0,0,,实际上 我所知的最好的程序
Dialogue: 0,0:00:42.44,0:00:44.43,Default,,0,0,0,,看起来更像是一堆语言
Dialogue: 0,0:00:44.91,0:00:47.96,Default,,0,0,0,,而不是将问题分解成若干部分
Dialogue: 0,0:00:49.90,0:00:51.45,Default,,0,0,0,,我想 此时此刻
Dialogue: 0,0:00:52.08,0:00:53.58,Default,,0,0,0,,关于这类东西的工作方式
Dialogue: 0,0:00:53.61,0:00:55.32,Default,,0,0,0,,仍然存在一些谜团
Dialogue: 0,0:00:56.26,0:00:59.68,Default,,0,0,0,,因此 我现在需要
Dialogue: 0,0:01:00.03,0:01:02.60,Default,,0,0,0,,偏离原先的计划
Dialogue: 0,0:01:02.96,0:01:05.42,Default,,0,0,0,,不再继续讲解如何组织大型程序
Dialogue: 0,0:01:05.45,0:01:08.19,Default,,0,0,0,,而是告诉你一些关于
Dialogue: 0,0:01:08.52,0:01:11.71,Default,,0,0,0,,使这些事情可以起作用的机制
Dialogue: 0,0:01:12.19,0:01:14.83,Default,,0,0,0,,这样做的主要是为了
Dialogue: 0,0:01:15.80,0:01:17.87,Default,,0,0,0,,揭秘
Dialogue: 0,0:01:18.65,0:01:20.54,Default,,0,0,0,,剩下的很多谜团
Dialogue: 0,0:01:21.08,0:01:25.48,Default,,0,0,0,,比如说 如何控制程序的运行
Dialogue: 0,0:01:26.08,0:01:30.38,Default,,0,0,0,,计算机如何知晓下一步的动作
Dialogue: 0,0:01:30.52,0:01:31.74,Default,,0,0,0,,等等等等
Dialogue: 0,0:01:32.43,0:01:35.56,Default,,0,0,0,,我现在就要让你们清楚地知道
Dialogue: 0,0:01:35.85,0:01:39.10,Default,,0,0,0,,就算你之前没有使用过计算机
Dialogue: 0,0:01:39.56,0:01:43.50,Default,,0,0,0,,但这种机制非常简单
Dialogue: 0,0:01:44.33,0:01:46.35,Default,,0,0,0,,你可以毫无问题地理解它
Dialogue: 0,0:01:47.65,0:01:51.24,Default,,0,0,0,,好吧 我们先来想象一个 --
Dialogue: 0,0:01:51.32,0:01:52.91,Default,,0,0,0,,先说明一下 我们采用的方法是
Dialogue: 0,0:01:52.96,0:01:55.80,Default,,0,0,0,,把一些非常简单的Lisp程序
Dialogue: 0,0:01:56.54,0:01:58.12,Default,,0,0,0,,真的非常简单
Dialogue: 0,0:01:59.04,0:02:00.62,Default,,0,0,0,,把它们转换成硬件
Dialogue: 0,0:02:02.16,0:02:04.16,Default,,0,0,0,,我不会考虑一些中间步骤
Dialogue: 0,0:02:04.70,0:02:07.45,Default,,0,0,0,,比如转换成某种现有的机器语言
Dialogue: 0,0:02:07.47,0:02:09.05,Default,,0,0,0,,然后来解释计算机是如何工作的
Dialogue: 0,0:02:09.82,0:02:12.00,Default,,0,0,0,,因为那不太明显
Dialogue: 0,0:02:12.75,0:02:14.17,Default,,0,0,0,,所以我真正要向你展示的是
Dialogue: 0,0:02:14.51,0:02:17.48,Default,,0,0,0,,如何构建一台机器来完成
Dialogue: 0,0:02:18.03,0:02:22.04,Default,,0,0,0,,一项由你写的程序所描述的工作
Dialogue: 0,0:02:22.04,0:02:24.03,Default,,0,0,0,,而程序呢 实际上就是一个机器的描述
Dialogue: 0,0:02:25.76,0:02:27.69,Default,,0,0,0,,我们从一个非常简单的程序开始
Dialogue: 0,0:02:28.09,0:02:30.81,Default,,0,0,0,,然后演示一些简单的机制
Dialogue: 0,0:02:31.39,0:02:33.68,Default,,0,0,0,,进而用更复杂的程序
Dialogue: 0,0:02:34.30,0:02:37.42,Default,,0,0,0,,然后又演示一个不那么复杂的程序
Dialogue: 0,0:02:37.44,0:02:41.23,Default,,0,0,0,,来演示求值器是如何变成硬件的
Dialogue: 0,0:02:41.23,0:02:42.06,Default,,0,0,0,,当然 到那个时候
Dialogue: 0,0:02:42.08,0:02:44.08,Default,,0,0,0,,你就有了通用的转换算法
Dialogue: 0,0:02:44.22,0:02:46.88,Default,,0,0,0,,并且可以用一个定义明确的硬件
Dialogue: 0,0:02:47.16,0:02:48.80,Default,,0,0,0,,来执行任何可以想象的程序
Dialogue: 0,0:02:51.72,0:02:52.91,Default,,0,0,0,,那么 现在让我们开始
Dialogue: 0,0:02:53.05,0:02:55.31,Default,,0,0,0,,给你们关于这些东西的具体感觉
Dialogue: 0,0:02:55.44,0:02:57.66,Default,,0,0,0,,我们先从一个非常简单的程序开始
Dialogue: 0,0:02:59.60,0:03:00.85,Default,,0,0,0,,这是欧几里得算法
Dialogue: 0,0:03:03.88,0:03:07.00,Default,,0,0,0,,它实际上比欧几里德算法更现代一些
Dialogue: 0,0:03:07.02,0:03:10.09,Default,,0,0,0,,我想 用来计算两数最大公约数的欧几里得算法
Dialogue: 0,0:03:10.41,0:03:13.60,Default,,0,0,0,,是在公元前350年发明的
Dialogue: 0,0:03:14.30,0:03:15.69,Default,,0,0,0,,它是已知最古老的算法
Dialogue: 0,0:03:19.32,0:03:23.34,Default,,0,0,0,,我们先定义(GCD A B)
Dialogue: 0,0:03:23.36,0:03:25.61,Default,,0,0,0,,也就是用来计算A、B两数的最大公约数
Dialogue: 0,0:03:26.20,0:03:28.91,Default,,0,0,0,,这个算法相当简单
Dialogue: 0,0:03:29.50,0:03:31.08,Default,,0,0,0,,如果B等于0
Dialogue: 0,0:03:34.16,0:03:36.83,Default,,0,0,0,,那么结果就是A
Dialogue: 0,0:03:37.52,0:03:43.61,Default,,0,0,0,,否则结果就是 (GCD B
Dialogue: 0,0:03:44.49,0:03:53.39,Default,,0,0,0,,(REMAINDER A B))
Dialogue: 0,0:03:58.53,0:04:01.90,Default,,0,0,0,,这里 我们定义了一个简单的迭代过程
Dialogue: 0,0:04:02.03,0:04:04.08,Default,,0,0,0,,这是一个简单的递归过程
Dialogue: 0,0:04:04.38,0:04:07.53,Default,,0,0,0,,也可以说这个过程是递归地定义的
Dialogue: 0,0:04:07.71,0:04:09.26,Default,,0,0,0,,但它产生的计算过程是迭代的
Dialogue: 0,0:04:09.95,0:04:12.46,Default,,0,0,0,,它的原理是 在每一步
Dialogue: 0,0:04:12.80,0:04:15.10,Default,,0,0,0,,判断B是否为0
Dialogue: 0,0:04:16.24,0:04:18.80,Default,,0,0,0,,如果B为0 那么A的值就是我们的答案
Dialogue: 0,0:04:19.63,0:04:22.46,Default,,0,0,0,,否则就进入下一个步骤
Dialogue: 0,0:04:22.49,0:04:23.87,Default,,0,0,0,,其中A就变成旧的B
Dialogue: 0,0:04:23.88,0:04:27.04,Default,,0,0,0,,而B的值 是A旧值除B旧值的余数
Dialogue: 0,0:04:28.76,0:04:29.55,Default,,0,0,0,,非常简单
Dialogue: 0,0:04:31.11,0:04:32.72,Default,,0,0,0,,现在 我已经通过这种方式
Dialogue: 0,0:04:32.99,0:04:34.86,Default,,0,0,0,,告诉了你一些机制
Dialogue: 0,0:04:34.86,0:04:35.90,Default,,0,0,0,,我是按时序告诉你们的
Dialogue: 0,0:04:36.36,0:04:37.72,Default,,0,0,0,,我说 其中有特定的步骤
Dialogue: 0,0:04:38.14,0:04:39.32,Default,,0,0,0,,并且实际上
Dialogue: 0,0:04:39.52,0:04:40.86,Default,,0,0,0,,你可以在这里知道
Dialogue: 0,0:04:41.18,0:04:43.69,Default,,0,0,0,,为什么这个过程是迭代的
Dialogue: 0,0:04:43.95,0:04:47.68,Default,,0,0,0,,是因为最后一步无需额外信息来得到答案
Dialogue: 0,0:04:49.44,0:04:55.29,Default,,0,0,0,,所有运行此算法所需的信息都在A和B中
Dialogue: 0,0:04:55.74,0:04:57.80,Default,,0,0,0,,它有两个定义明确的状态变量
Dialogue: 0,0:05:00.47,0:05:02.33,Default,,0,0,0,,现在 我就要给你们定义一台机器
Dialogue: 0,0:05:03.98,0:05:05.55,Default,,0,0,0,,用来计算GCD
Dialogue: 0,0:05:06.56,0:05:07.12,Default,,0,0,0,,我们来看看
Dialogue: 0,0:05:07.12,0:05:11.28,Default,,0,0,0,,每台制造的计算机都是单进程计算机
Dialogue: 0,0:05:11.80,0:05:14.08,Default,,0,0,0,,而不是某种多处理器
Dialogue: 0,0:05:15.04,0:05:16.59,Default,,0,0,0,,都是按照相同的方案制定的
Dialogue: 0,0:05:17.84,0:05:19.53,Default,,0,0,0,,这种方案就是：计算机由两部分组成
Dialogue: 0,0:05:20.57,0:05:22.35,Default,,0,0,0,,一部分叫数据通路
Dialogue: 0,0:05:23.10,0:05:24.36,Default,,0,0,0,,而另一部分叫控制器
Dialogue: 0,0:05:25.91,0:05:29.28,Default,,0,0,0,,数据通路相当于你可能有的计算器
Dialogue: 0,0:05:29.71,0:05:31.87,Default,,0,0,0,,它有一些寄存器 能够存储数据
Dialogue: 0,0:05:31.90,0:05:33.13,Default,,0,0,0,,你们都用过计算器
Dialogue: 0,0:05:33.56,0:05:35.34,Default,,0,0,0,,它上面有一些按钮和指示灯
Dialogue: 0,0:05:37.03,0:05:38.49,Default,,0,0,0,,通过按下不同的按钮
Dialogue: 0,0:05:38.52,0:05:41.34,Default,,0,0,0,,你可以使操作在寄存器内发生
Dialogue: 0,0:05:41.87,0:05:43.48,Default,,0,0,0,,并显示计算结果
Dialogue: 0,0:05:45.16,0:05:46.25,Default,,0,0,0,,它是完全机械式的
Dialogue: 0,0:05:46.25,0:05:49.55,Default,,0,0,0,,你可以认为那个盒子没有任何智能
Dialogue: 0,0:05:50.90,0:05:53.28,Default,,0,0,0,,它能计算一个数的正弦也许令人吃惊
Dialogue: 0,0:05:53.53,0:05:58.97,Default,,0,0,0,,但它显然是机械式的
Dialogue: 0,0:05:58.97,0:06:01.71,Default,,0,0,0,,至少 我可以像打开GCD机器一样打开它
Dialogue: 0,0:06:02.69,0:06:04.36,Default,,0,0,0,,也就是说 它其中可能有一整台计算机
Dialogue: 0,0:06:04.68,0:06:05.69,Default,,0,0,0,,但这并不有趣
Dialogue: 0,0:06:05.94,0:06:07.10,Default,,0,0,0,,加法相当简单
Dialogue: 0,0:06:08.20,0:06:09.84,Default,,0,0,0,,不借助额外机制就可以完成
Dialogue: 0,0:06:10.89,0:06:15.64,Default,,0,0,0,,现在 如果我们来看另外的一部分：控制器
Dialogue: 0,0:06:15.93,0:06:17.39,Default,,0,0,0,,这一部分也非常简单
Dialogue: 0,0:06:18.19,0:06:19.16,Default,,0,0,0,,它负责按下按钮
Dialogue: 0,0:06:20.35,0:06:21.52,Default,,0,0,0,,它根据指令序列来按按钮
Dialogue: 0,0:06:21.55,0:06:22.84,Default,,0,0,0,,指令是写在纸上的
Dialogue: 0,0:06:24.27,0:06:25.64,Default,,0,0,0,,控制器还会观察指示灯
Dialogue: 0,0:06:26.29,0:06:29.44,Default,,0,0,0,,而且每隔一段 它就会来到指令序列中的一处
Dialogue: 0,0:06:29.47,0:06:32.37,Default,,0,0,0,,如果指示灯A亮 则执行某段指令
Dialogue: 0,0:06:32.37,0:06:33.85,Default,,0,0,0,,否则执行另外的指令
Dialogue: 0,0:06:34.62,0:06:37.45,Default,,0,0,0,,因此 这其中也没有什么复杂的
Dialogue: 0,0:06:38.35,0:06:39.32,Default,,0,0,0,,那么 让我们来画一下
Dialogue: 0,0:06:39.34,0:06:40.57,Default,,0,0,0,,然后来感受一下它
Dialogue: 0,0:06:42.51,0:06:44.84,Default,,0,0,0,,为了计算GCD
Dialogue: 0,0:06:45.88,0:06:49.52,Default,,0,0,0,,你们要知道：这其中有一些寄存器
Dialogue: 0,0:06:50.56,0:06:53.02,Default,,0,0,0,,这里 寄存器就是一个存储数值的地方
Dialogue: 0,0:06:53.52,0:06:54.65,Default,,0,0,0,,这个寄存器存储的是A
Dialogue: 0,0:06:56.81,0:06:58.70,Default,,0,0,0,,而另外的这个存储的是B
Dialogue: 0,0:07:03.17,0:07:05.45,Default,,0,0,0,,现在我们来看看 有了这些寄存器后能做什么
Dialogue: 0,0:07:05.98,0:07:08.73,Default,,0,0,0,,至于你能利用它做什么 并不是很明显
Dialogue: 0,0:07:09.84,0:07:11.72,Default,,0,0,0,,那么 我们必须看看需要用它们做什么
Dialogue: 0,0:07:11.82,0:07:13.87,Default,,0,0,0,,我们来看看尝试求解的问题
Dialogue: 0,0:07:14.03,0:07:16.09,Default,,0,0,0,,计算机设计的一个要点就是
Dialogue: 0,0:07:17.10,0:07:19.58,Default,,0,0,0,,我想大多数设计师都不会照做
Dialogue: 0,0:07:20.20,0:07:21.88,Default,,0,0,0,,也就是专注于待解的问题
Dialogue: 0,0:07:22.62,0:07:25.18,Default,,0,0,0,,然后使用你研究问题所学到的东西
Dialogue: 0,0:07:25.44,0:07:27.28,Default,,0,0,0,,把那些求解问题所需要的机制
Dialogue: 0,0:07:27.53,0:07:28.70,Default,,0,0,0,,融入正在构建的计算机中
Dialogue: 0,0:07:28.81,0:07:30.08,Default,,0,0,0,,不多也不少
Dialogue: 0,0:07:32.14,0:07:33.96,Default,,0,0,0,,现在 可能你所要解决的问题
Dialogue: 0,0:07:34.24,0:07:35.40,Default,,0,0,0,,是大家共有的问题
Dialogue: 0,0:07:36.06,0:07:37.58,Default,,0,0,0,,这种情况下你需要构建
Dialogue: 0,0:07:37.60,0:07:39.29,Default,,0,0,0,,某种语言的通用解释器
Dialogue: 0,0:07:40.19,0:07:42.32,Default,,0,0,0,,但是你添加的机制不能比
Dialogue: 0,0:07:42.35,0:07:44.25,Default,,0,0,0,,想构建的语言解释器的需求多
Dialogue: 0,0:07:44.44,0:07:45.85,Default,,0,0,0,,这一点 我们稍后来讨论
Dialogue: 0,0:07:47.23,0:07:49.93,Default,,0,0,0,,好了 让我们回到这里
Dialogue: 0,0:07:49.93,0:07:51.24,Default,,0,0,0,,我们必须能够做什么？
Dialogue: 0,0:07:51.79,0:07:54.14,Default,,0,0,0,,首先 我们能把B的值赋给A
Dialogue: 0,0:07:56.08,0:07:59.60,Default,,0,0,0,,我们要能够把B的旧值赋给A
Dialogue: 0,0:08:00.38,0:08:03.32,Default,,0,0,0,,因此 我们需要某种能够让数据流通的“路径”
Dialogue: 0,0:08:03.34,0:08:04.76,Default,,0,0,0,,而不管数据具体是什么
Dialogue: 0,0:08:05.37,0:08:06.57,Default,,0,0,0,,从B到A的通路
Dialogue: 0,0:08:07.39,0:08:09.26,Default,,0,0,0,,我箭头来指示
Dialogue: 0,0:08:09.52,0:08:12.62,Default,,0,0,0,,我们能够把B的值赋给A
Dialogue: 0,0:08:12.96,0:08:14.57,Default,,0,0,0,,从而替换A的旧值
Dialogue: 0,0:08:15.12,0:08:16.73,Default,,0,0,0,,当你按下这里的按钮后
Dialogue: 0,0:08:17.48,0:08:18.56,Default,,0,0,0,,就能够实现这个效果
Dialogue: 0,0:08:19.71,0:08:20.78,Default,,0,0,0,,这个按钮就在这里
Dialogue: 0,0:08:23.07,0:08:23.93,Default,,0,0,0,,同样的
Dialogue: 0,0:08:23.95,0:08:26.28,Default,,0,0,0,,我还需要能够计算A除B的余数
Dialogue: 0,0:08:27.00,0:08:28.49,Default,,0,0,0,,这可能混乱而又复杂
Dialogue: 0,0:08:28.86,0:08:30.86,Default,,0,0,0,,但另一方面 我会把它放到一个小盒子中
Dialogue: 0,0:08:31.96,0:08:33.92,Default,,0,0,0,,如果有必要的话 我们可以打开那个盒子
Dialogue: 0,0:08:34.12,0:08:35.63,Default,,0,0,0,,看看其中有些什么
Dialogue: 0,0:08:37.77,0:08:39.16,Default,,0,0,0,,这就是那个小盒子
Dialogue: 0,0:08:39.20,0:08:40.38,Default,,0,0,0,,我这么来画它
Dialogue: 0,0:08:43.16,0:08:44.38,Default,,0,0,0,,我把它叫做REM
Dialogue: 0,0:08:46.44,0:08:48.60,Default,,0,0,0,,它接受A
Dialogue: 0,0:08:50.91,0:08:52.16,Default,,0,0,0,,同时也要接受B
Dialogue: 0,0:08:54.37,0:08:56.51,Default,,0,0,0,,它有一个输出
Dialogue: 0,0:08:58.89,0:09:00.46,Default,,0,0,0,,也就是A除以B的余数
Dialogue: 0,0:09:02.29,0:09:03.61,Default,,0,0,0,,在这里 我们同样需要能够
Dialogue: 0,0:09:03.64,0:09:06.06,Default,,0,0,0,,判断B是否等于0
Dialogue: 0,0:09:08.00,0:09:09.66,Default,,0,0,0,,也就是说 总得有个东西
Dialogue: 0,0:09:10.00,0:09:12.30,Default,,0,0,0,,去查询B的值
Dialogue: 0,0:09:13.39,0:09:14.40,Default,,0,0,0,,这是一个指示灯
Dialogue: 0,0:09:15.85,0:09:17.39,Default,,0,0,0,,当B等于0时 它就会点亮
Dialogue: 0,0:09:21.11,0:09:22.01,Default,,0,0,0,,它就是干这个的
Dialogue: 0,0:09:24.03,0:09:26.78,Default,,0,0,0,,最后 因为我们希望
Dialogue: 0,0:09:26.96,0:09:30.43,Default,,0,0,0,,A的新值是B的旧值
Dialogue: 0,0:09:30.46,0:09:34.41,Default,,0,0,0,,同时B的新值是有关于A的
Dialogue: 0,0:09:35.28,0:09:37.60,Default,,0,0,0,,如果我打算让机器
Dialogue: 0,0:09:37.80,0:09:39.74,Default,,0,0,0,,一次只发生一件事
Dialogue: 0,0:09:40.20,0:09:41.40,Default,,0,0,0,,一次执行一个动作
Dialogue: 0,0:09:41.61,0:09:43.42,Default,,0,0,0,,并且我不能在一个寄存器中放两个数字
Dialogue: 0,0:09:44.03,0:09:46.30,Default,,0,0,0,,那么进行互换时 必须有另外的地方放置一个数字
Dialogue: 0,0:09:49.29,0:09:49.60,Default,,0,0,0,,对吧？
Dialogue: 0,0:09:50.00,0:09:51.85,Default,,0,0,0,,我不能同时交换两手的东西
Dialogue: 0,0:09:52.11,0:09:53.72,Default,,0,0,0,,除非我一手拿两个
Dialogue: 0,0:09:53.72,0:09:55.13,Default,,0,0,0,,然后从中取另外一个
Dialogue: 0,0:09:55.50,0:09:56.91,Default,,0,0,0,,或者我先放下一个
Dialogue: 0,0:09:57.02,0:09:58.68,Default,,0,0,0,,取得另一个后再像这样捡起来
Dialogue: 0,0:09:59.64,0:10:00.94,Default,,0,0,0,,除非我是耍杂技的
Dialogue: 0,0:10:01.66,0:10:03.50,Default,,0,0,0,,当然正如大家所见 我并不是
Dialogue: 0,0:10:04.65,0:10:07.36,Default,,0,0,0,,这种情况下 我就会遇到时序错误
Dialogue: 0,0:10:08.85,0:10:11.04,Default,,0,0,0,,事实上 人们所做的许多类型的计算机设计
Dialogue: 0,0:10:11.07,0:10:12.68,Default,,0,0,0,,都遇到了时序错误
Dialogue: 0,0:10:13.12,0:10:15.00,Default,,0,0,0,,或者潜在的时序错误
Dialogue: 0,0:10:15.24,0:10:16.43,Default,,0,0,0,,我不太喜欢这种错误
Dialogue: 0,0:10:17.34,0:10:18.64,Default,,0,0,0,,因此 出于这个原因
Dialogue: 0,0:10:18.68,0:10:21.21,Default,,0,0,0,,我需要有一个地方来放置
Dialogue: 0,0:10:22.06,0:10:23.29,Default,,0,0,0,,其中的一个元素
Dialogue: 0,0:10:23.41,0:10:24.72,Default,,0,0,0,,因此 这里有一个寄存器
Dialogue: 0,0:10:24.75,0:10:26.84,Default,,0,0,0,,用来存放临时值T
Dialogue: 0,0:10:28.59,0:10:29.63,Default,,0,0,0,,上面有一个按钮
Dialogue: 0,0:10:30.47,0:10:31.88,Default,,0,0,0,,我会使用它的结果
Dialogue: 0,0:10:31.90,0:10:34.14,Default,,0,0,0,,因为我需要把这个结果送入B
Dialogue: 0,0:10:34.68,0:10:36.73,Default,,0,0,0,,我们会把结果像这样给送过来
Dialogue: 0,0:10:38.41,0:10:39.30,Default,,0,0,0,,这里同样有一个按钮
Dialogue: 0,0:10:42.43,0:10:45.84,Default,,0,0,0,,这就是GCD机器的数据通路
Dialogue: 0,0:10:47.60,0:10:48.57,Default,,0,0,0,,那么 控制器又是怎样的呢？
Dialogue: 0,0:10:49.74,0:10:51.28,Default,,0,0,0,,控制器同样很简单
Dialogue: 0,0:10:52.28,0:10:53.26,Default,,0,0,0,,机器具有状态
Dialogue: 0,0:10:54.38,0:10:57.72,Default,,0,0,0,,我喜欢形象地把它们比作迷宫
Dialogue: 0,0:10:59.01,0:11:03.20,Default,,0,0,0,,这个迷宫的各处是通过直接的箭头连接的
Dialogue: 0,0:11:04.43,0:11:05.60,Default,,0,0,0,,而我有一颗弹珠
Dialogue: 0,0:11:06.46,0:11:09.07,Default,,0,0,0,,它代表了控制器的状态
Dialogue: 0,0:11:10.74,0:11:12.27,Default,,0,0,0,,弹珠在迷宫中四处滚动
Dialogue: 0,0:11:13.74,0:11:17.15,Default,,0,0,0,,当然 这种类比因能量的原因而不成立
Dialogue: 0,0:11:17.15,0:11:19.08,Default,,0,0,0,,有时我不得不将弹珠泵到顶部
Dialogue: 0,0:11:19.12,0:11:21.85,Default,,0,0,0,,不然它就会成为一台永动机
Dialogue: 0,0:11:22.00,0:11:23.32,Default,,0,0,0,,但不用担心那么多
Dialogue: 0,0:11:23.90,0:11:25.90,Default,,0,0,0,,这并不是一个物理比喻
Dialogue: 0,0:11:26.08,0:11:27.42,Default,,0,0,0,,弹珠到处滚动
Dialogue: 0,0:11:27.68,0:11:29.56,Default,,0,0,0,,就像弹球机一样
Dialogue: 0,0:11:29.68,0:11:30.97,Default,,0,0,0,,每次当它滚动到一些缓冲器时
Dialogue: 0,0:11:31.26,0:11:32.60,Default,,0,0,0,,它就会按下这些按钮
Dialogue: 0,0:11:34.83,0:11:37.50,Default,,0,0,0,,它也会经常来到一个分支区域
Dialogue: 0,0:11:38.62,0:11:39.68,Default,,0,0,0,,它要在这里做选择
Dialogue: 0,0:11:40.25,0:11:42.36,Default,,0,0,0,,然后有一个由这个组件控制的挡板
Dialogue: 0,0:11:46.00,0:11:48.82,Default,,0,0,0,,所以这是一个非常机械化的思考方式
Dialogue: 0,0:11:48.82,0:11:51.05,Default,,0,0,0,,当然 真实计算机中的控制器
Dialogue: 0,0:11:51.08,0:11:51.84,Default,,0,0,0,,并不是这样的
Dialogue: 0,0:11:51.84,0:11:56.01,Default,,0,0,0,,而是由一些ROM和状态寄存器构成
Dialogue: 0,0:11:56.61,0:11:58.73,Default,,0,0,0,,但曾几何时 像DEC、PDP-6这些个机器
Dialogue: 0,0:11:59.29,0:12:01.02,Default,,0,0,0,,它们的控制器就是我们说的那样
Dialogue: 0,0:12:01.80,0:12:03.61,Default,,0,0,0,,延迟线上有一些比特信息
Dialogue: 0,0:12:05.69,0:12:08.14,Default,,0,0,0,,它随着时间的推移而触发事件
Dialogue: 0,0:12:08.58,0:12:10.70,Default,,0,0,0,,然后回到开始并再次轮回
Dialogue: 0,0:12:11.99,0:12:13.72,Default,,0,0,0,,当然 还有各种各样的错误
Dialogue: 0,0:12:13.74,0:12:17.67,Default,,0,0,0,,比如两个比特的信息 -- 对应两个弹珠
Dialogue: 0,0:12:17.67,0:12:19.26,Default,,0,0,0,,机器也会丢失弹珠
Dialogue: 0,0:12:19.45,0:12:20.20,Default,,0,0,0,,这也会发生
Dialogue: 0,0:12:20.98,0:12:21.58,Default,,0,0,0,,好吧
Dialogue: 0,0:12:22.27,0:12:24.22,Default,,0,0,0,,无论如何 对于这台机器
Dialogue: 0,0:12:24.27,0:12:25.48,Default,,0,0,0,,我想要这么来做
Dialogue: 0,0:12:25.80,0:12:27.74,Default,,0,0,0,,迷宫从这里开始
Dialogue: 0,0:12:30.52,0:12:32.73,Default,,0,0,0,,我首先要做的是
Dialogue: 0,0:12:33.76,0:12:36.75,Default,,0,0,0,,用一个你们非常熟悉的流程图记号
Dialogue: 0,0:12:37.07,0:12:39.85,Default,,0,0,0,,这是一个判断：B是否为0
Dialogue: 0,0:12:41.50,0:12:43.79,Default,,0,0,0,,如果判断为是的话
Dialogue: 0,0:12:43.93,0:12:45.58,Default,,0,0,0,,那我就做完了
Dialogue: 0,0:12:49.79,0:12:51.26,Default,,0,0,0,,否则的话
Dialogue: 0,0:12:52.70,0:12:54.32,Default,,0,0,0,,我就不得不滚动一些缓冲器
Dialogue: 0,0:12:55.00,0:12:56.46,Default,,0,0,0,,按照下列顺序执行
Dialogue: 0,0:12:57.42,0:13:03.40,Default,,0,0,0,,我想向这样来做一个互换游戏
Dialogue: 0,0:13:04.05,0:13:05.80,Default,,0,0,0,,首先 因为我需要A和B
Dialogue: 0,0:13:06.32,0:13:08.57,Default,,0,0,0,,但首先 -- 虽然并不是必要的
Dialogue: 0,0:13:08.65,0:13:09.72,Default,,0,0,0,,我需要先把它们收集起来
Dialogue: 0,0:13:11.07,0:13:12.62,Default,,0,0,0,,这里的值要送入到B中
Dialogue: 0,0:13:13.24,0:13:14.03,Default,,0,0,0,,因此 我会说
Dialogue: 0,0:13:14.28,0:13:16.27,Default,,0,0,0,,用A和B的值来计算这个
Dialogue: 0,0:13:16.36,0:13:18.67,Default,,0,0,0,,并把算得的余数放到这里
Dialogue: 0,0:13:19.15,0:13:20.33,Default,,0,0,0,,因此 我首先要按下这个按钮
Dialogue: 0,0:13:21.53,0:13:24.43,Default,,0,0,0,,然后我要把B的值送入A
Dialogue: 0,0:13:24.44,0:13:25.60,Default,,0,0,0,,通过按这个钮来实现
Dialogue: 0,0:13:25.82,0:13:27.63,Default,,0,0,0,,然后我再把临时值送入B
Dialogue: 0,0:13:28.76,0:13:29.42,Default,,0,0,0,,通过这个按钮实现
Dialogue: 0,0:13:32.03,0:13:34.97,Default,,0,0,0,,这是一个相当时序化的机器
Dialogue: 0,0:13:35.39,0:13:36.52,Default,,0,0,0,,它非常的低效
Dialogue: 0,0:13:37.75,0:13:39.05,Default,,0,0,0,,但目前来说还好
Dialogue: 0,0:13:39.81,0:13:40.97,Default,,0,0,0,,我们来为按钮命名
Dialogue: 0,0:13:41.47,0:13:42.72,Default,,0,0,0,,T←R
Dialogue: 0,0:13:46.75,0:13:48.73,Default,,0,0,0,,A←B
Dialogue: 0,0:13:50.03,0:13:54.81,Default,,0,0,0,,B←T
Dialogue: 0,0:13:55.47,0:13:57.63,Default,,0,0,0,,然后我要来到这里
Dialogue: 0,0:13:58.78,0:13:59.88,Default,,0,0,0,,也就是回到开始的地方
Dialogue: 0,0:14:01.62,0:14:03.87,Default,,0,0,0,,在这里 我们看到了什么？
Dialogue: 0,0:14:03.87,0:14:04.91,Default,,0,0,0,,我们看到各种各样的 --
Dialogue: 0,0:14:05.05,0:14:07.16,Default,,0,0,0,,我们真正拥有的是某种机械连接
Dialogue: 0,0:14:07.42,0:14:13.63,Default,,0,0,0,,其中T←R控制了这个东西
Dialogue: 0,0:14:16.83,0:14:21.48,Default,,0,0,0,,A←B控制了这个东西
Dialogue: 0,0:14:26.96,0:14:28.12,Default,,0,0,0,,而这里的这个东西
Dialogue: 0,0:14:28.12,0:14:31.08,Default,,0,0,0,,同学们 这简直太恶劣了
Dialogue: 0,0:14:31.48,0:14:32.48,Default,,0,0,0,,一点也没有优化
Dialogue: 0,0:14:32.63,0:14:34.59,Default,,0,0,0,,我画的所有线条都相互交叉
Dialogue: 0,0:14:38.54,0:14:41.15,Default,,0,0,0,,我想B←T控制的是这个
Dialogue: 0,0:14:45.69,0:14:47.95,Default,,0,0,0,,现在 我就要运行这台机器了
Dialogue: 0,0:14:48.04,0:14:49.34,Default,,0,0,0,,但是在我运行它之前
Dialogue: 0,0:14:49.37,0:14:51.40,Default,,0,0,0,,我想写下它的控制器的描述
Dialogue: 0,0:14:51.63,0:14:52.81,Default,,0,0,0,,以便使你们相信
Dialogue: 0,0:14:52.84,0:14:55.63,Default,,0,0,0,,这些东西可以组织成某种良好的语言
Dialogue: 0,0:14:56.08,0:14:58.08,Default,,0,0,0,,这样我们就不必总是像这样画图
Dialogue: 0,0:14:58.36,0:15:00.68,Default,,0,0,0,,图示的缺陷之一 就是占用了太多空间
Dialogue: 0,0:15:00.89,0:15:01.98,Default,,0,0,0,,对于这样的一个小型机器来说
Dialogue: 0,0:15:02.00,0:15:03.05,Default,,0,0,0,,它占用了两块黑板
Dialogue: 0,0:15:03.22,0:15:05.24,Default,,0,0,0,,而一台求值器机器
Dialogue: 0,0:15:05.40,0:15:07.10,Default,,0,0,0,,我就很难将它画在这间屋子里了
Dialogue: 0,0:15:07.95,0:15:09.16,Default,,0,0,0,,尽管它还不是非常大
Dialogue: 0,0:15:09.90,0:15:11.28,Default,,0,0,0,,因此我要为它构造一门小型语言
Dialogue: 0,0:15:11.29,0:15:12.51,Default,,0,0,0,,用来描述这个机器
Dialogue: 0,0:15:13.10,0:15:23.29,Default,,0,0,0,,(DEFIME-MACHINE GCD
Dialogue: 0,0:15:24.42,0:15:25.66,Default,,0,0,0,,当然 一旦我们有了像这样的描述
Dialogue: 0,0:15:25.68,0:15:26.83,Default,,0,0,0,,我们就能够模拟该机器
Dialogue: 0,0:15:27.22,0:15:29.42,Default,,0,0,0,,我之所以想构建这种形式的语言
Dialogue: 0,0:15:29.56,0:15:32.94,Default,,0,0,0,,是因为我们能够立即操纵这些表达式
Dialogue: 0,0:15:33.21,0:15:34.91,Default,,0,0,0,,因此 我也就能够
Dialogue: 0,0:15:35.29,0:15:38.16,Default,,0,0,0,,代数地操作 或者模拟这些东西
Dialogue: 0,0:15:38.20,0:15:39.96,Default,,0,0,0,,以及各种各样我想进行的操作
Dialogue: 0,0:15:40.12,0:15:42.59,Default,,0,0,0,,或者还可以把它们转换成布局图 谁知道呢？
Dialogue: 0,0:15:43.63,0:15:48.38,Default,,0,0,0,,一旦我有了寄存器的良好表示
Dialogue: 0,0:15:48.51,0:15:49.61,Default,,0,0,0,,它有一些寄存器
Dialogue: 0,0:15:53.00,0:15:55.64,Default,,0,0,0,,记作(REGISTERS A B T)
Dialogue: 0,0:15:56.75,0:15:57.80,Default,,0,0,0,,它还有控制器
Dialogue: 0,0:16:02.19,0:16:04.46,Default,,0,0,0,,实际上 更好的做法是让它更显式一些
Dialogue: 0,0:16:04.49,0:16:06.97,Default,,0,0,0,,也就是说 为每一个按钮命名
Dialogue: 0,0:16:08.14,0:16:10.17,Default,,0,0,0,,并指明它们的操作
Dialogue: 0,0:16:10.42,0:16:11.37,Default,,0,0,0,,比如说这个按钮
Dialogue: 0,0:16:11.55,0:16:14.19,Default,,0,0,0,,会让T的值送入到B中
Dialogue: 0,0:16:15.10,0:16:16.09,Default,,0,0,0,,但我却不想这么做
Dialogue: 0,0:16:16.11,0:16:17.95,Default,,0,0,0,,因为这样会让代码难以阅读
Dialogue: 0,0:16:18.20,0:16:19.34,Default,,0,0,0,,也会占用更多空间
Dialogue: 0,0:16:19.51,0:16:22.36,Default,,0,0,0,,所以我会把相关的指令写在控制器中
Dialogue: 0,0:16:23.29,0:16:25.24,Default,,0,0,0,,这样就隐式地指明了具体的操作
Dialogue: 0,0:16:26.32,0:16:28.57,Default,,0,0,0,,可以通过阅读代码推断出来
Dialogue: 0,0:16:29.16,0:16:31.39,Default,,0,0,0,,并收集所有可以完成的不同事情
Dialogue: 0,0:16:31.69,0:16:33.50,Default,,0,0,0,,我们来看一看
Dialogue: 0,0:16:33.50,0:16:34.70,Default,,0,0,0,,我们来看下这些东西是什么吧
Dialogue: 0,0:16:35.71,0:16:37.29,Default,,0,0,0,,首先是一个循环
Dialogue: 0,0:16:38.24,0:16:40.20,Default,,0,0,0,,先是一条分支指令
Dialogue: 0,0:16:42.64,0:16:46.46,Default,,0,0,0,,这个就对应了机器中的小挡板
Dialogue: 0,0:16:46.89,0:16:48.49,Default,,0,0,0,,它决定了你在此处的走向
Dialogue: 0,0:16:49.10,0:16:58.00,Default,,0,0,0,,判断 -- 取B的值 并判断是否为0
Dialogue: 0,0:16:58.65,0:17:00.06,Default,,0,0,0,,如果B的值是0
Dialogue: 0,0:17:00.32,0:17:01.72,Default,,0,0,0,,那么就跳转到一个叫DONE的地方
Dialogue: 0,0:17:03.64,0:17:05.29,Default,,0,0,0,,现在 你们在这里看到的是
Dialogue: 0,0:17:05.29,0:17:07.40,Default,,0,0,0,,这个看起来非常像传统计算机语言
Dialogue: 0,0:17:08.17,0:17:09.55,Default,,0,0,0,,但你们所见的是
Dialogue: 0,0:17:10.03,0:17:12.00,Default,,0,0,0,,一些个标签
Dialogue: 0,0:17:12.99,0:17:16.86,Default,,0,0,0,,它们代表着存放了一系列指令的地方
Dialogue: 0,0:17:17.60,0:17:18.94,Default,,0,0,0,,之所以需要它们
Dialogue: 0,0:17:19.48,0:17:21.15,Default,,0,0,0,,是因为在这里
Dialogue: 0,0:17:21.45,0:17:22.81,Default,,0,0,0,,我表达了“循环”的概念
Dialogue: 0,0:17:23.32,0:17:26.11,Default,,0,0,0,,但是如果我是在写英文之类的文本
Dialogue: 0,0:17:26.44,0:17:28.09,Default,,0,0,0,,就很难去引用一个位置
Dialogue: 0,0:17:28.58,0:17:29.53,Default,,0,0,0,,我没有箭头
Dialogue: 0,0:17:30.80,0:17:33.02,Default,,0,0,0,,箭头是通过
Dialogue: 0,0:17:33.05,0:17:34.44,Default,,0,0,0,,给箭头所指的地方命名来表示的
Dialogue: 0,0:17:34.57,0:17:36.28,Default,,0,0,0,,并通过名字来引用
Dialogue: 0,0:17:37.40,0:17:38.59,Default,,0,0,0,,这只是一种编码
Dialogue: 0,0:17:39.86,0:17:41.88,Default,,0,0,0,,而不是某种魔法
Dialogue: 0,0:17:43.15,0:17:44.96,Default,,0,0,0,,接下来我们要做的是
Dialogue: 0,0:17:45.02,0:17:46.84,Default,,0,0,0,,我们如何来实现T←R
Dialogue: 0,0:17:47.45,0:17:49.76,Default,,0,0,0,,非常简单 用ASSIGN
Dialogue: 0,0:17:52.19,0:17:55.55,Default,,0,0,0,,我们把余数赋值给T
Dialogue: 0,0:17:56.32,0:17:59.24,Default,,0,0,0,,ASSIGN就是按钮的名字
Dialogue: 0,0:18:01.47,0:18:02.64,Default,,0,0,0,,就是按按钮的家伙
Dialogue: 0,0:18:03.14,0:18:04.97,Default,,0,0,0,,把余数赋给T
Dialogue: 0,0:18:04.99,0:18:06.76,Default,,0,0,0,,这个操作是这样表示的
Dialogue: 0,0:18:11.74,0:18:17.53,Default,,0,0,0,,取A、B的值 相除得到余数
Dialogue: 0,0:18:23.85,0:18:30.99,Default,,0,0,0,,同时 我们也要取B的值 赋给A
Dialogue: 0,0:18:34.99,0:18:47.88,Default,,0,0,0,,再取T的值赋给B
Dialogue: 0,0:18:49.61,0:18:51.85,Default,,0,0,0,,现在 我需要引用这个开头
Dialogue: 0,0:18:53.18,0:18:55.92,Default,,0,0,0,,呃 我为什么不把这里叫做LOOP呢？
Dialogue: 0,0:19:04.09,0:19:07.04,Default,,0,0,0,,这就是如何引用这个箭头
Dialogue: 0,0:19:07.61,0:19:08.95,Default,,0,0,0,,当执行到DONE时 就完成了所有操作
Dialogue: 0,0:19:09.02,0:19:13.07,Default,,0,0,0,,我们来到了这里 所有指令的结尾
Dialogue: 0,0:19:15.26,0:19:17.04,Default,,0,0,0,,这段文字化描述的就是
Dialogue: 0,0:19:17.69,0:19:20.86,Default,,0,0,0,,我们在这里画的一小部分机器
Dialogue: 0,0:19:21.66,0:19:24.84,Default,,0,0,0,,下面 我就要运行它
Dialogue: 0,0:19:25.49,0:19:26.65,Default,,0,0,0,,我想让你们感受一下它的运行
Dialogue: 0,0:19:27.62,0:19:29.80,Default,,0,0,0,,从来没有做过这个 你必须做一次
Dialogue: 0,0:19:31.01,0:19:32.62,Default,,0,0,0,,让我们以一个具体的问题来演示
Dialogue: 0,0:19:33.10,0:19:34.70,Default,,0,0,0,,假设我们想要计算
Dialogue: 0,0:19:35.04,0:19:40.68,Default,,0,0,0,,30和42的最大公约数
Dialogue: 0,0:19:42.21,0:19:44.92,Default,,0,0,0,,我现在不知道结果是多少
Dialogue: 0,0:19:45.86,0:19:47.60,Default,,0,0,0,,但我知道A=30而B=42
Dialogue: 0,0:19:50.96,0:19:52.09,Default,,0,0,0,,我就这么着开始
Dialogue: 0,0:19:52.60,0:19:53.90,Default,,0,0,0,,那么 我首先要做些什么呢？
Dialogue: 0,0:19:54.24,0:19:56.86,Default,,0,0,0,,我先判断B是否为0：否
Dialogue: 0,0:19:57.59,0:20:02.11,Default,,0,0,0,,然后计算A除B的余数 并赋给T
Dialogue: 0,0:20:02.80,0:20:07.60,Default,,0,0,0,,当然 30除以42的余数就是30自己
Dialogue: 0,0:20:11.13,0:20:12.03,Default,,0,0,0,,按下那个按钮
Dialogue: 0,0:20:12.92,0:20:15.10,Default,,0,0,0,,现在弹珠就滚动到了这里
Dialogue: 0,0:20:17.10,0:20:18.06,Default,,0,0,0,,A←B
Dialogue: 0,0:20:19.02,0:20:20.76,Default,,0,0,0,,又按下了这个按钮
Dialogue: 0,0:20:21.22,0:20:22.54,Default,,0,0,0,,因此42来到了这里
Dialogue: 0,0:20:26.59,0:20:27.60,Default,,0,0,0,,B←T
Dialogue: 0,0:20:28.36,0:20:29.34,Default,,0,0,0,,按下了这个按钮
Dialogue: 0,0:20:29.87,0:20:30.96,Default,,0,0,0,,30来到了这里
Dialogue: 0,0:20:32.57,0:20:33.69,Default,,0,0,0,,这样我就交换了它们
Dialogue: 0,0:20:34.66,0:20:38.27,Default,,0,0,0,,我们再来看看 回到开始
Dialogue: 0,0:20:38.64,0:20:39.72,Default,,0,0,0,,B为0么？不
Dialogue: 0,0:20:40.19,0:20:41.50,Default,,0,0,0,,将余数赋给T
Dialogue: 0,0:20:43.23,0:20:46.30,Default,,0,0,0,,我想 42除以30的余数是12
Dialogue: 0,0:20:47.24,0:20:48.30,Default,,0,0,0,,按下这个钮
Dialogue: 0,0:20:48.53,0:20:51.40,Default,,0,0,0,,下面 我想让30来到这里
Dialogue: 0,0:20:53.90,0:20:55.95,Default,,0,0,0,,按下这个钮 让12来到这里
Dialogue: 0,0:20:58.41,0:21:00.38,Default,,0,0,0,,然后继续
Dialogue: 0,0:21:00.38,0:21:01.31,Default,,0,0,0,,程序执行完了么？
Dialogue: 0,0:21:01.53,0:21:02.12,Default,,0,0,0,,并没有
Dialogue: 0,0:21:02.36,0:21:08.22,Default,,0,0,0,,现在 我需要求解30除以12的余数
Dialogue: 0,0:21:08.85,0:21:10.67,Default,,0,0,0,,我想答案是6
Dialogue: 0,0:21:12.42,0:21:15.13,Default,,0,0,0,,按下这个钮 6就到了这里
Dialogue: 0,0:21:16.20,0:21:18.25,Default,,0,0,0,,然后我又按下这个钮
Dialogue: 0,0:21:18.30,0:21:19.61,Default,,0,0,0,,这就让12来到了这里
Dialogue: 0,0:21:23.73,0:21:25.09,Default,,0,0,0,,然后我又按下这个按钮
Dialogue: 0,0:21:25.09,0:21:26.00,Default,,0,0,0,,6就来到了这里
Dialogue: 0,0:21:29.85,0:21:31.68,Default,,0,0,0,,6等于0么？
Dialogue: 0,0:21:31.88,0:21:32.49,Default,,0,0,0,,不等于
Dialogue: 0,0:21:33.42,0:21:33.98,Default,,0,0,0,,好的
Dialogue: 0,0:21:34.38,0:21:36.80,Default,,0,0,0,,因此这时
Dialogue: 0,0:21:36.89,0:21:38.12,Default,,0,0,0,,接下来又要计算余数
Dialogue: 0,0:21:38.14,0:21:39.80,Default,,0,0,0,,哦 这个的余数是0
Dialogue: 0,0:21:40.66,0:21:41.74,Default,,0,0,0,,看起来我们就快完成了
Dialogue: 0,0:21:42.36,0:21:44.36,Default,,0,0,0,,将6从这里挪到这里
Dialogue: 0,0:21:47.00,0:21:48.27,Default,,0,0,0,,0移动到这里
Dialogue: 0,0:21:49.09,0:21:50.20,Default,,0,0,0,,0等于0么？
Dialogue: 0,0:21:50.20,0:21:50.73,Default,,0,0,0,,是的
Dialogue: 0,0:21:51.34,0:21:53.36,Default,,0,0,0,,B的值等于0 因此答案就是A的值
Dialogue: 0,0:21:54.28,0:21:55.76,Default,,0,0,0,,因此答案就是6
Dialogue: 0,0:21:56.61,0:21:57.61,Default,,0,0,0,,这确实是正确的答案
Dialogue: 0,0:21:57.63,0:21:59.47,Default,,0,0,0,,因为如果我们回过头审视最初的问题
Dialogue: 0,0:22:00.08,0:22:06.64,Default,,0,0,0,,我们知道30=2×3×5
Dialogue: 0,0:22:07.00,0:22:11.12,Default,,0,0,0,,42=2×3×7
Dialogue: 0,0:22:11.67,0:22:14.11,Default,,0,0,0,,因此最大公约数就是2×3
Dialogue: 0,0:22:14.20,0:22:15.08,Default,,0,0,0,,也就是6
Dialogue: 0,0:22:18.38,0:22:20.56,Default,,0,0,0,,我们通常在这里画另外一条线
Dialogue: 0,0:22:20.59,0:22:22.52,Default,,0,0,0,,为了使它更清晰一点
Dialogue: 0,0:22:22.89,0:22:27.71,Default,,0,0,0,,在这两者之间建立了联系
Dialogue: 0,0:22:27.85,0:22:31.01,Default,,0,0,0,,小挡板需要根据这个指示灯来工作
Dialogue: 0,0:22:34.00,0:22:37.32,Default,,0,0,0,,当然 跟我给你们展示的东西相比
Dialogue: 0,0:22:37.85,0:22:40.00,Default,,0,0,0,,真实计算机的组件更加复杂
Dialogue: 0,0:22:41.35,0:22:47.16,Default,,0,0,0,,让我们来看看第一张幻灯片
Dialogue: 0,0:22:47.98,0:22:48.81,Default,,0,0,0,,哇
Dialogue: 0,0:22:50.19,0:22:52.43,Default,,0,0,0,,我们看到 我们想要做的就是
Dialogue: 0,0:22:52.65,0:22:55.85,Default,,0,0,0,,IO形式的操作
Dialogue: 0,0:22:56.84,0:23:01.42,Default,,0,0,0,,我们需要从外部搜集一些东西
Dialogue: 0,0:23:01.98,0:23:03.93,Default,,0,0,0,,因此 对我们的状态机器来说
Dialogue: 0,0:23:04.30,0:23:07.02,Default,,0,0,0,,它们的控制器
Dialogue: 0,0:23:07.26,0:23:10.56,Default,,0,0,0,,可能会从某处取得某值
Dialogue: 0,0:23:10.78,0:23:12.41,Default,,0,0,0,,将它们放入寄存器并从中读取
Dialogue: 0,0:23:13.49,0:23:15.92,Default,,0,0,0,,我还可以把另外的值加载到寄存器B中
Dialogue: 0,0:23:17.07,0:23:18.60,Default,,0,0,0,,稍后 当执行完毕后
Dialogue: 0,0:23:18.99,0:23:20.52,Default,,0,0,0,,我想要输出结果
Dialogue: 0,0:23:21.20,0:23:25.23,Default,,0,0,0,,当然 答案或简单或复杂
Dialogue: 0,0:23:26.09,0:23:28.03,Default,,0,0,0,,我写代码的时候 总假设PRINT很简单
Dialogue: 0,0:23:28.09,0:23:29.29,Default,,0,0,0,,READ也很简单
Dialogue: 0,0:23:29.88,0:23:31.08,Default,,0,0,0,,但实际上 在真实世界中
Dialogue: 0,0:23:31.12,0:23:32.89,Default,,0,0,0,,这些都是非常复杂的操作
Dialogue: 0,0:23:33.08,0:23:35.52,Default,,0,0,0,,跟你尝试求解的问题相比
Dialogue: 0,0:23:35.55,0:23:38.33,Default,,0,0,0,,它们通常更加庞大而复杂
Dialogue: 0,0:23:41.67,0:23:43.90,Default,,0,0,0,,另一方面 我犹记得
Dialogue: 0,0:23:44.89,0:23:48.78,Default,,0,0,0,,使用IBM 7090一类的计算机的时候
Dialogue: 0,0:23:49.05,0:23:53.04,Default,,0,0,0,,它的READ和WRITE只能操作单个对象
Dialogue: 0,0:23:53.08,0:23:54.62,Default,,0,0,0,,也就是一个数字
Dialogue: 0,0:23:55.84,0:23:58.54,Default,,0,0,0,,这就是一个基本的IO操作
Dialogue: 0,0:23:59.63,0:24:02.04,Default,,0,0,0,,我们这里有同样的操作
Dialogue: 0,0:24:02.33,0:24:04.67,Default,,0,0,0,,在这样的一台机器中
Dialogue: 0,0:24:05.44,0:24:06.89,Default,,0,0,0,,我们实际上在做什么？
Dialogue: 0,0:24:07.12,0:24:11.60,Default,,0,0,0,,我们看到 这个叫做“READ”的组件是数据源头
Dialogue: 0,0:24:12.20,0:24:14.46,Default,,0,0,0,,这个操作总是返回一个值
Dialogue: 0,0:24:14.66,0:24:17.13,Default,,0,0,0,,我们可以把它看做 总是返回一个值
Dialogue: 0,0:24:17.21,0:24:19.84,Default,,0,0,0,,它可以赋给寄存器A或B
Dialogue: 0,0:24:21.66,0:24:23.23,Default,,0,0,0,,而PRINT这个过程呢
Dialogue: 0,0:24:23.37,0:24:25.02,Default,,0,0,0,,当你正确连接它的时候
Dialogue: 0,0:24:25.24,0:24:26.43,Default,,0,0,0,,当你按下上面的按钮
Dialogue: 0,0:24:26.65,0:24:29.61,Default,,0,0,0,,就会打印出当前寄存器A中的值
Dialogue: 0,0:24:31.66,0:24:32.73,Default,,0,0,0,,这非常普通
Dialogue: 0,0:24:33.32,0:24:35.20,Default,,0,0,0,,这是我们想要的一种功能
Dialogue: 0,0:24:35.88,0:24:38.32,Default,,0,0,0,,但这里还有些其它事情需要我们担忧
Dialogue: 0,0:24:38.32,0:24:40.67,Default,,0,0,0,,比如说 这里我使用了一些复杂的机制
Dialogue: 0,0:24:41.05,0:24:42.48,Default,,0,0,0,,我们这里有REMAINDER组件
Dialogue: 0,0:24:43.85,0:24:44.44,Default,,0,0,0,,这是个什么东西呢？
Dialogue: 0,0:24:44.69,0:24:46.41,Default,,0,0,0,,求取余数的计算过程并不是那么“显然”
Dialogue: 0,0:24:46.92,0:24:48.92,Default,,0,0,0,,如果我们把这个组件给拆开
Dialogue: 0,0:24:49.48,0:24:50.62,Default,,0,0,0,,就会得到一整台机器
Dialogue: 0,0:24:51.84,0:24:53.66,Default,,0,0,0,,事实就是这样的
Dialogue: 0,0:24:54.54,0:24:59.15,Default,,0,0,0,,举例来说 如果要编程实现REMAINDER
Dialogue: 0,0:24:59.44,0:25:02.44,Default,,0,0,0,,最简单的算法就是 不断地做减法
Dialogue: 0,0:25:04.78,0:25:05.95,Default,,0,0,0,,这是因为 除法可以通过
Dialogue: 0,0:25:05.96,0:25:08.99,Default,,0,0,0,,对整数不断做减法来实现
Dialogue: 0,0:25:09.80,0:25:23.58,Default,,0,0,0,,N除以D的余数不外乎就是
Dialogue: 0,0:25:24.99,0:25:31.44,Default,,0,0,0,,如果N小于D的话
Dialogue: 0,0:25:32.24,0:25:33.66,Default,,0,0,0,,答案就是N
Dialogue: 0,0:25:34.30,0:25:35.90,Default,,0,0,0,,否则的话就是
Dialogue: 0,0:25:41.15,0:25:47.60,Default,,0,0,0,,N先减去D
Dialogue: 0,0:25:48.27,0:25:49.32,Default,,0,0,0,,再除以D的余数
Dialogue: 0,0:25:51.28,0:25:55.05,Default,,0,0,0,,天啊 这个看起来就像是GCD程序
Dialogue: 0,0:25:56.89,0:25:59.48,Default,,0,0,0,,当然 这个不是求余数的最优算法
Dialogue: 0,0:25:59.75,0:26:00.91,Default,,0,0,0,,在实际中 你应该使用那些
Dialogue: 0,0:26:00.92,0:26:05.42,Default,,0,0,0,,二进制运算、移位运算等操作
Dialogue: 0,0:26:05.55,0:26:06.97,Default,,0,0,0,,但关键点就是
Dialogue: 0,0:26:07.13,0:26:08.48,Default,,0,0,0,,如果我把这些组件打开
Dialogue: 0,0:26:08.92,0:26:10.64,Default,,0,0,0,,我可能会发现其中有一台计算机
Dialogue: 0,0:26:11.88,0:26:12.99,Default,,0,0,0,,现在我们就知道它的原理了
Dialogue: 0,0:26:13.51,0:26:14.33,Default,,0,0,0,,因为我们就造过一台
Dialogue: 0,0:26:15.64,0:26:17.10,Default,,0,0,0,,这些个机器都大同小异
Dialogue: 0,0:26:17.40,0:26:18.06,Default,,0,0,0,,另外一方面
Dialogue: 0,0:26:18.08,0:26:20.00,Default,,0,0,0,,我们可能想要构建一台更高效
Dialogue: 0,0:26:20.01,0:26:21.68,Default,,0,0,0,,组织更精良的机器
Dialogue: 0,0:26:21.85,0:26:23.96,Default,,0,0,0,,比如说 多次利用其中的寄存器
Dialogue: 0,0:26:24.00,0:26:27.05,Default,,0,0,0,,或者是硬件设计者能想到的其它可怕混乱
Dialogue: 0,0:26:27.31,0:26:28.60,Default,,0,0,0,,等等原因
Dialogue: 0,0:26:29.25,0:26:31.56,Default,,0,0,0,,比如说 你们所见的这台机器
Dialogue: 0,0:26:32.52,0:26:34.91,Default,,0,0,0,,不是让你们去细读它的结构的
Dialogue: 0,0:26:35.05,0:26:37.52,Default,,0,0,0,,它有些复杂 对吧？
Dialogue: 0,0:26:37.52,0:26:39.87,Default,,0,0,0,,但它实际上是
Dialogue: 0,0:26:40.09,0:26:43.82,Default,,0,0,0,,整合了REMAINDER的GCD机器
Dialogue: 0,0:26:44.46,0:26:46.02,Default,,0,0,0,,并且实际上 它没有多余的寄存器
Dialogue: 0,0:26:46.02,0:26:48.62,Default,,0,0,0,,数据通路上有三个寄存器
Dialogue: 0,0:26:49.05,0:26:50.64,Default,,0,0,0,,但现在 这里有个减法器
Dialogue: 0,0:26:51.55,0:26:52.99,Default,,0,0,0,,又有两个东西被测试
Dialogue: 0,0:26:53.02,0:26:55.07,Default,,0,0,0,,B等于0么？
Dialogue: 0,0:26:55.23,0:26:56.56,Default,,0,0,0,,T小于B么？
Dialogue: 0,0:26:57.25,0:26:59.45,Default,,0,0,0,,而至于这一块的控制器
Dialogue: 0,0:27:00.22,0:27:01.76,Default,,0,0,0,,并不会更加复杂
Dialogue: 0,0:27:01.85,0:27:03.87,Default,,0,0,0,,它有两个循环
Dialogue: 0,0:27:04.52,0:27:08.33,Default,,0,0,0,,最主要的循环是计算GCD的
Dialogue: 0,0:27:08.40,0:27:10.14,Default,,0,0,0,,而另一条是减法循环
Dialogue: 0,0:27:10.43,0:27:12.80,Default,,0,0,0,,是用来计算余数的子操作
Dialogue: 0,0:27:14.03,0:27:15.80,Default,,0,0,0,,当然 还有一种思考方式
Dialogue: 0,0:27:15.96,0:27:18.68,Default,,0,0,0,,就是把求余数程序
Dialogue: 0,0:27:19.92,0:27:21.71,Default,,0,0,0,,如果我把那边的REMAINDER机器
Dialogue: 0,0:27:21.72,0:27:22.83,Default,,0,0,0,,当作LAMBDA表达式
Dialogue: 0,0:27:23.56,0:27:27.02,Default,,0,0,0,,代换到GCD程序的REMAINDER中
Dialogue: 0,0:27:28.20,0:27:30.12,Default,,0,0,0,,然后再做一些化简
Dialogue: 0,0:27:30.32,0:27:33.66,Default,,0,0,0,,代换其中的A和B
Dialogue: 0,0:27:34.46,0:27:35.95,Default,,0,0,0,,那么 我就可以展开这个循环
Dialogue: 0,0:27:36.63,0:27:39.42,Default,,0,0,0,,那么我就可以通过
Dialogue: 0,0:27:40.73,0:27:42.94,Default,,0,0,0,,LAMBDA表达式的基本代数化简
Dialogue: 0,0:27:43.36,0:27:45.21,Default,,0,0,0,,来得到这台机器
Dialogue: 0,0:27:48.55,0:27:51.20,Default,,0,0,0,,我想 你们已经见识了一个非常简单的机器了
Dialogue: 0,0:27:51.95,0:27:53.28,Default,,0,0,0,,有什么疑问么？
Dialogue: 0,0:28:02.70,0:28:03.10,Default,,0,0,0,,很好
Dialogue: 0,0:28:05.36,0:28:06.54,Default,,0,0,0,,看起来很容易 难道不是吗？
Dialogue: 0,0:28:10.14,0:28:11.32,Default,,0,0,0,,好吧 休息一下 谢谢大家
Dialogue: 0,0:28:12.54,0:28:24.94,Default,,0,0,0,,[音乐]
Dialogue: 0,0:28:25.13,0:28:28.08,Declare,,0,0,0,,{\an2\fad(500,500)}《计算机程序的构造和解释》
Dialogue: 0,0:28:31.37,0:28:34.70,Declare,,0,0,0,,{\an2\fad(500,500)}讲师：哈罗德·艾伯森教授 及 格兰德·杰·萨斯曼教授
Dialogue: 0,0:28:34.76,0:28:38.00,Declare,,0,0,0,,{\an2\fad(500,500)}《计算机程序的构造和解释》
Dialogue: 0,0:28:38.00,0:28:43.29,Declare,,0,0,0,,{\an2\fad(500,500)}寄存机器
Dialogue: 0,0:28:47.93,0:28:48.70,Default,,0,0,0,,教授：好吧
Dialogue: 0,0:28:49.37,0:28:52.46,Default,,0,0,0,,现在 你们已经知道如何去把迭代过程
Dialogue: 0,0:28:52.54,0:28:54.54,Default,,0,0,0,,或者是产生迭代计算的过程
Dialogue: 0,0:28:55.18,0:28:56.52,Default,,0,0,0,,变成一台机器
Dialogue: 0,0:28:57.77,0:29:00.04,Default,,0,0,0,,我想 接下来我们就应该考虑
Dialogue: 0,0:29:00.54,0:29:02.30,Default,,0,0,0,,如何来处理递归过程了
Dialogue: 0,0:29:02.81,0:29:05.05,Default,,0,0,0,,我们先从一个简单的阶乘过程开始
Dialogue: 0,0:29:11.20,0:29:16.94,Default,,0,0,0,,(DEFINE (FACT N)
Dialogue: 0,0:29:19.63,0:29:24.25,Default,,0,0,0,,如果N=1 那么结果就是1
Dialogue: 0,0:29:24.62,0:29:27.69,Default,,0,0,0,,为了减少模拟它的工作量 我就使用1
Dialogue: 0,0:29:28.12,0:29:33.94,Default,,0,0,0,,否则结果就是(* N (FACT (- N 1)))
Dialogue: 0,0:29:42.52,0:29:46.04,Default,,0,0,0,,正如你们所知 这个程序的不同之处在于
Dialogue: 0,0:29:46.65,0:29:50.36,Default,,0,0,0,,这里 我在计算(FACT (- N 1))之后
Dialogue: 0,0:29:50.67,0:29:52.26,Default,,0,0,0,,我要对结果做一些运算
Dialogue: 0,0:29:52.26,0:29:53.68,Default,,0,0,0,,我要将它与N相乘
Dialogue: 0,0:29:56.00,0:30:00.67,Default,,0,0,0,,将这台机器可视化的唯一途径就是
Dialogue: 0,0:30:01.08,0:30:02.01,Default,,0,0,0,,首先 由于--
Dialogue: 0,0:30:02.35,0:30:03.18,Default,,0,0,0,,请你们这么来想
Dialogue: 0,0:30:03.36,0:30:04.94,Default,,0,0,0,,这里 我有一台机器
Dialogue: 0,0:30:05.08,0:30:08.11,Default,,0,0,0,,而这台机器又需要某个阶乘机器来计算结果
Dialogue: 0,0:30:09.32,0:30:11.16,Default,,0,0,0,,但外面的这台机器
Dialogue: 0,0:30:11.20,0:30:13.02,Default,,0,0,0,,又需要在调用内部阶乘机器
Dialogue: 0,0:30:13.92,0:30:15.72,Default,,0,0,0,,的前后都要存在
Dialogue: 0,0:30:16.80,0:30:17.90,Default,,0,0,0,,然而在迭代情况中
Dialogue: 0,0:30:18.75,0:30:20.52,Default,,0,0,0,,外面的机器不需要
Dialogue: 0,0:30:20.91,0:30:24.01,Default,,0,0,0,,在内部机器运行后保持存在
Dialogue: 0,0:30:24.83,0:30:26.16,Default,,0,0,0,,这是因为你不需要回到
Dialogue: 0,0:30:26.19,0:30:27.53,Default,,0,0,0,,外部机器来进行其它操作
Dialogue: 0,0:30:28.64,0:30:30.06,Default,,0,0,0,,因此 我们这里的问题是
Dialogue: 0,0:30:30.27,0:30:30.97,Default,,0,0,0,,我们的机器内部
Dialogue: 0,0:30:31.00,0:30:32.73,Default,,0,0,0,,有一个同样的机器
Dialogue: 0,0:30:33.87,0:30:35.52,Default,,0,0,0,,一台无穷大的机器
Dialogue: 0,0:30:40.39,0:30:43.12,Default,,0,0,0,,这里面也有其它的东西 比如乘法器
Dialogue: 0,0:30:44.76,0:30:46.03,Default,,0,0,0,,它接收输入
Dialogue: 0,0:30:46.27,0:30:47.77,Default,,0,0,0,,这是-1操作
Dialogue: 0,0:30:48.12,0:30:49.31,Default,,0,0,0,,等等
Dialogue: 0,0:30:50.69,0:30:53.72,Default,,0,0,0,,你们可以想象 -- 它就是这个样子的
Dialogue: 0,0:30:54.37,0:30:56.76,Default,,0,0,0,,但重要之处就在于
Dialogue: 0,0:30:57.02,0:30:58.70,Default,,0,0,0,,内部机器执行之前与执行之后
Dialogue: 0,0:30:58.78,0:31:01.60,Default,,0,0,0,,外部机器中都进行了一些运算
Dialogue: 0,0:31:02.54,0:31:04.08,Default,,0,0,0,,因此这台机器必须有“生命”
Dialogue: 0,0:31:05.47,0:31:11.44,Default,,0,0,0,,外部机器需要在内部机器的两个时间点保持存在
Dialogue: 0,0:31:13.49,0:31:15.80,Default,,0,0,0,,因此 我就需要有一个地方来保存
Dialogue: 0,0:31:16.19,0:31:18.19,Default,,0,0,0,,维持外部机器运转的数据
Dialogue: 0,0:31:20.03,0:31:22.09,Default,,0,0,0,,现实世界中不存在无穷的对象
Dialogue: 0,0:31:24.14,0:31:25.58,Default,,0,0,0,,我们要做的就是营造一种假象
Dialogue: 0,0:31:26.12,0:31:27.48,Default,,0,0,0,,一种无穷对象的假象
Dialogue: 0,0:31:27.98,0:31:29.77,Default,,0,0,0,,我们在某处有无穷的硬件资源
Dialogue: 0,0:31:31.83,0:31:35.34,Default,,0,0,0,,现在 这个假象非常重要
Dialogue: 0,0:31:36.28,0:31:37.37,Default,,0,0,0,,如果我们能保证
Dialogue: 0,0:31:38.00,0:31:39.84,Default,,0,0,0,,每次当你查看某个无穷对象时
Dialogue: 0,0:31:39.88,0:31:42.96,Default,,0,0,0,,你所要观察的那部分存在
Dialogue: 0,0:31:44.49,0:31:46.04,Default,,0,0,0,,那么就不需要实际上的“无穷”
Dialogue: 0,0:31:47.39,0:31:49.44,Default,,0,0,0,,当然 这里面我们想做的就是
Dialogue: 0,0:31:49.82,0:31:52.49,Default,,0,0,0,,来看下这里的东西
Dialogue: 0,0:31:53.00,0:31:54.97,Default,,0,0,0,,这是我们目前为止的结构
Dialogue: 0,0:31:56.04,0:31:57.64,Default,,0,0,0,,这些结构呢
Dialogue: 0,0:31:57.92,0:32:01.37,Default,,0,0,0,,是机器的几大部分
Dialogue: 0,0:32:01.40,0:32:02.33,Default,,0,0,0,,比如控制器
Dialogue: 0,0:32:03.18,0:32:04.46,Default,,0,0,0,,它在这里
Dialogue: 0,0:32:04.78,0:32:07.61,Default,,0,0,0,,它相当简单 并且是有穷的
Dialogue: 0,0:32:09.17,0:32:10.44,Default,,0,0,0,,我们还有数据通路
Dialogue: 0,0:32:10.46,0:32:12.75,Default,,0,0,0,,它由寄存器和运算器组成
Dialogue: 0,0:32:13.08,0:32:15.20,Default,,0,0,0,,现在我提议
Dialogue: 0,0:32:15.48,0:32:16.96,Default,,0,0,0,,把机器分成两部分
Dialogue: 0,0:32:17.36,0:32:19.79,Default,,0,0,0,,这样 其中一部分全部是有穷的
Dialogue: 0,0:32:20.78,0:32:23.53,Default,,0,0,0,,而另一部分 可以保存无穷数据中的一部分
Dialogue: 0,0:32:24.23,0:32:25.90,Default,,0,0,0,,换句话说 这部分也非常简单
Dialogue: 0,0:32:26.41,0:32:28.72,Default,,0,0,0,,但并非无穷 只是非常大而已
Dialogue: 0,0:32:29.43,0:32:30.40,Default,,0,0,0,,但它非常简单
Dialogue: 0,0:32:30.52,0:32:32.92,Default,,0,0,0,,以至于能够廉价地大量生产
Dialogue: 0,0:32:34.09,0:32:34.92,Default,,0,0,0,,它就是内存
Dialogue: 0,0:32:35.95,0:32:39.07,Default,,0,0,0,,我们可以利用它来构造栈结构
Dialogue: 0,0:32:39.40,0:32:41.23,Default,,0,0,0,,事实上 这就使得我们
Dialogue: 0,0:32:41.45,0:32:43.63,Default,,0,0,0,,能够模拟无穷机器的存在
Dialogue: 0,0:32:43.64,0:32:46.96,Default,,0,0,0,,也就是那些递归嵌套的机器
Dialogue: 0,0:32:48.34,0:32:50.43,Default,,0,0,0,,而它的原理则是
Dialogue: 0,0:32:50.56,0:32:52.97,Default,,0,0,0,,我们要在栈上存放必要的信息
Dialogue: 0,0:32:54.30,0:32:57.58,Default,,0,0,0,,用于内部机器执行完毕后
Dialogue: 0,0:32:59.18,0:33:01.07,Default,,0,0,0,,继续外部机器的操作
Dialogue: 0,0:33:03.84,0:33:05.48,Default,,0,0,0,,因此它会记住
Dialogue: 0,0:33:05.63,0:33:07.95,Default,,0,0,0,,关于外部机器生命期的重要数据
Dialogue: 0,0:33:08.04,0:33:10.30,Default,,0,0,0,,这些是进行计算所必需的
Dialogue: 0,0:33:11.39,0:33:12.48,Default,,0,0,0,,当然
Dialogue: 0,0:33:12.75,0:33:16.33,Default,,0,0,0,,由于这些机器是通过递归的方式嵌套的
Dialogue: 0,0:33:18.33,0:33:23.39,Default,,0,0,0,,因此 栈的存取方式也会是
Dialogue: 0,0:33:23.45,0:33:26.44,Default,,0,0,0,,也会是后进先出的
Dialogue: 0,0:33:29.33,0:33:30.64,Default,,0,0,0,,因此我们只需要存取
Dialogue: 0,0:33:30.80,0:33:32.52,Default,,0,0,0,,这个栈内存的一小部分
Dialogue: 0,0:33:34.93,0:33:35.92,Default,,0,0,0,,好吧 让我们来试一试
Dialogue: 0,0:33:36.81,0:33:38.41,Default,,0,0,0,,我已经给你们画好了数据通路
Dialogue: 0,0:33:38.44,0:33:39.68,Default,,0,0,0,,现在该布置控制器了
Dialogue: 0,0:33:40.37,0:33:42.86,Default,,0,0,0,,然后我们来运行一下 观察实际工作原理
Dialogue: 0,0:33:43.51,0:33:46.88,Default,,0,0,0,,还好阶乘机器不是特别的复杂
Dialogue: 0,0:33:47.90,0:33:50.16,Default,,0,0,0,,它有一个VAL寄存器
Dialogue: 0,0:33:52.22,0:33:53.88,Default,,0,0,0,,这是用来存储答案的
Dialogue: 0,0:33:54.89,0:33:56.67,Default,,0,0,0,,还有一个寄存器N
Dialogue: 0,0:33:59.85,0:34:04.16,Default,,0,0,0,,它里面存储的是要计算阶乘的数
Dialogue: 0,0:34:04.51,0:34:06.57,Default,,0,0,0,,为了满足某些情况
Dialogue: 0,0:34:07.48,0:34:10.52,Default,,0,0,0,,我们要连接VAL和N
Dialogue: 0,0:34:11.74,0:34:15.63,Default,,0,0,0,,事实上 如果我在这里返回N
Dialogue: 0,0:34:16.38,0:34:19.53,Default,,0,0,0,,也是正确的 因为这时N就等于1
Dialogue: 0,0:34:20.09,0:34:23.26,Default,,0,0,0,,这样的话 我就可以把结果移动过去
Dialogue: 0,0:34:23.90,0:34:25.55,Default,,0,0,0,,但我现在不考虑这个问题
Dialogue: 0,0:34:26.98,0:34:28.60,Default,,0,0,0,,我还需要做一些事情
Dialogue: 0,0:34:29.06,0:34:31.02,Default,,0,0,0,,就像我们在这里看到的 我们还需要
Dialogue: 0,0:34:31.21,0:34:34.67,Default,,0,0,0,,用VAL的值乘以N
Dialogue: 0,0:34:34.91,0:34:37.45,Default,,0,0,0,,因为VAL是计算阶乘的结果
Dialogue: 0,0:34:38.68,0:34:40.44,Default,,0,0,0,,我需要把算得的结果送回VAL
Dialogue: 0,0:34:41.48,0:34:42.65,Default,,0,0,0,,所以这里我们看到
Dialogue: 0,0:34:42.83,0:34:46.43,Default,,0,0,0,,N的阶乘就是
Dialogue: 0,0:34:46.57,0:34:49.20,Default,,0,0,0,,N乘以某个阶乘
Dialogue: 0,0:34:50.69,0:34:53.77,Default,,0,0,0,,而VAL就代表了内部阶乘的结果
Dialogue: 0,0:34:55.19,0:35:00.25,Default,,0,0,0,,因此 在这里我需要有一个乘法器
Dialogue: 0,0:35:02.36,0:35:07.18,Default,,0,0,0,,它的参数有：N以及VAL
Dialogue: 0,0:35:08.64,0:35:15.60,Default,,0,0,0,,并且 像这样把计算结果送回VAL
Dialogue: 0,0:35:17.17,0:35:19.39,Default,,0,0,0,,我也需要知道N是否为1
Dialogue: 0,0:35:21.32,0:35:22.38,Default,,0,0,0,,因此我需要一个指示灯
Dialogue: 0,0:35:28.20,0:35:30.40,Default,,0,0,0,,另外 我想我还需要
Dialogue: 0,0:35:31.02,0:35:32.84,Default,,0,0,0,,一个组件来减小N
Dialogue: 0,0:35:34.84,0:35:36.09,Default,,0,0,0,,所以这里有一个递减器
Dialogue: 0,0:35:38.19,0:35:41.39,Default,,0,0,0,,它接收参数N 将结果送回N
Dialogue: 0,0:35:46.62,0:35:48.40,Default,,0,0,0,,这基本上就是我的机器所需要的东西了
Dialogue: 0,0:35:49.55,0:35:51.64,Default,,0,0,0,,然而 我还需要一些个东西
Dialogue: 0,0:35:52.30,0:35:53.58,Default,,0,0,0,,一个稍微复杂一点的东西
Dialogue: 0,0:35:55.16,0:35:56.88,Default,,0,0,0,,因为我需要有一种方式能够存储
Dialogue: 0,0:35:57.16,0:35:59.69,Default,,0,0,0,,必要的一些信息
Dialogue: 0,0:36:01.02,0:36:03.07,Default,,0,0,0,,以便计算完子阶乘后
Dialogue: 0,0:36:03.10,0:36:04.89,Default,,0,0,0,,恢复原始阶乘的计算
Dialogue: 0,0:36:06.25,0:36:06.86,Default,,0,0,0,,需要哪些信息呢?
Dialogue: 0,0:36:07.23,0:36:08.73,Default,,0,0,0,,首先就是N
Dialogue: 0,0:36:09.85,0:36:12.04,Default,,0,0,0,,因此 我要在这里构造一个栈
Dialogue: 0,0:36:14.70,0:36:15.77,Default,,0,0,0,,所谓的栈就是
Dialogue: 0,0:36:17.98,0:36:24.97,Default,,0,0,0,,一大堆连续的空间
Dialogue: 0,0:36:27.15,0:36:28.59,Default,,0,0,0,,我不知道它到底有多深
Dialogue: 0,0:36:29.15,0:36:31.48,Default,,0,0,0,,栈越深 无穷的假象营造得就越好
Dialogue: 0,0:36:33.23,0:36:35.56,Default,,0,0,0,,我还需要有一种方法 能够把
Dialogue: 0,0:36:35.60,0:36:37.02,Default,,0,0,0,,N中的值放入栈中
Dialogue: 0,0:36:38.12,0:36:39.08,Default,,0,0,0,,反过来也是
Dialogue: 0,0:36:39.93,0:36:41.74,Default,,0,0,0,,因此我需要一条像这样的连接
Dialogue: 0,0:36:44.41,0:36:45.48,Default,,0,0,0,,它是双向的
Dialogue: 0,0:36:50.44,0:36:52.22,Default,,0,0,0,,通过它 我就可以在某个时间
Dialogue: 0,0:36:52.24,0:36:55.50,Default,,0,0,0,,把N的值存储起来
Dialogue: 0,0:36:56.04,0:36:56.84,Default,,0,0,0,,这就是栈
Dialogue: 0,0:36:58.10,0:37:01.71,Default,,0,0,0,,我还需要一种方法来记住
Dialogue: 0,0:37:01.84,0:37:07.72,Default,,0,0,0,,我现在计算到外部程序的哪个地方了
Dialogue: 0,0:37:08.53,0:37:10.06,Default,,0,0,0,,现在 对于这台机器来说
Dialogue: 0,0:37:10.76,0:37:13.34,Default,,0,0,0,,这并不是什么问题
Dialogue: 0,0:37:14.17,0:37:16.24,Default,,0,0,0,,FACT总是返回在
Dialogue: 0,0:37:16.86,0:37:19.07,Default,,0,0,0,,一个跟N相乘的地方
Dialogue: 0,0:37:19.34,0:37:20.72,Default,,0,0,0,,除了最后的一次
Dialogue: 0,0:37:21.15,0:37:23.02,Default,,0,0,0,,它返回到需要FACT最终答案的地方
Dialogue: 0,0:37:23.04,0:37:24.04,Default,,0,0,0,,或者是'DONE、'STOP之类的
Dialogue: 0,0:37:25.66,0:37:26.67,Default,,0,0,0,,然而 通常来说
Dialogue: 0,0:37:27.16,0:37:28.73,Default,,0,0,0,,我需要记住我去过哪些地方
Dialogue: 0,0:37:29.13,0:37:31.24,Default,,0,0,0,,因为 我可能从其它地方调用FACT
Dialogue: 0,0:37:32.08,0:37:34.89,Default,,0,0,0,,我需要返回到那个地方 并从那里继续
Dialogue: 0,0:37:36.07,0:37:38.00,Default,,0,0,0,,因此 我需要有一种方法能够
Dialogue: 0,0:37:38.01,0:37:40.86,Default,,0,0,0,,记住有穷状态控制器中弹珠的位置
Dialogue: 0,0:37:41.32,0:37:42.64,Default,,0,0,0,,也就是控制器的状态
Dialogue: 0,0:37:44.22,0:37:46.35,Default,,0,0,0,,并将它存储在栈中
Dialogue: 0,0:37:47.40,0:37:49.10,Default,,0,0,0,,我也需要有一种方法
Dialogue: 0,0:37:49.45,0:37:51.12,Default,,0,0,0,,能够恢复弹珠的状态
Dialogue: 0,0:37:52.14,0:37:54.28,Default,,0,0,0,,因此 我需要有一种将弹珠归位的能力
Dialogue: 0,0:37:54.70,0:37:56.52,Default,,0,0,0,,现在 我们有一个地方用于存储弹珠
Dialogue: 0,0:37:57.87,0:37:59.34,Default,,0,0,0,,它被称作“继续”寄存器
Dialogue: 0,0:38:03.61,0:38:04.52,Default,,0,0,0,,记作CONTINUE
Dialogue: 0,0:38:09.16,0:38:10.68,Default,,0,0,0,,下一次调用(GOTO CONTINUE)时
Dialogue: 0,0:38:11.00,0:38:13.05,Default,,0,0,0,,弹珠就会去向这个地方
Dialogue: 0,0:38:14.91,0:38:15.92,Default,,0,0,0,,它就是用来干这个的
Dialogue: 0,0:38:16.14,0:38:18.48,Default,,0,0,0,,因此 它和控制器之间应该有一条通路
Dialogue: 0,0:38:22.91,0:38:27.12,Default,,0,0,0,,我也能够将它存储在栈上
Dialogue: 0,0:38:29.45,0:38:33.10,Default,,0,0,0,,我也能够把它设置成各种常量
Dialogue: 0,0:38:34.01,0:38:35.69,Default,,0,0,0,,某一些常量
Dialogue: 0,0:38:36.86,0:38:38.20,Default,,0,0,0,,这非常容易实现
Dialogue: 0,0:38:38.84,0:38:40.14,Default,,0,0,0,,我们现在这里设一些常量
Dialogue: 0,0:38:40.18,0:38:41.50,Default,,0,0,0,,我们把这个记作AFTER-FACT
Dialogue: 0,0:38:47.32,0:38:48.75,Default,,0,0,0,,这个常量
Dialogue: 0,0:38:48.84,0:38:51.50,Default,,0,0,0,,会送入CONTINUE寄存器
Dialogue: 0,0:38:52.59,0:38:54.43,Default,,0,0,0,,另外一个寄存器是FACT-DONE
Dialogue: 0,0:39:05.21,0:39:07.82,Default,,0,0,0,,这就是我想要构建的机器
Dialogue: 0,0:39:08.13,0:39:09.48,Default,,0,0,0,,至少是数据通路部分
Dialogue: 0,0:39:09.92,0:39:11.69,Default,,0,0,0,,这里还混合了一些控制器
Dialogue: 0,0:39:11.85,0:39:14.59,Default,,0,0,0,,这是因为我需要记住我当前的位置
Dialogue: 0,0:39:14.70,0:39:16.35,Default,,0,0,0,,并将我恢复到该位置
Dialogue: 0,0:39:17.30,0:39:19.93,Default,,0,0,0,,现在 让我们来编写控制器对应的程序
Dialogue: 0,0:39:20.39,0:39:23.47,Default,,0,0,0,,我就把DEFINE-MACHINE和寄存器列表给省略了
Dialogue: 0,0:39:23.48,0:39:24.89,Default,,0,0,0,,因为它们无关紧要
Dialogue: 0,0:39:25.13,0:39:27.79,Default,,0,0,0,,我就直接写那些跟控制器有关的
Dialogue: 0,0:39:27.82,0:39:29.02,Default,,0,0,0,,指令序列
Dialogue: 0,0:39:31.48,0:39:41.85,Default,,0,0,0,,首先是(ASSIGN CONTINUE DONE)
Dialogue: 0,0:39:45.15,0:39:45.82,Default,,0,0,0,,然后是一个循环
Dialogue: 0,0:39:47.34,0:39:56.08,Default,,0,0,0,,先判断 如果1=N 那么就跳转
Dialogue: 0,0:40:00.94,0:40:04.11,Default,,0,0,0,,那么就进入归纳的基本步骤
Dialogue: 0,0:40:06.06,0:40:07.20,Default,,0,0,0,,也就是最简单的情况
Dialogue: 0,0:40:08.05,0:40:08.76,Default,,0,0,0,,否则的话
Dialogue: 0,0:40:08.88,0:40:10.84,Default,,0,0,0,,我就要记住那些
Dialogue: 0,0:40:10.88,0:40:13.84,Default,,0,0,0,,计算子阶乘所必须的信息
Dialogue: 0,0:40:14.67,0:40:16.75,Default,,0,0,0,,我需要来带这里 以便计算子阶乘
Dialogue: 0,0:40:17.57,0:40:19.29,Default,,0,0,0,,所以我需要记住 完成它需要些什么
Dialogue: 0,0:40:19.71,0:40:22.52,Default,,0,0,0,,需要记住我计算完之后需要哪些东西
Dialogue: 0,0:40:24.00,0:40:25.51,Default,,0,0,0,,看到了吗 我要做些糟糕的事儿
Dialogue: 0,0:40:25.72,0:40:27.39,Default,,0,0,0,,我要去修改N的值
Dialogue: 0,0:40:28.57,0:40:30.40,Default,,0,0,0,,但是它又需要记住N的旧值
Dialogue: 0,0:40:32.14,0:40:33.64,Default,,0,0,0,,但是为了计算子阶乘
Dialogue: 0,0:40:33.66,0:40:34.92,Default,,0,0,0,,我又需要修改N的值
Dialogue: 0,0:40:35.60,0:40:37.10,Default,,0,0,0,,因此 我就得记住N的旧值
Dialogue: 0,0:40:38.00,0:40:39.60,Default,,0,0,0,,我也需要记住我的位置
Dialogue: 0,0:40:40.85,0:40:42.32,Default,,0,0,0,,因此 我保存CONTINUE的值
Dialogue: 0,0:40:47.70,0:40:51.29,Default,,0,0,0,,这条指令 就是用来将数据入栈的
Dialogue: 0,0:40:53.12,0:40:55.53,Default,,0,0,0,,将CONTINUE寄存器的值保存起来
Dialogue: 0,0:40:56.51,0:40:58.00,Default,,0,0,0,,在本例中也就是DONE
Dialogue: 0,0:40:58.88,0:41:00.25,Default,,0,0,0,,因为稍后我也会修改它
Dialogue: 0,0:41:00.27,0:41:02.78,Default,,0,0,0,,因为我也需要回到AFTER-FACT
Dialogue: 0,0:41:03.55,0:41:04.19,Default,,0,0,0,,我们来看看
Dialogue: 0,0:41:05.04,0:41:09.71,Default,,0,0,0,,我们需要存储N 因为稍后会用到
Dialogue: 0,0:41:10.38,0:41:20.54,Default,,0,0,0,,(ASSIGN N (-1+ (FETCH N)))
Dialogue: 0,0:41:23.26,0:41:28.97,Default,,0,0,0,,(ASSIGN CONTINUE ...
Dialogue: 0,0:41:32.12,0:41:33.42,Default,,0,0,0,,我看一下 --
Dialogue: 0,0:41:34.06,0:41:35.61,Default,,0,0,0,,AFT)
Dialogue: 0,0:41:37.69,0:41:38.70,Default,,0,0,0,,这个名字很好
Dialogue: 0,0:41:38.73,0:41:40.65,Default,,0,0,0,,因为它短小精炼 很适合用在这里
Dialogue: 0,0:41:53.36,0:41:54.64,Default,,0,0,0,,现在 来看看我怎么做
Dialogue: 0,0:41:55.33,0:41:57.02,Default,,0,0,0,,我说 如果ANSWER是1的话
Dialogue: 0,0:41:58.72,0:41:59.66,Default,,0,0,0,,那程序就结束了
Dialogue: 0,0:42:00.46,0:42:01.66,Default,,0,0,0,,我只需要取得这个答案
Dialogue: 0,0:42:02.15,0:42:04.88,Default,,0,0,0,,否则我就要保存当前的继续以及N的值
Dialogue: 0,0:42:05.77,0:42:07.32,Default,,0,0,0,,然后让N减1
Dialogue: 0,0:42:07.60,0:42:09.63,Default,,0,0,0,,注意 我先要跳转到某处
Dialogue: 0,0:42:09.64,0:42:11.48,Default,,0,0,0,,然后来到这里 计算另外的阶乘
Dialogue: 0,0:42:13.50,0:42:15.74,Default,,0,0,0,,然而 这之中又有了另外的机器
Dialogue: 0,0:42:16.05,0:42:18.38,Default,,0,0,0,,其中N=1 CONTINUE是其它值
Dialogue: 0,0:42:22.11,0:42:23.21,Default,,0,0,0,,N=N-1
Dialogue: 0,0:42:23.77,0:42:25.28,Default,,0,0,0,,再我完成这个之后
Dialogue: 0,0:42:26.94,0:42:27.76,Default,,0,0,0,,我会来到这里
Dialogue: 0,0:42:28.66,0:42:30.46,Default,,0,0,0,,我会恢复N的旧值
Dialogue: 0,0:42:32.68,0:42:36.56,Default,,0,0,0,,也就是这里SAVE的逆运算
Dialogue: 0,0:42:38.36,0:42:39.88,Default,,0,0,0,,然后恢复CONTINUE
Dialogue: 0,0:42:49.66,0:42:52.57,Default,,0,0,0,,然后我又会来到这里
Dialogue: 0,0:42:54.32,0:43:00.86,Default,,0,0,0,,(ASSIGN VAL
Dialogue: 0,0:43:01.16,0:43:08.13,Default,,0,0,0,,(* (FETCH N) (FETCH VAL)))
Dialogue: 0,0:43:13.44,0:43:18.30,Default,,0,0,0,,（闭合括号中）
Dialogue: 0,0:43:19.79,0:43:21.44,Default,,0,0,0,,这样操作就完成了
Dialogue: 0,0:43:21.44,0:43:25.68,Default,,0,0,0,,子阶乘的结果就存储在了VAL中
Dialogue: 0,0:43:26.57,0:43:27.37,Default,,0,0,0,,这个时候
Dialogue: 0,0:43:27.66,0:43:28.75,Default,,0,0,0,,我就要返回到
Dialogue: 0,0:43:29.28,0:43:31.61,Default,,0,0,0,,CONTINUE所指向的地方
Dialogue: 0,0:43:33.64,0:43:35.77,Default,,0,0,0,,也就是(GOTO (FETCH CONTINUE))
Dialogue: 0,0:43:45.87,0:43:47.40,Default,,0,0,0,,最后就是基本情况的那步
Dialogue: 0,0:43:49.31,0:43:50.51,Default,,0,0,0,,也就是一个立即值
Dialogue: 0,0:43:50.68,0:43:56.88,Default,,0,0,0,,(ASSIGN VAL (FETCH N))
Dialogue: 0,0:44:01.36,0:44:02.75,Default,,0,0,0,,(GOTO (FETCH CONTINUE))
Dialogue: 0,0:44:12.67,0:44:13.55,Default,,0,0,0,,这样我就完成了
Dialogue: 0,0:44:18.64,0:44:21.21,Default,,0,0,0,,现在 我们用一个非常简单的例子来运行一下
Dialogue: 0,0:44:22.51,0:44:23.53,Default,,0,0,0,,因为这样我们就将看到
Dialogue: 0,0:44:23.66,0:44:26.52,Default,,0,0,0,,栈是如何帮助我们完成计算的
Dialogue: 0,0:44:26.89,0:44:28.22,Default,,0,0,0,,这是计算的静态描述
Dialogue: 0,0:44:28.22,0:44:29.80,Default,,0,0,0,,我们需要动态地观察它
Dialogue: 0,0:44:31.34,0:44:32.09,Default,,0,0,0,,因此 让我们来看看
Dialogue: 0,0:44:32.30,0:44:34.56,Default,,0,0,0,,首先我们要把CONTINUE设置为DONE
Dialogue: 0,0:44:36.73,0:44:38.09,Default,,0,0,0,,这是我通过按下这个钮来实现的
Dialogue: 0,0:44:38.30,0:44:39.60,Default,,0,0,0,,我们还是把它记作DONE吧
Dialogue: 0,0:44:46.22,0:44:47.03,Default,,0,0,0,,我按下这个按钮
Dialogue: 0,0:44:47.03,0:44:48.11,Default,,0,0,0,,DONE就进到了这里
Dialogue: 0,0:44:48.95,0:44:53.71,Default,,0,0,0,,现在 我还要为这些东西设置初始值
Dialogue: 0,0:44:53.85,0:44:58.08,Default,,0,0,0,,让我们考虑3的阶乘
Dialogue: 0,0:44:58.38,0:44:59.24,Default,,0,0,0,,这个例子非常简单
Dialogue: 0,0:45:00.54,0:45:04.04,Default,,0,0,0,,我们的栈从这里开始增长
Dialogue: 0,0:45:05.90,0:45:07.76,Default,,0,0,0,,栈有它们自己的内部状态
Dialogue: 0,0:45:07.79,0:45:09.05,Default,,0,0,0,,用来标识栈顶位置
Dialogue: 0,0:45:09.80,0:45:11.64,Default,,0,0,0,,也就是下一个可写位置
Dialogue: 0,0:45:12.77,0:45:14.59,Default,,0,0,0,,现在我们问 N=1么？
Dialogue: 0,0:45:14.76,0:45:15.71,Default,,0,0,0,,当然不等于
Dialogue: 0,0:45:16.11,0:45:18.56,Default,,0,0,0,,因此现在我要保存CONTINUE
Dialogue: 0,0:45:19.15,0:45:20.65,Default,,0,0,0,,现在 DONE就来到了这里
Dialogue: 0,0:45:22.08,0:45:23.55,Default,,0,0,0,,然后 这个指针移动到了这里
Dialogue: 0,0:45:24.88,0:45:26.14,Default,,0,0,0,,下次我要把数据写到这里
Dialogue: 0,0:45:26.66,0:45:28.78,Default,,0,0,0,,保存N的值--也就是3
Dialogue: 0,0:45:29.95,0:45:30.32,Default,,0,0,0,,对吧？
Dialogue: 0,0:45:30.67,0:45:33.61,Default,,0,0,0,,N←N-1
Dialogue: 0,0:45:33.96,0:45:35.37,Default,,0,0,0,,也就是说 我得按下这个钮
Dialogue: 0,0:45:35.94,0:45:37.32,Default,,0,0,0,,这就变成了2
Dialogue: 0,0:45:38.73,0:45:42.28,Default,,0,0,0,,COUNTINUE←AFT
Dialogue: 0,0:45:42.58,0:45:43.61,Default,,0,0,0,,因此我要按下这个钮
Dialogue: 0,0:45:43.61,0:45:44.54,Default,,0,0,0,,AFT就进入了这里
Dialogue: 0,0:45:49.14,0:45:53.93,Default,,0,0,0,,然后 跳转到LOOP 我们就来到了这里
Dialogue: 0,0:45:54.83,0:45:57.08,Default,,0,0,0,,N=1么？当然不
Dialogue: 0,0:45:57.78,0:45:59.23,Default,,0,0,0,,因此我又要保存CONTINUE
Dialogue: 0,0:45:59.49,0:46:00.27,Default,,0,0,0,,CONTINUE的值是什么呢？
Dialogue: 0,0:46:00.60,0:46:01.53,Default,,0,0,0,,目前是AFT
Dialogue: 0,0:46:01.53,0:46:02.32,Default,,0,0,0,,按下这个按钮
Dialogue: 0,0:46:02.78,0:46:03.95,Default,,0,0,0,,这个指针移动到了这里
Dialogue: 0,0:46:08.49,0:46:09.74,Default,,0,0,0,,我还要保存N
Dialogue: 0,0:46:10.51,0:46:12.12,Default,,0,0,0,,N在那里 它的值是2
Dialogue: 0,0:46:12.28,0:46:13.37,Default,,0,0,0,,按下这个按钮
Dialogue: 0,0:46:13.85,0:46:15.24,Default,,0,0,0,,2就进入了这里
Dialogue: 0,0:46:16.05,0:46:17.64,Default,,0,0,0,,然后这个指针移动到了这里
Dialogue: 0,0:46:20.06,0:46:22.60,Default,,0,0,0,,保存N之后 又赋N←N-1
Dialogue: 0,0:46:24.60,0:46:25.46,Default,,0,0,0,,它就变成了1
Dialogue: 0,0:46:29.24,0:46:30.54,Default,,0,0,0,,CONTINUE←AFT
Dialogue: 0,0:46:31.37,0:46:34.48,Default,,0,0,0,,AFT又进入了这里
Dialogue: 0,0:46:34.96,0:46:35.64,Default,,0,0,0,,然后又跳转到LOOP
Dialogue: 0,0:46:36.52,0:46:37.74,Default,,0,0,0,,N等于1么？
Dialogue: 0,0:46:37.93,0:46:39.52,Default,,0,0,0,,是的 那么答案就是1
Dialogue: 0,0:46:41.04,0:46:43.26,Default,,0,0,0,,跳转到BASE那一步
Dialogue: 0,0:46:44.16,0:46:45.77,Default,,0,0,0,,(ASSIGN VAL (FETCH N))
Dialogue: 0,0:46:46.56,0:46:50.72,Default,,0,0,0,,按下这个 1就进入到了这里
Dialogue: 0,0:46:51.10,0:46:52.20,Default,,0,0,0,,(GOTO (FETCH CONTINUE))
Dialogue: 0,0:46:52.20,0:46:53.53,Default,,0,0,0,,来看下CONTINUE寄存器
Dialogue: 0,0:46:53.68,0:46:56.06,Default,,0,0,0,,基本上来说 我按下这里的按钮 进入到控制器
Dialogue: 0,0:46:56.67,0:46:58.28,Default,,0,0,0,,CONTINUE寄存器就变成了AFT
Dialogue: 0,0:46:58.32,0:47:00.25,Default,,0,0,0,,这样一下子 程序就运行到了这里
Dialogue: 0,0:47:02.64,0:47:05.63,Default,,0,0,0,,现在 我就需要恢复外部的阶乘了
Dialogue: 0,0:47:06.65,0:47:07.55,Default,,0,0,0,,因此我们来到这里
Dialogue: 0,0:47:07.55,0:47:09.48,Default,,0,0,0,,我们先要恢复N
Dialogue: 0,0:47:10.32,0:47:13.04,Default,,0,0,0,,这就意味着 我们要使用这里的内容
Dialogue: 0,0:47:13.94,0:47:18.17,Default,,0,0,0,,按下这个按钮 2就会来到这里
Dialogue: 0,0:47:18.56,0:47:20.04,Default,,0,0,0,,然后指针会向上移动
Dialogue: 0,0:47:21.98,0:47:24.49,Default,,0,0,0,,恢复CONTINUE寄存器也非常简单
Dialogue: 0,0:47:24.81,0:47:26.49,Default,,0,0,0,,来按下这个按钮
Dialogue: 0,0:47:27.02,0:47:28.92,Default,,0,0,0,,然后 AFT又一次进入到这里
Dialogue: 0,0:47:31.28,0:47:32.64,Default,,0,0,0,,同时 这个指针也要上移
Dialogue: 0,0:47:32.64,0:47:35.19,Default,,0,0,0,,这样就避开了栈上的其它东西
Dialogue: 0,0:47:42.24,0:47:43.47,Default,,0,0,0,,然后我来到这里
Dialogue: 0,0:47:43.87,0:47:47.15,Default,,0,0,0,,也就是(ASSIGN VAL (* N VAL))
Dialogue: 0,0:47:47.85,0:47:50.57,Default,,0,0,0,,然后我按下这个按钮
Dialogue: 0,0:47:50.97,0:47:52.91,Default,,0,0,0,,2乘以1等于2
Dialogue: 0,0:47:54.01,0:47:54.75,Default,,0,0,0,,我写到这里
Dialogue: 0,0:47:55.76,0:47:57.20,Default,,0,0,0,,然后是(GOTO (FETCH CONTINUE))
Dialogue: 0,0:47:57.54,0:47:59.85,Default,,0,0,0,,CONTINUE现在是AFT 我跳转到AFT
Dialogue: 0,0:48:01.15,0:48:03.88,Default,,0,0,0,,AFT首先要恢复N
Dialogue: 0,0:48:04.36,0:48:05.72,Default,,0,0,0,,恢复N指的是
Dialogue: 0,0:48:05.87,0:48:08.44,Default,,0,0,0,,我把这里的值 也就是3
Dialogue: 0,0:48:09.24,0:48:10.33,Default,,0,0,0,,按下这里的按钮
Dialogue: 0,0:48:10.60,0:48:15.50,Default,,0,0,0,,然后把它放到这里 N
Dialogue: 0,0:48:16.25,0:48:17.34,Default,,0,0,0,,然后 我们按下这个钮
Dialogue: 0,0:48:18.01,0:48:19.90,Default,,0,0,0,,接下来我就要恢复CONTINUE
Dialogue: 0,0:48:20.20,0:48:22.20,Default,,0,0,0,,CONTINUE寄存器现在成为了DONE
Dialogue: 0,0:48:22.83,0:48:26.78,Default,,0,0,0,,当我按下这个钮后 指针就移动到了这里
Dialogue: 0,0:48:27.13,0:48:29.72,Default,,0,0,0,,DONE可能从此之后不在这里了
Dialogue: 0,0:48:29.72,0:48:31.55,Default,,0,0,0,,对此我并不感兴趣 但它现在一定在这里
Dialogue: 0,0:48:35.80,0:48:38.12,Default,,0,0,0,,下一步 我将要把VAL赋值为
Dialogue: 0,0:48:38.43,0:48:40.76,Default,,0,0,0,,N乘以VAL的值
Dialogue: 0,0:48:41.44,0:48:44.30,Default,,0,0,0,,按下这里的按钮就可以实现
Dialogue: 0,0:48:44.30,0:48:45.77,Default,,0,0,0,,2乘以3等于6
Dialogue: 0,0:48:46.52,0:48:47.87,Default,,0,0,0,,所以这里我就得到了6
Dialogue: 0,0:48:50.97,0:48:53.40,Default,,0,0,0,,下一步是(GOTO (FETCH CONTINUE))
Dialogue: 0,0:48:53.48,0:48:54.83,Default,,0,0,0,,哦 跳转到DONE 这样我就完成了
Dialogue: 0,0:48:55.02,0:48:56.09,Default,,0,0,0,,最后的答案是6
Dialogue: 0,0:48:56.60,0:48:57.82,Default,,0,0,0,,你们可以在VAL寄存器中看到
Dialogue: 0,0:48:58.95,0:48:59.82,Default,,0,0,0,,事实上
Dialogue: 0,0:49:00.91,0:49:03.34,Default,,0,0,0,,栈又回到了它初始的状态
Dialogue: 0,0:49:08.20,0:49:10.70,Default,,0,0,0,,在使用像栈这样的东西中 有一些原则
Dialogue: 0,0:49:11.20,0:49:12.27,Default,,0,0,0,,我们需要注意
Dialogue: 0,0:49:13.62,0:49:15.52,Default,,0,0,0,,我们会在下一小节中介绍
Dialogue: 0,0:49:16.26,0:49:18.46,Default,,0,0,0,,但首先 对于这一小节所讲的内容
Dialogue: 0,0:49:28.56,0:49:29.64,Default,,0,0,0,,有什么问题么？
Dialogue: 0,0:49:30.17,0:49:30.63,Default,,0,0,0,,Ron 请讲
Dialogue: 0,0:49:30.63,0:49:33.37,Default,,0,0,0,,学生：当你越过了栈的顶端会怎样--
Dialogue: 0,0:49:33.39,0:49:34.62,Default,,0,0,0,,教授：你所谓的“越过”是指什么？
Dialogue: 0,0:49:35.03,0:49:37.50,Default,,0,0,0,,学生：如果我们的N是一个很大的数
Dialogue: 0,0:49:37.52,0:49:38.72,Default,,0,0,0,,就需要更多的内存 对吧？
Dialogue: 0,0:49:38.86,0:49:39.44,Default,,0,0,0,,教授：是的
Dialogue: 0,0:49:39.44,0:49:41.12,Default,,0,0,0,,这样 我就需要一个足够大的栈
Dialogue: 0,0:49:41.53,0:49:43.20,Default,,0,0,0,,你想问 如果破坏了无穷存储的假象会发生什么？
Dialogue: 0,0:49:43.84,0:49:44.12,Default,,0,0,0,,学生：是的
Dialogue: 0,0:49:44.55,0:49:46.73,Default,,0,0,0,,教授：那么 这些魔法就不再起效了
Dialogue: 0,0:49:47.96,0:49:51.00,Default,,0,0,0,,真相就是 任何机器都是有穷的
Dialogue: 0,0:49:51.64,0:49:53.72,Default,,0,0,0,,而对于像这样的过程
Dialogue: 0,0:49:54.17,0:49:58.86,Default,,0,0,0,,我只能进行有限数量的子阶乘计算
Dialogue: 0,0:49:59.95,0:50:02.48,Default,,0,0,0,,想一想 我们之前讲解的Y组合子
Dialogue: 0,0:50:02.80,0:50:06.22,Default,,0,0,0,,我们指出 存在一系列的指数过程
Dialogue: 0,0:50:06.25,0:50:08.09,Default,,0,0,0,,其中每一个都要比前一个更精准
Dialogue: 0,0:50:08.72,0:50:11.60,Default,,0,0,0,,现在 我们看到了如何实现这个数学理念
Dialogue: 0,0:50:13.09,0:50:14.19,Default,,0,0,0,,这个取极限的过程
Dialogue: 0,0:50:14.35,0:50:16.33,Default,,0,0,0,,只有当你取到极限时才足够精准
Dialogue: 0,0:50:17.99,0:50:19.42,Default,,0,0,0,,如果你仔细想想 我这里用了什么
Dialogue: 0,0:50:19.42,0:50:22.65,Default,,0,0,0,,对于这个过程的每一次递归
Dialogue: 0,0:50:23.04,0:50:27.07,Default,,0,0,0,,我用了大概两块内存
Dialogue: 0,0:50:29.10,0:50:31.71,Default,,0,0,0,,如果我们尝试计算10000的阶乘
Dialogue: 0,0:50:31.72,0:50:32.81,Default,,0,0,0,,这并不会花掉很多内存
Dialogue: 0,0:50:33.18,0:50:34.68,Default,,0,0,0,,虽然这是一个很大的数
Dialogue: 0,0:50:35.95,0:50:38.41,Default,,0,0,0,,因此 实际的问题就是值不值得
Dialogue: 0,0:50:39.18,0:50:42.19,Default,,0,0,0,,但这并不是这种实现的局限
Dialogue: 0,0:50:42.22,0:50:43.53,Default,,0,0,0,,因为内存非常低廉
Dialogue: 0,0:50:44.16,0:50:45.34,Default,,0,0,0,,但人力资源却相当昂贵
Dialogue: 0,0:50:48.13,0:50:50.22,Default,,0,0,0,,好吧 我们先休息一下 谢谢大家
Dialogue: 0,0:50:50.78,0:51:07.60,Default,,0,0,0,,[音乐]
Dialogue: 0,0:51:07.60,0:51:12.19,Declare,,0,0,0,,{\an2\fad(500,500)}《计算机程序的构造和解释》
Dialogue: 0,0:51:39.93,0:51:43.69,Declare,,0,0,0,,{\an2\fad(500,500)}讲师：哈罗德·艾伯森教授 及 格兰德·杰·萨斯曼教授
Dialogue: 0,0:51:43.71,0:51:47.93,Declare,,0,0,0,,{\an2\fad(500,500)}《计算机程序的构造和解释》
Dialogue: 0,0:51:47.93,0:51:53.08,Declare,,0,0,0,,{\an2\fad(500,500)}寄存机器
Dialogue: 0,0:51:56.11,0:51:57.04,Default,,0,0,0,,教授：我们讲解了
Dialogue: 0,0:51:58.70,0:52:03.37,Default,,0,0,0,,如果进行简单的迭代计算
Dialogue: 0,0:52:03.69,0:52:05.31,Default,,0,0,0,,以及简单的递归计算
Dialogue: 0,0:52:05.64,0:52:08.68,Default,,0,0,0,,我只想通过向你们展示一些针对特定应用的
Dialogue: 0,0:52:09.63,0:52:11.12,Default,,0,0,0,,更加复杂的设计
Dialogue: 0,0:52:11.21,0:52:13.58,Default,,0,0,0,,来总结简单机器的设计
Dialogue: 0,0:52:13.96,0:52:17.13,Default,,0,0,0,,也就是同时递归地调用两个斐波那契函数
Dialogue: 0,0:52:17.23,0:52:19.88,Default,,0,0,0,,因为它会向我们表明 并且我们会理解
Dialogue: 0,0:52:20.04,0:52:22.68,Default,,0,0,0,,一些关于栈正常工作
Dialogue: 0,0:52:22.76,0:52:25.04,Default,,0,0,0,,所需要遵守的约定
Dialogue: 0,0:52:26.40,0:52:27.11,Default,,0,0,0,,现在 让我们来看看
Dialogue: 0,0:52:27.11,0:52:28.27,Default,,0,0,0,,先让我在黑板上写下
Dialogue: 0,0:52:28.30,0:52:29.71,Default,,0,0,0,,将要翻译的程序
Dialogue: 0,0:52:34.15,0:52:36.52,Default,,0,0,0,,这是一个斐波那契过程
Dialogue: 0,0:52:39.23,0:52:41.58,Default,,0,0,0,,它非常的简单
Dialogue: 0,0:52:44.60,0:52:48.56,Default,,0,0,0,,如果N小于2 那么结果就是N
Dialogue: 0,0:52:49.26,0:52:55.34,Default,,0,0,0,,否则就是(FIB (- N 1))加上
Dialogue: 0,0:52:58.44,0:52:59.85,Default,,0,0,0,,(FIB (- N 2))
Dialogue: 0,0:53:07.05,0:53:09.29,Default,,0,0,0,,这就是我的计划
Dialogue: 0,0:53:09.29,0:53:12.56,Default,,0,0,0,,现在 我们要来写下这台机器的控制器
Dialogue: 0,0:53:13.07,0:53:15.53,Default,,0,0,0,,首先 我们假设有一个寄存器N
Dialogue: 0,0:53:15.56,0:53:19.15,Default,,0,0,0,,里面存放的是斐波那契函数的自变量
Dialogue: 0,0:53:19.82,0:53:21.80,Default,,0,0,0,,而计算结果会存放在VAL寄存器中
Dialogue: 0,0:53:22.17,0:53:24.97,Default,,0,0,0,,CONTINUE寄存器会和控制器相连
Dialogue: 0,0:53:26.11,0:53:26.81,Default,,0,0,0,,就跟之前一样
Dialogue: 0,0:53:26.96,0:53:29.21,Default,,0,0,0,,但我不会再去画数据通路了
Dialogue: 0,0:53:31.53,0:53:34.00,Default,,0,0,0,,因为它和之前的那个差不多
Dialogue: 0,0:53:34.36,0:53:37.84,Default,,0,0,0,,当然 关于计算的最神奇的事情之一
Dialogue: 0,0:53:38.75,0:53:39.88,Default,,0,0,0,,就是一段时间后
Dialogue: 0,0:53:40.08,0:53:41.93,Default,,0,0,0,,你构建了一个又一个的小功能
Dialogue: 0,0:53:41.95,0:53:43.32,Default,,0,0,0,,你就一下子拥有了需要的一切
Dialogue: 0,0:53:44.75,0:53:47.60,Default,,0,0,0,,这种效率是非常了不起的
Dialogue: 0,0:53:48.17,0:53:50.84,Default,,0,0,0,,构造制作一台通用计算机不需要太多的东西
Dialogue: 0,0:53:51.81,0:53:54.68,Default,,0,0,0,,总之 我们来看看斐波那契机器的控制器
Dialogue: 0,0:53:55.06,0:53:57.07,Default,,0,0,0,,我首先要做的是
Dialogue: 0,0:53:57.32,0:54:02.52,Default,,0,0,0,,通过为CONTINUE寄存器赋值
Dialogue: 0,0:54:07.13,0:54:10.28,Default,,0,0,0,,赋FIB-DONE来启动计算
Dialogue: 0,0:54:14.14,0:54:15.53,Default,,0,0,0,,这就意味着在这里
Dialogue: 0,0:54:15.55,0:54:18.48,Default,,0,0,0,,我需要有一个标签 FIB-DONE
Dialogue: 0,0:54:19.71,0:54:21.10,Default,,0,0,0,,当我来到这个地方后
Dialogue: 0,0:54:21.23,0:54:22.44,Default,,0,0,0,,机器就停止了
Dialogue: 0,0:54:24.00,0:54:24.86,Default,,0,0,0,,这就是这个标签的作用
Dialogue: 0,0:54:25.92,0:54:26.89,Default,,0,0,0,,然后我要创建一个循环
Dialogue: 0,0:54:31.11,0:54:34.25,Default,,0,0,0,,我要来到这里来启动FIB的计算
Dialogue: 0,0:54:35.47,0:54:36.86,Default,,0,0,0,,无论这时 N等于多少
Dialogue: 0,0:54:37.39,0:54:38.99,Default,,0,0,0,,斐波那契函数都会被计算
Dialogue: 0,0:54:39.13,0:54:42.01,Default,,0,0,0,,然后会返回到由CONTINUE寄存器指向的地方
Dialogue: 0,0:54:44.80,0:54:48.40,Default,,0,0,0,,因此你们将在这里看到
Dialogue: 0,0:54:48.44,0:54:50.48,Default,,0,0,0,,我想要在做一个约定
Dialogue: 0,0:54:50.97,0:54:54.25,Default,,0,0,0,,我用注释的形式来说明这个约定
Dialogue: 0,0:54:54.57,0:55:00.99,Default,,0,0,0,,也就是N中存储的是参数
Dialogue: 0,0:55:02.10,0:55:09.82,Default,,0,0,0,,而CONTINUE存储的是接收者
Dialogue: 0,0:55:13.36,0:55:14.29,Default,,0,0,0,,这个约定就是这样的
Dialogue: 0,0:55:15.71,0:55:18.96,Default,,0,0,0,,因此每当我来到这里
Dialogue: 0,0:55:19.24,0:55:21.04,Default,,0,0,0,,我希望这个约定是成立的
Dialogue: 0,0:55:21.52,0:55:23.32,Default,,0,0,0,,这些计算斐波那契函数所需要的参数
Dialogue: 0,0:55:24.82,0:55:26.83,Default,,0,0,0,,接下来我想做的是分支
Dialogue: 0,0:55:30.22,0:55:32.22,Default,,0,0,0,,如果N小于2
Dialogue: 0,0:55:35.07,0:55:37.44,Default,,0,0,0,,随便说一下 我使用的语法看起来像Lisp
Dialogue: 0,0:55:38.73,0:55:39.63,Default,,0,0,0,,但它并不是Lisp
Dialogue: 0,0:55:41.31,0:55:42.38,Default,,0,0,0,,它们运行不起来
Dialogue: 0,0:55:42.75,0:55:45.47,Default,,0,0,0,,我在这里写的并不是一个简单的Lisp程序
Dialogue: 0,0:55:46.12,0:55:49.31,Default,,0,0,0,,这是另一门语言的表示形式
Dialogue: 0,0:55:49.71,0:55:52.25,Default,,0,0,0,,我之所以使用这种满是括号的语法
Dialogue: 0,0:55:52.40,0:55:54.70,Default,,0,0,0,,是因为我刚好使用Lisp系统
Dialogue: 0,0:55:55.32,0:55:57.34,Default,,0,0,0,,来为这门语言编写解释器
Dialogue: 0,0:55:57.82,0:55:59.18,Default,,0,0,0,,这就使得我们能够模拟
Dialogue: 0,0:55:59.29,0:56:00.91,Default,,0,0,0,,我想要构建的机器
Dialogue: 0,0:56:03.38,0:56:06.24,Default,,0,0,0,,我不想让你们感到困惑 认为这是Lisp代码
Dialogue: 0,0:56:06.94,0:56:08.60,Default,,0,0,0,,只是我用了很多Lisp组件
Dialogue: 0,0:56:09.51,0:56:10.84,Default,,0,0,0,,我在Lisp中嵌入了一门语言
Dialogue: 0,0:56:11.02,0:56:12.44,Default,,0,0,0,,把Lisp当作组件
Dialogue: 0,0:56:12.72,0:56:15.12,Default,,0,0,0,,这样就能让我的模拟工作变得简单
Dialogue: 0,0:56:16.62,0:56:18.56,Default,,0,0,0,,我从Lisp中继承了这些属性
Dialogue: 0,0:56:19.10,0:56:21.53,Default,,0,0,0,,(FETCH N) 2)
Dialogue: 0,0:56:21.77,0:56:23.72,Default,,0,0,0,,成立的话 我想要跳转到IMMEDIATE-ANSWER这个地方
Dialogue: 0,0:56:26.20,0:56:27.29,Default,,0,0,0,,这是基本步骤
Dialogue: 0,0:56:33.15,0:56:34.35,Default,,0,0,0,,它对应在这里
Dialogue: 0,0:56:35.92,0:56:36.89,Default,,0,0,0,,也就是在FIB-DONE的上方
Dialogue: 0,0:56:37.75,0:56:38.64,Default,,0,0,0,,我们稍后就会看到
Dialogue: 0,0:56:39.42,0:56:40.70,Default,,0,0,0,,现在 对于一般情况来说
Dialogue: 0,0:56:40.72,0:56:42.44,Default,,0,0,0,,也就是我现在要写的
Dialogue: 0,0:56:43.13,0:56:44.19,Default,,0,0,0,,是这样的
Dialogue: 0,0:56:44.91,0:56:48.20,Default,,0,0,0,,首先呢 我需要调用斐波那契函数两次
Dialogue: 0,0:56:49.42,0:56:52.54,Default,,0,0,0,,在每一次中 -- 至少在其中一次
Dialogue: 0,0:56:52.78,0:56:53.95,Default,,0,0,0,,我得需要知道该怎么做
Dialogue: 0,0:56:53.96,0:56:55.36,Default,,0,0,0,,才能回过头来进行另外一个计算
Dialogue: 0,0:56:56.31,0:56:58.36,Default,,0,0,0,,我需要记住
Dialogue: 0,0:56:59.20,0:57:01.23,Default,,0,0,0,,我计算完第一个FIB了么？
Dialogue: 0,0:57:01.26,0:57:02.54,Default,,0,0,0,,或者第二个也计算完了？
Dialogue: 0,0:57:04.50,0:57:07.04,Default,,0,0,0,,我是该返回到计算第二个FIB的地方
Dialogue: 0,0:57:07.07,0:57:09.08,Default,,0,0,0,,还是回到执行ADD的地方
Dialogue: 0,0:57:10.12,0:57:12.11,Default,,0,0,0,,无论哪种情况 我都需要--
Dialogue: 0,0:57:12.14,0:57:14.46,Default,,0,0,0,,在第一个计算第一个FIB时
Dialogue: 0,0:57:14.51,0:57:16.98,Default,,0,0,0,,我需要保存N的值 来计算第二个FIB
Dialogue: 0,0:57:19.84,0:57:21.58,Default,,0,0,0,,因此我要把这些东西保存起来
Dialogue: 0,0:57:23.36,0:57:24.89,Default,,0,0,0,,首先要保存CONTINUE
Dialogue: 0,0:57:26.19,0:57:27.32,Default,,0,0,0,,也就是答案的接收者
Dialogue: 0,0:57:31.32,0:57:32.46,Default,,0,0,0,,我之所以要这么做
Dialogue: 0,0:57:32.48,0:57:34.20,Default,,0,0,0,,是因为我现在要把CONTINUE赋值为
Dialogue: 0,0:57:40.11,0:57:44.32,Default,,0,0,0,,我待会儿想要返回的地方
Dialogue: 0,0:57:46.83,0:57:50.27,Default,,0,0,0,,我们把它叫做AFTER-FIB-N-1
Dialogue: 0,0:57:51.04,0:57:53.76,Default,,0,0,0,,这个长名字 非常具有Lisp的命名特点
Dialogue: 0,0:57:57.36,0:58:00.22,Default,,0,0,0,,这是因为我先要计算第一个(FIB (- N 1))
Dialogue: 0,0:58:00.84,0:58:01.72,Default,,0,0,0,,计算完成之后
Dialogue: 0,0:58:01.72,0:58:03.29,Default,,0,0,0,,我想要回过头来做些其它事
Dialogue: 0,0:58:03.96,0:58:06.52,Default,,0,0,0,,而AFTER-FIB-N-1这个地方
Dialogue: 0,0:58:07.55,0:58:09.48,Default,,0,0,0,,就是我计算完第一个FIB后应该返回的地方
Dialogue: 0,0:58:11.52,0:58:13.13,Default,,0,0,0,,接下来我要保存N
Dialogue: 0,0:58:14.41,0:58:17.26,Default,,0,0,0,,因为我稍后需要用到它
Dialogue: 0,0:58:19.13,0:58:20.54,Default,,0,0,0,,在这里 我就已经
Dialogue: 0,0:58:20.67,0:58:22.84,Default,,0,0,0,,准备好计算(FIB (- N 1))了
Dialogue: 0,0:58:23.02,0:58:33.95,Default,,0,0,0,,(ASSIGN N (- (FETCH N) 1))
Dialogue: 0,0:58:38.11,0:58:40.27,Default,,0,0,0,,现在 该跳转到FIB-LOOP了
Dialogue: 0,0:58:47.18,0:58:49.87,Default,,0,0,0,,我满足我立下的约定么？
Dialogue: 0,0:58:50.40,0:58:51.50,Default,,0,0,0,,答案是是的
Dialogue: 0,0:58:51.77,0:58:55.12,Default,,0,0,0,,N现在存储的是N-1 这是我需要的
Dialogue: 0,0:58:56.43,0:59:00.09,Default,,0,0,0,,而CONTINUE包含的是计算完成后 返回的目的地
Dialogue: 0,0:59:01.28,0:59:03.07,Default,,0,0,0,,也就是计算(FIB (- N 1))完成之后
Dialogue: 0,0:59:04.10,0:59:05.44,Default,,0,0,0,,因此我满足了这些约定
Dialogue: 0,0:59:05.44,0:59:09.02,Default,,0,0,0,,因此 我就可以在这里写下一个标签
Dialogue: 0,0:59:11.47,0:59:17.56,Default,,0,0,0,,AFTER-FIB-N-1
Dialogue: 0,0:59:20.49,0:59:21.63,Default,,0,0,0,,在这里 我又该做些什么呢？
Dialogue: 0,0:59:22.69,0:59:23.61,Default,,0,0,0,,在这里
Dialogue: 0,0:59:23.95,0:59:26.75,Default,,0,0,0,,我已经准备好去计算(FIB (- N 2))了
Dialogue: 0,0:59:29.27,0:59:30.72,Default,,0,0,0,,但是为了计算(FIB (- N 2))
Dialogue: 0,0:59:30.75,0:59:31.63,Default,,0,0,0,,首先 我不知道
Dialogue: 0,0:59:31.78,0:59:33.40,Default,,0,0,0,,这里 我已经改变了N
Dialogue: 0,0:59:33.81,0:59:35.47,Default,,0,0,0,,或者在这个时候 我的N总是不断地
Dialogue: 0,0:59:37.85,0:59:38.80,Default,,0,0,0,,向1或者0递减
Dialogue: 0,0:59:39.78,0:59:42.51,Default,,0,0,0,,所以我不知道N寄存器中存储的到底是什么
Dialogue: 0,0:59:43.03,0:59:44.75,Default,,0,0,0,,我想要保存在栈中的N的值
Dialogue: 0,0:59:44.80,0:59:46.00,Default,,0,0,0,,也就是我在这里保存的值
Dialogue: 0,0:59:46.17,0:59:47.88,Default,,0,0,0,,这样我就可以在这里恢复它
Dialogue: 0,0:59:49.52,0:59:51.02,Default,,0,0,0,,我在这里存储的N
Dialogue: 0,0:59:51.15,0:59:54.49,Default,,0,0,0,,是这个时间点N的值
Dialogue: 0,0:59:54.89,0:59:57.37,Default,,0,0,0,,因此计算完(FIB (- N 1))之后我可以恢复它
Dialogue: 0,0:59:57.53,0:59:59.36,Default,,0,0,0,,这样的话 我就可以计算(- N 2)
Dialogue: 0,0:59:59.39,1:00:00.86,Default,,0,0,0,,然后就可以计算(FIB (- N 2))的值
Dialogue: 0,1:00:01.81,1:00:02.75,Default,,0,0,0,,现在让我们来恢复它
Dialogue: 0,1:00:08.83,1:00:09.77,Default,,0,0,0,,(RESTORE N)
Dialogue: 0,1:00:11.13,1:00:15.98,Default,,0,0,0,,现在我要做一件很教条的事
Dialogue: 0,1:00:16.00,1:00:17.40,Default,,0,0,0,,我们会尽快将其删除
Dialogue: 0,1:00:18.52,1:00:20.48,Default,,0,0,0,,如果你们愿意的话
Dialogue: 0,1:00:20.59,1:00:23.44,Default,,0,0,0,,我将要结束子过程调用
Dialogue: 0,1:00:24.80,1:00:25.95,Default,,0,0,0,,接下来我会说
Dialogue: 0,1:00:26.06,1:00:27.90,Default,,0,0,0,,因为我保存了CONTINUE
Dialogue: 0,1:00:28.48,1:00:30.43,Default,,0,0,0,,现在就要去恢复它
Dialogue: 0,1:00:31.60,1:00:32.60,Default,,0,0,0,,但实际上 我并不需要这么做
Dialogue: 0,1:00:32.64,1:00:33.55,Default,,0,0,0,,因为我并不需要用到它
Dialogue: 0,1:00:34.61,1:00:35.72,Default,,0,0,0,,我们稍后会修正它
Dialogue: 0,1:00:36.26,1:00:37.95,Default,,0,0,0,,现在我们来恢复CONTINUE
Dialogue: 0,1:00:46.04,1:00:48.02,Default,,0,0,0,,通常来说 我都会这么做
Dialogue: 0,1:00:48.02,1:00:49.23,Default,,0,0,0,,我们将要看到
Dialogue: 0,1:00:49.31,1:00:52.14,Default,,0,0,0,,编译器领域中的“窥孔优化”
Dialogue: 0,1:00:52.27,1:00:53.72,Default,,0,0,0,,来帮我们消除这个不必要的步骤
Dialogue: 0,1:00:55.42,1:00:57.10,Default,,0,0,0,,因此 我即将要做的就是
Dialogue: 0,1:00:58.46,1:01:02.28,Default,,0,0,0,,准备好计算(FIB (- N 2))
Dialogue: 0,1:01:02.77,1:01:04.49,Default,,0,0,0,,但是我不再需要保存N了
Dialogue: 0,1:01:05.05,1:01:06.72,Default,,0,0,0,,原因就是
Dialogue: 0,1:01:06.80,1:01:09.34,Default,,0,0,0,,计算完(FIB (- N 2))之后 我就不需要N了
Dialogue: 0,1:01:09.36,1:01:10.72,Default,,0,0,0,,因为 我接下来要做的就是ADD
Dialogue: 0,1:01:13.54,1:01:15.85,Default,,0,0,0,,因此 我会这么来设置N
Dialogue: 0,1:01:16.60,1:01:28.99,Default,,0,0,0,,(ASSIGN N (- (FETCH N) 2))
Dialogue: 0,1:01:31.85,1:01:34.01,Default,,0,0,0,,现在我需要结束
Dialogue: 0,1:01:34.27,1:01:36.73,Default,,0,0,0,,调用(FIB (- N 2))的设置过程了
Dialogue: 0,1:01:36.95,1:01:38.33,Default,,0,0,0,,我需要保存CONTINUE
Dialogue: 0,1:01:44.22,1:01:49.02,Default,,0,0,0,,然后把CONTINUE赋值为
Dialogue: 0,1:01:52.30,1:01:59.95,Default,,0,0,0,,AFTER-FIB-N-2
Dialogue: 0,1:02:02.57,1:02:04.03,Default,,0,0,0,,对应了那边代码的某处
Dialogue: 0,1:02:05.32,1:02:07.23,Default,,0,0,0,,然而 我需要非常小心
Dialogue: 0,1:02:08.65,1:02:11.42,Default,,0,0,0,,而(FIB (- N 1))的值
Dialogue: 0,1:02:12.06,1:02:13.12,Default,,0,0,0,,我稍后会用到
Dialogue: 0,1:02:15.30,1:02:17.37,Default,,0,0,0,,(FIB (- N 1))的值
Dialogue: 0,1:02:17.61,1:02:18.48,Default,,0,0,0,,我需要它的值
Dialogue: 0,1:02:18.78,1:02:19.80,Default,,0,0,0,,我不能去改变它
Dialogue: 0,1:02:21.07,1:02:23.60,Default,,0,0,0,,因为我需要用它来加上(FIB (- N 2))
Dialogue: 0,1:02:24.15,1:02:25.88,Default,,0,0,0,,它是存放在寄存器中的 因此我需要保存它
Dialogue: 0,1:02:27.79,1:02:32.60,Default,,0,0,0,,所以现在我要用(SAVE VAL)来保存它
Dialogue: 0,1:02:33.78,1:02:35.44,Default,,0,0,0,,现在我就可以调用子过程了
Dialogue: 0,1:02:36.67,1:02:39.54,Default,,0,0,0,,(GOTO FIB-LOOP)
Dialogue: 0,1:02:44.22,1:02:46.57,Default,,0,0,0,,现在 在进行更进一步计算之前
Dialogue: 0,1:02:46.80,1:02:49.36,Default,,0,0,0,,在结束这个程序之前
Dialogue: 0,1:02:49.39,1:02:51.05,Default,,0,0,0,,我想审视一下目前的代码片段
Dialogue: 0,1:02:51.23,1:02:56.00,Default,,0,0,0,,这里有一系列的指令
Dialogue: 0,1:02:57.84,1:02:59.08,Default,,0,0,0,,我可以对它们进行某些操作
Dialogue: 0,1:03:01.58,1:03:03.20,Default,,0,0,0,,这里 我有一个操作用来恢复CONTINUE
Dialogue: 0,1:03:04.25,1:03:05.48,Default,,0,0,0,,一个操作用来保存CONTINUE
Dialogue: 0,1:03:06.01,1:03:07.40,Default,,0,0,0,,然后给CONTINUE赋值
Dialogue: 0,1:03:08.70,1:03:10.64,Default,,0,0,0,,但这之中没有CONTINUE的其它引用
Dialogue: 0,1:03:13.84,1:03:15.48,Default,,0,0,0,,恢复之后又保存
Dialogue: 0,1:03:15.50,1:03:16.67,Default,,0,0,0,,使得栈没有被修改
Dialogue: 0,1:03:19.09,1:03:21.72,Default,,0,0,0,,唯一的区别就是 我给CONTINUE寄存器赋了值
Dialogue: 0,1:03:21.96,1:03:23.28,Default,,0,0,0,,一个存放在栈上的值
Dialogue: 0,1:03:24.33,1:03:25.79,Default,,0,0,0,,由于我现在改变了这个值
Dialogue: 0,1:03:26.44,1:03:27.93,Default,,0,0,0,,但这之间并没有引用这个值
Dialogue: 0,1:03:28.59,1:03:30.09,Default,,0,0,0,,这些指令就是不必要的
Dialogue: 0,1:03:31.76,1:03:35.39,Default,,0,0,0,,因此我们会移除它们
Dialogue: 0,1:03:38.88,1:03:40.78,Default,,0,0,0,,但我只有先把它们写出来 才会发现这个情况
Dialogue: 0,1:03:43.78,1:03:44.72,Default,,0,0,0,,真是这样吗？
Dialogue: 0,1:03:45.77,1:03:46.60,Default,,0,0,0,,我并不知道
Dialogue: 0,1:03:48.61,1:03:52.91,Default,,0,0,0,,现在 我们要开始计算(FIB (- N 2))了
Dialogue: 0,1:03:53.66,1:03:54.59,Default,,0,0,0,,计算完毕后
Dialogue: 0,1:04:02.96,1:04:03.85,Default,,0,0,0,,我们又要做什么呢？
Dialogue: 0,1:04:05.07,1:04:06.76,Default,,0,0,0,,我想 我们首先要做的就是
Dialogue: 0,1:04:06.99,1:04:07.88,Default,,0,0,0,,我们有两件事要做
Dialogue: 0,1:04:07.96,1:04:10.49,Default,,0,0,0,,目前VAL寄存器中的值 是有意义的
Dialogue: 0,1:04:10.92,1:04:11.98,Default,,0,0,0,,然而 栈上也有一个数据
Dialogue: 0,1:04:12.04,1:04:13.63,Default,,0,0,0,,需要恢复到VAL寄存器中
Dialogue: 0,1:04:14.81,1:04:16.57,Default,,0,0,0,,现在我需要非常小心的是
Dialogue: 0,1:04:16.88,1:04:18.99,Default,,0,0,0,,正确地给它们排序 以便计算乘法
Dialogue: 0,1:04:19.47,1:04:21.24,Default,,0,0,0,,现在 我可能会使用不同的约定
Dialogue: 0,1:04:21.47,1:04:23.52,Default,,0,0,0,,但我现在会采用非常挑剔的一种
Dialogue: 0,1:04:23.55,1:04:25.88,Default,,0,0,0,,栈上数据来自于哪个寄存器 就恢复到那个寄存器中
Dialogue: 0,1:04:26.74,1:04:28.28,Default,,0,0,0,,如果是这样的话 在这里我就要进行洗牌
Dialogue: 0,1:04:29.24,1:04:31.84,Default,,0,0,0,,这跟我有多少只手是同样的问题
Dialogue: 0,1:04:32.68,1:04:37.13,Default,,0,0,0,,现在我要给N赋值
Dialogue: 0,1:04:37.16,1:04:39.37,Default,,0,0,0,,因为我现在不再需要N了 N是无用的
Dialogue: 0,1:04:39.92,1:04:41.21,Default,,0,0,0,,获取当前VAL寄存器的值
Dialogue: 0,1:04:45.21,1:04:47.34,Default,,0,0,0,,也就是(FIB (- N 2))的值
Dialogue: 0,1:04:52.95,1:04:56.35,Default,,0,0,0,,现在 我就要恢复VAL寄存器了
Dialogue: 0,1:05:01.85,1:05:03.92,Default,,0,0,0,,这个RESTORE匹配这里的SAVE
Dialogue: 0,1:05:05.58,1:05:08.83,Default,,0,0,0,,如果你非常仔细地研究发生了什么
Dialogue: 0,1:05:09.21,1:05:11.96,Default,,0,0,0,,会发现 RESTORE和SAVE总是成对的
Dialogue: 0,1:05:13.84,1:05:15.15,Default,,0,0,0,,现在 这里有个额外的SAVE
Dialogue: 0,1:05:15.18,1:05:16.38,Default,,0,0,0,,当然 我们很快就会消灭它
Dialogue: 0,1:05:19.00,1:05:20.59,Default,,0,0,0,,恢复完VAL寄存器后
Dialogue: 0,1:05:20.94,1:05:22.57,Default,,0,0,0,,我就要恢复CONTINUE寄存器了
Dialogue: 0,1:05:31.15,1:05:32.40,Default,,0,0,0,,它匹配了这个
Dialogue: 0,1:05:34.80,1:05:37.85,Default,,0,0,0,,从这里到这里
Dialogue: 0,1:05:40.59,1:05:42.46,Default,,0,0,0,,这样就恢复了继续
Dialogue: 0,1:05:42.86,1:05:45.71,Default,,0,0,0,,这个表达式继续是由(FIB N)产生的
Dialogue: 0,1:05:46.46,1:05:47.84,Default,,0,0,0,,也就是我正尝试求解的
Dialogue: 0,1:05:47.85,1:05:49.32,Default,,0,0,0,,最主要的问题
Dialogue: 0,1:05:49.98,1:05:52.35,Default,,0,0,0,,我需要把(FIB N)的答案返回给这个继续
Dialogue: 0,1:05:52.54,1:05:54.03,Default,,0,0,0,,在我意识到N并不小于2之前
Dialogue: 0,1:05:54.16,1:05:56.60,Default,,0,0,0,,我一直保存着它们
Dialogue: 0,1:05:57.36,1:05:59.07,Default,,0,0,0,,因此 我需要进行一个复杂的运算
Dialogue: 0,1:06:00.84,1:06:02.57,Default,,0,0,0,,现在万事俱备
Dialogue: 0,1:06:03.24,1:06:04.36,Default,,0,0,0,,因此我要恢复它们
Dialogue: 0,1:06:05.42,1:06:21.08,Default,,0,0,0,,(ASSIGN VAL (+ (FETCH VAL) (FETCH N)))
Dialogue: 0,1:06:27.44,1:06:28.60,Default,,0,0,0,,然后跳转到CONTINUE
Dialogue: 0,1:06:38.26,1:06:44.78,Default,,0,0,0,,然后我就从(FIB N)中返回了出来
Dialogue: 0,1:06:45.39,1:06:46.57,Default,,0,0,0,,也就是FIB的一般情况
Dialogue: 0,1:06:47.11,1:06:50.60,Default,,0,0,0,,现在还有一些细节 需要我们填充
Dialogue: 0,1:06:50.99,1:06:55.53,Default,,0,0,0,,比如归纳的基本情况：可以立即得到答案
Dialogue: 0,1:07:02.54,1:07:06.59,Default,,0,0,0,,这不过就是
Dialogue: 0,1:07:06.60,1:07:11.85,Default,,0,0,0,,(ASSIGN VAL (FETCH N)
Dialogue: 0,1:07:13.64,1:07:15.47,Default,,0,0,0,,因为N小于2
Dialogue: 0,1:07:15.50,1:07:16.89,Default,,0,0,0,,因此答案就是N
Dialogue: 0,1:07:16.99,1:07:18.19,Default,,0,0,0,,跟源程序是一致的
Dialogue: 0,1:07:19.23,1:07:26.48,Default,,0,0,0,,(GOTO (FETCH CONTINUE))
Dialogue: 0,1:07:31.24,1:07:36.13,Default,,0,0,0,,最后就结束了
Dialogue: 0,1:07:43.46,1:07:45.64,Default,,0,0,0,,这是个相当复杂的程序
Dialogue: 0,1:07:45.64,1:07:47.34,Default,,0,0,0,,我之所以给你们演示这个程序
Dialogue: 0,1:07:47.50,1:07:49.21,Default,,0,0,0,,是因为我想让你们见识
Dialogue: 0,1:07:49.45,1:07:52.67,Default,,0,0,0,,我所遵守的栈使用准则
Dialogue: 0,1:07:53.32,1:07:55.21,Default,,0,0,0,,第一点就是 我不想保存那些
Dialogue: 0,1:07:56.92,1:07:58.12,Default,,0,0,0,,稍后不需要的值
Dialogue: 0,1:08:00.57,1:08:01.85,Default,,0,0,0,,我非常地小心
Dialogue: 0,1:08:01.85,1:08:02.91,Default,,0,0,0,,这非常重要
Dialogue: 0,1:08:03.94,1:08:06.52,Default,,0,0,0,,当然 人们还制定了其它的准则
Dialogue: 0,1:08:07.37,1:08:09.61,Default,,0,0,0,,来操作栈帧之类的东西
Dialogue: 0,1:08:10.19,1:08:11.39,Default,,0,0,0,,这些准则中 那些不再需要的东西
Dialogue: 0,1:08:11.40,1:08:12.64,Default,,0,0,0,,也需要保存并恢复
Dialogue: 0,1:08:12.67,1:08:15.26,Default,,0,0,0,,因为从某种意义上来说 这样做更容易些
Dialogue: 0,1:08:15.83,1:08:17.40,Default,,0,0,0,,但这会带来各种灾难
Dialogue: 0,1:08:18.59,1:08:20.25,Default,,0,0,0,,我们稍后就会见识一些
Dialogue: 0,1:08:21.44,1:08:24.24,Default,,0,0,0,,只保存那些你稍后需要的值 这很关键
Dialogue: 0,1:08:26.89,1:08:28.01,Default,,0,0,0,,这是非常重要的理念
Dialogue: 0,1:08:29.87,1:08:33.36,Default,,0,0,0,,无论谁保存了一个值 都应该由他来恢复
Dialogue: 0,1:08:33.76,1:08:35.32,Default,,0,0,0,,因为他需要这个值
Dialogue: 0,1:08:36.93,1:08:38.54,Default,,0,0,0,,在这样的准则中
Dialogue: 0,1:08:38.86,1:08:40.76,Default,,0,0,0,,你可以发现哪些数据是不必要的
Dialogue: 0,1:08:43.45,1:08:44.73,Default,,0,0,0,,哪些操作又是不重要的
Dialogue: 0,1:08:47.15,1:08:50.40,Default,,0,0,0,,我还想告诉你们
Dialogue: 0,1:08:51.66,1:08:54.67,Default,,0,0,0,,当然 你们看到的并不是全部的图景
Dialogue: 0,1:08:55.35,1:08:56.68,Default,,0,0,0,,假设我的系统中
Dialogue: 0,1:08:56.80,1:09:01.52,Default,,0,0,0,,具有像CAR、CDR、CONS这样的运算
Dialogue: 0,1:09:03.53,1:09:05.60,Default,,0,0,0,,或者创建一个向量
Dialogue: 0,1:09:05.88,1:09:07.32,Default,,0,0,0,,并引用它的第N个元素
Dialogue: 0,1:09:08.30,1:09:09.21,Default,,0,0,0,,等等运算
Dialogue: 0,1:09:10.40,1:09:13.60,Default,,0,0,0,,然而 就在这个层次的细节来说
Dialogue: 0,1:09:13.87,1:09:17.85,Default,,0,0,0,,我们可以在数据通路中把它们视为基本运算
Dialogue: 0,1:09:18.75,1:09:21.95,Default,,0,0,0,,换句话说 我们可以认为 有一台机器
Dialogue: 0,1:09:22.32,1:09:24.11,Default,,0,0,0,,包含了APPEND机器
Dialogue: 0,1:09:24.20,1:09:26.46,Default,,0,0,0,,它通过(CONS (CAR X)
Dialogue: 0,1:09:26.64,1:09:29.80,Default,,0,0,0,,(APPEND (CDR X) Y)来实现
Dialogue: 0,1:09:29.88,1:09:33.18,Default,,0,0,0,,哦 天啊 这就跟阶乘机器有相同的结构
Dialogue: 0,1:09:33.63,1:09:35.29,Default,,0,0,0,,当然 它有相同的结构
Dialogue: 0,1:09:36.54,1:09:37.27,Default,,0,0,0,,我们有什么呢？
Dialogue: 0,1:09:37.27,1:09:39.39,Default,,0,0,0,,我们有某种东西 其中有
Dialogue: 0,1:09:39.76,1:09:42.48,Default,,0,0,0,,诸如X、Y之类的寄存器
Dialogue: 0,1:09:42.51,1:09:45.12,Default,,0,0,0,,有时X会移动到Y中
Dialogue: 0,1:09:45.28,1:09:46.75,Default,,0,0,0,,或者X会取得Y的值
Dialogue: 0,1:09:46.93,1:09:50.11,Default,,0,0,0,,我们或许要需要能够进行CONS运算
Dialogue: 0,1:09:51.70,1:09:57.74,Default,,0,0,0,,我记不清这个系统中是否需要这样的东西
Dialogue: 0,1:09:57.76,1:10:01.10,Default,,0,0,0,,但CONS有点类似于减法器或加法器之类的东西
Dialogue: 0,1:10:01.42,1:10:02.70,Default,,0,0,0,,它把两个东西结合起来
Dialogue: 0,1:10:02.73,1:10:04.27,Default,,0,0,0,,然后产生一个序对
Dialogue: 0,1:10:04.51,1:10:06.49,Default,,0,0,0,,然后会把输出结果送入到这里
Dialogue: 0,1:10:07.60,1:10:09.72,Default,,0,0,0,,可能还有一个叫做CAR的组件
Dialogue: 0,1:10:12.88,1:10:16.22,Default,,0,0,0,,它的结果是 -- 某个东西的CAR部分
Dialogue: 0,1:10:16.92,1:10:19.55,Default,,0,0,0,,我还可以取得某物的CDR部分 等等
Dialogue: 0,1:10:20.15,1:10:22.30,Default,,0,0,0,,但我们不应该害怕这么说
Dialogue: 0,1:10:22.92,1:10:24.24,Default,,0,0,0,,因为最坏的情况不过
Dialogue: 0,1:10:24.94,1:10:26.41,Default,,0,0,0,,当我们打开CONS后
Dialogue: 0,1:10:27.31,1:10:29.82,Default,,0,0,0,,会发现其中存在某台机器
Dialogue: 0,1:10:31.88,1:10:34.44,Default,,0,0,0,,CONS可能会与CAR和CDR有所重叠
Dialogue: 0,1:10:35.50,1:10:38.12,Default,,0,0,0,,就像加法和减法有所重叠一样
Dialogue: 0,1:10:38.57,1:10:39.85,Default,,0,0,0,,它们本质上都是一样的
Dialogue: 0,1:10:41.21,1:10:42.60,Default,,0,0,0,,CONS、CAR和CDR将会有所重叠
Dialogue: 0,1:10:42.62,1:10:44.52,Default,,0,0,0,,我们会发现其中有小型控制器
Dialogue: 0,1:10:45.50,1:10:46.54,Default,,0,0,0,,小型的数据通路
Dialogue: 0,1:10:48.03,1:10:49.64,Default,,0,0,0,,其中还有一些寄存器
Dialogue: 0,1:10:50.00,1:10:52.86,Default,,0,0,0,,一些其它的像这样的东西
Dialogue: 0,1:10:53.30,1:10:54.41,Default,,0,0,0,,并且 也许在这之中
Dialogue: 0,1:10:54.43,1:10:56.16,Default,,0,0,0,,可能也有无穷的部分
Dialogue: 0,1:10:56.46,1:10:58.70,Default,,0,0,0,,又或者是半无穷的 之类的
Dialogue: 0,1:10:58.81,1:11:00.65,Default,,0,0,0,,这些都是统一的东西
Dialogue: 0,1:11:00.96,1:11:02.03,Default,,0,0,0,,也就是我们所谓的“内存”
Dialogue: 0,1:11:06.57,1:11:08.83,Default,,0,0,0,,有限的内存也能无穷地存储 对此我一点也不吃惊
Dialogue: 0,1:11:09.33,1:11:11.07,Default,,0,0,0,,实际上它就是这样的 我们之后就会了解
Dialogue: 0,1:11:13.32,1:11:14.57,Default,,0,0,0,,那么 有什么疑问么？
Dialogue: 0,1:11:24.34,1:11:25.80,Default,,0,0,0,,天啊！你们都一言不发
Dialogue: 0,1:11:28.67,1:11:30.33,Default,,0,0,0,,假设我说得都是谎言吧！
Dialogue: 0,1:11:39.69,1:11:40.38,Default,,0,0,0,,好吧
Dialogue: 0,1:11:41.99,1:11:42.52,Default,,0,0,0,,谢谢大家
Dialogue: 0,1:11:42.52,1:11:43.28,Default,,0,0,0,,我们下课吧！
Dialogue: 0,1:11:44.23,1:11:55.15,Declare,,0,0,0,,{\fad(500,500)}MIT OpenCourseWare\Nhttp://ocw.mit.edu
Dialogue: 0,1:11:44.23,1:11:55.15,Default,,0,0,0,,{\an2\fad(500,500)}本项目主页\Nhttps://github.com/DeathKing/Learning-SICP
