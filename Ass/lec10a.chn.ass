[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 640
PlayResY: 480

[Aegisub Project Garbage]
Active Line: 6
Video Position: 355

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: EN,Calisto MT,21,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,1,0,2,10,10,30,1
Style: Declare,微软雅黑,30,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,2,0,8,10,10,10,1
Style: staff,微软雅黑,30,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,0,2,5,10,10,10,1
Style: title,微软雅黑,35,&H001D64D9,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,0,1,5,10,10,10,1
Style: Default,雅黑宋体,20,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,1,0,2,10,10,30,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.01,0:00:05.02,Declare,,0,0,0,,{\an2\fad(500,500)}Learning-SICP学习小组\N倾情制作
Dialogue: 0,0:00:05.37,0:00:11.84,staff,,0,0,0,,{\fad(600,800)\pos(110.666,403.334)}翻译&&时间轴\N杨启钊\N（windfarer）
Dialogue: 0,0:00:05.37,0:00:11.84,staff,,0,0,0,,{\fad(600,800)\pos(534.666,404)}压制&&特效\N邓雄飞\N（Dysprosium）
Dialogue: 0,0:00:05.37,0:00:11.84,staff,,0,0,0,,{\fad(600,800)\pos(574.667,277.333)}校对\N邓雄飞
Dialogue: 0,0:00:05.37,0:00:11.84,staff,,0,0,0,,{\fad(600,800)\pos(89.334,273.333)}特别感谢\N裘宗燕教授
Dialogue: 0,0:00:05.37,0:00:11.84,title,,0,0,0,,{\fad(600,800)\pos(324,32)}《计算机程序的构造和解释》
Dialogue: 0,0:00:11.84,0:00:13.84,Declare,,0,0,0,,{\an2\fad(500,500)}编译
Dialogue: 0,0:00:19.36,0:00:22.65,Default,,0,0,0,,教授: 上节课 我们学习了
Dialogue: 0,0:00:22.65,0:00:25.67,Default,,0,0,0,,一个显式控制的Lisp求值器
Dialogue: 0,0:00:25.67,0:00:28.97,Default,,0,0,0,,它弥合了像Lisp
Dialogue: 0,0:00:29.05,0:00:32.14,Default,,0,0,0,,或者查询语言之类的高级语言
Dialogue: 0,0:00:32.50,0:00:36.16,Default,,0,0,0,,与传统寄存器机器之间的鸿沟
Dialogue: 0,0:00:36.70,0:00:40.14,Default,,0,0,0,,事实上 你可以将显式控制求值器
Dialogue: 0,0:00:40.16,0:00:44.38,Default,,0,0,0,,看作是 在一台常见的
Dialogue: 0,0:00:44.40,0:00:45.95,Default,,0,0,0,,寄存机器上实现的
Dialogue: 0,0:00:46.52,0:00:49.50,Default,,0,0,0,,Lisp求值器的汇编代码
Dialogue: 0,0:00:49.50,0:00:51.50,Default,,0,0,0,,或者 你可以把它看做是
Dialogue: 0,0:00:52.08,0:00:54.56,Default,,0,0,0,,某台专门运行Lisp的机器的微程序
Dialogue: 0,0:00:55.20,0:00:55.92,Default,,0,0,0,,无论是那种情况
Dialogue: 0,0:00:55.92,0:00:58.68,Default,,0,0,0,,我们都是把一台
Dialogue: 0,0:00:58.94,0:01:00.51,Default,,0,0,0,,处理低级语言的机器
Dialogue: 0,0:01:01.42,0:01:03.32,Default,,0,0,0,,抬高到一个层次
Dialogue: 0,0:01:03.37,0:01:04.88,Default,,0,0,0,,以便处理像Lisp这样的高级语言
Dialogue: 0,0:01:05.36,0:01:06.35,Default,,0,0,0,,这是通过编写解释器来实现的
Dialogue: 0,0:01:08.22,0:01:09.58,Default,,0,0,0,,来看个例子
Dialogue: 0,0:01:11.82,0:01:13.77,Default,,0,0,0,,这里 从概念上来说
Dialogue: 0,0:01:18.01,0:01:19.47,Default,,0,0,0,,从概念上来说 这是一台
Dialogue: 0,0:01:20.54,0:01:23.44,Default,,0,0,0,,专用于计算阶乘的机器
Dialogue: 0,0:01:24.09,0:01:27.39,Default,,0,0,0,,输入5 输出120
Dialogue: 0,0:01:28.92,0:01:30.83,Default,,0,0,0,,这个专用机器实际上
Dialogue: 0,0:01:30.97,0:01:32.72,Default,,0,0,0,,是一个Lisp解释器
Dialogue: 0,0:01:33.50,0:01:36.17,Default,,0,0,0,,它将自己配置为计算阶乘
Dialogue: 0,0:01:38.35,0:01:40.99,Default,,0,0,0,,因为你向它送入了一台阶乘机器的描述
Dialogue: 0,0:01:42.12,0:01:43.70,Default,,0,0,0,,这就是解释器
Dialogue: 0,0:01:43.70,0:01:45.66,Default,,0,0,0,,它将自己配置为
Dialogue: 0,0:01:46.37,0:01:49.24,Default,,0,0,0,,模拟你所输入描述的机器
Dialogue: 0,0:01:50.07,0:01:51.93,Default,,0,0,0,,那么 在Lisp解释器里是什么?
Dialogue: 0,0:01:52.04,0:01:55.44,Default,,0,0,0,,里面可能是通用的寄存器语言解释器
Dialogue: 0,0:01:56.98,0:02:00.18,Default,,0,0,0,,它将自己配置成像Lisp解释器那样
Dialogue: 0,0:02:00.18,0:02:02.03,Default,,0,0,0,,因为你输入了一系列用寄存器语言
Dialogue: 0,0:02:02.12,0:02:03.04,Default,,0,0,0,,编写的指令
Dialogue: 0,0:02:03.37,0:02:05.16,Default,,0,0,0,,这就是显式控制求值器
Dialogue: 0,0:02:07.05,0:02:08.70,Default,,0,0,0,,它里面也有一些库
Dialogue: 0,0:02:08.73,0:02:11.08,Default,,0,0,0,,由基本运算符和Lisp运算
Dialogue: 0,0:02:11.12,0:02:12.28,Default,,0,0,0,,等等要素组成
Dialogue: 0,0:02:12.75,0:02:16.89,Default,,0,0,0,,这是解释执行的一般策略
Dialogue: 0,0:02:17.32,0:02:18.51,Default,,0,0,0,,事实上 我们所做的是
Dialogue: 0,0:02:18.60,0:02:20.14,Default,,0,0,0,,通过编写解释器
Dialogue: 0,0:02:21.62,0:02:23.40,Default,,0,0,0,,将机器抬升到
Dialogue: 0,0:02:23.42,0:02:25.24,Default,,0,0,0,,我们程序所在的层次
Dialogue: 0,0:02:25.24,0:02:26.72,Default,,0,0,0,,当然 还有另外一种策略
Dialogue: 0,0:02:27.42,0:02:28.89,Default,,0,0,0,,这种不同的策略就是编译
Dialogue: 0,0:02:29.04,0:02:30.43,Default,,0,0,0,,编译有一些不同
Dialogue: 0,0:02:31.04,0:02:31.50,Default,,0,0,0,,这里
Dialogue: 0,0:02:33.37,0:02:34.75,Default,,0,0,0,,我们可能已经实现了
Dialogue: 0,0:02:35.67,0:02:38.52,Default,,0,0,0,,一个特定用途的机器
Dialogue: 0,0:02:38.62,0:02:39.98,Default,,0,0,0,,用来计算阶乘
Dialogue: 0,0:02:43.62,0:02:46.26,Default,,0,0,0,,从某种使用寄存器语言的机器开始
Dialogue: 0,0:02:46.26,0:02:47.72,Default,,0,0,0,,但是 我们将让它执行不同的策略
Dialogue: 0,0:02:47.72,0:02:50.38,Default,,0,0,0,,把我们的阶乘程序
Dialogue: 0,0:02:51.55,0:02:53.92,Default,,0,0,0,,作为源代码输入编译器
Dialogue: 0,0:02:53.92,0:02:55.15,Default,,0,0,0,,编译器就会
Dialogue: 0,0:02:55.15,0:02:57.62,Default,,0,0,0,,把这个阶乘程序
Dialogue: 0,0:02:57.62,0:02:59.07,Default,,0,0,0,,翻译成某种寄存器机器语言
Dialogue: 0,0:03:00.25,0:03:03.40,Default,,0,0,0,,现在它并不是Lisp的显式控制求值器
Dialogue: 0,0:03:03.40,0:03:06.17,Default,,0,0,0,,而是某种用来计算阶乘的寄存器语言
Dialogue: 0,0:03:06.49,0:03:08.36,Default,,0,0,0,,这就是翻译的过程
Dialogue: 0,0:03:10.54,0:03:12.41,Default,,0,0,0,,它将进入某种加载器
Dialogue: 0,0:03:13.35,0:03:15.21,Default,,0,0,0,,它会把这些代码
Dialogue: 0,0:03:15.31,0:03:16.84,Default,,0,0,0,,和从程序库中选取的代码
Dialogue: 0,0:03:16.86,0:03:18.65,Default,,0,0,0,,比如乘法运算等 结合在一起
Dialogue: 0,0:03:19.82,0:03:21.69,Default,,0,0,0,,随后我们将生成一个加载模块
Dialogue: 0,0:03:22.22,0:03:25.06,Default,,0,0,0,,它把寄存器语言机器配置成
Dialogue: 0,0:03:25.06,0:03:27.24,Default,,0,0,0,,一个专门用来计算阶乘的机器
Dialogue: 0,0:03:28.12,0:03:30.22,Default,,0,0,0,,这就是不同的策略
Dialogue: 0,0:03:30.22,0:03:31.22,Default,,0,0,0,,在解释中
Dialogue: 0,0:03:31.22,0:03:32.01,Default,,0,0,0,,我们把机器
Dialogue: 0,0:03:32.91,0:03:35.23,Default,,0,0,0,,抬升到Lisp语言的层次
Dialogue: 0,0:03:35.32,0:03:36.34,Default,,0,0,0,,而在编译中
Dialogue: 0,0:03:36.34,0:03:38.43,Default,,0,0,0,,我们将我们的程序下降到
Dialogue: 0,0:03:38.48,0:03:40.56,Default,,0,0,0,,机器语言的层次
Dialogue: 0,0:03:41.96,0:03:43.84,Default,,0,0,0,,那么 这两个策略有什么区别呢?
Dialogue: 0,0:03:44.30,0:03:49.42,Default,,0,0,0,,编译器可以生成执行起来更有效率的代码
Dialogue: 0,0:03:52.05,0:03:53.90,Default,,0,0,0,,主要原因是
Dialogue: 0,0:03:54.17,0:03:58.89,Default,,0,0,0,,如果你考虑运行中的寄存器操作
Dialogue: 0,0:04:01.92,0:04:04.49,Default,,0,0,0,,解释器需要生成寄存器的操作
Dialogue: 0,0:04:04.97,0:04:06.75,Default,,0,0,0,,从原则上来讲 它需要足够通用
Dialogue: 0,0:04:07.32,0:04:08.94,Default,,0,0,0,,以支持任何Lisp过程的执行
Dialogue: 0,0:04:10.22,0:04:12.25,Default,,0,0,0,,而编译器只需要
Dialogue: 0,0:04:12.27,0:04:14.92,Default,,0,0,0,,生成一组特定的寄存器操作
Dialogue: 0,0:04:15.52,0:04:18.22,Default,,0,0,0,,用来执行你所编译的那部分特定的Lisp过程
Dialogue: 0,0:04:20.17,0:04:21.20,Default,,0,0,0,,换一种说法
Dialogue: 0,0:04:21.20,0:04:25.31,Default,,0,0,0,,解释器是一种通用的模拟器
Dialogue: 0,0:04:25.92,0:04:27.58,Default,,0,0,0,,当你输入一个Lisp过程时
Dialogue: 0,0:04:27.58,0:04:31.32,Default,,0,0,0,,它们就会模拟那个过程所描述的程序
Dialogue: 0,0:04:31.32,0:04:33.87,Default,,0,0,0,,所以解释器旨在成为一个通用模拟器
Dialogue: 0,0:04:34.62,0:04:35.96,Default,,0,0,0,,而编译器 实际上
Dialogue: 0,0:04:36.00,0:04:37.68,Default,,0,0,0,,只需要将东西配置成
Dialogue: 0,0:04:37.71,0:04:39.34,Default,,0,0,0,,解释器将要去模拟的机器
Dialogue: 0,0:04:40.02,0:04:41.34,Default,,0,0,0,,所以编译器可以运行得更快
Dialogue: 0,0:04:52.55,0:04:53.64,Default,,0,0,0,,另一方面
Dialogue: 0,0:04:55.97,0:04:58.28,Default,,0,0,0,,解释器更适合用来排查错误
Dialogue: 0,0:04:59.43,0:05:01.25,Default,,0,0,0,,这是因为
Dialogue: 0,0:05:01.57,0:05:03.02,Default,,0,0,0,,我们的源代码实际上就在那里
Dialogue: 0,0:05:03.02,0:05:04.81,Default,,0,0,0,,我们正在解释它们
Dialogue: 0,0:05:05.87,0:05:07.69,Default,,0,0,0,,并且库也在其中
Dialogue: 0,0:05:07.90,0:05:10.89,Default,,0,0,0,,看 库是解释器的一部分
Dialogue: 0,0:05:11.30,0:05:13.16,Default,,0,0,0,,而编译器只会拉取
Dialogue: 0,0:05:13.20,0:05:14.56,Default,,0,0,0,,运行程序所需要的代码
Dialogue: 0,0:05:14.87,0:05:17.00,Default,,0,0,0,,所以 如果你在排查错误的途中
Dialogue: 0,0:05:18.00,0:05:20.72,Default,,0,0,0,,你想写一些额外的代码
Dialogue: 0,0:05:20.80,0:05:22.57,Default,,0,0,0,,来考察运行过程中的数据类型
Dialogue: 0,0:05:23.05,0:05:24.25,Default,,0,0,0,,或者做一些
Dialogue: 0,0:05:24.30,0:05:25.92,Default,,0,0,0,,在写程序时没有想到的计算
Dialogue: 0,0:05:25.95,0:05:27.53,Default,,0,0,0,,解释器可以完美搞定这些
Dialogue: 0,0:05:28.05,0:05:29.21,Default,,0,0,0,,而编译器不行
Dialogue: 0,0:05:29.62,0:05:31.90,Default,,0,0,0,,所以它们各有优点
Dialogue: 0,0:05:31.90,0:05:34.48,Default,,0,0,0,,编译器将生成运行更快的代码
Dialogue: 0,0:05:34.85,0:05:37.02,Default,,0,0,0,,而解释器是一种更适合排错的环境
Dialogue: 0,0:05:38.95,0:05:41.40,Default,,0,0,0,,大多数Lisp系统最终将二者都实现了
Dialogue: 0,0:05:42.92,0:05:45.23,Default,,0,0,0,,这样你就可以在开发阶段
Dialogue: 0,0:05:45.24,0:05:47.08,Default,,0,0,0,,可以使用解释器
Dialogue: 0,0:05:47.08,0:05:48.62,Default,,0,0,0,,随后通过编译加速代码的运行
Dialogue: 0,0:05:49.02,0:05:50.03,Default,,0,0,0,,并且通常
Dialogue: 0,0:05:50.04,0:05:51.68,Default,,0,0,0,,你能够让被编译的代码
Dialogue: 0,0:05:51.69,0:05:53.56,Default,,0,0,0,,和被解释的代码互相调用
Dialogue: 0,0:05:54.60,0:05:56.33,Default,,0,0,0,,我们将学习如何做到 其实不难
Dialogue: 0,0:05:59.27,0:05:59.85,Default,,0,0,0,,好
Dialogue: 0,0:06:00.97,0:06:02.09,Default,,0,0,0,,事实上
Dialogue: 0,0:06:04.30,0:06:05.75,Default,,0,0,0,,在我们将要构建的编译器中
Dialogue: 0,0:06:05.75,0:06:07.58,Default,,0,0,0,,我们实现编译的代码和解释的代码
Dialogue: 0,0:06:07.58,0:06:09.45,Default,,0,0,0,,互相调用的方式是
Dialogue: 0,0:06:09.90,0:06:12.06,Default,,0,0,0,,我们让编译器和解释器使用
Dialogue: 0,0:06:12.11,0:06:14.40,Default,,0,0,0,,使用完全一致的寄存器约定
Dialogue: 0,0:06:18.42,0:06:21.72,Default,,0,0,0,,编译器的理念
Dialogue: 0,0:06:21.76,0:06:25.74,Default,,0,0,0,,与解释器或求值器的理念很像
Dialogue: 0,0:06:25.87,0:06:26.46,Default,,0,0,0,,它们是相同的
Dialogue: 0,0:06:27.05,0:06:29.39,Default,,0,0,0,,求值器遍历代码
Dialogue: 0,0:06:29.82,0:06:32.35,Default,,0,0,0,,产生一些寄存器操作
Dialogue: 0,0:06:33.65,0:06:34.97,Default,,0,0,0,,就是我们昨天做的事情
Dialogue: 0,0:06:37.10,0:06:40.27,Default,,0,0,0,,而编译器会读取代码
Dialogue: 0,0:06:40.52,0:06:43.00,Default,,0,0,0,,生成一些进行求值时
Dialogue: 0,0:06:43.04,0:06:44.67,Default,,0,0,0,,求值器会进行的
Dialogue: 0,0:06:45.23,0:06:46.64,Default,,0,0,0,,相关寄存器操作
Dialogue: 0,0:06:48.60,0:06:49.95,Default,,0,0,0,,这就给我们提供了一个模型
Dialogue: 0,0:06:50.60,0:06:53.77,Default,,0,0,0,,来实现一个零阶编译器
Dialogue: 0,0:06:55.30,0:06:58.32,Default,,0,0,0,,一个很差劲但是能用的编译器
Dialogue: 0,0:06:58.32,0:06:59.32,Default,,0,0,0,,这种模型就是
Dialogue: 0,0:06:59.36,0:07:00.59,Default,,0,0,0,,你用求值器
Dialogue: 0,0:07:00.68,0:07:01.88,Default,,0,0,0,,把代码跑一遍
Dialogue: 0,0:07:02.80,0:07:06.06,Default,,0,0,0,,但不去执行实际的操作
Dialogue: 0,0:07:06.06,0:07:07.15,Default,,0,0,0,,只是把它们保存下来
Dialogue: 0,0:07:07.55,0:07:08.82,Default,,0,0,0,,那就是你编译后的代码
Dialogue: 0,0:07:08.82,0:07:10.24,Default,,0,0,0,,让我举个例子
Dialogue: 0,0:07:12.70,0:07:14.14,Default,,0,0,0,,假设我们要编译
Dialogue: 0,0:07:15.10,0:07:17.90,Default,,0,0,0,,编译(F X) 这个表达式
Dialogue: 0,0:07:25.07,0:07:25.96,Default,,0,0,0,,我们假设
Dialogue: 0,0:07:25.96,0:07:28.06,Default,,0,0,0,,EXP寄存器中保存着(F X)
Dialogue: 0,0:07:28.06,0:07:29.55,Default,,0,0,0,,而ENV寄存器又保存着其它东西
Dialogue: 0,0:07:30.10,0:07:32.20,Default,,0,0,0,,想象我们启动了求值器
Dialogue: 0,0:07:34.60,0:07:35.71,Default,,0,0,0,,它读取了表达式
Dialogue: 0,0:07:35.71,0:07:37.36,Default,,0,0,0,,判断它是一个应用
Dialogue: 0,0:07:37.92,0:07:41.90,Default,,0,0,0,,它分支到求值器代码中的一个地方
Dialogue: 0,0:07:42.52,0:07:45.15,Default,,0,0,0,,我们之前见过的叫EV-APPLICATION的地方
Dialogue: 0,0:07:47.12,0:07:48.12,Default,,0,0,0,,然后继续处理
Dialogue: 0,0:07:48.16,0:07:50.08,Default,,0,0,0,,恢复运算对象和UNEV
Dialogue: 0,0:07:50.08,0:07:52.44,Default,,0,0,0,,然后之后它将运算符放在EXP寄存器中
Dialogue: 0,0:07:52.48,0:07:54.27,Default,,0,0,0,,递归地对它求值
Dialogue: 0,0:07:54.47,0:07:56.08,Default,,0,0,0,,这就是我们经历的过程
Dialogue: 0,0:07:56.67,0:07:57.84,Default,,0,0,0,,如果你看代码
Dialogue: 0,0:07:57.87,0:07:59.74,Default,,0,0,0,,会看到一些寄存器操作
Dialogue: 0,0:08:00.20,0:08:02.30,Default,,0,0,0,,你会看到将运算对象赋值给UNEV寄存器
Dialogue: 0,0:08:02.30,0:08:03.95,Default,,0,0,0,,把运算符赋值给EXP
Dialogue: 0,0:08:04.09,0:08:06.20,Default,,0,0,0,,保存环境、生成新环境 等等
Dialogue: 0,0:08:10.22,0:08:11.93,Default,,0,0,0,,如果我们来看下这里的投影
Dialogue: 0,0:08:15.75,0:08:19.58,Default,,0,0,0,,我们会看到产生的这些操作
Dialogue: 0,0:08:20.82,0:08:22.52,Default,,0,0,0,,这是求值器实际要进行的
Dialogue: 0,0:08:22.72,0:08:24.80,Default,,0,0,0,,第一个操作
Dialogue: 0,0:08:25.00,0:08:27.20,Default,,0,0,0,,它将运算对象从EXP寄存器里取出来
Dialogue: 0,0:08:27.47,0:08:28.62,Default,,0,0,0,,并将它赋值给UNEV
Dialogue: 0,0:08:30.03,0:08:32.27,Default,,0,0,0,,然后它给EXP寄存器赋了某个值
Dialogue: 0,0:08:32.30,0:08:33.46,Default,,0,0,0,,然后保存CONTINUE
Dialogue: 0,0:08:33.46,0:08:34.62,Default,,0,0,0,,保存ENV
Dialogue: 0,0:08:34.62,0:08:38.65,Default,,0,0,0,,我在这里就只是寄存器赋值
Dialogue: 0,0:08:39.57,0:08:42.32,Default,,0,0,0,,这就是求值器求值代码时进行的操作
Dialogue: 0,0:08:42.77,0:08:43.79,Default,,0,0,0,,我们缩小画面看看
Dialogue: 0,0:08:44.30,0:08:47.13,Default,,0,0,0,,总计有19个操作
Dialogue: 0,0:08:49.40,0:08:51.64,Default,,0,0,0,,这些代码
Dialogue: 0,0:08:52.05,0:08:53.90,Default,,0,0,0,,对应着
Dialogue: 0,0:08:54.75,0:08:57.10,Default,,0,0,0,,求值器跳转到APPLY-DISPATCH代码之前
Dialogue: 0,0:08:57.86,0:08:59.16,Default,,0,0,0,,事实上 在这个编译器中
Dialogue: 0,0:08:59.20,0:09:01.18,Default,,0,0,0,,我们不需要再关心APPLY-DISPATCH了
Dialogue: 0,0:09:01.30,0:09:02.11,Default,,0,0,0,,我们有所有东西
Dialogue: 0,0:09:02.35,0:09:05.04,Default,,0,0,0,,我们拥有解释后和编译后的所有代码
Dialogue: 0,0:09:06.07,0:09:07.61,Default,,0,0,0,,通常求值过程
Dialogue: 0,0:09:07.61,0:09:09.85,Default,,0,0,0,,是由APPLY-DISPATCH处理的
Dialogue: 0,0:09:10.27,0:09:12.32,Default,,0,0,0,,这将让被解释后代码与编译后代码
Dialogue: 0,0:09:12.36,0:09:13.71,Default,,0,0,0,,很容易互相调用
Dialogue: 0,0:09:18.27,0:09:19.87,Default,,0,0,0,,从原理上来说 这样做足矣
Dialogue: 0,0:09:21.05,0:09:22.66,Default,,0,0,0,,只需运行求值器
Dialogue: 0,0:09:22.66,0:09:24.50,Default,,0,0,0,,因而编译器非常像求值器
Dialogue: 0,0:09:24.50,0:09:26.47,Default,,0,0,0,,你运行它 唯一不同是你把操作存下来
Dialogue: 0,0:09:26.47,0:09:28.40,Default,,0,0,0,,而不是实际执行它们
Dialogue: 0,0:09:29.35,0:09:31.39,Default,,0,0,0,,这其实不完全正确
Dialogue: 0,0:09:32.91,0:09:34.99,Default,,0,0,0,,这里面我们撒了个小谎
Dialogue: 0,0:09:36.24,0:09:39.29,Default,,0,0,0,,你需要关心的是：如果有个谓词
Dialogue: 0,0:09:40.12,0:09:42.16,Default,,0,0,0,,如果你要进行某种测试
Dialogue: 0,0:09:43.45,0:09:46.03,Default,,0,0,0,,显然 在你编译时
Dialogue: 0,0:09:46.52,0:09:47.98,Default,,0,0,0,,你不知道这些分支中
Dialogue: 0,0:09:48.32,0:09:50.14,Default,,0,0,0,,哪条分支会被执行
Dialogue: 0,0:09:51.13,0:09:53.92,Default,,0,0,0,,所以你不能确定求值器将对哪个求值
Dialogue: 0,0:09:54.90,0:09:57.12,Default,,0,0,0,,因此在这里就很简单
Dialogue: 0,0:09:57.12,0:09:58.49,Default,,0,0,0,,你把两个分支全编译了
Dialogue: 0,0:09:59.32,0:10:01.29,Default,,0,0,0,,因此你编译出一个这样的结构
Dialogue: 0,0:10:02.00,0:10:03.98,Default,,0,0,0,,它们都会被编译成
Dialogue: 0,0:10:05.31,0:10:09.15,Default,,0,0,0,,首先是P的代码
Dialogue: 0,0:10:10.71,0:10:16.51,Default,,0,0,0,,它把结果存入VAL寄存器
Dialogue: 0,0:10:18.17,0:10:20.64,Default,,0,0,0,,解释器对谓词求值
Dialogue: 0,0:10:21.35,0:10:24.19,Default,,0,0,0,,并保证结果会放到VAL寄存器中
Dialogue: 0,0:10:24.70,0:10:27.22,Default,,0,0,0,,随后你编译一条指令
Dialogue: 0,0:10:27.22,0:10:33.79,Default,,0,0,0,,如果VAL是TRUE
Dialogue: 0,0:10:37.17,0:10:38.75,Default,,0,0,0,,就转到LABEL1这个地方
Dialogue: 0,0:10:44.97,0:10:47.52,Default,,0,0,0,,然后我们写下B的代码
Dialogue: 0,0:10:49.42,0:10:52.32,Default,,0,0,0,,让解释器对B进行求值
Dialogue: 0,0:10:53.62,0:10:57.21,Default,,0,0,0,,然后写一句指令
Dialogue: 0,0:10:57.23,0:10:58.75,Default,,0,0,0,,用来跳转到下一条指令
Dialogue: 0,0:11:02.20,0:11:04.56,Default,,0,0,0,,就是它结束之后要去的地方
Dialogue: 0,0:11:04.95,0:11:06.09,Default,,0,0,0,,你放入那个指令
Dialogue: 0,0:11:06.88,0:11:08.62,Default,,0,0,0,,这里你写下LABEL1
Dialogue: 0,0:11:12.12,0:11:13.80,Default,,0,0,0,,这里写A的代码
Dialogue: 0,0:11:19.47,0:11:25.85,Default,,0,0,0,,然后又是跳转到下一条指令
Dialogue: 0,0:11:31.42,0:11:32.88,Default,,0,0,0,,这就是处理条件分支的办法
Dialogue: 0,0:11:32.98,0:11:34.65,Default,,0,0,0,,你生成一小段这样的代码
Dialogue: 0,0:11:35.75,0:11:38.12,Default,,0,0,0,,除此之外
Dialogue: 0,0:11:38.95,0:11:41.55,Default,,0,0,0,,这个零阶编译器与求值器一模一样
Dialogue: 0,0:11:42.55,0:11:45.12,Default,,0,0,0,,它只是把指令存起来 而不执行它们
Dialogue: 0,0:11:46.55,0:11:47.60,Default,,0,0,0,,看起来很简单
Dialogue: 0,0:11:47.64,0:11:49.08,Default,,0,0,0,,但我们已经取得了某些收获
Dialogue: 0,0:11:50.12,0:11:52.62,Default,,0,0,0,,它会比求值器更有效率
Dialogue: 0,0:11:53.52,0:11:56.14,Default,,0,0,0,,因为 如果你观察求值器的运行
Dialogue: 0,0:11:56.35,0:12:01.05,Default,,0,0,0,,它并不只是进行寄存器操作
Dialogue: 0,0:12:01.27,0:12:03.50,Default,,0,0,0,,它还会决定执行哪个
Dialogue: 0,0:12:04.70,0:12:07.23,Default,,0,0,0,,它做的第一件事就是
Dialogue: 0,0:12:07.92,0:12:09.77,Default,,0,0,0,,以它为例 就是进行某些测试
Dialogue: 0,0:12:09.77,0:12:11.56,Default,,0,0,0,,确定它是一个应用
Dialogue: 0,0:12:13.57,0:12:15.05,Default,,0,0,0,,然后就跳转到
Dialogue: 0,0:12:15.39,0:12:16.62,Default,,0,0,0,,处理应用的地方去
Dialogue: 0,0:12:16.62,0:12:18.44,Default,,0,0,0,,换句话说 求值器做的事情是
Dialogue: 0,0:12:18.62,0:12:22.76,Default,,0,0,0,,分析代码需要进行的运算
Dialogue: 0,0:12:23.47,0:12:24.99,Default,,0,0,0,,同时并执行它们
Dialogue: 0,0:12:25.55,0:12:28.28,Default,,0,0,0,,当你运行求值器一百万次
Dialogue: 0,0:12:28.28,0:12:30.30,Default,,0,0,0,,这个分析过程就进行一百万次
Dialogue: 0,0:12:30.85,0:12:32.58,Default,,0,0,0,,而在编译器中 它只会进行一次
Dialogue: 0,0:12:32.58,0:12:34.81,Default,,0,0,0,,之后就只有寄存器操作了
Dialogue: 0,0:12:39.20,0:12:41.68,Default,,0,0,0,,这就是零阶编译器了
Dialogue: 0,0:12:41.80,0:12:44.04,Default,,0,0,0,,但它是个拙劣的编译器
Dialogue: 0,0:12:44.45,0:12:45.28,Default,,0,0,0,,它挺蠢的
Dialogue: 0,0:12:46.90,0:12:48.41,Default,,0,0,0,,让我们回过头来
Dialogue: 0,0:12:49.88,0:12:50.97,Default,,0,0,0,,看看这张投影
Dialogue: 0,0:12:52.02,0:12:55.29,Default,,0,0,0,,看看这个东西做的一些操作
Dialogue: 0,0:12:55.85,0:12:56.88,Default,,0,0,0,,我们想看看
Dialogue: 0,0:12:59.72,0:13:02.28,Default,,0,0,0,,在解释(F  X)时的操作
Dialogue: 0,0:13:03.52,0:13:04.84,Default,,0,0,0,,这里就是它做了什么
Dialogue: 0,0:13:05.17,0:13:06.11,Default,,0,0,0,,举个例子 这里
Dialogue: 0,0:13:07.15,0:13:11.98,Default,,0,0,0,,它将(OPERATOR (FETCH EXP))赋值给EXP
Dialogue: 0,0:13:13.75,0:13:15.87,Default,,0,0,0,,其实没必要这样做
Dialogue: 0,0:13:16.22,0:13:17.47,Default,,0,0,0,,因为编译器知道
Dialogue: 0,0:13:17.66,0:13:21.84,Default,,0,0,0,,(OPERATOR (FETCH EXP))的值就是F
Dialogue: 0,0:13:23.35,0:13:25.56,Default,,0,0,0,,因此这个指令没理由存在
Dialogue: 0,0:13:25.70,0:13:28.88,Default,,0,0,0,,应该改为：要把F赋值给EXP
Dialogue: 0,0:13:29.45,0:13:31.08,Default,,0,0,0,,或者实际上 你完全不需要EXP
Dialogue: 0,0:13:31.87,0:13:33.56,Default,,0,0,0,,没有理由需要EXP
Dialogue: 0,0:13:33.56,0:13:35.16,Default,,0,0,0,,EXP是用来做什么的?
Dialogue: 0,0:13:35.18,0:13:36.33,Default,,0,0,0,,我们看这里
Dialogue: 0,0:13:40.77,0:13:42.20,Default,,0,0,0,,我们对VAL赋值
Dialogue: 0,0:13:43.05,0:13:47.34,Default,,0,0,0,,在环境里的EXP里寻找东西
Dialogue: 0,0:13:48.68,0:13:49.53,Default,,0,0,0,,因此 我们实际上是要
Dialogue: 0,0:13:49.55,0:13:51.54,Default,,0,0,0,,替换掉所有的EXP寄存器
Dialogue: 0,0:13:51.54,0:13:53.32,Default,,0,0,0,,把这个指令修改为
Dialogue: 0,0:13:53.34,0:13:54.16,Default,,0,0,0,,给VAL赋值
Dialogue: 0,0:13:54.45,0:13:56.06,Default,,0,0,0,,在环境中查找
Dialogue: 0,0:13:56.36,0:13:58.40,Default,,0,0,0,,符号F的值
Dialogue: 0,0:14:01.09,0:14:01.77,Default,,0,0,0,,类似地
Dialogue: 0,0:14:02.57,0:14:04.27,Default,,0,0,0,,回到这里 我们也完全不需要UNEV
Dialogue: 0,0:14:04.72,0:14:05.79,Default,,0,0,0,,因为我们知道
Dialogue: 0,0:14:06.22,0:14:09.16,Default,,0,0,0,,因为我们知道 (FETCH EXP)取出的运算对象
Dialogue: 0,0:14:09.16,0:14:10.62,Default,,0,0,0,,就是'(X)
Dialogue: 0,0:14:13.25,0:14:14.06,Default,,0,0,0,,从某种意义上来说
Dialogue: 0,0:14:16.17,0:14:19.39,Default,,0,0,0,,你完全不需要UNEV和EXP
Dialogue: 0,0:14:19.67,0:14:21.05,Default,,0,0,0,,看看它们实际上是什么
Dialogue: 0,0:14:21.08,0:14:25.30,Default,,0,0,0,,它们不是实际运行机器的寄存器
Dialogue: 0,0:14:25.30,0:14:26.40,Default,,0,0,0,,它们实际上是
Dialogue: 0,0:14:26.60,0:14:29.50,Default,,0,0,0,,为了模拟该机器的而设置的寄存器
Dialogue: 0,0:14:30.72,0:14:33.77,Default,,0,0,0,,所以它们保存一些表达式
Dialogue: 0,0:14:34.00,0:14:36.04,Default,,0,0,0,,以编译器的视角看来
Dialogue: 0,0:14:36.06,0:14:36.81,Default,,0,0,0,,它们就是常量
Dialogue: 0,0:14:36.95,0:14:38.48,Default,,0,0,0,,因此可以直接把它们放到代码中
Dialogue: 0,0:14:39.47,0:14:41.34,Default,,0,0,0,,你可以忘掉那些关于
Dialogue: 0,0:14:41.36,0:14:42.54,Default,,0,0,0,,EXP和UNEV的操作
Dialogue: 0,0:14:42.57,0:14:43.77,Default,,0,0,0,,只用那些常量
Dialogue: 0,0:14:44.02,0:14:48.00,Default,,0,0,0,,与之相似 如果我们回顾这里
Dialogue: 0,0:14:48.00,0:14:51.32,Default,,0,0,0,,有像(ASSIGN CONTINUE EVAL-ARGS)之类的语句
Dialogue: 0,0:14:53.75,0:14:55.39,Default,,0,0,0,,现在 它和任何东西都没有关系
Dialogue: 0,0:14:55.62,0:14:57.76,Default,,0,0,0,,它只是求值器
Dialogue: 0,0:14:58.08,0:15:00.17,Default,,0,0,0,,维护了下一步需要去哪
Dialogue: 0,0:15:02.70,0:15:05.96,Default,,0,0,0,,在某些应用中对参数进行求值
Dialogue: 0,0:15:06.82,0:15:08.65,Default,,0,0,0,,当然 这与编译器没关系
Dialogue: 0,0:15:08.65,0:15:13.88,Default,,0,0,0,,因为这个分析过程已经被编译器做完了
Dialogue: 0,0:15:15.05,0:15:16.83,Default,,0,0,0,,所以编译后的代码完全不需要它
Dialogue: 0,0:15:17.70,0:15:19.32,Default,,0,0,0,,因此许多向CONTINUE寄存器
Dialogue: 0,0:15:19.32,0:15:21.30,Default,,0,0,0,,赋值的操作都是无用的
Dialogue: 0,0:15:21.30,0:15:24.62,Default,,0,0,0,,运行着的机器留着它们
Dialogue: 0,0:15:24.64,0:15:25.77,Default,,0,0,0,,是为了跟踪它的状态
Dialogue: 0,0:15:26.07,0:15:28.72,Default,,0,0,0,,是为了知道求值器的下一步分析
Dialogue: 0,0:15:28.72,0:15:30.03,Default,,0,0,0,,而它们是完全无关的
Dialogue: 0,0:15:30.06,0:15:31.23,Default,,0,0,0,,因此我们可以去掉它们
Dialogue: 0,0:15:43.90,0:15:45.98,Default,,0,0,0,,那么 如果我们简单地
Dialogue: 0,0:15:46.16,0:15:47.75,Default,,0,0,0,,进行这类优化
Dialogue: 0,0:15:47.75,0:15:51.64,Default,,0,0,0,,不再考虑EXP和UNEV
Dialogue: 0,0:15:51.75,0:15:56.22,Default,,0,0,0,,去掉这些无关的寄存器赋值
Dialogue: 0,0:15:57.25,0:15:59.96,Default,,0,0,0,,我们就可以找到这些代码
Dialogue: 0,0:16:01.48,0:16:06.20,Default,,0,0,0,,也就是求值器会执行的这19条指令
Dialogue: 0,0:16:06.91,0:16:08.12,Default,,0,0,0,,给替换掉
Dialogue: 0,0:16:08.36,0:16:10.33,Default,,0,0,0,,请看幻灯片
Dialogue: 0,0:16:12.27,0:16:15.34,Default,,0,0,0,,我们去掉了大概一半
Dialogue: 0,0:16:18.28,0:16:20.75,Default,,0,0,0,,同样 这就是某种过滤
Dialogue: 0,0:16:21.07,0:16:24.46,Default,,0,0,0,,把无关的东西去掉
Dialogue: 0,0:16:25.17,0:16:26.22,Default,,0,0,0,,你们看 比如说
Dialogue: 0,0:16:27.47,0:16:29.66,Default,,0,0,0,,这里 求值器说
Dialogue: 0,0:16:29.68,0:16:32.43,Default,,0,0,0,,(ASSIGN VAL (LOOKUP 'F (FETCH ENV)))
Dialogue: 0,0:16:32.46,0:16:34.22,Default,,0,0,0,,这里 我们放入了一个常量F
Dialogue: 0,0:16:35.44,0:16:37.02,Default,,0,0,0,,这里又放了一个常量X
Dialogue: 0,0:16:40.02,0:16:42.41,Default,,0,0,0,,因此 这个编译器又稍微好一点
Dialogue: 0,0:16:43.79,0:16:46.76,Default,,0,0,0,,但它还是比较蠢
Dialogue: 0,0:16:47.95,0:16:49.58,Default,,0,0,0,,它仍会做很多蠢事
Dialogue: 0,0:16:50.45,0:16:52.52,Default,,0,0,0,,我们再看幻灯片
Dialogue: 0,0:16:52.88,0:16:53.93,Default,,0,0,0,,看最开头的地方
Dialogue: 0,0:16:56.34,0:16:58.17,Default,,0,0,0,,我们调用(SAVE ENV)保存环境
Dialogue: 0,0:16:59.35,0:17:01.72,Default,,0,0,0,,然后给VAL寄存器赋某个值
Dialogue: 0,0:17:01.80,0:17:03.35,Default,,0,0,0,,然后恢复环境
Dialogue: 0,0:17:03.35,0:17:04.41,Default,,0,0,0,,它是从哪来的
Dialogue: 0,0:17:04.91,0:17:07.10,Default,,0,0,0,,它来自求值器的这个地方
Dialogue: 0,0:17:07.15,0:17:10.28,Default,,0,0,0,,哦 我在正在对一个应用求值
Dialogue: 0,0:17:11.10,0:17:14.68,Default,,0,0,0,,因此我要递归调用EVAL-DISPATCH
Dialogue: 0,0:17:15.87,0:17:17.98,Default,,0,0,0,,我最好把接下来要用到的东西
Dialogue: 0,0:17:17.98,0:17:19.08,Default,,0,0,0,,保存到环境中
Dialogue: 0,0:17:19.77,0:17:22.86,Default,,0,0,0,,这就是递归调用EVAL-DISPATCH的结果
Dialogue: 0,0:17:23.47,0:17:25.77,Default,,0,0,0,,刚才那个例子就是对符号F求值的结果
Dialogue: 0,0:17:26.50,0:17:28.27,Default,,0,0,0,,从EVAL-DISPATCH中返回
Dialogue: 0,0:17:28.28,0:17:29.66,Default,,0,0,0,,将环境恢复
Dialogue: 0,0:17:31.25,0:17:32.28,Default,,0,0,0,,但是实际上
Dialogue: 0,0:17:32.59,0:17:35.88,Default,,0,0,0,,这个求值过程中 所进行的操作
Dialogue: 0,0:17:35.92,0:17:37.71,Default,,0,0,0,,完全不会影响环境
Dialogue: 0,0:17:38.67,0:17:40.80,Default,,0,0,0,,所以这里没必要先保存环境
Dialogue: 0,0:17:40.84,0:17:42.22,Default,,0,0,0,,再恢复环境
Dialogue: 0,0:17:45.67,0:17:46.62,Default,,0,0,0,,与之类似
Dialogue: 0,0:17:49.79,0:17:51.39,Default,,0,0,0,,这里 我们保存了参数表
Dialogue: 0,0:17:53.07,0:17:55.80,Default,,0,0,0,,那是一个求值参数的循环
Dialogue: 0,0:17:55.82,0:17:56.86,Default,,0,0,0,,先保存参数表
Dialogue: 0,0:17:57.20,0:17:58.03,Default,,0,0,0,,然后在这里恢复
Dialogue: 0,0:17:58.08,0:18:00.51,Default,,0,0,0,,但事实上最后
Dialogue: 0,0:18:00.80,0:18:02.28,Default,,0,0,0,,并没有变更参数表
Dialogue: 0,0:18:02.84,0:18:04.17,Default,,0,0,0,,所以不需要保存它
Dialogue: 0,0:18:08.65,0:18:12.88,Default,,0,0,0,,换种方式来说
Dialogue: 0,0:18:13.77,0:18:14.80,Default,,0,0,0,,怎么说呢
Dialogue: 0,0:18:16.43,0:18:19.13,Default,,0,0,0,,求值器需要最大限度地保持悲观
Dialogue: 0,0:18:19.87,0:18:21.07,Default,,0,0,0,,因为 从它的视角来看
Dialogue: 0,0:18:21.08,0:18:23.06,Default,,0,0,0,,只知道接下来是要对某些东西进行求值
Dialogue: 0,0:18:23.24,0:18:24.97,Default,,0,0,0,,所以最好把稍后要用的都存下来
Dialogue: 0,0:18:26.12,0:18:27.79,Default,,0,0,0,,一旦你完成了分析
Dialogue: 0,0:18:27.82,0:18:29.68,Default,,0,0,0,,从编译器的角度就会考虑
Dialogue: 0,0:18:29.72,0:18:31.47,Default,,0,0,0,,哪些是我真正需要存下来的?
Dialogue: 0,0:18:32.12,0:18:33.31,Default,,0,0,0,,我们需要去 --
Dialogue: 0,0:18:33.42,0:18:37.30,Default,,0,0,0,,它不需要像求值器一样小心翼翼
Dialogue: 0,0:18:37.30,0:18:38.80,Default,,0,0,0,,因为它知道 实际需要什么
Dialogue: 0,0:18:39.69,0:18:41.16,Default,,0,0,0,,无论如何 如果我们完成了优化
Dialogue: 0,0:18:42.50,0:18:45.71,Default,,0,0,0,,消除掉所有多余的保存和恢复
Dialogue: 0,0:18:46.40,0:18:49.05,Default,,0,0,0,,那么我们可以得到这样的结果
Dialogue: 0,0:18:49.90,0:18:51.53,Default,,0,0,0,,我们可以发现
Dialogue: 0,0:18:51.64,0:18:53.71,Default,,0,0,0,,只有三条指令是必须的
Dialogue: 0,0:18:54.07,0:18:55.72,Default,,0,0,0,,从刚才的11条指令优化成这样
Dialogue: 0,0:18:55.97,0:18:58.81,Default,,0,0,0,,或是从原始的20条指令优化而来
Dialogue: 0,0:18:59.87,0:19:00.92,Default,,0,0,0,,这告诉我们
Dialogue: 0,0:19:01.12,0:19:03.18,Default,,0,0,0,,对于这些寄存器操作
Dialogue: 0,0:19:03.27,0:19:04.94,Default,,0,0,0,,哪些是必需的?
Dialogue: 0,0:19:09.42,0:19:11.74,Default,,0,0,0,,让我换个方式来总结一下
Dialogue: 0,0:19:11.74,0:19:13.48,Default,,0,0,0,,我先给你们看一张图
Dialogue: 0,0:19:16.00,0:19:17.52,Default,,0,0,0,,这张图片
Dialogue: 0,0:19:18.77,0:19:20.81,Default,,0,0,0,,展示了所有的保存和恢复
Dialogue: 0,0:19:23.50,0:19:25.23,Default,,0,0,0,,这里是表达式(F X)
Dialogue: 0,0:19:25.32,0:19:27.87,Default,,0,0,0,,在下面这里
Dialogue: 0,0:19:28.75,0:19:31.80,Default,,0,0,0,,是对求值器中各种地方的跟踪
Dialogue: 0,0:19:34.97,0:19:38.04,Default,,0,0,0,,在求值发生时会使用这些地方
Dialogue: 0,0:19:38.04,0:19:40.01,Default,,0,0,0,,在这里 你可以看到箭头
Dialogue: 0,0:19:40.22,0:19:42.08,Default,,0,0,0,,下箭头代表寄存器的保存
Dialogue: 0,0:19:42.40,0:19:44.84,Default,,0,0,0,,所以最先保存的是ENV寄存器
Dialogue: 0,0:19:46.82,0:19:48.68,Default,,0,0,0,,然后 在这里恢复ENV
Dialogue: 0,0:19:52.38,0:19:54.54,Default,,0,0,0,,这些都是成对的栈操作
Dialogue: 0,0:19:56.12,0:19:57.56,Default,,0,0,0,,如果你更进一步
Dialogue: 0,0:19:58.12,0:20:00.78,Default,,0,0,0,,我们记得
Dialogue: 0,0:20:00.89,0:20:03.02,Default,,0,0,0,,UNEV是个完全没用的寄存器
Dialogue: 0,0:20:07.80,0:20:09.78,Default,,0,0,0,,如果我们用固定结构的代码
Dialogue: 0,0:20:09.78,0:20:12.52,Default,,0,0,0,,就不需要保存UNEV 因为完全用不上
Dialogue: 0,0:20:16.20,0:20:19.15,Default,,0,0,0,,然后 根据我们约定的
Dialogue: 0,0:20:19.16,0:20:21.88,Default,,0,0,0,,应用过程的准则
Dialogue: 0,0:20:21.88,0:20:23.85,Default,,0,0,0,,我们会选择是否保存CONTINUE
Dialogue: 0,0:20:27.40,0:20:28.74,Default,,0,0,0,,这就是我们做的第一件事
Dialogue: 0,0:20:28.74,0:20:30.51,Default,,0,0,0,,然后我们可以看看
Dialogue: 0,0:20:31.71,0:20:32.70,Default,,0,0,0,,实际需要些什么
Dialogue: 0,0:20:33.07,0:20:35.56,Default,,0,0,0,,其实在求值F的过程中
Dialogue: 0,0:20:36.04,0:20:37.82,Default,,0,0,0,,我们不需要保存ENV
Dialogue: 0,0:20:38.08,0:20:39.92,Default,,0,0,0,,因为它不会被破坏
Dialogue: 0,0:20:39.92,0:20:41.31,Default,,0,0,0,,因此 如果我们利用这点
Dialogue: 0,0:20:44.12,0:20:47.56,Default,,0,0,0,,这里对F的求值
Dialogue: 0,0:20:48.57,0:20:50.44,Default,,0,0,0,,完全不需要担心
Dialogue: 0,0:20:51.61,0:20:52.60,Default,,0,0,0,,会破坏ENV
Dialogue: 0,0:20:52.60,0:20:54.94,Default,,0,0,0,,类似地 这里对X的求值
Dialogue: 0,0:20:57.17,0:20:58.89,Default,,0,0,0,,当求值器进行求值时 它会说
Dialogue: 0,0:20:58.91,0:21:01.64,Default,,0,0,0,,我最好保存好与之有关的FUN寄存器
Dialogue: 0,0:21:02.07,0:21:03.22,Default,,0,0,0,,因为后面也许会用得着
Dialogue: 0,0:21:03.28,0:21:04.89,Default,,0,0,0,,我最好也保存参数表
Dialogue: 0,0:21:06.90,0:21:09.05,Default,,0,0,0,,然而 在这如果是编译器的话
Dialogue: 0,0:21:09.05,0:21:10.38,Default,,0,0,0,,实际需要哪些寄存器
Dialogue: 0,0:21:10.52,0:21:11.84,Default,,0,0,0,,从而进行相关的保存与恢复
Dialogue: 0,0:21:12.70,0:21:16.09,Default,,0,0,0,,事实上 这里求值器做的所有栈操作
Dialogue: 0,0:21:16.32,0:21:19.58,Default,,0,0,0,,都证明是过于悲观而不必要
Dialogue: 0,0:21:19.62,0:21:21.45,Default,,0,0,0,,而编译器在这里是知道这一点的
Dialogue: 0,0:21:27.35,0:21:28.48,Default,,0,0,0,,这是最基础的想法
Dialogue: 0,0:21:29.80,0:21:31.00,Default,,0,0,0,,我们把求值器
Dialogue: 0,0:21:31.00,0:21:33.24,Default,,0,0,0,,剔除那些不需要的东西
Dialogue: 0,0:21:33.24,0:21:35.24,Default,,0,0,0,,去除那些对于编译器完全无用的东西
Dialogue: 0,0:21:35.24,0:21:36.19,Default,,0,0,0,,只保留求值的部分
Dialogue: 0,0:21:37.40,0:21:40.40,Default,,0,0,0,,然后你可以看到哪些栈操作是不必要的
Dialogue: 0,0:21:40.82,0:21:43.76,Default,,0,0,0,,这就是书中所描述的编译器
Dialogue: 0,0:21:43.85,0:21:45.04,Default,,0,0,0,,的基本结构
Dialogue: 0,0:21:45.04,0:21:47.00,Default,,0,0,0,,我给你们展示一下这
Dialogue: 0,0:21:47.76,0:21:49.68,Default,,0,0,0,,这个简单的例子
Dialogue: 0,0:21:51.20,0:21:53.26,Default,,0,0,0,,为了说清楚 多余的东西是怎样保存的
Dialogue: 0,0:21:53.29,0:21:56.06,Default,,0,0,0,,我们来看一个稍复杂的表达式
Dialogue: 0,0:21:58.15,0:22:01.93,Default,,0,0,0,,(F (G X) 1)
Dialogue: 0,0:22:03.87,0:22:05.52,Default,,0,0,0,,我们不会讲解所有的代码
Dialogue: 0,0:22:06.40,0:22:08.56,Default,,0,0,0,,因为代码有点多
Dialogue: 0,0:22:09.72,0:22:12.35,Default,,0,0,0,,我认为在求值器在处理它时
Dialogue: 0,0:22:12.35,0:22:14.67,Default,,0,0,0,,大概会产生
Dialogue: 0,0:22:14.70,0:22:16.25,Default,,0,0,0,,16对保存-恢复操作
Dialogue: 0,0:22:17.00,0:22:18.57,Default,,0,0,0,,这有一张图表
Dialogue: 0,0:22:20.57,0:22:21.95,Default,,0,0,0,,演示了其中的过程
Dialogue: 0,0:22:22.97,0:22:23.90,Default,,0,0,0,,你从这里开始--
Dialogue: 0,0:22:24.25,0:22:26.62,Default,,0,0,0,,求值器说：“我要求值一个应用”
Dialogue: 0,0:22:26.90,0:22:29.13,Default,,0,0,0,,在这里保存ENV 又在这里恢复
Dialogue: 0,0:22:30.65,0:22:34.44,Default,,0,0,0,,然后处理第一个运算对象
Dialogue: 0,0:22:36.81,0:22:39.28,Default,,0,0,0,,这是求值器的递归调用
Dialogue: 0,0:22:39.28,0:22:40.89,Default,,0,0,0,,求值器发现 这是一个应用
Dialogue: 0,0:22:40.91,0:22:42.10,Default,,0,0,0,,又会保存环境
Dialogue: 0,0:22:42.10,0:22:44.97,Default,,0,0,0,,求值组合式的运算符 然后在这里恢复环境
Dialogue: 0,0:22:45.80,0:22:48.92,Default,,0,0,0,,这个恢复匹配的是这个保存操作
Dialogue: 0,0:22:49.77,0:22:50.78,Default,,0,0,0,,以此类推
Dialogue: 0,0:22:51.65,0:22:52.51,Default,,0,0,0,,这里的UNEV
Dialogue: 0,0:22:52.52,0:22:54.62,Default,,0,0,0,,完全没有必要存在
Dialogue: 0,0:22:54.97,0:22:56.60,Default,,0,0,0,,CONTINUE寄存器不断地被保存-恢复
Dialogue: 0,0:22:57.42,0:23:00.41,Default,,0,0,0,,而FUN寄存器则是在
Dialogue: 0,0:23:00.78,0:23:04.36,Default,,0,0,0,,处理运算对象期间被保存
Dialogue: 0,0:23:05.10,0:23:06.52,Default,,0,0,0,,这类的事情一直在发生
Dialogue: 0,0:23:06.78,0:23:09.39,Default,,0,0,0,,但如果你问 跟求值器相比
Dialogue: 0,0:23:09.87,0:23:11.66,Default,,0,0,0,,编译器究竟要做什么？
Dialogue: 0,0:23:12.27,0:23:13.55,Default,,0,0,0,,你会去掉一大堆东西
Dialogue: 0,0:23:14.30,0:23:16.64,Default,,0,0,0,,在这个的基础上 如果你说
Dialogue: 0,0:23:19.40,0:23:22.54,Default,,0,0,0,,对F的求值不会修改ENV寄存器
Dialogue: 0,0:23:23.82,0:23:26.51,Default,,0,0,0,,或者对符号X的查找
Dialogue: 0,0:23:29.28,0:23:32.09,Default,,0,0,0,,不需要特别保护FUN寄存器
Dialogue: 0,0:23:34.30,0:23:37.60,Default,,0,0,0,,就得到了只有几对的保存-恢复操作
Dialogue: 0,0:23:40.25,0:23:42.27,Default,,0,0,0,,然而 你还可以再优化一下
Dialogue: 0,0:23:42.27,0:23:44.33,Default,,0,0,0,,看看这里的ENV寄存器发生了什么
Dialogue: 0,0:23:45.21,0:23:47.39,Default,,0,0,0,,我们观察ENV寄存器的操作 发现
Dialogue: 0,0:23:51.00,0:23:52.25,Default,,0,0,0,,这是一个组合式
Dialogue: 0,0:23:54.33,0:23:55.69,Default,,0,0,0,,而这个求值器
Dialogue: 0,0:23:55.78,0:23:57.27,Default,,0,0,0,,对G一无所知
Dialogue: 0,0:23:58.57,0:24:00.73,Default,,0,0,0,,所以在这 它说
Dialogue: 0,0:24:01.29,0:24:03.45,Default,,0,0,0,,我最好保存ENV寄存器
Dialogue: 0,0:24:03.96,0:24:05.42,Default,,0,0,0,,因为对G的求值
Dialogue: 0,0:24:05.42,0:24:07.42,Default,,0,0,0,,可能会修改ENV寄存器的值
Dialogue: 0,0:24:07.55,0:24:09.45,Default,,0,0,0,,而我稍后可能会需要它
Dialogue: 0,0:24:10.17,0:24:11.40,Default,,0,0,0,,在这个参数之后
Dialogue: 0,0:24:12.22,0:24:13.37,Default,,0,0,0,,在处理第二个参数的时候
Dialogue: 0,0:24:15.60,0:24:17.24,Default,,0,0,0,,这就是为什么它没被优化掉
Dialogue: 0,0:24:19.07,0:24:22.54,Default,,0,0,0,,因为编译器没有对G将要做的事情做任何假设
Dialogue: 0,0:24:22.54,0:24:23.60,Default,,0,0,0,,另一方面
Dialogue: 0,0:24:24.61,0:24:26.52,Default,,0,0,0,,如果你看看这里的第二个参数
Dialogue: 0,0:24:26.64,0:24:27.70,Default,,0,0,0,,它只是查找“1”这个常量
Dialogue: 0,0:24:27.70,0:24:29.60,Default,,0,0,0,,这不需要ENV寄存器
Dialogue: 0,0:24:30.77,0:24:32.04,Default,,0,0,0,,因此没必要保存它
Dialogue: 0,0:24:32.06,0:24:33.77,Default,,0,0,0,,事实上 你也可以把这个也去掉
Dialogue: 0,0:24:34.85,0:24:37.81,Default,,0,0,0,,这一堆寄存器操作
Dialogue: 0,0:24:37.98,0:24:40.08,Default,,0,0,0,,如果你像这样简单地推理的话
Dialogue: 0,0:24:40.55,0:24:43.05,Default,,0,0,0,,只会剩下两对保存-恢复操作
Dialogue: 0,0:24:45.10,0:24:46.97,Default,,0,0,0,,而这些 如果你知道关于G的某些信息的话
Dialogue: 0,0:24:47.52,0:24:49.08,Default,,0,0,0,,可以进一步优化
Dialogue: 0,0:24:56.27,0:24:57.85,Default,,0,0,0,,基本的理念是
Dialogue: 0,0:24:57.95,0:24:59.98,Default,,0,0,0,,编译器之所以更好
Dialogue: 0,0:24:59.98,0:25:02.56,Default,,0,0,0,,是因为解释器对于将要处理的东西一无所知
Dialogue: 0,0:25:03.25,0:25:05.04,Default,,0,0,0,,它不得不以最悲观的方式保存东西
Dialogue: 0,0:25:05.05,0:25:06.70,Default,,0,0,0,,来保护它自己
Dialogue: 0,0:25:07.90,0:25:08.76,Default,,0,0,0,,而编译器
Dialogue: 0,0:25:09.48,0:25:12.38,Default,,0,0,0,,只需要保存实际需要的东西
Dialogue: 0,0:25:13.37,0:25:15.20,Default,,0,0,0,,某个东西是否需要保存
Dialogue: 0,0:25:15.24,0:25:17.37,Default,,0,0,0,,有两种原因
Dialogue: 0,0:25:17.82,0:25:18.70,Default,,0,0,0,,一种是
Dialogue: 0,0:25:18.70,0:25:19.82,Default,,0,0,0,,你保护的东西
Dialogue: 0,0:25:19.95,0:25:21.44,Default,,0,0,0,,不会修改寄存器
Dialogue: 0,0:25:22.08,0:25:23.58,Default,,0,0,0,,例如 变量查找
Dialogue: 0,0:25:24.12,0:25:25.20,Default,,0,0,0,,另一种原因是
Dialogue: 0,0:25:25.32,0:25:27.10,Default,,0,0,0,,你所保存的东西
Dialogue: 0,0:25:28.28,0:25:29.92,Default,,0,0,0,,最后并不会被用到
Dialogue: 0,0:25:30.81,0:25:34.27,Default,,0,0,0,,因此 编译器正是利用了
Dialogue: 0,0:25:34.30,0:25:35.88,Default,,0,0,0,,这两条基本原则
Dialogue: 0,0:25:36.27,0:25:37.76,Default,,0,0,0,,来让代码变得更高效的
Dialogue: 0,0:25:44.27,0:25:45.32,Default,,0,0,0,,有什么问题吗？
Dialogue: 0,0:25:51.20,0:25:53.10,Default,,0,0,0,,学生: 你一直在说UNEV寄存器
Dialogue: 0,0:25:53.13,0:25:56.40,Default,,0,0,0,,UNEV寄存器完全不会被用到
Dialogue: 0,0:25:56.41,0:25:58.68,Default,,0,0,0,,是否意味着 机器只需要6个寄存器足矣？
Dialogue: 0,0:25:58.70,0:26:00.08,Default,,0,0,0,,或者是说 在这个特定的例子里
Dialogue: 0,0:26:00.11,0:26:01.18,Default,,0,0,0,,它没有被用到？
Dialogue: 0,0:26:01.72,0:26:02.81,Default,,0,0,0,,教授: 对于编译器
Dialogue: 0,0:26:04.31,0:26:07.42,Default,,0,0,0,,你可以生成6个或5个寄存器的代码
Dialogue: 0,0:26:07.56,0:26:09.02,Default,,0,0,0,,因为EXP寄存器也没有用到
Dialogue: 0,0:26:09.40,0:26:14.57,Default,,0,0,0,,是的 你可以把EXP和UNEV都去掉
Dialogue: 0,0:26:14.57,0:26:16.87,Default,,0,0,0,,因为这些是求值器的数据结构
Dialogue: 0,0:26:17.36,0:26:19.36,Default,,0,0,0,,以编译器的视角来看
Dialogue: 0,0:26:19.39,0:26:20.87,Default,,0,0,0,,这些东西都是常量
Dialogue: 0,0:26:21.65,0:26:22.44,Default,,0,0,0,,关键在于
Dialogue: 0,0:26:22.48,0:26:24.59,Default,,0,0,0,,这个特定编译器是被构造出来的
Dialogue: 0,0:26:24.79,0:26:27.92,Default,,0,0,0,,因此被解释的代码和被编译的代码可以共存
Dialogue: 0,0:26:29.32,0:26:30.72,Default,,0,0,0,,可以这样看待它
Dialogue: 0,0:26:30.97,0:26:32.29,Default,,0,0,0,,你构建了一个芯片
Dialogue: 0,0:26:34.30,0:26:35.50,Default,,0,0,0,,它就是求值器
Dialogue: 0,0:26:35.88,0:26:37.28,Default,,0,0,0,,而编译器可以做的就是
Dialogue: 0,0:26:37.31,0:26:39.02,Default,,0,0,0,,为这个芯片生成代码
Dialogue: 0,0:26:40.40,0:26:41.90,Default,,0,0,0,,只是它不会用到两个寄存器而已
Dialogue: 0,0:26:51.52,0:26:52.47,Default,,0,0,0,,好 休息一会
Dialogue: 0,0:26:53.55,0:27:07.18,Default,,0,0,0,,[音乐]
Dialogue: 0,0:27:07.37,0:27:11.42,Declare,,0,0,0,,{\an2\fad(500,500)}《计算机程序的构造和解释》
Dialogue: 0,0:27:14.57,0:27:18.12,Declare,,0,0,0,,{\an2\fad(500,500)}讲师： 哈罗德·艾伯森教授 及 格兰德·杰·萨斯曼教授
Dialogue: 0,0:27:18.17,0:27:22.08,Declare,,0,0,0,,{\an2\fad(500,500)}《计算机程序的构造和解释》
Dialogue: 0,0:27:22.22,0:27:26.48,Declare,,0,0,0,,{\an2\fad(500,500)}编译
Dialogue: 0,0:27:29.21,0:27:32.43,Default,,0,0,0,,我们刚才研究了编译器应该要做什么
Dialogue: 0,0:27:32.78,0:27:36.04,Default,,0,0,0,,现在我们来简略地看看
Dialogue: 0,0:27:36.15,0:27:37.47,Default,,0,0,0,,这些目标如何达成
Dialogue: 0,0:27:38.26,0:27:39.58,Default,,0,0,0,,而我不会给出细节
Dialogue: 0,0:27:39.60,0:27:42.17,Default,,0,0,0,,在书中有一大堆代码
Dialogue: 0,0:27:42.22,0:27:43.42,Default,,0,0,0,,展示了所有细节
Dialogue: 0,0:27:43.45,0:27:45.31,Default,,0,0,0,,我要做的 是给你们展示
Dialogue: 0,0:27:45.96,0:27:47.26,Default,,0,0,0,,其中的关键思想
Dialogue: 0,0:27:49.49,0:27:51.36,Default,,0,0,0,,换个时间再来关心细节
Dialogue: 0,0:27:51.51,0:27:55.30,Default,,0,0,0,,设想我们正在编译一条表达式
Dialogue: 0,0:27:55.30,0:27:57.01,Default,,0,0,0,,这里有一些运算符
Dialogue: 0,0:27:57.48,0:27:58.56,Default,,0,0,0,,和两个参数
Dialogue: 0,0:28:03.56,0:28:04.24,Default,,0,0,0,,现在
Dialogue: 0,0:28:06.27,0:28:08.14,Default,,0,0,0,,这个编译器会生成什么代码?
Dialogue: 0,0:28:08.85,0:28:09.78,Default,,0,0,0,,首先
Dialogue: 0,0:28:09.83,0:28:11.20,Default,,0,0,0,,它会递归运行
Dialogue: 0,0:28:11.90,0:28:13.28,Default,,0,0,0,,编译运算符
Dialogue: 0,0:28:14.37,0:28:19.02,Default,,0,0,0,,它说 我要编译运算符
Dialogue: 0,0:28:21.16,0:28:24.54,Default,,0,0,0,,最后我需要让它们的结果
Dialogue: 0,0:28:24.84,0:28:27.95,Default,,0,0,0,,存放在FUN寄存器中
Dialogue: 0,0:28:28.42,0:28:29.60,Default,,0,0,0,,所以我编译一些指令
Dialogue: 0,0:28:29.64,0:28:31.56,Default,,0,0,0,,它们会编译运算符
Dialogue: 0,0:28:31.69,0:28:38.62,Default,,0,0,0,,最后把结果放在FUN寄存器中
Dialogue: 0,0:28:45.51,0:28:46.94,Default,,0,0,0,,接下来我要做的是
Dialogue: 0,0:28:47.71,0:28:49.68,Default,,0,0,0,,另一个代码片段则说
Dialogue: 0,0:28:49.68,0:28:55.17,Default,,0,0,0,,我要编译第一个参数
Dialogue: 0,0:28:55.17,0:28:56.80,Default,,0,0,0,,因此它递归调地用自己
Dialogue: 0,0:28:58.04,0:29:03.36,Default,,0,0,0,,而结果会被放在VAL中
Dialogue: 0,0:29:09.07,0:29:10.75,Default,,0,0,0,,接下来需要做的是
Dialogue: 0,0:29:10.75,0:29:12.26,Default,,0,0,0,,建立起参数表
Dialogue: 0,0:29:12.95,0:29:25.50,Default,,0,0,0,,(ASSIGN ARGL (CONS (FETCH --
Dialogue: 0,0:29:25.55,0:29:27.10,Default,,0,0,0,,它会生成这些代码
Dialogue: 0,0:29:27.50,0:29:32.51,Default,,0,0,0,,(FETCH VAL) '()))
Dialogue: 0,0:29:35.00,0:29:36.05,Default,,0,0,0,,然而
Dialogue: 0,0:29:37.99,0:29:40.61,Default,,0,0,0,,当它到这里时
Dialogue: 0,0:29:41.32,0:29:42.82,Default,,0,0,0,,它可能需要环境
Dialogue: 0,0:29:43.95,0:29:45.29,Default,,0,0,0,,它需要环境
Dialogue: 0,0:29:45.32,0:29:48.21,Default,,0,0,0,,这是求值第一个参数所需要的
Dialogue: 0,0:29:49.04,0:29:51.18,Default,,0,0,0,,因此 它需要保证
Dialogue: 0,0:29:51.92,0:29:53.76,Default,,0,0,0,,对运算对象的编译
Dialogue: 0,0:29:55.32,0:29:57.85,Default,,0,0,0,,或者说它需要保护FUN寄存器
Dialogue: 0,0:29:58.01,0:30:00.98,Default,,0,0,0,,来应对编译运算对象时发生的各种情况
Dialogue: 0,0:30:01.30,0:30:03.08,Default,,0,0,0,,因此它在这做了个标注说
Dialogue: 0,0:30:03.37,0:30:12.89,Default,,0,0,0,,这个片段需要保护ENV寄存器
Dialogue: 0,0:30:17.39,0:30:18.44,Default,,0,0,0,,与之类似 这里
Dialogue: 0,0:30:21.02,0:30:23.30,Default,,0,0,0,,在完成第一个运算对象的编译后
Dialogue: 0,0:30:23.57,0:30:24.67,Default,,0,0,0,,它会说 我最好--
Dialogue: 0,0:30:24.71,0:30:27.92,Default,,0,0,0,,我需要知道第二个运算对象的环境
Dialogue: 0,0:30:27.92,0:30:29.46,Default,,0,0,0,,所以它在这做了个标注
Dialogue: 0,0:30:29.71,0:30:35.96,Default,,0,0,0,,这里也需要保护ENV
Dialogue: 0,0:30:39.42,0:30:41.02,Default,,0,0,0,,现在它继续运行
Dialogue: 0,0:30:41.12,0:30:42.83,Default,,0,0,0,,下一段代码
Dialogue: 0,0:30:43.31,0:30:49.74,Default,,0,0,0,,是要编译第二个参数
Dialogue: 0,0:30:50.82,0:30:52.64,Default,,0,0,0,,它将会
Dialogue: 0,0:30:52.99,0:30:59.28,Default,,0,0,0,,把编译的结果按约定放入到VAL中
Dialogue: 0,0:31:03.86,0:31:06.70,Default,,0,0,0,,随后它会生成一条指令
Dialogue: 0,0:31:07.84,0:31:09.25,Default,,0,0,0,,从而建立起参数表
Dialogue: 0,0:31:09.55,0:31:15.28,Default,,0,0,0,,(ASSIGN ARGL
Dialogue: 0,0:31:20.22,0:31:28.94,Default,,0,0,0,,(CONS (FETCH VAL) (FETCH ARGL))
Dialogue: 0,0:31:33.97,0:31:34.64,Default,,0,0,0,,然而
Dialogue: 0,0:31:34.81,0:31:36.58,Default,,0,0,0,,为了取得旧的参数表
Dialogue: 0,0:31:37.15,0:31:40.99,Default,,0,0,0,,它最好保证这期间发生的任何事情
Dialogue: 0,0:31:41.30,0:31:42.69,Default,,0,0,0,,都不影响旧的参数表
Dialogue: 0,0:31:43.50,0:31:45.17,Default,,0,0,0,,因此它在这做了个标注说
Dialogue: 0,0:31:45.34,0:31:51.64,Default,,0,0,0,,哦 这里需要保护ARGL
Dialogue: 0,0:31:54.16,0:31:56.03,Default,,0,0,0,,现在参数表就建立好了
Dialogue: 0,0:31:58.01,0:32:02.86,Default,,0,0,0,,现在可以准备去APPLY-DISPATCH了
Dialogue: 0,0:32:07.02,0:32:10.80,Default,,0,0,0,,它生成了这条指令
Dialogue: 0,0:32:15.19,0:32:17.37,Default,,0,0,0,,因为现在参数都在ARGL中
Dialogue: 0,0:32:18.15,0:32:20.59,Default,,0,0,0,,运算符在FUN中
Dialogue: 0,0:32:20.59,0:32:22.89,Default,,0,0,0,,如果只是单纯地把运算符放到FUN寄存器中
Dialogue: 0,0:32:23.27,0:32:26.64,Default,,0,0,0,,就需要它保证这块代码
Dialogue: 0,0:32:27.09,0:32:29.27,Default,,0,0,0,,不会破坏FUN寄存器里的东西
Dialogue: 0,0:32:29.67,0:32:31.24,Default,,0,0,0,,所以它在这做了个标注说
Dialogue: 0,0:32:31.55,0:32:32.73,Default,,0,0,0,,这里的所有东西
Dialogue: 0,0:32:34.88,0:32:40.73,Default,,0,0,0,,最好能够在保护FUN寄存器的情况下完成
Dialogue: 0,0:32:43.71,0:32:46.15,Default,,0,0,0,,所以这就是--
Dialogue: 0,0:32:46.15,0:32:47.10,Default,,0,0,0,,基本上来说
Dialogue: 0,0:32:48.20,0:32:50.24,Default,,0,0,0,,编译器所做的就是
Dialogue: 0,0:32:50.54,0:32:52.46,Default,,0,0,0,,追加一大堆的代码
Dialogue: 0,0:32:53.50,0:32:58.83,Default,,0,0,0,,而这些代码之中都是一些基本运算
Dialogue: 0,0:32:58.86,0:33:00.12,Default,,0,0,0,,比如符号查找
Dialogue: 0,0:33:01.44,0:33:02.60,Default,,0,0,0,,条件分支的处理
Dialogue: 0,0:33:02.64,0:33:05.44,Default,,0,0,0,,都是一些琐碎的事情
Dialogue: 0,0:33:05.44,0:33:07.99,Default,,0,0,0,,然后按照这种准则将它们追加到一起
Dialogue: 0,0:33:08.78,0:33:10.79,Default,,0,0,0,,因此 组合的基本手段就是
Dialogue: 0,0:33:10.86,0:33:13.18,Default,,0,0,0,,将一段代码追加到另一段的后面
Dialogue: 0,0:33:21.55,0:33:22.86,Default,,0,0,0,,就是这里发生的事情
Dialogue: 0,0:33:25.58,0:33:27.24,Default,,0,0,0,,这有点取巧
Dialogue: 0,0:33:27.56,0:33:30.37,Default,,0,0,0,,向一段代码后面追加代码的思路是
Dialogue: 0,0:33:31.60,0:33:33.76,Default,,0,0,0,,小心保护寄存器
Dialogue: 0,0:33:35.63,0:33:37.93,Default,,0,0,0,,追加操作看起来像这样
Dialogue: 0,0:33:39.15,0:33:40.65,Default,,0,0,0,,它要做的是
Dialogue: 0,0:33:41.20,0:33:44.11,Default,,0,0,0,,代码的追加是这么来做的
Dialogue: 0,0:33:44.53,0:33:53.63,Default,,0,0,0,,如果SEQ1需要寄存器--
Dialogue: 0,0:33:53.66,0:33:54.72,Default,,0,0,0,,我应该改一下这个
Dialogue: 0,0:33:54.72,0:33:56.87,Default,,0,0,0,,在SEQ1后面追加SEQ2
Dialogue: 0,0:33:57.42,0:34:03.96,Default,,0,0,0,,并保护一些寄存器
Dialogue: 0,0:34:08.52,0:34:09.91,Default,,0,0,0,,这里改成AND
Dialogue: 0,0:34:11.36,0:34:13.03,Default,,0,0,0,,这样的话前后顺序就清楚了
Dialogue: 0,0:34:13.88,0:34:19.87,Default,,0,0,0,,如果SEQ2需要寄存器
Dialogue: 0,0:34:21.12,0:34:27.85,Default,,0,0,0,,而SEQ1又修改了寄存器
Dialogue: 0,0:34:33.68,0:34:36.30,Default,,0,0,0,,那么编译器生成的指令是
Dialogue: 0,0:34:36.97,0:34:41.34,Default,,0,0,0,,保存寄存器
Dialogue: 0,0:34:43.02,0:34:44.19,Default,,0,0,0,,这就是代码
Dialogue: 0,0:34:44.35,0:34:45.35,Default,,0,0,0,,生成这段代码
Dialogue: 0,0:34:45.35,0:34:46.28,Default,,0,0,0,,保存寄存器
Dialogue: 0,0:34:46.72,0:34:52.97,Default,,0,0,0,,然后写下递归编译SEQ1的结果
Dialogue: 0,0:34:53.30,0:34:54.84,Default,,0,0,0,,然后恢复寄存器
Dialogue: 0,0:35:00.52,0:35:03.92,Default,,0,0,0,,再写下递归编译
Dialogue: 0,0:35:04.46,0:35:05.47,Default,,0,0,0,,SEQ2的结果
Dialogue: 0,0:35:07.07,0:35:09.62,Default,,0,0,0,,这就是你需要做的
Dialogue: 0,0:35:09.62,0:35:11.82,Default,,0,0,0,,实际上SEQ2需要寄存器
Dialogue: 0,0:35:11.82,0:35:13.74,Default,,0,0,0,,而SEQ1改动了它
Dialogue: 0,0:35:15.12,0:35:17.07,Default,,0,0,0,,否则的话
Dialogue: 0,0:35:20.50,0:35:26.57,Default,,0,0,0,,得到的就是SEQ1后面跟着SEQ2
Dialogue: 0,0:35:28.17,0:35:30.30,Default,,0,0,0,,这就是把两个代码片段
Dialogue: 0,0:35:30.59,0:35:33.52,Default,,0,0,0,,连接到一起的基本操作
Dialogue: 0,0:35:33.93,0:35:35.93,Default,,0,0,0,,把这些指令组合成序列
Dialogue: 0,0:35:36.89,0:35:38.87,Default,,0,0,0,,我们可以发现 从这个角度看
Dialogue: 0,0:35:40.94,0:35:45.96,Default,,0,0,0,,解释器和编译器的区别
Dialogue: 0,0:35:46.82,0:35:49.34,Default,,0,0,0,,是编译器有保护寄存器的标注
Dialogue: 0,0:35:50.14,0:35:52.22,Default,,0,0,0,,上面记录着
Dialogue: 0,0:35:52.49,0:35:54.22,Default,,0,0,0,,是否需要生成保存-恢复代码
Dialogue: 0,0:35:55.19,0:35:57.24,Default,,0,0,0,,而解释器会以最悲观的方式处理
Dialogue: 0,0:35:57.28,0:35:58.90,Default,,0,0,0,,总是会进行保存-恢复
Dialogue: 0,0:36:00.76,0:36:01.93,Default,,0,0,0,,这就是关键的区别
Dialogue: 0,0:36:04.16,0:36:06.05,Default,,0,0,0,,为了实现这个
Dialogue: 0,0:36:06.65,0:36:09.40,Default,,0,0,0,,编译器需要一些理论
Dialogue: 0,0:36:09.56,0:36:11.96,Default,,0,0,0,,来确定代码序列会需要、又会修改哪些寄存器
Dialogue: 0,0:36:14.26,0:36:17.28,Default,,0,0,0,,所以你放入的小片段
Dialogue: 0,0:36:17.48,0:36:21.00,Default,,0,0,0,,例如这段基础代码
Dialogue: 0,0:36:22.74,0:36:24.59,Default,,0,0,0,,当你查找一个变量时
Dialogue: 0,0:36:24.92,0:36:26.04,Default,,0,0,0,,进行了哪些操作？
Dialogue: 0,0:36:26.89,0:36:29.02,Default,,0,0,0,,你又是做了些什么
Dialogue: 0,0:36:29.05,0:36:30.68,Default,,0,0,0,,来编译一个常量
Dialogue: 0,0:36:30.97,0:36:32.10,Default,,0,0,0,,或者应用一个函数
Dialogue: 0,0:36:32.97,0:36:34.48,Default,,0,0,0,,它们都会带有一些标注
Dialogue: 0,0:36:34.67,0:36:36.46,Default,,0,0,0,,说明了它们需要的和修改的寄存器
Dialogue: 0,0:36:38.78,0:36:41.50,Default,,0,0,0,,所以底层的数据结构
Dialogue: 0,0:36:42.66,0:36:44.33,Default,,0,0,0,,我会这样讲
Dialogue: 0,0:36:44.39,0:36:47.91,Default,,0,0,0,,传递给编译器的代码序列大概是这样
Dialogue: 0,0:36:48.07,0:36:51.42,Default,,0,0,0,,它里面有实际的指令序列
Dialogue: 0,0:36:55.67,0:36:56.81,Default,,0,0,0,,跟它一起的还有
Dialogue: 0,0:36:57.18,0:37:02.60,Default,,0,0,0,,一组被修改的寄存器
Dialogue: 0,0:37:10.54,0:37:12.60,Default,,0,0,0,,还有一组需要的寄存器
Dialogue: 0,0:37:20.00,0:37:22.46,Default,,0,0,0,,为了能够执行此操作
Dialogue: 0,0:37:23.00,0:37:26.41,Default,,0,0,0,,编译器必须要掌握这些信息
Dialogue: 0,0:37:29.30,0:37:31.08,Default,,0,0,0,,它们从哪来呢
Dialogue: 0,0:37:32.91,0:37:34.49,Default,,0,0,0,,它们来自于--你们可能也想到了
Dialogue: 0,0:37:34.51,0:37:35.53,Default,,0,0,0,,对于那些最基本的片段
Dialogue: 0,0:37:35.55,0:37:36.84,Default,,0,0,0,,我们会手工添加
Dialogue: 0,0:37:37.24,0:37:38.86,Default,,0,0,0,,然后 当我们组合两个序列时
Dialogue: 0,0:37:38.89,0:37:41.02,Default,,0,0,0,,我们会计算出这两个集合
Dialogue: 0,0:37:42.16,0:37:44.12,Default,,0,0,0,,举一个非常基本的例子
Dialogue: 0,0:37:48.43,0:37:51.40,Default,,0,0,0,,例如做一个寄存器赋值
Dialogue: 0,0:37:51.77,0:37:53.50,Default,,0,0,0,,因此 基本代码片段会说
Dialogue: 0,0:37:53.52,0:37:56.22,Default,,0,0,0,,噢 它是个代码片段
Dialogue: 0,0:37:56.22,0:38:03.17,Default,,0,0,0,,代码的指令部分是(ASSIGN R1 (FETCH R2))
Dialogue: 0,0:38:03.17,0:38:04.27,Default,,0,0,0,,这个例子就是这样的
Dialogue: 0,0:38:05.42,0:38:08.52,Default,,0,0,0,,一段指令序列大概就是这样
Dialogue: 0,0:38:08.77,0:38:10.53,Default,,0,0,0,,和它在一起的是
Dialogue: 0,0:38:10.64,0:38:15.76,Default,,0,0,0,,它需要记得修改了R1
Dialogue: 0,0:38:18.60,0:38:21.16,Default,,0,0,0,,然后它需要R2
Dialogue: 0,0:38:24.69,0:38:26.99,Default,,0,0,0,,因此当你开始构建编译器时
Dialogue: 0,0:38:27.10,0:38:29.35,Default,,0,0,0,,你放入这样的一个片段
Dialogue: 0,0:38:30.95,0:38:33.20,Default,,0,0,0,,当它组合两个序列时
Dialogue: 0,0:38:36.70,0:38:38.04,Default,,0,0,0,,我要组合
Dialogue: 0,0:38:38.92,0:38:41.58,Default,,0,0,0,,代码片段S1
Dialogue: 0,0:38:42.88,0:38:47.16,Default,,0,0,0,,修改了一组寄存器M1
Dialogue: 0,0:38:48.45,0:38:51.42,Default,,0,0,0,,并且需要一组寄存器N1
Dialogue: 0,0:38:54.85,0:38:59.48,Default,,0,0,0,,并且我要把它和序列S2组合到一起
Dialogue: 0,0:39:00.81,0:39:05.96,Default,,0,0,0,,后者修改了一组寄存器M2
Dialogue: 0,0:39:07.11,0:39:10.00,Default,,0,0,0,,并且需要一组寄存器N2
Dialogue: 0,0:39:12.44,0:39:14.83,Default,,0,0,0,,这样我们就能得出结果
Dialogue: 0,0:39:15.11,0:39:16.32,Default,,0,0,0,,新的代码片段是这样的
Dialogue: 0,0:39:17.18,0:39:21.82,Default,,0,0,0,,指令序列S1后面跟着S2
Dialogue: 0,0:39:24.09,0:39:26.45,Default,,0,0,0,,它要修改什么?
Dialogue: 0,0:39:27.80,0:39:29.18,Default,,0,0,0,,它要修改的是
Dialogue: 0,0:39:29.20,0:39:32.68,Default,,0,0,0,,被S1或者被S2修改的寄存器
Dialogue: 0,0:39:34.00,0:39:36.35,Default,,0,0,0,,N1和N2的并集
Dialogue: 0,0:39:37.68,0:39:39.64,Default,,0,0,0,,就是新的修改集
Dialogue: 0,0:39:40.46,0:39:41.79,Default,,0,0,0,,然后你问
Dialogue: 0,0:39:44.66,0:39:46.41,Default,,0,0,0,,又需要哪些寄存器？
Dialogue: 0,0:39:47.95,0:39:49.77,Default,,0,0,0,,需要这些寄存器的是
Dialogue: 0,0:39:49.93,0:39:51.85,Default,,0,0,0,,首先 一定是序列S1需要的
Dialogue: 0,0:39:52.91,0:39:54.49,Default,,0,0,0,,因此必然有N1
Dialogue: 0,0:39:55.19,0:39:58.28,Default,,0,0,0,,然后 并不是N2里面的所有元素
Dialogue: 0,0:39:58.32,0:39:59.61,Default,,0,0,0,,我们都需要
Dialogue: 0,0:39:59.75,0:40:03.49,Default,,0,0,0,,新的修改集需要N2中那些
Dialogue: 0,0:40:03.88,0:40:06.88,Default,,0,0,0,,没有被S1修改过的寄存器
Dialogue: 0,0:40:08.14,0:40:09.72,Default,,0,0,0,,所以 这个并集是N1并上
Dialogue: 0,0:40:11.66,0:40:13.40,Default,,0,0,0,,序列S2的需要集N2
Dialogue: 0,0:40:14.51,0:40:18.52,Default,,0,0,0,,减去序列S1的修改集M1
Dialogue: 0,0:40:19.31,0:40:20.88,Default,,0,0,0,,因为它关心的是如何设置它们
Dialogue: 0,0:40:23.95,0:40:26.26,Default,,0,0,0,,这就是编译器的基本结构
Dialogue: 0,0:40:26.70,0:40:29.82,Default,,0,0,0,,我们进行寄存器优化的方式是
Dialogue: 0,0:40:30.22,0:40:32.70,Default,,0,0,0,,一些策略来应对需要保护的东西
Dialogue: 0,0:40:34.10,0:40:35.63,Default,,0,0,0,,这取决于数据结构
Dialogue: 0,0:40:35.72,0:40:38.51,Default,,0,0,0,,这取决于将东西组合在一起的操作
Dialogue: 0,0:40:39.03,0:40:41.63,Default,,0,0,0,,想知道要保护哪些东西
Dialogue: 0,0:40:41.93,0:40:47.28,Default,,0,0,0,,就需要知道这段代码需要以及修改的寄存器
Dialogue: 0,0:40:48.75,0:40:51.26,Default,,0,0,0,,这就需要我们有一个数据结构
Dialogue: 0,0:40:51.42,0:40:55.43,Default,,0,0,0,,它不但要存放实际的指令序列
Dialogue: 0,0:40:55.60,0:40:57.33,Default,,0,0,0,,它修改了什么 又需要什么
Dialogue: 0,0:40:57.33,0:40:59.77,Default,,0,0,0,,这些信息来自于--最基本的情况是内置的
Dialogue: 0,0:40:59.79,0:41:01.36,Default,,0,0,0,,对于最基本的情况
Dialogue: 0,0:41:01.37,0:41:02.52,Default,,0,0,0,,我们可以容易地知道
Dialogue: 0,0:41:03.00,0:41:04.44,Default,,0,0,0,,需要哪些寄存器 又修改了哪些
Dialogue: 0,0:41:04.82,0:41:05.35,Default,,0,0,0,,另外
Dialogue: 0,0:41:05.44,0:41:08.60,Default,,0,0,0,,利用这个特定的方法构建复杂指令时
Dialogue: 0,0:41:09.28,0:41:11.89,Default,,0,0,0,,我们可以像这样生成新的修改集
Dialogue: 0,0:41:11.93,0:41:13.37,Default,,0,0,0,,以及新的需要集
Dialogue: 0,0:41:15.27,0:41:17.77,Default,,0,0,0,,这就是全部的内容 -- 我不该这么说
Dialogue: 0,0:41:17.77,0:41:19.34,Default,,0,0,0,,这就是书里面大概30页的细节
Dialogue: 0,0:41:19.74,0:41:21.87,Default,,0,0,0,,的核心内容了
Dialogue: 0,0:41:22.31,0:41:27.69,Default,,0,0,0,,但它是一个完全可用的初级编译器
Dialogue: 0,0:41:28.76,0:41:31.37,Default,,0,0,0,,让我给你展示一下它能做什么
Dialogue: 0,0:41:31.39,0:41:35.56,Default,,0,0,0,,假设我们从一个递归阶乘开始
Dialogue: 0,0:41:36.20,0:41:38.60,Default,,0,0,0,,这些幻灯片的字太小不适合阅读
Dialogue: 0,0:41:38.60,0:41:39.79,Default,,0,0,0,,我只想快速翻一下代码
Dialogue: 0,0:41:39.79,0:41:41.28,Default,,0,0,0,,让你们看看它有多少代码
Dialogue: 0,0:41:42.25,0:41:43.29,Default,,0,0,0,,代码从这开始--
Dialogue: 0,0:41:44.32,0:41:45.68,Default,,0,0,0,,这是代码的第一部分
Dialogue: 0,0:41:45.95,0:41:47.68,Default,,0,0,0,,这里编译了一个过程入口
Dialogue: 0,0:41:47.69,0:41:48.73,Default,,0,0,0,,并进行了一些赋值操作
Dialogue: 0,0:41:48.75,0:41:51.48,Default,,0,0,0,,这基本上对应了解释器中
Dialogue: 0,0:41:52.65,0:41:53.90,Default,,0,0,0,,进行判断之前的部分
Dialogue: 0,0:41:54.31,0:41:56.59,Default,,0,0,0,,并判断谓词是否成立
Dialogue: 0,0:41:56.97,0:41:57.85,Default,,0,0,0,,第二部分是
Dialogue: 0,0:41:58.46,0:42:03.73,Default,,0,0,0,,递归调用N-1的阶乘的结果
Dialogue: 0,0:42:04.12,0:42:05.05,Default,,0,0,0,,最后一部分是
Dialogue: 0,0:42:06.07,0:42:07.48,Default,,0,0,0,,从那里返回
Dialogue: 0,0:42:07.87,0:42:09.90,Default,,0,0,0,,并处理递归的基本情况
Dialogue: 0,0:42:09.90,0:42:13.16,Default,,0,0,0,,这就是编译阶乘会生成的代码量
Dialogue: 0,0:42:13.72,0:42:17.69,Default,,0,0,0,,当然 我们可以把这个编译器做得更好
Dialogue: 0,0:42:18.67,0:42:21.24,Default,,0,0,0,,优化它的主要方式是
Dialogue: 0,0:42:21.24,0:42:24.00,Default,,0,0,0,,当你调用一个过程时
Dialogue: 0,0:42:24.35,0:42:26.27,Default,,0,0,0,,允许编译器做任何假设
Dialogue: 0,0:42:26.97,0:42:28.28,Default,,0,0,0,,举例来说
Dialogue: 0,0:42:28.30,0:42:32.32,Default,,0,0,0,,这个编译器甚至不知道
Dialogue: 0,0:42:33.12,0:42:36.14,Default,,0,0,0,,乘法可以被内联执行
Dialogue: 0,0:42:36.14,0:42:37.87,Default,,0,0,0,,它则会自行构建起整个机制
Dialogue: 0,0:42:38.00,0:42:39.34,Default,,0,0,0,,进行APPLY-DISPATCH
Dialogue: 0,0:42:41.37,0:42:42.49,Default,,0,0,0,,这是极大的浪费
Dialogue: 0,0:42:42.54,0:42:45.02,Default,,0,0,0,,因为 每当你进行APPLY-DISPATCH时
Dialogue: 0,0:42:45.02,0:42:46.80,Default,,0,0,0,,你都要关心这个参数表
Dialogue: 0,0:42:47.40,0:42:49.10,Default,,0,0,0,,因为它是个很普遍的操作
Dialogue: 0,0:42:49.13,0:42:51.07,Default,,0,0,0,,在任何真实的编译器中
Dialogue: 0,0:42:51.08,0:42:53.29,Default,,0,0,0,,你会有寄存器来暂存参数
Dialogue: 0,0:42:53.77,0:42:55.31,Default,,0,0,0,,你要开始保护
Dialogue: 0,0:42:56.38,0:42:58.05,Default,,0,0,0,,保存这些寄存器
Dialogue: 0,0:42:58.05,0:43:01.61,Default,,0,0,0,,和这里的策略相近
Dialogue: 0,0:43:02.85,0:43:05.93,Default,,0,0,0,,因此 我们可能主要通过这个方法
Dialogue: 0,0:43:05.95,0:43:08.30,Default,,0,0,0,,来优化书中这个特定的编译器
Dialogue: 0,0:43:08.69,0:43:09.70,Default,,0,0,0,,还有其它的一些方法
Dialogue: 0,0:43:09.70,0:43:11.82,Default,,0,0,0,,比如查找变量的值
Dialogue: 0,0:43:11.83,0:43:13.87,Default,,0,0,0,,使用更高效的基本操作
Dialogue: 0,0:43:13.88,0:43:14.56,Default,,0,0,0,,等等方法
Dialogue: 0,0:43:14.59,0:43:16.60,Default,,0,0,0,,本质上来说 一个好的Lisp编译器
Dialogue: 0,0:43:16.62,0:43:18.49,Default,,0,0,0,,可以吸收任意数量的努力
Dialogue: 0,0:43:19.72,0:43:21.63,Default,,0,0,0,,可能这其中的一个原因是
Dialogue: 0,0:43:21.89,0:43:23.04,Default,,0,0,0,,跟FORTRAN这类语言相比
Dialogue: 0,0:43:23.63,0:43:25.44,Default,,0,0,0,,Lisp就要慢一些
Dialogue: 0,0:43:25.90,0:43:28.19,Default,,0,0,0,,如果你回头审视历史
Dialogue: 0,0:43:28.22,0:43:31.12,Default,,0,0,0,,会发现人们为构建Lisp编译器而呕心沥血
Dialogue: 0,0:43:31.16,0:43:32.35,Default,,0,0,0,,但也远远没有接近
Dialogue: 0,0:43:32.36,0:43:33.90,Default,,0,0,0,,构建FORTRAN编译器的工作量
Dialogue: 0,0:43:34.43,0:43:35.79,Default,,0,0,0,,在接下来的几年
Dialogue: 0,0:43:35.92,0:43:37.68,Default,,0,0,0,,情况可能会发生变化
Dialogue: 0,0:43:38.00,0:43:38.83,Default,,0,0,0,,好吧 就讲到这里
Dialogue: 0,0:43:43.80,0:43:44.65,Default,,0,0,0,,有问题吗
Dialogue: 0,0:43:48.27,0:43:49.95,Default,,0,0,0,,学生: 很早的一个课时里--
Dialogue: 0,0:43:49.95,0:43:51.40,Default,,0,0,0,,我不记得是课上还是课后--
Dialogue: 0,0:43:51.47,0:43:53.88,Default,,0,0,0,,你向我们展示了
Dialogue: 0,0:43:54.00,0:43:57.52,Default,,0,0,0,,ADD操作有一些我们看不到的基本运算
Dialogue: 0,0:43:57.69,0:43:59.21,Default,,0,0,0,,类似于ADD%之类的
Dialogue: 0,0:43:59.82,0:44:01.65,Default,,0,0,0,,这是因为
Dialogue: 0,0:44:01.65,0:44:02.60,Default,,0,0,0,,你想把代码内联为
Dialogue: 0,0:44:02.60,0:44:08.19,Default,,0,0,0,,专门针对二元运算对象的运算么？
Dialogue: 0,0:44:08.70,0:44:10.25,Default,,0,0,0,,但如果你有更多的运算对象
Dialogue: 0,0:44:10.28,0:44:11.47,Default,,0,0,0,,你会做什么特殊的事情吗？
Dialogue: 0,0:44:12.71,0:44:16.04,Default,,0,0,0,,教授: 你看的是Scheme的实际实现
Dialogue: 0,0:44:16.06,0:44:17.84,Default,,0,0,0,,其中有一个‘+’ 这是一个运算符
Dialogue: 0,0:44:17.90,0:44:20.19,Default,,0,0,0,,如果你看‘+’的源代码
Dialogue: 0,0:44:20.33,0:44:21.37,Default,,0,0,0,,你会看到一些叫做--
Dialogue: 0,0:44:21.57,0:44:24.14,Default,,0,0,0,,我记不清了--可能叫ADD%、PLUS之类的东西
Dialogue: 0,0:44:24.55,0:44:25.79,Default,,0,0,0,,这里所进行的
Dialogue: 0,0:44:25.79,0:44:27.92,Default,,0,0,0,,就是你说的那种优化
Dialogue: 0,0:44:28.47,0:44:31.87,Default,,0,0,0,,因为 广义的‘+’接受任意数量的参数
Dialogue: 0,0:44:35.02,0:44:36.38,Default,,0,0,0,,所以 广义加法
Dialogue: 0,0:44:36.76,0:44:38.25,Default,,0,0,0,,会说：如果我有一个参数表
Dialogue: 0,0:44:38.28,0:44:40.62,Default,,0,0,0,,我最好将它们用CONS连接到表里
Dialogue: 0,0:44:41.63,0:44:44.14,Default,,0,0,0,,并指出有多少个参数
Dialogue: 0,0:44:44.72,0:44:46.16,Default,,0,0,0,,这样效率非常低下
Dialogue: 0,0:44:46.81,0:44:49.25,Default,,0,0,0,,因为大部分时间你在把两个数相加
Dialogue: 0,0:44:49.25,0:44:51.24,Default,,0,0,0,,你不必把整个参数表连接到一起
Dialogue: 0,0:44:52.04,0:44:53.93,Default,,0,0,0,,所以你想做的是
Dialogue: 0,0:44:55.66,0:44:57.71,Default,,0,0,0,,构建把一堆东西相加的代码
Dialogue: 0,0:44:58.15,0:45:00.17,Default,,0,0,0,,所以它做的大部分事情是一样的
Dialogue: 0,0:45:00.49,0:45:01.95,Default,,0,0,0,,但这里可能有个特殊的入口
Dialogue: 0,0:45:01.98,0:45:03.92,Default,,0,0,0,,如果你知道只有两个参数
Dialogue: 0,0:45:04.56,0:45:05.87,Default,,0,0,0,,你会把它们放到寄存器中
Dialogue: 0,0:45:05.87,0:45:06.97,Default,,0,0,0,,它们不需要参数表
Dialogue: 0,0:45:06.99,0:45:07.98,Default,,0,0,0,,你也不必用CONS连接它们
Dialogue: 0,0:45:08.67,0:45:10.42,Default,,0,0,0,,这就是这些东西工作的原理
Dialogue: 0,0:45:12.30,0:45:13.72,Default,,0,0,0,,好吧 下课吧
Dialogue: 0,0:45:14.10,0:45:42.97,Declare,,0,0,0,,{\fad(500,500)}MIT OpenCourseWare\Nhttp://ocw.mit.edu
Dialogue: 0,0:45:14.10,0:45:42.97,Declare,,0,0,0,,{\an2\fad(500,500)}本项目主页\Nhttps://github.com/DeathKing/Learning-SICP
