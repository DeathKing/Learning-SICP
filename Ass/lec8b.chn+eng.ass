[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 640
PlayResY: 480

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: EN,Calisto MT,21,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,1,0,2,10,10,30,1
Style: Declare,微软雅黑,30,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,2,0,8,10,10,10,1
Style: staff,微软雅黑,30,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,0,2,5,10,10,10,1
Style: title,微软雅黑,35,&H001D64D9,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,0,1,5,10,10,10,1
Style: Default,雅黑宋体,20,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,1,0,2,10,10,30,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:18.91,0:00:21.79,EN,,0,0,0,,PROFESSOR: All right, well, we've seen how the query language works.
Dialogue: 0,0:00:22.64,0:00:25.07,EN,,0,0,0,,Now, let's talk about how it's implemented.
Dialogue: 0,0:00:26.28,0:00:27.98,EN,,0,0,0,,You already pretty much can guess
Dialogue: 0,0:00:28.59,0:00:29.47,EN,,0,0,0,,what's going on there.
Dialogue: 0,0:00:29.47,0:00:31.64,EN,,0,0,0,,At the bottom of it, there's a pattern matcher.
Dialogue: 0,0:00:32.81,0:00:34.25,EN,,0,0,0,,And we looked at a pattern matcher
Dialogue: 0,0:00:34.67,0:00:36.94,EN,,0,0,0,,when we did the rule-based control language.
Dialogue: 0,0:00:38.11,0:00:40.59,EN,,0,0,0,,Just to remind you, here are some sample patterns.
Dialogue: 0,0:00:41.52,0:00:43.68,EN,,0,0,0,,This is a pattern that will match
Dialogue: 0,0:00:43.80,0:00:44.92,EN,,0,0,0,,any list of three things
Dialogue: 0,0:00:44.96,0:00:47.10,EN,,0,0,0,,which the first is a
Dialogue: 0,0:00:47.16,0:00:48.33,EN,,0,0,0,,the second is c
Dialogue: 0,0:00:48.48,0:00:50.19,EN,,0,0,0,,and the middle one can be anything.
Dialogue: 0,0:00:50.65,0:00:52.27,EN,,0,0,0,,So in this little pattern-matching syntax,
Dialogue: 0,0:00:52.30,0:00:54.05,EN,,0,0,0,,there's only one distinction you make.
Dialogue: 0,0:00:54.05,0:00:57.20,EN,,0,0,0,,There's either literal things or variables,
Dialogue: 0,0:00:57.23,0:00:58.86,EN,,0,0,0,,and variables begin with question mark.
Dialogue: 0,0:01:01.37,0:01:03.64,EN,,0,0,0,,So this matches any list of three things
Dialogue: 0,0:01:04.44,0:01:06.50,EN,,0,0,0,,of which the first is a and the second is c.
Dialogue: 0,0:01:06.50,0:01:09.00,EN,,0,0,0,,This one matches any list of three things
Dialogue: 0,0:01:10.43,0:01:12.53,EN,,0,0,0,,of which the first is the symbol job.
Dialogue: 0,0:01:12.53,0:01:13.90,EN,,0,0,0,,The second can be anything.
Dialogue: 0,0:01:14.21,0:01:15.90,EN,,0,0,0,,And the third is a list of two things
Dialogue: 0,0:01:15.95,0:01:17.72,EN,,0,0,0,,of which the first is the symbol computer
Dialogue: 0,0:01:17.88,0:01:19.42,EN,,0,0,0,,and the second can be anything.
Dialogue: 0,0:01:20.48,0:01:25.55,EN,,0,0,0,,And this one, this next one matches any list of three things,
Dialogue: 0,0:01:25.87,0:01:26.99,EN,,0,0,0,,and the only difference is,
Dialogue: 0,0:01:28.40,0:01:31.32,EN,,0,0,0,,here, the third list, the first is the symbol computer,
Dialogue: 0,0:01:31.76,0:01:33.29,EN,,0,0,0,,and then there's some rest of the list.
Dialogue: 0,0:01:35.04,0:01:37.53,EN,,0,0,0,,So this means two elements and this means arbitrary number.
Dialogue: 0,0:01:37.86,0:01:39.74,EN,,0,0,0,,And our language implementation isn't
Dialogue: 0,0:01:39.85,0:01:42.06,EN,,0,0,0,,isn't even going to have to worry about implementing this dot
Dialogue: 0,0:01:42.11,0:01:44.17,EN,,0,0,0,,because that's automatically done by Lisp's reader.
Dialogue: 0,0:01:48.34,0:01:50.31,EN,,0,0,0,,Remember matchers also have some consistency in them.
Dialogue: 0,0:01:50.31,0:01:52.32,EN,,0,0,0,,This match is a list of three things
Dialogue: 0,0:01:52.59,0:01:53.98,EN,,0,0,0,,of which the first is a.
Dialogue: 0,0:01:54.43,0:01:55.79,EN,,0,0,0,,And the second and third can be anything,
Dialogue: 0,0:01:55.80,0:01:57.08,EN,,0,0,0,,but they have to be the same thing.
Dialogue: 0,0:01:57.94,0:01:58.84,EN,,0,0,0,,They're both called x.
Dialogue: 0,0:01:59.60,0:02:01.55,EN,,0,0,0,,And this matches a list of four things
Dialogue: 0,0:02:01.96,0:02:03.26,EN,,0,0,0,,of which the first is the fourth
Dialogue: 0,0:02:03.66,0:02:05.15,EN,,0,0,0,,and the second is the same as the third.
Dialogue: 0,0:02:05.59,0:02:08.60,EN,,0,0,0,,And this last one matches any list that begins with a.
Dialogue: 0,0:02:09.68,0:02:11.05,EN,,0,0,0,,The first thing is a,
Dialogue: 0,0:02:11.23,0:02:12.56,EN,,0,0,0,,and the rest can be anything.
Dialogue: 0,0:02:14.04,0:02:16.60,EN,,0,0,0,,So that's just a review of pattern matcher syntax
Dialogue: 0,0:02:16.62,0:02:17.87,EN,,0,0,0,,that you've already seen.
Dialogue: 0,0:02:18.78,0:02:19.64,EN,,0,0,0,,And remember,
Dialogue: 0,0:02:19.79,0:02:22.28,EN,,0,0,0,,that's implemented by some procedure called match.
Dialogue: 0,0:02:24.87,0:02:36.06,EN,,0,0,0,,And match takes a pattern and some data and a dictionary.
Dialogue: 0,0:02:43.20,0:02:47.12,EN,,0,0,0,,And match asks the question
Dialogue: 0,0:02:47.79,0:02:52.64,EN,,0,0,0,,is there any way to match this pattern against this data object
Dialogue: 0,0:02:53.55,0:02:56.73,EN,,0,0,0,,subject to the bindings that are already in this dictionary?
Dialogue: 0,0:02:58.16,0:02:59.21,EN,,0,0,0,,So, for instance,
Dialogue: 0,0:02:59.56,0:03:06.43,EN,,0,0,0,,if we're going to match the pattern x, y, y, x
Dialogue: 0,0:03:07.71,0:03:13.84,EN,,0,0,0,,against the data a, b, b, a
Dialogue: 0,0:03:15.12,0:03:20.52,EN,,0,0,0,,subject to a dictionary, that says x equals a.
Dialogue: 0,0:03:22.01,0:03:25.23,EN,,0,0,0,,Then the matcher would say, yes, that's consistent.
Dialogue: 0,0:03:25.26,0:03:27.16,EN,,0,0,0,,These match, and it's consistent
Dialogue: 0,0:03:27.80,0:03:30.20,EN,,0,0,0,,with what's in the dictionary to say that x equals a.
Dialogue: 0,0:03:30.32,0:03:31.60,EN,,0,0,0,,And the result of the match
Dialogue: 0,0:03:32.25,0:03:34.30,EN,,0,0,0,,is the extended dictionary
Dialogue: 0,0:03:34.46,0:03:37.60,EN,,0,0,0,,that says x equals a and y equals b.
Dialogue: 0,0:03:39.49,0:03:42.24,EN,,0,0,0,,So a matcher takes in pattern data dictionary,
Dialogue: 0,0:03:42.38,0:03:44.54,EN,,0,0,0,,puts out an extended dictionary if it matches,
Dialogue: 0,0:03:44.97,0:03:46.84,EN,,0,0,0,,or if it doesn't match, says that it fails.
Dialogue: 0,0:03:46.84,0:03:47.71,EN,,0,0,0,,So, for example,
Dialogue: 0,0:03:47.88,0:03:50.38,EN,,0,0,0,,if I use the same pattern here,
Dialogue: 0,0:03:50.97,0:03:55.12,EN,,0,0,0,,if I say this x, y, y, x
Dialogue: 0,0:03:55.66,0:03:58.49,EN,,0,0,0,,match a, b, b, a
Dialogue: 0,0:03:59.47,0:04:02.84,EN,,0,0,0,,with the dictionary y equals a,
Dialogue: 0,0:04:05.15,0:04:06.81,EN,,0,0,0,,then the matcher would put out fail.
Dialogue: 0,0:04:12.52,0:04:14.65,EN,,0,0,0,,Well, you've already seen the code for a pattern matcher
Dialogue: 0,0:04:15.00,0:04:16.17,EN,,0,0,0,,so I'm not going to go over it,
Dialogue: 0,0:04:16.64,0:04:19.77,EN,,0,0,0,,but it's the same thing we've been doing before.
Dialogue: 0,0:04:21.19,0:04:23.22,EN,,0,0,0,,You saw that in the system on rule-based control.
Dialogue: 0,0:04:23.22,0:04:24.56,EN,,0,0,0,,It's essentially the same matcher.
Dialogue: 0,0:04:24.95,0:04:27.66,EN,,0,0,0,,In fact, I think the syntax is a little bit simpler
Dialogue: 0,0:04:28.16,0:04:29.31,EN,,0,0,0,,because we're not worrying about
Dialogue: 0,0:04:29.40,0:04:31.40,EN,,0,0,0,,arbitrary constants and expressions and things.
Dialogue: 0,0:04:31.40,0:04:32.88,EN,,0,0,0,,There's just variables and constants.
Dialogue: 0,0:04:35.79,0:04:37.32,EN,,0,0,0,,OK, well, given that,
Dialogue: 0,0:04:38.46,0:04:39.61,EN,,0,0,0,,what's a primitive query?
Dialogue: 0,0:04:42.97,0:04:45.34,EN,,0,0,0,,Primitive query is going to be a rather complicated thing.
Dialogue: 0,0:04:46.67,0:05:03.58,EN,,0,0,0,,It's going to be-- let's think about the query job of x is d dot y.
Dialogue: 0,0:05:07.04,0:05:08.73,EN,,0,0,0,,That's a query we might type in.
Dialogue: 0,0:05:09.40,0:05:11.39,EN,,0,0,0,,That's going to be implemented in the system.
Dialogue: 0,0:05:14.14,0:05:15.66,EN,,0,0,0,,We'll think of it as this little box.
Dialogue: 0,0:05:15.70,0:05:16.80,EN,,0,0,0,,Here's the primitive query.
Dialogue: 0,0:05:18.88,0:05:20.30,EN,,0,0,0,,What this little box is going to do
Dialogue: 0,0:05:22.24,0:05:27.28,EN,,0,0,0,,is take in two streams and put out a stream.
Dialogue: 0,0:05:31.96,0:05:33.20,EN,,0,0,0,,and put out a stream.
Dialogue: 0,0:05:34.03,0:05:36.19,EN,,0,0,0,,So the shape of a primitive query
Dialogue: 0,0:05:36.51,0:05:38.46,EN,,0,0,0,,is that it's a thing where two streams come in
Dialogue: 0,0:05:38.67,0:05:39.96,EN,,0,0,0,,and one stream goes out.
Dialogue: 0,0:05:41.12,0:05:46.20,EN,,0,0,0,,What these streams are going to be is down here is the database.
Dialogue: 0,0:05:51.95,0:05:53.93,EN,,0,0,0,,So we imagine all the things in the database
Dialogue: 0,0:05:55.93,0:05:57.20,EN,,0,0,0,,sort of sitting there in a stream
Dialogue: 0,0:05:57.31,0:05:58.40,EN,,0,0,0,,and this thing sucks on them.
Dialogue: 0,0:06:00.36,0:06:02.43,EN,,0,0,0,,So what are some things that might be in the database?
Dialogue: 0,0:06:08.43,0:06:20.32,EN,,0,0,0,,Oh, job of Alyssa is something
Dialogue: 0,0:06:21.96,0:06:23.71,EN,,0,0,0,,and some other job is something.
Dialogue: 0,0:06:25.77,0:06:30.41,EN,,0,0,0,,So imagine all of the facts in the database sitting there in the stream.
Dialogue: 0,0:06:32.04,0:06:33.10,EN,,0,0,0,,That's what comes in here.
Dialogue: 0,0:06:33.36,0:06:34.52,EN,,0,0,0,,What comes in here
Dialogue: 0,0:06:34.89,0:06:36.52,EN,,0,0,0,,is a stream of dictionaries.
Dialogue: 0,0:06:38.51,0:06:41.40,EN,,0,0,0,,So one particular dictionary might say
Dialogue: 0,0:06:46.70,0:06:49.31,EN,,0,0,0,,might say y equals programmer.
Dialogue: 0,0:06:55.47,0:06:56.64,EN,,0,0,0,,Now, what the query does
Dialogue: 0,0:06:57.07,0:06:59.80,EN,,0,0,0,,when it gets in a dictionary from this stream,
Dialogue: 0,0:07:02.01,0:07:06.67,EN,,0,0,0,,it finds all possible ways of matching the query
Dialogue: 0,0:07:07.45,0:07:10.24,EN,,0,0,0,,against whatever is coming in from the database.
Dialogue: 0,0:07:11.39,0:07:12.89,EN,,0,0,0,,It looks at the query as a pattern,
Dialogue: 0,0:07:13.15,0:07:16.72,EN,,0,0,0,,matches it against any fact from the database
Dialogue: 0,0:07:16.96,0:07:21.98,EN,,0,0,0,,or all possible ways of finding and matching the database
Dialogue: 0,0:07:22.94,0:07:25.68,EN,,0,0,0,,with respect to this dictionary that's coming in.
Dialogue: 0,0:07:27.55,0:07:29.69,EN,,0,0,0,,So for each fact in the database,
Dialogue: 0,0:07:29.72,0:07:34.35,EN,,0,0,0,,it calls the matcher using the pattern, fact, and dictionary.
Dialogue: 0,0:07:35.11,0:07:37.68,EN,,0,0,0,,And every time it gets a good match,
Dialogue: 0,0:07:38.19,0:07:39.93,EN,,0,0,0,,it puts out the extended dictionary.
Dialogue: 0,0:07:40.67,0:07:42.32,EN,,0,0,0,,So, for example, if this one comes in
Dialogue: 0,0:07:43.00,0:07:44.09,EN,,0,0,0,,and it finds a match,
Dialogue: 0,0:07:44.51,0:07:45.87,EN,,0,0,0,,out will come a dictionary
Dialogue: 0,0:07:46.81,0:07:49.79,EN,,0,0,0,,that in this case will have y equals programmer
Dialogue: 0,0:07:51.52,0:07:52.97,EN,,0,0,0,,nd x equals something.
Dialogue: 0,0:07:56.54,0:07:58.75,EN,,0,0,0,,y is programmer, x is something,
Dialogue: 0,0:07:58.96,0:08:00.54,EN,,0,0,0,,and d is whatever it found.
Dialogue: 0,0:08:01.72,0:08:02.27,EN,,0,0,0,,And that's all.
Dialogue: 0,0:08:03.52,0:08:07.82,EN,,0,0,0,,And, of course, it's going to try this for every fact in the dictionary.
Dialogue: 0,0:08:07.98,0:08:09.25,EN,,0,0,0,,So it might find lots of them.
Dialogue: 0,0:08:09.56,0:08:10.59,EN,,0,0,0,,It might find another one
Dialogue: 0,0:08:11.28,0:08:17.12,EN,,0,0,0,,that says y equals programmer and x equals, and d equals.
Dialogue: 0,0:08:19.18,0:08:21.55,EN,,0,0,0,,So thats, So for one frame coming in,
Dialogue: 0,0:08:21.76,0:08:23.69,EN,,0,0,0,,it might put out-- for one dictionary coming in,
Dialogue: 0,0:08:23.72,0:08:25.24,EN,,0,0,0,,it might put out a lot of dictionaries,
Dialogue: 0,0:08:26.54,0:08:28.67,EN,,0,0,0,,or it might put out none.
Dialogue: 0,0:08:30.47,0:08:38.48,EN,,0,0,0,,It might have something that wouldn't match like x equals FOO.
Dialogue: 0,0:08:39.02,0:08:40.89,EN,,0,0,0,,This one might not match anything
Dialogue: 0,0:08:41.52,0:08:45.12,EN,,0,0,0,,in which case nothing will go into this stream corresponding to this frame.
Dialogue: 0,0:08:47.51,0:08:51.28,EN,,0,0,0,,Or what you might do is put in an empty frame,
Dialogue: 0,0:08:52.91,0:08:56.24,EN,,0,0,0,,and an empty frame says try matching all ways--
Dialogue: 0,0:08:59.87,0:09:02.33,EN,,0,0,0,,find all possible ways of matching the query
Dialogue: 0,0:09:02.57,0:09:06.14,EN,,0,0,0,,against something in the database subject to no previous restrictions.
Dialogue: 0,0:09:07.57,0:09:09.16,EN,,0,0,0,,And if you think about what that means, that's just
Dialogue: 0,0:09:10.32,0:09:13.87,EN,,0,0,0,,the computation that's done when you type in a query right off.
Dialogue: 0,0:09:14.20,0:09:15.56,EN,,0,0,0,,It tries to find all matches.
Dialogue: 0,0:09:16.65,0:09:18.83,EN,,0,0,0,,So a primitive query sets up this mechanism.
Dialogue: 0,0:09:19.37,0:09:20.57,EN,,0,0,0,,And what the language does,
Dialogue: 0,0:09:22.75,0:09:24.67,EN,,0,0,0,,when you type in the query at the top level,
Dialogue: 0,0:09:24.84,0:09:26.14,EN,,0,0,0,,it takes this mechanism,
Dialogue: 0,0:09:26.16,0:09:28.35,EN,,0,0,0,,feeds in one single empty dictionary,
Dialogue: 0,0:09:30.86,0:09:32.56,EN,,0,0,0,,and then for each thing that comes out
Dialogue: 0,0:09:33.08,0:09:35.88,EN,,0,0,0,,takes the original query
Dialogue: 0,0:09:36.56,0:09:40.44,EN,,0,0,0,,and instantiates the result with all the different dictionaries,
Dialogue: 0,0:09:40.81,0:09:44.36,EN,,0,0,0,,producing a new stream of instantiated patterns here.
Dialogue: 0,0:09:44.99,0:09:46.51,EN,,0,0,0,,And that's what gets printed on the terminal.
Dialogue: 0,0:09:48.17,0:09:51.24,EN,,0,0,0,,That's the basic mechanism going on there.
Dialogue: 0,0:09:53.51,0:09:55.48,EN,,0,0,0,,Well, why is that so complicated?
Dialogue: 0,0:09:57.71,0:10:01.00,EN,,0,0,0,,You probably can think of a lot simpler ways to arrange this match for
Dialogue: 0,0:10:01.37,0:10:04.25,EN,,0,0,0,,a primitive query rather than having all of these streams floating around.
Dialogue: 0,0:10:05.18,0:10:06.09,EN,,0,0,0,,And the answer is--
Dialogue: 0,0:10:07.15,0:10:08.51,EN,,0,0,0,,you probably guess already.
Dialogue: 0,0:10:10.86,0:10:14.09,EN,,0,0,0,,The answer is this thing extends elegantly
Dialogue: 0,0:10:14.56,0:10:16.76,EN,,0,0,0,,to implement the means of combination.
Dialogue: 0,0:10:17.79,0:10:18.80,EN,,0,0,0,,So, for instance,
Dialogue: 0,0:10:20.65,0:10:22.47,EN,,0,0,0,,suppose I don't only want to do this.
Dialogue: 0,0:10:22.47,0:10:26.96,EN,,0,0,0,,I don't want to say who to be everybody's job description.
Dialogue: 0,0:10:27.23,0:10:28.35,EN,,0,0,0,,Suppose I want to say
Dialogue: 0,0:10:29.47,0:10:35.92,EN,,0,0,0,,to say AND the job of x is d dot y
Dialogue: 0,0:10:36.80,0:10:47.04,EN,,0,0,0,,and the supervisor of x is z.
Dialogue: 0,0:10:48.80,0:10:50.67,EN,,0,0,0,,Now, supervisor of x is z
Dialogue: 0,0:10:51.39,0:10:52.96,EN,,0,0,0,,is going to be another primitive query
Dialogue: 0,0:10:53.71,0:10:58.43,EN,,0,0,0,,that has the same shape to take in a stream of data objects,
Dialogue: 0,0:10:59.18,0:11:01.64,EN,,0,0,0,,a stream of initial dictionaries,
Dialogue: 0,0:11:01.68,0:11:05.52,EN,,0,0,0,,which are the restrictions to try and use when you match,
Dialogue: 0,0:11:05.53,0:11:07.44,EN,,0,0,0,,and it's going to put out a stream of dictionaries.
Dialogue: 0,0:11:08.70,0:11:10.80,EN,,0,0,0,,So that's what this primitive query looks like.
Dialogue: 0,0:11:11.50,0:11:12.91,EN,,0,0,0,,And how do I implement the AND?
Dialogue: 0,0:11:12.91,0:11:13.45,EN,,0,0,0,,Well, it's simple.
Dialogue: 0,0:11:13.45,0:11:14.44,EN,,0,0,0,,I just hook them together.
Dialogue: 0,0:11:14.88,0:11:16.28,EN,,0,0,0,,I take the output of this one,
Dialogue: 0,0:11:16.96,0:11:18.81,EN,,0,0,0,,and I put that to the input of that one.
Dialogue: 0,0:11:19.83,0:11:21.84,EN,,0,0,0,,And I take the dictionary here and I fan it out.
Dialogue: 0,0:11:26.57,0:11:27.96,EN,,0,0,0,,And then you see how that's going to work,
Dialogue: 0,0:11:29.05,0:11:32.44,EN,,0,0,0,,because what's going to happen is a frame will now come in here,
Dialogue: 0,0:11:32.51,0:11:36.84,EN,,0,0,0,,which has a binding for x, y, and d.
Dialogue: 0,0:11:37.92,0:11:39.28,EN,,0,0,0,,And then when this one gets it, it'll say,
Dialogue: 0,0:11:39.29,0:11:41.60,EN,,0,0,0,,oh, gee, subject to these restrictions,
Dialogue: 0,0:11:42.17,0:11:49.24,EN,,0,0,0,,which now already have values in the dictionary for y and x and d,
Dialogue: 0,0:11:51.80,0:11:53.08,EN,,0,0,0,,it looks in the database and says,
Dialogue: 0,0:11:53.12,0:11:54.92,EN,,0,0,0,,gee, can I find any supervisor facts?
Dialogue: 0,0:11:56.04,0:11:58.51,EN,,0,0,0,,And if it finds any, out will come dictionaries
Dialogue: 0,0:11:59.58,0:12:09.34,EN,,0,0,0,,which have bindings for y and x and d and z now.
Dialogue: 0,0:12:12.07,0:12:14.09,EN,,0,0,0,,And then notice that the match---
Dialogue: 0,0:12:14.19,0:12:17.24,EN,,0,0,0,,because the frames coming in here have these restrictions,
Dialogue: 0,0:12:17.61,0:12:20.28,EN,,0,0,0,,that's the thing that assures when you do the AND,
Dialogue: 0,0:12:20.49,0:12:24.62,EN,,0,0,0,,this x will mean the same thing as that x.
Dialogue: 0,0:12:26.47,0:12:28.96,EN,,0,0,0,,Because by the time something comes floating in here,
Dialogue: 0,0:12:29.96,0:12:32.65,EN,,0,0,0,,x has a value that you have to match against consistently.
Dialogue: 0,0:12:34.46,0:12:36.17,EN,,0,0,0,,And then you remember from the code from the matcher,
Dialogue: 0,0:12:36.19,0:12:38.17,EN,,0,0,0,,there was something in the way the matcher did dictionaries
Dialogue: 0,0:12:38.20,0:12:39.82,EN,,0,0,0,,that arrange consistent matches.
Dialogue: 0,0:12:40.92,0:12:41.77,EN,,0,0,0,,So there's AND.
Dialogue: 0,0:12:44.08,0:12:46.94,EN,,0,0,0,,The important point to notice is the general shape.
Dialogue: 0,0:12:48.49,0:12:51.55,EN,,0,0,0,,Look at what happened: the AND of two queries, say, P and Q.
Dialogue: 0,0:12:52.88,0:12:55.61,EN,,0,0,0,,Here's P and Q.
Dialogue: 0,0:12:57.29,0:12:58.60,EN,,0,0,0,,The AND of two queries,
Dialogue: 0,0:13:00.27,0:13:01.19,EN,,0,0,0,,well, it looks like this.
Dialogue: 0,0:13:01.19,0:13:04.44,EN,,0,0,0,,Each query takes in a stream from the database,
Dialogue: 0,0:13:04.54,0:13:05.71,EN,,0,0,0,,a stream of inputs,
Dialogue: 0,0:13:06.33,0:13:08.17,EN,,0,0,0,,and puts out a stream of outputs.
Dialogue: 0,0:13:10.23,0:13:11.72,EN,,0,0,0,,And the important point to notice
Dialogue: 0,0:13:12.20,0:13:15.02,EN,,0,0,0,,is that if I draw a box around this thing
Dialogue: 0,0:13:19.26,0:13:23.64,EN,,0,0,0,,and say this is AND of P and Q,
Dialogue: 0,0:13:25.66,0:13:30.38,EN,,0,0,0,,then that box has exactly the same overall shape.
Dialogue: 0,0:13:32.04,0:13:34.20,EN,,0,0,0,,It's something that takes in a stream from the database.
Dialogue: 0,0:13:34.20,0:13:35.74,EN,,0,0,0,,Here it's going to get fanned out inside,
Dialogue: 0,0:13:36.60,0:13:37.93,EN,,0,0,0,,but from the outside you don't see that.
Dialogue: 0,0:13:38.16,0:13:40.64,EN,,0,0,0,,It takes an input stream and puts out an output stream.
Dialogue: 0,0:13:42.06,0:13:43.16,EN,,0,0,0,,So this is AND.
Dialogue: 0,0:13:43.57,0:13:45.72,EN,,0,0,0,,And then similarly, OR would look like this.
Dialogue: 0,0:13:46.02,0:13:49.58,EN,,0,0,0,,OR would-- although I didn't show you examples of OR.
Dialogue: 0,0:13:49.84,0:13:54.70,EN,,0,0,0,,OR would say can I find all ways of matching P or Q.
Dialogue: 0,0:13:55.80,0:13:58.07,EN,,0,0,0,,So I have P and Q. Each will have their shape.
Dialogue: 0,0:14:04.46,0:14:06.68,EN,,0,0,0,,And the way OR is implemented is
Dialogue: 0,0:14:08.54,0:14:10.91,EN,,0,0,0,,I'll take my database stream.
Dialogue: 0,0:14:12.50,0:14:13.49,EN,,0,0,0,,I'll fan it out.
Dialogue: 0,0:14:13.49,0:14:16.04,EN,,0,0,0,,I'll put one into P and one into Q.
Dialogue: 0,0:14:17.44,0:14:21.98,EN,,0,0,0,,I'll take my initial query stream coming in and fan it out.
Dialogue: 0,0:14:26.75,0:14:29.16,EN,,0,0,0,,So I'll look at all the answers I might get from P
Dialogue: 0,0:14:29.29,0:14:31.08,EN,,0,0,0,,and all the answers I might get from Q,
Dialogue: 0,0:14:31.61,0:14:34.56,EN,,0,0,0,,and I'll put them through some sort of thing that appends them
Dialogue: 0,0:14:34.62,0:14:37.48,EN,,0,0,0,,or merges the result into one stream,
Dialogue: 0,0:14:39.64,0:14:40.88,EN,,0,0,0,,and that's what will come out.
Dialogue: 0,0:14:41.08,0:14:48.24,EN,,0,0,0,,And this whole thing from the outside is OR.
Dialogue: 0,0:14:52.35,0:14:54.89,EN,,0,0,0,,And again, you see it has the same overall shape
Dialogue: 0,0:14:55.07,0:14:56.54,EN,,0,0,0,,And again, you see it has the same overall shape
Dialogue: 0,0:15:01.00,0:15:01.61,EN,,0,0,0,,What's NOT?
Dialogue: 0,0:15:02.02,0:15:03.45,EN,,0,0,0,,NOT works kind of the same way.
Dialogue: 0,0:15:04.31,0:15:05.95,EN,,0,0,0,,If I have some query P,
Dialogue: 0,0:15:06.86,0:15:13.50,EN,,0,0,0,,If I have P, I take the primitive query for P.
Dialogue: 0,0:15:14.69,0:15:16.32,EN,,0,0,0,,Here, I'm going to implement NOT P.
Dialogue: 0,0:15:18.68,0:15:20.54,EN,,0,0,0,,And NOT's just going to act as a filter.
Dialogue: 0,0:15:20.72,0:15:21.95,EN,,0,0,0,,I'll take in the database
Dialogue: 0,0:15:23.84,0:15:28.28,EN,,0,0,0,,and my original stream of dictionaries coming in,
Dialogue: 0,0:15:28.78,0:15:31.53,EN,,0,0,0,,and what NOT P will do is
Dialogue: 0,0:15:31.88,0:15:37.40,EN,,0,0,0,,it will filter these guys.
Dialogue: 0,0:15:39.02,0:15:40.09,EN,,0,0,0,,And the way it will filter it,
Dialogue: 0,0:15:40.19,0:15:42.70,EN,,0,0,0,,it will say when I get in a dictionary here,
Dialogue: 0,0:15:43.42,0:15:44.65,EN,,0,0,0,,I'll find all the matches,
Dialogue: 0,0:15:44.83,0:15:46.48,EN,,0,0,0,,and if I find any, I'll throw it away.
Dialogue: 0,0:15:47.46,0:15:49.93,EN,,0,0,0,,And if I don't find any matches to something coming in here,
Dialogue: 0,0:15:50.12,0:15:51.37,EN,,0,0,0,,I'll just pass that through,
Dialogue: 0,0:15:52.40,0:15:53.55,EN,,0,0,0,,so NOT is a pure filter.
Dialogue: 0,0:15:55.34,0:15:59.98,EN,,0,0,0,,So AND is-- think of these sort of electoral resistors or something.
Dialogue: 0,0:15:59.98,0:16:01.85,EN,,0,0,0,,AND is series combination
Dialogue: 0,0:16:02.49,0:16:04.14,EN,,0,0,0,,and OR is parallel combination.
Dialogue: 0,0:16:04.96,0:16:07.46,EN,,0,0,0,,And then NOT is not going to extend any dictionaries at all.
Dialogue: 0,0:16:07.46,0:16:08.40,EN,,0,0,0,,It's just going to filter it.
Dialogue: 0,0:16:08.75,0:16:11.79,EN,,0,0,0,,It's going to throw away the ones for which it finds a way to match.
Dialogue: 0,0:16:12.64,0:16:14.19,EN,,0,0,0,,And lisp-value is sort of the same way.
Dialogue: 0,0:16:14.84,0:16:16.60,EN,,0,0,0,,The filter's a little more complicated.
Dialogue: 0,0:16:16.60,0:16:17.37,EN,,0,0,0,,It applies to predicate.
Dialogue: 0,0:16:19.93,0:16:21.64,EN,,0,0,0,,The major point to notice here,
Dialogue: 0,0:16:21.92,0:16:23.55,EN,,0,0,0,,and it's a major point we've looked at before,
Dialogue: 0,0:16:23.64,0:16:25.29,EN,,0,0,0,,is this idea of closure.
Dialogue: 0,0:16:28.22,0:16:31.80,EN,,0,0,0,,The things that we build as a means of combination
Dialogue: 0,0:16:31.95,0:16:34.51,EN,,0,0,0,,have the same overall structure
Dialogue: 0,0:16:35.69,0:16:37.58,EN,,0,0,0,,as the primitive things that we're combining.
Dialogue: 0,0:16:39.75,0:16:41.68,EN,,0,0,0,,So the AND of two things
Dialogue: 0,0:16:41.71,0:16:43.72,EN,,0,0,0,,looked at from the outside has the same shape.
Dialogue: 0,0:16:44.63,0:16:46.14,EN,,0,0,0,,And what that means is that
Dialogue: 0,0:16:46.94,0:16:50.28,EN,,0,0,0,,this box here could be an AND or an OR or a NOT or something
Dialogue: 0,0:16:50.30,0:16:54.22,EN,,0,0,0,,because it has the same shape to interface to the larger things.
Dialogue: 0,0:16:54.95,0:16:56.68,EN,,0,0,0,,It's the same thing that allowed us to get
Dialogue: 0,0:16:56.92,0:16:58.96,EN,,0,0,0,,complexity in the Escher picture language
Dialogue: 0,0:16:59.55,0:17:01.31,EN,,0,0,0,,or allows you to immediately build up these
Dialogue: 0,0:17:01.34,0:17:03.26,EN,,0,0,0,,complicated structures just out of pairs.
Dialogue: 0,0:17:03.93,0:17:04.78,EN,,0,0,0,,It's closure.
Dialogue: 0,0:17:06.28,0:17:08.06,EN,,0,0,0,,And that's the thing that
Dialogue: 0,0:17:09.64,0:17:11.72,EN,,0,0,0,,allowed me to do what by now you took for granted
Dialogue: 0,0:17:11.76,0:17:14.91,EN,,0,0,0,,I said, gee, there's a query which is AND of job and salary,
Dialogue: 0,0:17:14.91,0:17:18.80,EN,,0,0,0,,and I said, oh, there's another one, which is AND of job, a NOT of something.
Dialogue: 0,0:17:19.26,0:17:20.92,EN,,0,0,0,,The fact that I can do that is
Dialogue: 0,0:17:20.94,0:17:22.91,EN,,0,0,0,,a direct consequence of this closure principle.
Dialogue: 0,0:17:25.18,0:17:27.08,EN,,0,0,0,,OK, let's break and then we'll go on.
Dialogue: 0,0:17:29.32,0:17:30.89,EN,,0,0,0,,AUDIENCE: Where does the dictionary come from?
Dialogue: 0,0:17:30.99,0:17:36.03,EN,,0,0,0,,PROFESSOR: The dictionary comes initially from what you type in.
Dialogue: 0,0:17:36.09,0:17:37.32,EN,,0,0,0,,So when you start this up,
Dialogue: 0,0:17:39.16,0:17:41.09,EN,,0,0,0,,the first thing it does is set up this whole structure.
Dialogue: 0,0:17:41.09,0:17:42.64,EN,,0,0,0,,It puts in one empty dictionary.
Dialogue: 0,0:17:45.00,0:17:47.24,EN,,0,0,0,,And if all you have is one primitive query,
Dialogue: 0,0:17:48.24,0:17:51.10,EN,,0,0,0,,then what will come out is a bunch of dictionaries with things filled in.
Dialogue: 0,0:17:52.31,0:17:54.33,EN,,0,0,0,,The general situation that I have here
Dialogue: 0,0:17:54.51,0:17:59.71,EN,,0,0,0,,is when this is in the middle of some nest of combined things.
Dialogue: 0,0:18:01.55,0:18:02.30,EN,,0,0,0,,So by the time.
Dialogue: 0,0:18:02.38,0:18:03.79,EN,,0,0,0,,Let's look at the picture over here.
Dialogue: 0,0:18:04.38,0:18:06.73,EN,,0,0,0,,This supervisor query gets in some dictionary.
Dialogue: 0,0:18:06.73,0:18:08.03,EN,,0,0,0,,Where did this one come from?
Dialogue: 0,0:18:08.73,0:18:11.15,EN,,0,0,0,,This dictionary came from the fact that
Dialogue: 0,0:18:12.84,0:18:14.89,EN,,0,0,0,,I'm looking at the output of this primitive query.
Dialogue: 0,0:18:16.26,0:18:17.88,EN,,0,0,0,,So maybe to be very specific,
Dialogue: 0,0:18:18.35,0:18:21.72,EN,,0,0,0,,if I literally typed in just this query at the top level,
Dialogue: 0,0:18:22.27,0:18:22.92,EN,,0,0,0,,this AND,
Dialogue: 0,0:18:23.07,0:18:25.28,EN,,0,0,0,,what would actually happen is it would build this structure
Dialogue: 0,0:18:25.50,0:18:30.24,EN,,0,0,0,,and start up this whole thing with one empty dictionary.
Dialogue: 0,0:18:31.77,0:18:34.33,EN,,0,0,0,,And now this one would process, and a whole bunch of dictionaries
Dialogue: 0,0:18:34.36,0:18:37.36,EN,,0,0,0,,would come out with x, y's and d's in them.
Dialogue: 0,0:18:38.64,0:18:39.58,EN,,0,0,0,,Run it through this one.
Dialogue: 0,0:18:40.19,0:18:42.16,EN,,0,0,0,,So now that's the input to this one.
Dialogue: 0,0:18:42.16,0:18:43.72,EN,,0,0,0,,This one would now put out some other stuff.
Dialogue: 0,0:18:45.04,0:18:48.22,EN,,0,0,0,,And if this itself were buried in some larger thing,
Dialogue: 0,0:18:49.31,0:18:51.00,EN,,0,0,0,,like an OR of something,
Dialogue: 0,0:18:53.42,0:18:55.71,EN,,0,0,0,,then that would go feed into the next one.
Dialogue: 0,0:18:58.56,0:19:01.28,EN,,0,0,0,,So you initially get only one empty dictionary when you start it,
Dialogue: 0,0:19:01.68,0:19:04.08,EN,,0,0,0,,but as you're in the middle of processing these compounds things,
Dialogue: 0,0:19:04.11,0:19:06.65,EN,,0,0,0,,that's where these cascades of dictionaries start getting generated.
Dialogue: 0,0:19:07.66,0:19:12.28,EN,,0,0,0,,AUDIENCE: Dictionaries only come about as a result of using the queries?
Dialogue: 0,0:19:15.12,0:19:17.69,EN,,0,0,0,,Or do they stays, do they become--
Dialogue: 0,0:19:18.84,0:19:22.81,EN,,0,0,0,,do they stay someplace in space like the database does?
Dialogue: 0,0:19:23.68,0:19:24.98,EN,,0,0,0,,Are these temporary items?
Dialogue: 0,0:19:24.98,0:19:27.18,EN,,0,0,0,,PROFESSOR: They're created temporarily in the matcher.
Dialogue: 0,0:19:28.03,0:19:29.88,EN,,0,0,0,,Really, they're someplace in storage.
Dialogue: 0,0:19:29.88,0:19:33.02,EN,,0,0,0,,Initially, someone creates a thing called the empty dictionary
Dialogue: 0,0:19:34.22,0:19:36.80,EN,,0,0,0,,that gets initially fed to this match procedure,
Dialogue: 0,0:19:36.81,0:19:39.05,EN,,0,0,0,,and then the match procedure builds some dictionaries,
Dialogue: 0,0:19:39.07,0:19:40.27,EN,,0,0,0,,and they get passed on and on.
Dialogue: 0,0:19:40.76,0:19:42.48,EN,,0,0,0,,AUDIENCE: OK, so they'll go way after the match?
Dialogue: 0,0:19:43.64,0:19:46.25,EN,,0,0,0,,PROFESSOR: They'll go away when no one needs them again, yeah.
Dialogue: 0,0:19:51.90,0:19:53.60,EN,,0,0,0,,AUDIENCE: It appears that the AND performs
Dialogue: 0,0:19:53.63,0:19:55.37,EN,,0,0,0,,some redundant searches of the database.
Dialogue: 0,0:19:55.96,0:19:57.48,EN,,0,0,0,,If the first clause matched,
Dialogue: 0,0:19:57.50,0:19:59.90,EN,,0,0,0,,let's say, the third element and not on the first two elements,
Dialogue: 0,0:20:00.25,0:20:03.64,EN,,0,0,0,,the second clause is going to look at those first two elements again,
Dialogue: 0,0:20:04.32,0:20:06.59,EN,,0,0,0,,discarding them because they don't match.
Dialogue: 0,0:20:06.64,0:20:08.72,EN,,0,0,0,,The match is already in the dictionary.
Dialogue: 0,0:20:10.00,0:20:12.56,EN,,0,0,0,,Would it makes sense to carry the data element
Dialogue: 0,0:20:12.57,0:20:14.43,EN,,0,0,0,,from the database along with the dictionary?
Dialogue: 0,0:20:15.69,0:20:17.60,EN,,0,0,0,,PROFESSOR: Yeah, there're... Well, in general,
Dialogue: 0,0:20:17.63,0:20:19.48,EN,,0,0,0,,there are other ways to arrange this search,
Dialogue: 0,0:20:20.12,0:20:21.74,EN,,0,0,0,,and there's some analysis that you can do.
Dialogue: 0,0:20:21.74,0:20:23.16,EN,,0,0,0,,I think there's a problem in the book,
Dialogue: 0,0:20:23.87,0:20:26.65,EN,,0,0,0,,which talks about a different way that you can cascade AND
Dialogue: 0,0:20:27.00,0:20:29.20,EN,,0,0,0,,to eliminate various kinds of redundancies.
Dialogue: 0,0:20:29.85,0:20:30.72,EN,,0,0,0,,This one is meant to be--
Dialogue: 0,0:20:31.32,0:20:34.54,EN,,0,0,0,,was mainly meant to be very simple so you can see how they fit together.
Dialogue: 0,0:20:34.70,0:20:35.38,EN,,0,0,0,,But you're quite right.
Dialogue: 0,0:20:35.38,0:20:37.32,EN,,0,0,0,,There are redundancies here that you can get rid of.
Dialogue: 0,0:20:38.37,0:20:40.80,EN,,0,0,0,,That's another reason why this language is somewhat slow.
Dialogue: 0,0:20:41.19,0:20:42.70,EN,,0,0,0,,There are a lot smarter things you can do.
Dialogue: 0,0:20:42.93,0:20:46.22,EN,,0,0,0,,We're just trying to show you a very simple, in principle, implementation.
Dialogue: 0,0:20:51.22,0:20:53.23,EN,,0,0,0,,AUDIENCE: Did you model this language on Prolog,
Dialogue: 0,0:20:53.24,0:20:55.13,EN,,0,0,0,,or did it just come out looking like Prolog?
Dialogue: 0,0:21:04.96,0:21:07.08,EN,,0,0,0,,PROFESSOR: Well, Gerry insulted a whole bunch of people yesterday,
Dialogue: 0,0:21:07.24,0:21:09.92,EN,,0,0,0,,so I might as well say that the MIT attitude towards Prolog is
Dialogue: 0,0:21:10.19,0:21:12.60,EN,,0,0,0,,is something that people did in about 1971
Dialogue: 0,0:21:12.64,0:21:15.60,EN,,0,0,0,,and decided that it wasn't really the right thing and stopped.
Dialogue: 0,0:21:16.12,0:21:22.80,EN,,0,0,0,,So we modeled this on the sort of natural way that this thing was done
Dialogue: 0,0:21:22.84,0:21:24.73,EN,,0,0,0,,in about 1971,
Dialogue: 0,0:21:25.13,0:21:27.24,EN,,0,0,0,,except at that point, we didn't do it with streams.
Dialogue: 0,0:21:28.27,0:21:33.04,EN,,0,0,0,,And then we... After we were using it for about six months,
Dialogue: 0,0:21:33.08,0:21:34.91,EN,,0,0,0,,we discovered that it had all these problems,
Dialogue: 0,0:21:34.94,0:21:36.30,EN,,0,0,0,,some of which I'll talk about later.
Dialogue: 0,0:21:37.33,0:21:38.19,EN,,0,0,0,,And we said,
Dialogue: 0,0:21:38.44,0:21:39.92,EN,,0,0,0,,gee, Prolog must have fixed those,
Dialogue: 0,0:21:39.93,0:21:41.21,EN,,0,0,0,,and then we found out that it didn't.
Dialogue: 0,0:21:41.25,0:21:43.02,EN,,0,0,0,,So this does about the same thing as Prolog.
Dialogue: 0,0:21:43.60,0:21:44.95,EN,,0,0,0,,AUDIENCE: Does Prolog use streams?
Dialogue: 0,0:21:44.95,0:21:46.20,EN,,0,0,0,,PROFESSOR: No. Prolog --
Dialogue: 0,0:21:46.78,0:21:51.04,EN,,0,0,0,,In how it behaves, it behaves a lot like Prolog.
Dialogue: 0,0:21:51.04,0:21:52.96,EN,,0,0,0,,Prolog uses a backtracking strategy.
Dialogue: 0,0:21:53.80,0:21:55.71,EN,,0,0,0,,But the other thing that's really good about Prolog
Dialogue: 0,0:21:55.72,0:21:57.98,EN,,0,0,0,,that makes it a usable thing
Dialogue: 0,0:21:58.28,0:22:01.50,EN,,0,0,0,,is that there's a really very, very
Dialogue: 0,0:22:01.68,0:22:04.09,EN,,0,0,0,,there's a really very, very well-engineered compiler technology
Dialogue: 0,0:22:04.11,0:22:05.32,EN,,0,0,0,,that makes it run fast.
Dialogue: 0,0:22:06.65,0:22:10.81,EN,,0,0,0,,So although you saw the merge spitting out these answers very, very slowly,
Dialogue: 0,0:22:11.66,0:22:13.61,EN,,0,0,0,,a real Prolog will run very, very fast.
Dialogue: 0,0:22:14.70,0:22:16.48,EN,,0,0,0,,Because even though it's sort of doing this,
Dialogue: 0,0:22:16.67,0:22:20.81,EN,,0,0,0,,the real work that went into Prolog is a very, very excellent compiler effort.
Dialogue: 0,0:22:24.30,0:22:25.21,EN,,0,0,0,,Let's take a break.
Dialogue: 0,0:22:25.42,0:22:36.17,EN,,0,0,0,,[JESU, JOY OF MAN'S DESIRING]
Dialogue: 0,0:23:16.65,0:23:18.83,EN,,0,0,0,,We've looked at the primitive queries
Dialogue: 0,0:23:19.21,0:23:23.52,EN,,0,0,0,,and the ways that streams are used to implement the means of combination:
Dialogue: 0,0:23:23.79,0:23:25.72,EN,,0,0,0,,AND and OR and NOT.
Dialogue: 0,0:23:26.95,0:23:28.43,EN,,0,0,0,,Now, let go on to the means of abstraction.
Dialogue: 0,0:23:29.58,0:23:32.80,EN,,0,0,0,,Remember, the means of abstraction in this language are rules.
Dialogue: 0,0:23:35.15,0:23:37.79,EN,,0,0,0,,So z is a boss in division d
Dialogue: 0,0:23:39.18,0:23:43.77,EN,,0,0,0,,if there's some x who has a job in division d
Dialogue: 0,0:23:45.68,0:23:47.47,EN,,0,0,0,,and z is the supervisor of x.
Dialogue: 0,0:23:48.90,0:23:50.60,EN,,0,0,0,,That's what it means for someone to be a boss.
Dialogue: 0,0:23:52.26,0:23:53.15,EN,,0,0,0,,So, and in effect,
Dialogue: 0,0:23:53.34,0:23:55.61,EN,,0,0,0,,if you think about what we're doing with relation to this,
Dialogue: 0,0:23:56.80,0:23:57.90,EN,,0,0,0,,there's the query we wrote--
Dialogue: 0,0:23:57.93,0:24:01.90,EN,,0,0,0,,the job of x is in d and the supervisor of x is z--
Dialogue: 0,0:24:02.19,0:24:04.28,EN,,0,0,0,,what we in effect want to do is take this whole mess
Dialogue: 0,0:24:05.07,0:24:06.57,EN,,0,0,0,,and draw a box around it
Dialogue: 0,0:24:19.08,0:24:24.54,EN,,0,0,0,,and say this whole thing inside the box
Dialogue: 0,0:24:25.15,0:24:32.48,EN,,0,0,0,,is boss of z in division d.
Dialogue: 0,0:24:33.90,0:24:35.25,EN,,0,0,0,,That's in effect what we want to do.
Dialogue: 0,0:24:38.72,0:24:39.72,EN,,0,0,0,,So, for instance,
Dialogue: 0,0:24:43.18,0:24:44.08,EN,,0,0,0,,if we've done that,
Dialogue: 0,0:24:45.00,0:24:47.84,EN,,0,0,0,,and we want to check whether or not it's true
Dialogue: 0,0:24:47.95,0:24:50.51,EN,,0,0,0,,that Ben Bitdiddle is a boss in the computer division,
Dialogue: 0,0:24:51.10,0:25:02.86,EN,,0,0,0,,so if I want to say boss of Ben Bitdiddle in the computer division,
Dialogue: 0,0:25:04.78,0:25:07.08,EN,,0,0,0,,imagine typing that in as query to the system,
Dialogue: 0,0:25:07.12,0:25:09.16,EN,,0,0,0,,in effect what we want to do
Dialogue: 0,0:25:10.67,0:25:12.92,EN,,0,0,0,,is set up a dictionary here,
Dialogue: 0,0:25:15.82,0:25:23.63,EN,,0,0,0,,which has z to Ben Bitdiddle
Dialogue: 0,0:25:28.88,0:25:33.31,EN,,0,0,0,,and d to computer.
Dialogue: 0,0:25:37.08,0:25:38.62,EN,,0,0,0,,Where did that dictionary come from?
Dialogue: 0,0:25:38.68,0:25:40.71,EN,,0,0,0,,Let's look at the slide for one second.
Dialogue: 0,0:25:40.71,0:25:43.71,EN,,0,0,0,,That dictionary came from matching the query
Dialogue: 0,0:25:44.30,0:25:46.33,EN,,0,0,0,,that said boss of Ben Bitdiddle and computer
Dialogue: 0,0:25:46.51,0:25:49.63,EN,,0,0,0,,onto the conclusion of the rule: boss of z and d.
Dialogue: 0,0:25:51.65,0:25:54.11,EN,,0,0,0,,So we match the query to the conclusion of the rule.
Dialogue: 0,0:25:54.19,0:25:55.53,EN,,0,0,0,,That gives us a dictionary,
Dialogue: 0,0:25:58.99,0:26:02.54,EN,,0,0,0,,and that's the thing that we would now like to put into this whole big thing
Dialogue: 0,0:26:02.92,0:26:05.56,EN,,0,0,0,,and process and see if anything comes out the other side.
Dialogue: 0,0:26:06.67,0:26:09.88,EN,,0,0,0,,If anything comes out, it'll be true.
Dialogue: 0,0:26:11.33,0:26:12.37,EN,,0,0,0,,That's the basic idea.
Dialogue: 0,0:26:12.37,0:26:13.24,EN,,0,0,0,,So in general,
Dialogue: 0,0:26:14.03,0:26:15.40,EN,,0,0,0,,the way we implement a rule
Dialogue: 0,0:26:15.85,0:26:18.89,EN,,0,0,0,,is we match the conclusion of the rule
Dialogue: 0,0:26:20.86,0:26:22.96,EN,,0,0,0,,against something we might want to check it's true.
Dialogue: 0,0:26:23.58,0:26:25.12,EN,,0,0,0,,That match gives us a dictionary,
Dialogue: 0,0:26:25.29,0:26:28.22,EN,,0,0,0,,and with respect to that dictionary,
Dialogue: 0,0:26:30.35,0:26:34.51,EN,,0,0,0,,we process the body of the rule.
Dialogue: 0,0:26:36.33,0:26:37.68,EN,,0,0,0,,Well, that's really all there is,
Dialogue: 0,0:26:38.64,0:26:41.44,EN,,0,0,0,,except for two technical points.
Dialogue: 0,0:26:43.04,0:26:44.32,EN,,0,0,0,,The first technical point is that
Dialogue: 0,0:26:45.74,0:26:47.26,EN,,0,0,0,,I might have said something else.
Dialogue: 0,0:26:47.51,0:26:48.41,EN,,0,0,0,,I might have said
Dialogue: 0,0:26:50.54,0:26:52.36,EN,,0,0,0,,who's the boss in the computer division?
Dialogue: 0,0:26:52.54,0:26:56.32,EN,,0,0,0,,So I might say boss of who in computer division.
Dialogue: 0,0:27:00.78,0:27:01.63,EN,,0,0,0,,And if I did that,
Dialogue: 0,0:27:02.57,0:27:04.62,EN,,0,0,0,,what I would really like to do in effect is not
Dialogue: 0,0:27:05.04,0:27:06.49,EN,,0,0,0,,is start up this dictionary
Dialogue: 0,0:27:08.35,0:27:09.88,EN,,0,0,0,,with a match that sort of says,
Dialogue: 0,0:27:09.93,0:27:11.20,EN,,0,0,0,,well, d is computer
Dialogue: 0,0:27:14.35,0:27:18.48,EN,,0,0,0,,and z is whatever who is.
Dialogue: 0,0:27:21.70,0:27:23.22,EN,,0,0,0,,And our matcher won't quite do that.
Dialogue: 0,0:27:23.22,0:27:27.00,EN,,0,0,0,,That's not quite matching a pattern against data.
Dialogue: 0,0:27:28.58,0:27:29.72,EN,,0,0,0,,It's matching two patterns
Dialogue: 0,0:27:29.74,0:27:31.58,EN,,0,0,0,,sort of saying are they consistent or not
Dialogue: 0,0:27:31.90,0:27:33.48,EN,,0,0,0,,or what ways make them consistent.
Dialogue: 0,0:27:33.48,0:27:36.43,EN,,0,0,0,,In other words, what we need is not quite a pattern matcher,
Dialogue: 0,0:27:36.96,0:27:38.91,EN,,0,0,0,,but something a little bit more general
Dialogue: 0,0:27:39.13,0:27:40.11,EN,,0,0,0,,called a unifier.
Dialogue: 0,0:27:44.42,0:27:48.06,EN,,0,0,0,,And a unifier is a slight generalization of a pattern matcher.
Dialogue: 0,0:27:49.53,0:27:52.17,EN,,0,0,0,,What a unifier does is take two patterns
Dialogue: 0,0:27:53.23,0:27:57.53,EN,,0,0,0,,and say what's the most general thing you can substitute
Dialogue: 0,0:27:58.20,0:28:00.01,EN,,0,0,0,,for the variables in those two patterns
Dialogue: 0,0:28:02.68,0:28:05.08,EN,,0,0,0,,to make them satisfy the pattern simultaneously?
Dialogue: 0,0:28:05.68,0:28:06.60,EN,,0,0,0,,Let me give you an example.
Dialogue: 0,0:28:08.86,0:28:14.49,EN,,0,0,0,,If I have the pattern two-element list, which is x and x,
Dialogue: 0,0:28:15.76,0:28:17.15,EN,,0,0,0,,so this is I have a two-element list
Dialogue: 0,0:28:17.32,0:28:18.64,EN,,0,0,0,,where both elements are the same
Dialogue: 0,0:28:18.67,0:28:20.04,EN,,0,0,0,,and otherwise I don't care what they are,
Dialogue: 0,0:28:20.40,0:28:22.83,EN,,0,0,0,,and I unify that against the pattern
Dialogue: 0,0:28:22.92,0:28:24.62,EN,,0,0,0,,that says there's a two-element list,
Dialogue: 0,0:28:24.65,0:28:27.61,EN,,0,0,0,,and the first one is a and something and c
Dialogue: 0,0:28:28.00,0:28:30.14,EN,,0,0,0,,and the second one is a and b and z,
Dialogue: 0,0:28:33.07,0:28:34.88,EN,,0,0,0,,then what the unifier should tell me is,
Dialogue: 0,0:28:34.89,0:28:36.17,EN,,0,0,0,,oh yeah, in that dictionary,
Dialogue: 0,0:28:36.35,0:28:37.96,EN,,0,0,0,,x has to be a, b, c,
Dialogue: 0,0:28:39.34,0:28:41.92,EN,,0,0,0,,and y has to be d and z has to be c.
Dialogue: 0,0:28:43.44,0:28:46.28,EN,,0,0,0,,Those are the restrictions I'd have to put on the values of x, y, and z
Dialogue: 0,0:28:46.33,0:28:47.58,EN,,0,0,0,,to make these two unify,
Dialogue: 0,0:28:48.12,0:28:50.84,EN,,0,0,0,,or in other words, to make this match x
Dialogue: 0,0:28:51.15,0:28:53.37,EN,,0,0,0,,and make this match x.
Dialogue: 0,0:28:55.28,0:28:57.76,EN,,0,0,0,,The unifier should be able to deduce that.
Dialogue: 0,0:28:58.54,0:29:01.08,EN,,0,0,0,,But the unifier may-- there are more complicated things.
Dialogue: 0,0:29:01.08,0:29:03.07,EN,,0,0,0,,I might have said something a little bit more complicated.
Dialogue: 0,0:29:03.48,0:29:05.74,EN,,0,0,0,,I might have said there's a list with two elements,
Dialogue: 0,0:29:07.00,0:29:08.28,EN,,0,0,0,,and they're both the same,
Dialogue: 0,0:29:08.86,0:29:11.15,EN,,0,0,0,,and they should unify against something of this form.
Dialogue: 0,0:29:12.65,0:29:15.36,EN,,0,0,0,,And the unifier should be able to deduce from that.
Dialogue: 0,0:29:16.89,0:29:19.57,EN,,0,0,0,,Like that y would have to be b. y would have to be b.
Dialogue: 0,0:29:19.57,0:29:22.12,EN,,0,0,0,,Because these two are the same,
Dialogue: 0,0:29:22.22,0:29:23.52,EN,,0,0,0,,so y's got to be b.
Dialogue: 0,0:29:24.34,0:29:27.53,EN,,0,0,0,,And v here would have to be a.
Dialogue: 0,0:29:28.94,0:29:30.99,EN,,0,0,0,,And z and w can be anything,
Dialogue: 0,0:29:31.00,0:29:32.43,EN,,0,0,0,,but they have to be the same thing.
Dialogue: 0,0:29:35.71,0:29:41.76,EN,,0,0,0,,And x would have to be b, followed by a, followed by whatever w
Dialogue: 0,0:29:42.83,0:29:44.68,EN,,0,0,0,,or whatever z is, which is the same.
Dialogue: 0,0:29:44.70,0:29:49.42,EN,,0,0,0,,So you see, the unifier somehow has to deduce things to unify these patterns.
Dialogue: 0,0:29:50.88,0:29:53.52,EN,,0,0,0,,So you might think there's some kind of magic deduction going on,
Dialogue: 0,0:29:54.27,0:29:55.23,EN,,0,0,0,,but there's not.
Dialogue: 0,0:29:55.85,0:29:59.88,EN,,0,0,0,,A unifier is basically a very simple modification of a pattern matcher.
Dialogue: 0,0:30:00.15,0:30:01.85,EN,,0,0,0,,And if you look in the book, you'll see something like
Dialogue: 0,0:30:02.25,0:30:06.16,EN,,0,0,0,,like three or four lines of code added to the pattern matcher you just saw
Dialogue: 0,0:30:06.49,0:30:08.17,EN,,0,0,0,,to handle the symmetric case.
Dialogue: 0,0:30:08.28,0:30:10.81,EN,,0,0,0,,Remember, the pattern matcher has a place where it says
Dialogue: 0,0:30:11.66,0:30:14.28,EN,,0,0,0,,is this variable matching a constant.
Dialogue: 0,0:30:14.98,0:30:16.42,EN,,0,0,0,,And if so, it checks in the dictionary.
Dialogue: 0,0:30:16.42,0:30:18.25,EN,,0,0,0,,There's only one other clause in the unifier,
Dialogue: 0,0:30:18.49,0:30:20.75,EN,,0,0,0,,which says is this variable matching a variable,
Dialogue: 0,0:30:22.00,0:30:23.42,EN,,0,0,0,,in which case you go look in the dictionary
Dialogue: 0,0:30:23.45,0:30:25.68,EN,,0,0,0,,and see if that's consistent with what's in the dictionary.
Dialogue: 0,0:30:27.03,0:30:31.13,EN,,0,0,0,,So all the, quote, deduction that's in this language,
Dialogue: 0,0:30:31.28,0:30:34.59,EN,,0,0,0,,if you sort of look at it, sort of sits in the rule applications,
Dialogue: 0,0:30:34.99,0:30:37.88,EN,,0,0,0,,which, if you look at that, sits in the unifier,
Dialogue: 0,0:30:38.36,0:30:40.32,EN,,0,0,0,,which, if you look at that under a microscope,
Dialogue: 0,0:30:40.56,0:30:43.96,EN,,0,0,0,,sits essentially in the pattern matcher.
Dialogue: 0,0:30:44.94,0:30:47.07,EN,,0,0,0,,There's no magic at all going on in there.
Dialogue: 0,0:30:47.41,0:30:50.25,EN,,0,0,0,,And the, quote, deduction that you see
Dialogue: 0,0:30:50.94,0:30:52.89,EN,,0,0,0,,is just the fact that there's this recursion,
Dialogue: 0,0:30:52.92,0:30:55.69,EN,,0,0,0,,which is unwinding the matches bit by bit.
Dialogue: 0,0:30:56.03,0:30:58.03,EN,,0,0,0,,So it looks like this thing is being very clever,
Dialogue: 0,0:30:58.44,0:31:00.36,EN,,0,0,0,,but in fact, it's not being very clever at all.
Dialogue: 0,0:31:02.14,0:31:04.41,EN,,0,0,0,,There are cases where a unifier might have to be clever.
Dialogue: 0,0:31:04.88,0:31:05.87,EN,,0,0,0,,Let me show you one more.
Dialogue: 0,0:31:11.07,0:31:13.36,EN,,0,0,0,,Suppose I want to unify a list of two elements,
Dialogue: 0,0:31:13.48,0:31:14.81,EN,,0,0,0,,x and x,
Dialogue: 0,0:31:17.24,0:31:22.14,EN,,0,0,0,,with a thing that says it's y followed by a dot y.
Dialogue: 0,0:31:24.37,0:31:26.12,EN,,0,0,0,,Now, if you think of what that would have to mean,
Dialogue: 0,0:31:26.86,0:31:29.71,EN,,0,0,0,,it would have to mean that x had better be the same as y,
Dialogue: 0,0:31:30.92,0:31:31.66,EN,,0,0,0,,but also
Dialogue: 0,0:31:31.82,0:31:36.16,EN,,0,0,0,,x had better be the same as a list whose first element is a and whose rest is y.
Dialogue: 0,0:31:37.33,0:31:39.45,EN,,0,0,0,,And if you think about what that would have to mean,
Dialogue: 0,0:31:42.27,0:31:44.71,EN,,0,0,0,,it would have to mean that y is the infinite list of a's.
Dialogue: 0,0:31:47.50,0:31:48.35,EN,,0,0,0,,In some sense,
Dialogue: 0,0:31:49.21,0:31:52.40,EN,,0,0,0,,in order to do that unification,
Dialogue: 0,0:31:52.60,0:31:54.84,EN,,0,0,0,,I have to solve the fixed-point equation
Dialogue: 0,0:31:55.05,0:32:01.84,EN,,0,0,0,,cons of a to y is equal to y.
Dialogue: 0,0:32:04.57,0:32:06.96,EN,,0,0,0,,And in general, I wrote a very simple one.
Dialogue: 0,0:32:07.29,0:32:08.67,EN,,0,0,0,,Really doing unification
Dialogue: 0,0:32:08.97,0:32:11.98,EN,,0,0,0,,might have to solve an arbitrary fixed-point equation:
Dialogue: 0,0:32:12.01,0:32:13.42,EN,,0,0,0,,f of y equals y.
Dialogue: 0,0:32:15.53,0:32:17.08,EN,,0,0,0,,And basically, you can't do that
Dialogue: 0,0:32:17.10,0:32:19.47,EN,,0,0,0,,and make the thing finite all the time.
Dialogue: 0,0:32:20.57,0:32:23.60,EN,,0,0,0,,So how does the logic language handle that?
Dialogue: 0,0:32:24.89,0:32:26.48,EN,,0,0,0,,The answer is it doesn't.
Dialogue: 0,0:32:27.16,0:32:28.04,EN,,0,0,0,,It just punts.
Dialogue: 0,0:32:28.73,0:32:31.07,EN,,0,0,0,,And there's a little check in the unifier,
Dialogue: 0,0:32:31.31,0:32:33.82,EN,,0,0,0,,which says, oh, is this one of the hard cases
Dialogue: 0,0:32:34.44,0:32:38.00,EN,,0,0,0,,which when I go to match things would involve solving a fixed-point equation?
Dialogue: 0,0:32:38.65,0:32:40.81,EN,,0,0,0,,And in this case, I will throw up my hands.
Dialogue: 0,0:32:42.84,0:32:44.65,EN,,0,0,0,,And if that check were not in there,
Dialogue: 0,0:32:45.00,0:32:45.88,EN,,0,0,0,,what would happen?
Dialogue: 0,0:32:47.99,0:32:49.10,EN,,0,0,0,,In most cases is
Dialogue: 0,0:32:49.13,0:32:51.31,EN,,0,0,0,,that the unifier would just go into an infinite loop.
Dialogue: 0,0:32:53.74,0:32:56.54,EN,,0,0,0,,And other logic programming languages work like that.
Dialogue: 0,0:32:56.80,0:32:58.14,EN,,0,0,0,,So there's really no magic.
Dialogue: 0,0:32:58.22,0:32:59.93,EN,,0,0,0,,The easy case is done in a matcher.
Dialogue: 0,0:33:00.10,0:33:01.58,EN,,0,0,0,,The hard case is not done at all.
Dialogue: 0,0:33:02.96,0:33:05.47,EN,,0,0,0,,And that's about the state of this technology.
Dialogue: 0,0:33:11.88,0:33:14.24,EN,,0,0,0,,OK, Let me just say again formally
Dialogue: 0,0:33:14.27,0:33:16.38,EN,,0,0,0,,how rules work now that I talked about unifiers.
Dialogue: 0,0:33:17.39,0:33:18.75,EN,,0,0,0,,So the official definition
Dialogue: 0,0:33:19.20,0:33:20.96,EN,,0,0,0,,is that to apply a rule,
Dialogue: 0,0:33:24.17,0:33:27.13,EN,,0,0,0,,we-- well, let's start using some words we've used before.
Dialogue: 0,0:33:28.27,0:33:32.01,EN,,0,0,0,,Let's talk about sticking dictionaries into
Dialogue: 0,0:33:32.88,0:33:34.78,EN,,0,0,0,,these big boxes of query things
Dialogue: 0,0:33:34.81,0:33:38.54,EN,,0,0,0,,as evaluating these large queries
Dialogue: 0,0:33:39.95,0:33:43.85,EN,,0,0,0,,relative to an environment or a frame.
Dialogue: 0,0:33:43.85,0:33:45.04,EN,,0,0,0,,So when you think of that dictionary,
Dialogue: 0,0:33:45.07,0:33:46.28,EN,,0,0,0,,what's the dictionary after all?
Dialogue: 0,0:33:46.72,0:33:48.18,EN,,0,0,0,,It's a bunch of meanings for symbols.
Dialogue: 0,0:33:48.18,0:33:50.22,EN,,0,0,0,,That's what we've been calling frames or environments.
Dialogue: 0,0:33:51.80,0:33:55.97,EN,,0,0,0,,What does it mean to do some processing relevant to an environment?
Dialogue: 0,0:33:55.97,0:33:57.42,EN,,0,0,0,,That's what we've been calling evaluation.
Dialogue: 0,0:33:58.33,0:34:01.56,EN,,0,0,0,,So we can say the way that you apply a rule
Dialogue: 0,0:34:01.92,0:34:06.16,EN,,0,0,0,,is to evaluate the rule body relative to an environment
Dialogue: 0,0:34:06.67,0:34:11.58,EN,,0,0,0,,that's formed by unifying the rule conclusion with the given query.
Dialogue: 0,0:34:13.23,0:34:14.51,EN,,0,0,0,,And the thing I want you to notice
Dialogue: 0,0:34:14.80,0:34:17.08,EN,,0,0,0,,is the complete formal similarity
Dialogue: 0,0:34:18.16,0:34:21.50,EN,,0,0,0,,to the net of circular evaluator or the substitution model.
Dialogue: 0,0:34:21.63,0:34:22.73,EN,,0,0,0,,To apply a procedure,
Dialogue: 0,0:34:22.86,0:34:28.36,EN,,0,0,0,,we evaluate the procedure body relative to an environment
Dialogue: 0,0:34:28.54,0:34:33.13,EN,,0,0,0,,that's formed by blinding the procedure parameters to the arguments.
Dialogue: 0,0:34:34.56,0:34:36.41,EN,,0,0,0,,There's a complete formal similarity there
Dialogue: 0,0:34:36.44,0:34:40.41,EN,,0,0,0,,between the rules, rule application, and procedure application
Dialogue: 0,0:34:40.57,0:34:42.30,EN,,0,0,0,,even though these things are very, very different.
Dialogue: 0,0:34:43.65,0:34:45.61,EN,,0,0,0,,And again, you have the EVAL APPLY loop.
Dialogue: 0,0:34:47.29,0:34:49.52,EN,,0,0,0,,EVAL and APPLY.
Dialogue: 0,0:34:53.39,0:34:57.39,EN,,0,0,0,,So in general, I might be processing some combined expression
Dialogue: 0,0:34:57.42,0:34:59.13,EN,,0,0,0,,that will turn into a rule application,
Dialogue: 0,0:35:00.70,0:35:03.28,EN,,0,0,0,,which will generate some dictionaries or frames or environments--
Dialogue: 0,0:35:03.31,0:35:04.72,EN,,0,0,0,,whatever you want to call them-- from match,
Dialogue: 0,0:35:05.02,0:35:08.43,EN,,0,0,0,,which will then be the input to some big compound thing like this.
Dialogue: 0,0:35:08.66,0:35:11.77,EN,,0,0,0,,This has pieces of it and may have other rule applications.
Dialogue: 0,0:35:13.58,0:35:15.68,EN,,0,0,0,,And you have essentially the same cycle
Dialogue: 0,0:35:15.72,0:35:18.68,EN,,0,0,0,,even though there's nothing here at all that looks like procedures.
Dialogue: 0,0:35:19.68,0:35:21.87,EN,,0,0,0,,It really has to do with the fact you've built a language
Dialogue: 0,0:35:22.08,0:35:25.49,EN,,0,0,0,,whose means of combination and abstraction unwind in certain ways.
Dialogue: 0,0:35:28.77,0:35:29.52,EN,,0,0,0,,And then in general,
Dialogue: 0,0:35:29.77,0:35:31.39,EN,,0,0,0,,what happens at the very top level,
Dialogue: 0,0:35:33.79,0:35:35.96,EN,,0,0,0,,you might have rules in your database also,
Dialogue: 0,0:35:36.65,0:35:38.70,EN,,0,0,0,,so things in this database might be rules.
Dialogue: 0,0:35:40.46,0:35:42.06,EN,,0,0,0,,There are ways to check that things are true.
Dialogue: 0,0:35:42.92,0:35:44.89,EN,,0,0,0,,So it might come in here and have to do a rule check.
Dialogue: 0,0:35:46.75,0:35:48.16,EN,,0,0,0,,And then there's some control structure
Dialogue: 0,0:35:48.19,0:35:50.48,EN,,0,0,0,,which says, well, you look at some rules, and you look at some data elements,
Dialogue: 0,0:35:50.51,0:35:51.80,EN,,0,0,0,,and you look at some rules and data elements,
Dialogue: 0,0:35:51.84,0:35:53.12,EN,,0,0,0,,and these fan out and out and out.
Dialogue: 0,0:35:53.35,0:35:55.48,EN,,0,0,0,,So it becomes essentially impossible
Dialogue: 0,0:35:55.68,0:35:57.69,EN,,0,0,0,,to say what order it's looking at these things in,
Dialogue: 0,0:35:58.20,0:36:00.27,EN,,0,0,0,,whether it's breadth first or depth first or anything.
Dialogue: 0,0:36:00.28,0:36:01.64,EN,,0,0,0,,And it's even more impossible
Dialogue: 0,0:36:01.66,0:36:05.58,EN,,0,0,0,,because the actual order is somehow buried in the delays of the streams.
Dialogue: 0,0:36:07.69,0:36:11.16,EN,,0,0,0,,So what's very hard to tell from this is the order in which it's scanned.
Dialogue: 0,0:36:11.27,0:36:12.16,EN,,0,0,0,,But what's true is,
Dialogue: 0,0:36:12.19,0:36:13.64,EN,,0,0,0,,because you're looking at the stream view,
Dialogue: 0,0:36:13.90,0:36:15.82,EN,,0,0,0,,is that all of them eventually get looked at.
Dialogue: 0,0:36:24.98,0:36:28.15,EN,,0,0,0,,Let me just mention one tiny technical problem.
Dialogue: 0,0:36:30.88,0:36:33.55,EN,,0,0,0,,Um Suppose I tried over here.
Dialogue: 0,0:36:37.53,0:36:41.00,EN,,0,0,0,,Suppose I tried saying boss of y is computer,
Dialogue: 0,0:36:44.22,0:36:45.78,EN,,0,0,0,,then a funny thing would happen.
Dialogue: 0,0:36:45.78,0:36:50.25,EN,,0,0,0,,As I stuck a dictionary with y in here,
Dialogue: 0,0:36:52.73,0:36:57.37,EN,,0,0,0,,I might get-- this y is not the same as that y,
Dialogue: 0,0:36:57.42,0:37:00.62,EN,,0,0,0,,which was the other piece of somebody's job description.
Dialogue: 0,0:37:01.58,0:37:03.80,EN,,0,0,0,,So if I really only did literally what I said,
Dialogue: 0,0:37:04.22,0:37:06.44,EN,,0,0,0,,we'd get some variable conflict problems.
Dialogue: 0,0:37:09.28,0:37:10.48,EN,,0,0,0,,So I lied to you a little bit.
Dialogue: 0,0:37:10.93,0:37:13.84,EN,,0,0,0,,Notice that problem is exactly a problem we've run into before.
Dialogue: 0,0:37:14.27,0:37:15.56,EN,,0,0,0,,It is precisely
Dialogue: 0,0:37:15.96,0:37:18.36,EN,,0,0,0,,the need for local variables in a language.
Dialogue: 0,0:37:19.24,0:37:21.74,EN,,0,0,0,,When I square, when I have the sum of squares,
Dialogue: 0,0:37:21.79,0:37:23.39,EN,,0,0,0,,that x had better not be that x.
Dialogue: 0,0:37:24.96,0:37:26.32,EN,,0,0,0,,That's exactly the same as
Dialogue: 0,0:37:27.39,0:37:29.77,EN,,0,0,0,,as this y had better not be that y.
Dialogue: 0,0:37:31.80,0:37:32.75,EN,,0,0,0,,And we know how to solve that.
Dialogue: 0,0:37:32.78,0:37:34.49,EN,,0,0,0,,We built -- That was this whole environment model,
Dialogue: 0,0:37:34.51,0:37:37.04,EN,,0,0,0,,and we built chains of frames and all sorts of things like that.
Dialogue: 0,0:37:37.71,0:37:39.10,EN,,0,0,0,,There's a much more brutal way to solve it.
Dialogue: 0,0:37:39.10,0:37:41.73,EN,,0,0,0,,In the query language, we didn't even do that.
Dialogue: 0,0:37:41.73,0:37:43.18,EN,,0,0,0,,We did something completely brutal.
Dialogue: 0,0:37:43.54,0:37:45.93,EN,,0,0,0,,We said every time you apply a rule,
Dialogue: 0,0:37:47.26,0:37:49.63,EN,,0,0,0,,rename consistently all the variables in the rule
Dialogue: 0,0:37:49.77,0:37:53.50,EN,,0,0,0,,to some new unique names that won't conflict with anything.
Dialogue: 0,0:37:54.04,0:37:57.10,EN,,0,0,0,,If you looked at the -- That's conceptually simpler,
Dialogue: 0,0:37:57.12,0:37:59.24,EN,,0,0,0,,but really brutal and not particularly efficient.
Dialogue: 0,0:37:59.97,0:38:01.15,EN,,0,0,0,,But notice,
Dialogue: 0,0:38:01.39,0:38:04.68,EN,,0,0,0,,we could have gotten rid of all of our environment structures
Dialogue: 0,0:38:05.50,0:38:08.72,EN,,0,0,0,,if we defined for procedures in Lisp the same thing.
Dialogue: 0,0:38:08.75,0:38:11.56,EN,,0,0,0,,If every time we applied a procedure and did the substitution model
Dialogue: 0,0:38:11.87,0:38:13.90,EN,,0,0,0,,we renamed all the variables in the procedure,
Dialogue: 0,0:38:14.19,0:38:16.28,EN,,0,0,0,,then we never would have had to worry about local variables
Dialogue: 0,0:38:16.33,0:38:17.39,EN,,0,0,0,,because they would never arise.
Dialogue: 0,0:38:19.04,0:38:20.41,EN,,0,0,0,,OK, well, that would be inefficient,
Dialogue: 0,0:38:20.91,0:38:23.04,EN,,0,0,0,,and it's inefficient here in the query language, too,
Dialogue: 0,0:38:23.29,0:38:24.59,EN,,0,0,0,,but we did it to keep it simple.
Dialogue: 0,0:38:25.61,0:38:26.67,EN,,0,0,0,,Let's break for questions.
Dialogue: 0,0:38:30.88,0:38:33.39,EN,,0,0,0,,AUDIENCE: When you started this section,
Dialogue: 0,0:38:33.40,0:38:39.60,EN,,0,0,0,,you emphasized how powerful our APPLY EVAL model was
Dialogue: 0,0:38:39.63,0:38:41.17,EN,,0,0,0,,that we could use it for any language.
Dialogue: 0,0:38:41.17,0:38:43.39,EN,,0,0,0,,And then you say we're going to have this language which is so different.
Dialogue: 0,0:38:43.95,0:38:45.13,EN,,0,0,0,,It turns out that this language,
Dialogue: 0,0:38:45.58,0:38:47.88,EN,,0,0,0,,as you just pointed out, is very much the same.
Dialogue: 0,0:38:47.88,0:38:49.85,EN,,0,0,0,,I'm wondering if you're arguing that all languages end up
Dialogue: 0,0:38:50.48,0:38:54.57,EN,,0,0,0,,coming down to this you can apply a rule or apply a procedure
Dialogue: 0,0:38:55.12,0:38:55.98,EN,,0,0,0,,or some kind of apply?
Dialogue: 0,0:38:57.07,0:38:58.88,EN,,0,0,0,,PROFESSOR: I would say that pretty much any language
Dialogue: 0,0:38:58.92,0:39:00.30,EN,,0,0,0,,where you really are building up
Dialogue: 0,0:39:00.92,0:39:04.40,EN,,0,0,0,,these means of combination and giving them simpler names
Dialogue: 0,0:39:04.70,0:39:06.86,EN,,0,0,0,,and you're saying anything of the sort, like
Dialogue: 0,0:39:07.79,0:39:09.90,EN,,0,0,0,,here's a general kind of expression,
Dialogue: 0,0:39:09.98,0:39:11.40,EN,,0,0,0,,like how to square something,
Dialogue: 0,0:39:12.03,0:39:14.20,EN,,0,0,0,,almost anything that you would call a procedure.
Dialogue: 0,0:39:14.88,0:39:15.88,EN,,0,0,0,,If that's got to have parts,
Dialogue: 0,0:39:15.90,0:39:17.24,EN,,0,0,0,,you have to unwind those parts.
Dialogue: 0,0:39:18.02,0:39:20.19,EN,,0,0,0,,You have to have some kind of organization which says
Dialogue: 0,0:39:20.57,0:39:24.03,EN,,0,0,0,,when I look at the abstract variables or tags
Dialogue: 0,0:39:24.06,0:39:27.10,EN,,0,0,0,,or whatever you want to call them that might stand for particular things,
Dialogue: 0,0:39:28.33,0:39:29.34,EN,,0,0,0,,you have to keep track of that,
Dialogue: 0,0:39:29.39,0:39:30.91,EN,,0,0,0,,and that's going to be something like an environment.
Dialogue: 0,0:39:31.72,0:39:32.54,EN,,0,0,0,,And then if you say
Dialogue: 0,0:39:32.70,0:39:35.26,EN,,0,0,0,,this part can have parts which I have to unwind,
Dialogue: 0,0:39:35.80,0:39:37.44,EN,,0,0,0,,you've got to have something like this cycle.
Dialogue: 0,0:39:39.97,0:39:43.20,EN,,0,0,0,,And lots and lots of languages have that character
Dialogue: 0,0:39:43.36,0:39:45.40,EN,,0,0,0,,as long ... when they sort of get put together in this way.
Dialogue: 0,0:39:45.59,0:39:47.20,EN,,0,0,0,,This language again really is different
Dialogue: 0,0:39:47.21,0:39:49.50,EN,,0,0,0,,because there's nothing like procedures on the outside.
Dialogue: 0,0:39:50.69,0:39:52.68,EN,,0,0,0,,When you go below the surface and you see the implementation,
Dialogue: 0,0:39:52.70,0:39:54.24,EN,,0,0,0,,of course, it starts looking the same.
Dialogue: 0,0:39:54.87,0:39:56.95,EN,,0,0,0,,But from the outside, it's a very different world view.
Dialogue: 0,0:39:56.95,0:39:58.54,EN,,0,0,0,,You're not computing functions of inputs.
Dialogue: 0,0:40:03.97,0:40:05.71,EN,,0,0,0,,AUDIENCE: You mentioned earlier that
Dialogue: 0,0:40:06.60,0:40:09.55,EN,,0,0,0,,when you build all of these rules in pattern matcher
Dialogue: 0,0:40:10.01,0:40:11.42,EN,,0,0,0,,and with the delayed action of streams,
Dialogue: 0,0:40:11.45,0:40:12.72,EN,,0,0,0,,you really have no way to know
Dialogue: 0,0:40:13.37,0:40:15.36,EN,,0,0,0,,in what order things are evaluated.
Dialogue: 0,0:40:15.58,0:40:15.94,EN,,0,0,0,,PROFESSOR: Right.
Dialogue: 0,0:40:15.94,0:40:18.28,EN,,0,0,0,,AUDIENCE: And that would indicate then that
Dialogue: 0,0:40:18.94,0:40:22.28,EN,,0,0,0,,you should only express declarative knowledge that's true for all-time,
Dialogue: 0,0:40:22.30,0:40:23.79,EN,,0,0,0,,no-time sequence built into it.
Dialogue: 0,0:40:23.95,0:40:25.47,EN,,0,0,0,,Otherwise, these things get all--
Dialogue: 0,0:40:27.39,0:40:28.76,EN,,0,0,0,,PROFESSOR: Yes. Yes.
Dialogue: 0,0:40:28.82,0:40:29.48,EN,,0,0,0,,The question is
Dialogue: 0,0:40:30.06,0:40:32.60,EN,,0,0,0,,this really is set up for doing declarative knowledge,
Dialogue: 0,0:40:33.26,0:40:34.81,EN,,0,0,0,,and as I presented it-- no
Dialogue: 0,0:40:35.71,0:40:39.56,EN,,0,0,0,,and I'll show you some of the ugly warts under this after the break.
Dialogue: 0,0:40:40.83,0:40:42.60,EN,,0,0,0,,As I presented it, it's just doing logic.
Dialogue: 0,0:40:43.07,0:40:44.52,EN,,0,0,0,,And in principle, if it were logic,
Dialogue: 0,0:40:44.54,0:40:46.81,EN,,0,0,0,,it wouldn't matter what order it's getting done.
Dialogue: 0,0:40:48.84,0:40:51.55,EN,,0,0,0,,And it's quite true
Dialogue: 0,0:40:51.60,0:40:53.61,EN,,0,0,0,,when you start doing things where you have side effects
Dialogue: 0,0:40:53.68,0:40:55.20,EN,,0,0,0,,like adding things to the database
Dialogue: 0,0:40:55.23,0:40:58.16,EN,,0,0,0,,and taking things out, and we'll see some others,
Dialogue: 0,0:40:58.75,0:41:00.83,EN,,0,0,0,,you loose that kind of control.
Dialogue: 0,0:41:01.29,0:41:02.94,EN,,0,0,0,,So, for example, contrasting with Prolog.
Dialogue: 0,0:41:02.94,0:41:05.15,EN,,0,0,0,,Say Prolog has various features
Dialogue: 0,0:41:05.16,0:41:07.79,EN,,0,0,0,,where you really exploit the order of evaluation.
Dialogue: 0,0:41:09.64,0:41:11.77,EN,,0,0,0,,And people write Prolog programs that way.
Dialogue: 0,0:41:11.77,0:41:14.04,EN,,0,0,0,,That turns out to be very complicated in Prolog,
Dialogue: 0,0:41:14.32,0:41:17.55,EN,,0,0,0,,although if you're an expert Prolog programmer, you can do it.
Dialogue: 0,0:41:18.59,0:41:20.21,EN,,0,0,0,,However, here I don't think you can do it at all.
Dialogue: 0,0:41:20.21,0:41:21.24,EN,,0,0,0,,It's very complicated
Dialogue: 0,0:41:21.72,0:41:23.64,EN,,0,0,0,,because you really are giving up control over
Dialogue: 0,0:41:23.77,0:41:25.72,EN,,0,0,0,,any prearranged order of trying things.
Dialogue: 0,0:41:27.15,0:41:30.16,EN,,0,0,0,,AUDIENCE: Now, that would indicate then that you have a functional mapping.
Dialogue: 0,0:41:30.67,0:41:32.51,EN,,0,0,0,,And when you started out this lecture,
Dialogue: 0,0:41:32.99,0:41:34.08,EN,,0,0,0,,you said that
Dialogue: 0,0:41:34.67,0:41:36.70,EN,,0,0,0,,we express the declarative knowledge which is a relation,
Dialogue: 0,0:41:37.15,0:41:38.81,EN,,0,0,0,,and we don't talk about the inputs and the outputs.
Dialogue: 0,0:41:41.21,0:41:43.37,EN,,0,0,0,,PROFESSOR: Well, there's a pun on functional, right?
Dialogue: 0,0:41:43.37,0:41:45.79,EN,,0,0,0,,There's functional in the sense of no side effects
Dialogue: 0,0:41:46.20,0:41:48.16,EN,,0,0,0,,and not depending on what order is going on.
Dialogue: 0,0:41:48.70,0:41:51.04,EN,,0,0,0,,And then there's functional in the sense of mathematical function,
Dialogue: 0,0:41:51.07,0:41:52.22,EN,,0,0,0,,which means input and output.
Dialogue: 0,0:41:52.59,0:41:54.36,EN,,0,0,0,,And it's just that pun that you're making, I think.
Dialogue: 0,0:41:56.51,0:41:58.51,EN,,0,0,0,,AUDIENCE: I'm a little unclear on what you're doing with
Dialogue: 0,0:41:58.81,0:42:00.70,EN,,0,0,0,,two statements, the two boss statements.
Dialogue: 0,0:42:01.27,0:42:05.74,EN,,0,0,0,,Is the first one building up the database
Dialogue: 0,0:42:05.76,0:42:08.08,EN,,0,0,0,,and the second one a query or--
Dialogue: 0,0:42:09.07,0:42:10.12,EN,,0,0,0,,PROFESSOR: OK, I'm sorry.
Dialogue: 0,0:42:12.44,0:42:15.16,EN,,0,0,0,,What I meant here, if I type something like this in as a query--
Dialogue: 0,0:42:16.12,0:42:18.44,EN,,0,0,0,,I should have given an example way at the very beginning.
Dialogue: 0,0:42:19.47,0:42:23.52,EN,,0,0,0,,If I type in job, Ben Bitdiddle, computer wizard,
Dialogue: 0,0:42:25.04,0:42:27.77,EN,,0,0,0,,what the processing will do is if it finds a match,
Dialogue: 0,0:42:28.30,0:42:30.28,EN,,0,0,0,,it'll find a match to that exact thing,
Dialogue: 0,0:42:30.86,0:42:33.28,EN,,0,0,0,,and it'll type out a job, Ben Bitdiddle, computer wizard.
Dialogue: 0,0:42:34.22,0:42:35.60,EN,,0,0,0,,If it doesn't find a match,
Dialogue: 0,0:42:35.69,0:42:36.75,EN,,0,0,0,,it won't find anything.
Dialogue: 0,0:42:37.40,0:42:39.55,EN,,0,0,0,,So what I should have said is the way
Dialogue: 0,0:42:39.56,0:42:42.27,EN,,0,0,0,,you use the query language to check whether something is true,
Dialogue: 0,0:42:43.40,0:42:45.77,EN,,0,0,0,,that's one of the things you want to do in logic programming,
Dialogue: 0,0:42:46.41,0:42:49.34,EN,,0,0,0,,is you type in your query and either that comes out or it doesn't.
Dialogue: 0,0:42:50.68,0:42:52.38,EN,,0,0,0,,So what I was trying to illustrate here,
Dialogue: 0,0:42:52.41,0:42:54.80,EN,,0,0,0,,I wanted to start with a very simple example
Dialogue: 0,0:42:54.83,0:42:56.62,EN,,0,0,0,,before talking about unifiers.
Dialogue: 0,0:42:57.48,0:42:58.11,EN,,0,0,0,,So what I should have said,
Dialogue: 0,0:42:58.14,0:43:00.96,EN,,0,0,0,,if I just wanted to check whether this is true,
Dialogue: 0,0:43:01.18,0:43:03.28,EN,,0,0,0,,I could type that in and see if anything came out
Dialogue: 0,0:43:05.16,0:43:06.27,EN,,0,0,0,,AUDIENCE: And then the second one--
Dialogue: 0,0:43:06.28,0:43:07.84,EN,,0,0,0,,PROFESSOR: The second one would be a real query.
Dialogue: 0,0:43:07.88,0:43:09.12,EN,,0,0,0,,AUDIENCE: A real query, yeah.
Dialogue: 0,0:43:10.77,0:43:13.10,EN,,0,0,0,,PROFESSOR: What would come out, see, it would go in here say with WHO,
Dialogue: 0,0:43:13.90,0:43:15.74,EN,,0,0,0,,and in would go frame that says z
Dialogue: 0,0:43:16.62,0:43:18.81,EN,,0,0,0,,z is bound to who and d is bound to computer.
Dialogue: 0,0:43:19.56,0:43:20.49,EN,,0,0,0,,And this will pass through,
Dialogue: 0,0:43:20.51,0:43:21.95,EN,,0,0,0,,and then by the time it got out of here,
Dialogue: 0,0:43:22.01,0:43:23.25,EN,,0,0,0,,who would pick up a binding.
Dialogue: 0,0:43:26.95,0:43:28.76,EN,,0,0,0,,AUDIENCE: On the unifying thing there,
Dialogue: 0,0:43:29.18,0:43:35.96,EN,,0,0,0,,I still am not sure what happens with who and z.
Dialogue: 0,0:43:36.46,0:43:39.58,EN,,0,0,0,,OK being unifying-- the rule here says--
Dialogue: 0,0:43:42.03,0:43:46.22,EN,,0,0,0,,OK, so you say that you can't make question mark equal to question mark who.
Dialogue: 0,0:43:46.26,0:43:48.08,EN,,0,0,0,,PROFESSOR: Right. That's what the matcher can't do.
Dialogue: 0,0:43:48.36,0:43:50.83,EN,,0,0,0,,But unifier, what this will mean to a unifier
Dialogue: 0,0:43:51.92,0:43:54.01,EN,,0,0,0,,is that there's an environment with three variables.
Dialogue: 0,0:43:56.69,0:43:57.90,EN,,0,0,0,,d here is computer.
Dialogue: 0,0:43:58.52,0:44:00.19,EN,,0,0,0,,z is whatever who is.
Dialogue: 0,0:44:01.83,0:44:05.26,EN,,0,0,0,,So if later on in the matcher routine
Dialogue: 0,0:44:07.20,0:44:10.38,EN,,0,0,0,,it said, for example, who has to be 3,
Dialogue: 0,0:44:12.06,0:44:13.66,EN,,0,0,0,,then when I looked up in the dictionary,
Dialogue: 0,0:44:14.00,0:44:16.40,EN,,0,0,0,,it will say, oh, z is 3 because it's the same as who.
Dialogue: 0,0:44:18.36,0:44:20.44,EN,,0,0,0,,And that's in some sense the only thing you need to do
Dialogue: 0,0:44:20.46,0:44:21.98,EN,,0,0,0,,to extend the unifier to a matcher.
Dialogue: 0,0:44:22.48,0:44:24.80,EN,,0,0,0,,AUDIENCE: OK, because it looked like when you were telling how to unify,
Dialogue: 0,0:44:24.83,0:44:26.96,EN,,0,0,0,,it looked like you would put the things together in such a way
Dialogue: 0,0:44:26.99,0:44:29.23,EN,,0,0,0,,that you'd actually solve and have a value for both of them.
Dialogue: 0,0:44:29.77,0:44:31.24,EN,,0,0,0,,And what it looks like now
Dialogue: 0,0:44:31.28,0:44:32.83,EN,,0,0,0,,is that you're actually pass a dictionary
Dialogue: 0,0:44:32.88,0:44:34.86,EN,,0,0,0,,with two variables and the variables are linked.
Dialogue: 0,0:44:34.88,0:44:37.23,EN,,0,0,0,,PROFESSOR: Right. It only looks like you're solving for both of them
Dialogue: 0,0:44:37.52,0:44:39.74,EN,,0,0,0,,because you're sort of looking at the whole solution at once.
Dialogue: 0,0:44:40.54,0:44:42.81,EN,,0,0,0,,If you sort of watch the thing getting built up recursively,
Dialogue: 0,0:44:42.81,0:44:43.74,EN,,0,0,0,,it's merely this.
Dialogue: 0,0:44:44.98,0:44:48.40,EN,,0,0,0,,AUDIENCE: OK, so you do pass off that dictionary with two variables?
Dialogue: 0,0:44:48.40,0:44:49.11,EN,,0,0,0,,PROFESSOR: That's right.
Dialogue: 0,0:44:49.11,0:44:49.68,EN,,0,0,0,,AUDIENCE: And link?
Dialogue: 0,0:44:50.38,0:44:52.91,EN,,0,0,0,,PROFESSOR: Right. It just looks like an ordinary dictionary.
Dialogue: 0,0:44:54.35,0:44:56.06,EN,,0,0,0,,AUDIENCE: When you're talking about the unifier,
Dialogue: 0,0:44:56.09,0:45:00.19,EN,,0,0,0,,is it that there are some cases or some points
Dialogue: 0,0:45:00.75,0:45:03.98,EN,,0,0,0,,that you are not able to unify them?
Dialogue: 0,0:45:04.03,0:45:04.30,EN,,0,0,0,,PROFESSOR: Right.
Dialogue: 0,0:45:04.97,0:45:08.46,EN,,0,0,0,,AUDIENCE: Can you just by building the rules or
Dialogue: 0,0:45:09.16,0:45:15.93,EN,,0,0,0,,writing the forms know in advance if you are going to be able to solve
Dialogue: 0,0:45:16.48,0:45:18.54,EN,,0,0,0,,to get the unification or not?
Dialogue: 0,0:45:18.76,0:45:22.94,EN,,0,0,0,,Can you add some properties either to the rules itself
Dialogue: 0,0:45:23.18,0:45:25.45,EN,,0,0,0,,or to the form that you're writing
Dialogue: 0,0:45:25.82,0:45:29.04,EN,,0,0,0,,so that you avoid the problem of not finding unification?
Dialogue: 0,0:45:29.18,0:45:31.15,EN,,0,0,0,,Well I mean, you can agree,
Dialogue: 0,0:45:31.47,0:45:35.26,EN,,0,0,0,,I think, to write in a fairly restricted way where you won't run into it.
Dialogue: 0,0:45:35.60,0:45:36.67,EN,,0,0,0,,See, because what you're getting--
Dialogue: 0,0:45:36.88,0:45:39.12,EN,,0,0,0,,see, the place where you get into problems is when you--
Dialogue: 0,0:45:39.68,0:45:44.25,EN,,0,0,0,,well, again, you're trying to match things like that
Dialogue: 0,0:45:44.59,0:45:47.20,EN,,0,0,0,,against things where these have structure,
Dialogue: 0,0:45:47.55,0:45:55.30,EN,,0,0,0,,where a, y, b, y something.
Dialogue: 0,0:45:58.98,0:46:01.48,EN,,0,0,0,,So this is the kind of place where you're going to get into trouble.
Dialogue: 0,0:46:03.07,0:46:05.80,EN,,0,0,0,,AUDIENCE: So you can do that syntactically?
Dialogue: 0,0:46:06.14,0:46:08.76,EN,,0,0,0,,PROFESSOR: So you can kind of watch your rules
Dialogue: 0,0:46:08.76,0:46:10.49,EN,,0,0,0,,in the kinds of things that your writing.
Dialogue: 0,0:46:11.90,0:46:14.08,EN,,0,0,0,,AUDIENCE: So that's the problem that the builder
Dialogue: 0,0:46:14.11,0:46:16.27,EN,,0,0,0,,of the database has to be concerned?
Dialogue: 0,0:46:16.57,0:46:17.80,EN,,0,0,0,,PROFESSOR: That's a problem.
Dialogue: 0,0:46:19.93,0:46:22.01,EN,,0,0,0,,It's a problem either-- not quite the builder of the database,
Dialogue: 0,0:46:22.04,0:46:23.61,EN,,0,0,0,,the person who is expressing the rules,
Dialogue: 0,0:46:24.01,0:46:25.31,EN,,0,0,0,,or the builder of the database.
Dialogue: 0,0:46:25.80,0:46:29.79,EN,,0,0,0,,What the unifier actually does is you can check at the next level down
Dialogue: 0,0:46:29.92,0:46:31.87,EN,,0,0,0,,when you actually get to the unifier
Dialogue: 0,0:46:32.41,0:46:34.76,EN,,0,0,0,,and you'll see in the code where it looks up in the dictionary.
Dialogue: 0,0:46:34.94,0:46:36.83,EN,,0,0,0,,If it sort of says what does y have to be?
Dialogue: 0,0:46:37.26,0:46:41.42,EN,,0,0,0,,Oh, does y have to be something that contains a y as its expression?
Dialogue: 0,0:46:41.96,0:46:43.26,EN,,0,0,0,,At that point, the unifier and say,
Dialogue: 0,0:46:43.28,0:46:46.24,EN,,0,0,0,,oh my God, I'm trying to solve a fixed-point equation.
Dialogue: 0,0:46:46.24,0:46:46.99,EN,,0,0,0,,I'll give it up here.
Dialogue: 0,0:46:48.59,0:46:51.91,EN,,0,0,0,,AUDIENCE: You make the distinction between the rules in the database.
Dialogue: 0,0:46:51.91,0:46:56.48,EN,,0,0,0,,Are the rules added to the database?
Dialogue: 0,0:46:56.95,0:46:57.36,EN,,0,0,0,,PROFESSOR: Yes.
Dialogue: 0,0:46:57.87,0:46:58.87,EN,,0,0,0,,Yes, I should have said that.
Dialogue: 0,0:46:58.87,0:47:00.33,EN,,0,0,0,,One way to think about rules
Dialogue: 0,0:47:00.60,0:47:02.65,EN,,0,0,0,,is that they're just other things in the database.
Dialogue: 0,0:47:03.71,0:47:06.81,EN,,0,0,0,,So if you want to check the things that have to be checked in the database,
Dialogue: 0,0:47:06.83,0:47:09.44,EN,,0,0,0,,they're kind of virtual facts that are in the database.
Dialogue: 0,0:47:09.44,0:47:12.32,EN,,0,0,0,,AUDIENCE: But in that explanation, you made the differentiation
Dialogue: 0,0:47:12.43,0:47:17.26,EN,,0,0,0,,between database and the rules itself.
Dialogue: 0,0:47:18.23,0:47:19.90,EN,,0,0,0,,PROFESSOR: Yeah, I probably should not have done that.
Dialogue: 0,0:47:20.49,0:47:23.31,EN,,0,0,0,,The only reason to do that is in terms of the implementation.
Dialogue: 0,0:47:23.54,0:47:24.67,EN,,0,0,0,,When you look at the implementation,
Dialogue: 0,0:47:24.68,0:47:27.50,EN,,0,0,0,,there's a part which says check either primitive
Dialogue: 0,0:47:27.55,0:47:29.85,EN,,0,0,0,,assertions in the database or check rules.
Dialogue: 0,0:47:30.47,0:47:32.72,EN,,0,0,0,,And then the real reason, the real reason why
Dialogue: 0,0:47:32.78,0:47:34.56,EN,,0,0,0,,you can't tell what order things are going to come out in
Dialogue: 0,0:47:34.96,0:47:40.46,EN,,0,0,0,,is that the rules database and the data database
Dialogue: 0,0:47:40.48,0:47:43.68,EN,,0,0,0,,sort of get merged in a kind of delayed evaluation way.
Dialogue: 0,0:47:44.60,0:47:46.80,EN,,0,0,0,,And so that's what makes the order very complicated.
Dialogue: 0,0:47:55.44,0:47:56.09,EN,,0,0,0,,OK, let's break.
Dialogue: 0,0:47:56.30,0:48:09.90,EN,,0,0,0,,[JESU, JOY OF MAN'S DESIRING]
Dialogue: 0,0:48:33.16,0:48:35.37,EN,,0,0,0,,We've just seen how the logic language works
Dialogue: 0,0:48:35.39,0:48:36.41,EN,,0,0,0,,and how rules work.
Dialogue: 0,0:48:37.23,0:48:39.37,EN,,0,0,0,,Now, let's turn to a more profound question.
Dialogue: 0,0:48:40.12,0:48:41.28,EN,,0,0,0,,What do these things mean?
Dialogue: 0,0:48:43.18,0:48:46.86,EN,,0,0,0,,That brings us to the subtlest, most devious part
Dialogue: 0,0:48:46.99,0:48:48.67,EN,,0,0,0,,of this whole query language business,
Dialogue: 0,0:48:49.21,0:48:53.07,EN,,0,0,0,,and that is that it's not quite what it seems to be.
Dialogue: 0,0:48:53.57,0:48:56.22,EN,,0,0,0,,AND and OR and NOT
Dialogue: 0,0:48:57.02,0:48:58.88,EN,,0,0,0,,and the logical implication of rules
Dialogue: 0,0:48:59.69,0:49:06.64,EN,,0,0,0,,are not really the AND and OR and NOT and logical implication of logic.
Dialogue: 0,0:49:07.69,0:49:09.71,EN,,0,0,0,,Let me give you an example of that.
Dialogue: 0,0:49:09.91,0:49:12.22,EN,,0,0,0,,Certainly, if we have two things in logic,
Dialogue: 0,0:49:12.40,0:49:19.44,EN,,0,0,0,,it ought to be the case that AND of P and Q
Dialogue: 0,0:49:20.00,0:49:22.59,EN,,0,0,0,,is the same as AND of Q and P
Dialogue: 0,0:49:23.10,0:49:24.51,EN,,0,0,0,,and that OR of P and Q
Dialogue: 0,0:49:24.78,0:49:26.51,EN,,0,0,0,,is the same as OR of Q and P.
Dialogue: 0,0:49:28.67,0:49:30.09,EN,,0,0,0,,But let's look here.
Dialogue: 0,0:49:30.10,0:49:32.01,EN,,0,0,0,,Here's an example.
Dialogue: 0,0:49:32.18,0:49:36.16,EN,,0,0,0,,Let's talk about somebody outranking somebody else
Dialogue: 0,0:49:36.28,0:49:40.14,EN,,0,0,0,,in this our little database organization.
Dialogue: 0,0:49:40.14,0:49:42.89,EN,,0,0,0,,We'll say s is outranked by b
Dialogue: 0,0:49:44.64,0:49:48.62,EN,,0,0,0,,if or if either the supervisor of s is b
Dialogue: 0,0:49:49.63,0:49:51.07,EN,,0,0,0,,or there's some middle manager here,
Dialogue: 0,0:49:51.10,0:49:55.82,EN,,0,0,0,,that supervisor of s is m, and m is outranked by b.
Dialogue: 0,0:49:59.64,0:50:02.31,EN,,0,0,0,,So there's one way to define rule outranked by.
Dialogue: 0,0:50:02.31,0:50:04.16,EN,,0,0,0,,Or we can write exactly the same thing,
Dialogue: 0,0:50:05.08,0:50:06.91,EN,,0,0,0,,except at the bottom here,
Dialogue: 0,0:50:07.21,0:50:09.88,EN,,0,0,0,,we reversed the order of these two clauses.
Dialogue: 0,0:50:11.63,0:50:12.99,EN,,0,0,0,,And certainly if this were logic,
Dialogue: 0,0:50:13.00,0:50:14.88,EN,,0,0,0,,those ought to mean the same thing.
Dialogue: 0,0:50:16.69,0:50:17.31,EN,,0,0,0,,However,
Dialogue: 0,0:50:17.71,0:50:19.61,EN,,0,0,0,,in our particular implementation,
Dialogue: 0,0:50:19.64,0:50:22.88,EN,,0,0,0,,if you say something like who's outranked by Ben Bitdiddle,
Dialogue: 0,0:50:23.48,0:50:25.36,EN,,0,0,0,,what you'll find is that this rule
Dialogue: 0,0:50:26.76,0:50:28.72,EN,,0,0,0,,will work perfectly well and generate answers,
Dialogue: 0,0:50:30.04,0:50:31.98,EN,,0,0,0,,whereas this rule will go into an infinite loop.
Dialogue: 0,0:50:34.11,0:50:36.27,EN,,0,0,0,,And the reason for that is that
Dialogue: 0,0:50:36.33,0:50:40.33,EN,,0,0,0,,this will come in and say, oh, who's outranked by Ben Bitdiddle?
Dialogue: 0,0:50:41.92,0:50:43.53,EN,,0,0,0,,Find an s, find an s
Dialogue: 0,0:50:43.88,0:50:46.22,EN,,0,0,0,,which is outranked by b, where b is Ben Bitdiddle,
Dialogue: 0,0:50:47.50,0:50:49.63,EN,,0,0,0,,which is going to happen in it a subproblem.
Dialogue: 0,0:50:50.33,0:50:51.98,EN,,0,0,0,,Oh gee, find an m
Dialogue: 0,0:50:52.24,0:50:54.57,EN,,0,0,0,,such as m is outranked by Ben Bitdiddle
Dialogue: 0,0:50:55.61,0:50:57.36,EN,,0,0,0,,with no restrictions on m.
Dialogue: 0,0:50:58.56,0:51:00.40,EN,,0,0,0,,So this will say in order to solve this problem,
Dialogue: 0,0:51:01.42,0:51:03.29,EN,,0,0,0,,I solve exactly the same problem.
Dialogue: 0,0:51:04.57,0:51:07.23,EN,,0,0,0,,And then after I've solved that, I'll check for a supervisory relationship.
Dialogue: 0,0:51:08.00,0:51:09.16,EN,,0,0,0,,Whereas this one won't get into that,
Dialogue: 0,0:51:09.18,0:51:12.35,EN,,0,0,0,,because before it tries to find this outranked by,
Dialogue: 0,0:51:12.94,0:51:15.26,EN,,0,0,0,,it'll already have had a restriction on m here.
Dialogue: 0,0:51:18.38,0:51:20.94,EN,,0,0,0,,So these two things which ought to mean the same,
Dialogue: 0,0:51:20.99,0:51:22.67,EN,,0,0,0,,in fact, one goes into an infinite loop.
Dialogue: 0,0:51:22.86,0:51:25.04,EN,,0,0,0,,One goes, one does not.
Dialogue: 0,0:51:26.72,0:51:29.77,EN,,0,0,0,,That's a very extreme case
Dialogue: 0,0:51:29.79,0:51:32.65,EN,,0,0,0,,of a general thing that you'll find in logic programming that
Dialogue: 0,0:51:34.28,0:51:38.70,EN,,0,0,0,,if you start changing the order of the things in the ANDs or ORs,
Dialogue: 0,0:51:39.34,0:51:41.58,EN,,0,0,0,,you'll find tremendous differences in efficiency.
Dialogue: 0,0:51:42.24,0:51:43.21,EN,,0,0,0,,And we just saw
Dialogue: 0,0:51:43.55,0:51:46.54,EN,,0,0,0,,an infinitely big difference in efficiency and an infinite loop.
Dialogue: 0,0:51:49.19,0:51:51.74,EN,,0,0,0,,And there are similar things having to do order
Dialogue: 0,0:51:52.00,0:51:53.31,EN,,0,0,0,,in which you enter rules.
Dialogue: 0,0:51:54.07,0:51:56.48,EN,,0,0,0,,The order in which it happens to look at rules in the database
Dialogue: 0,0:51:56.70,0:51:59.95,EN,,0,0,0,,may vastly change the efficiency with which it gets out answers or,
Dialogue: 0,0:52:00.46,0:52:02.60,EN,,0,0,0,,in fact, send it into an infinite loop for some orderings.
Dialogue: 0,0:52:03.84,0:52:07.29,EN,,0,0,0,,And this whole thing has to do
Dialogue: 0,0:52:07.63,0:52:10.04,EN,,0,0,0,,the fact that you're checking these rules in some order.
Dialogue: 0,0:52:10.95,0:52:14.41,EN,,0,0,0,,And some rules may lead to really long paths of implication.
Dialogue: 0,0:52:14.44,0:52:16.06,EN,,0,0,0,,Others might, others might not.
Dialogue: 0,0:52:16.44,0:52:17.68,EN,,0,0,0,,And you don't know a priori
Dialogue: 0,0:52:17.72,0:52:19.16,EN,,0,0,0,,which ones are good and which ones are bad.
Dialogue: 0,0:52:19.30,0:52:21.48,EN,,0,0,0,,And there's a whole bunch of research having to do with that,
Dialogue: 0,0:52:22.16,0:52:23.76,EN,,0,0,0,,mostly having to do with thinking about
Dialogue: 0,0:52:23.95,0:52:26.97,EN,,0,0,0,,making parallel implementations of logic programming languages.
Dialogue: 0,0:52:27.32,0:52:29.90,EN,,0,0,0,,And in some sense, what you'd like to do is check all rules in parallel
Dialogue: 0,0:52:30.36,0:52:32.80,EN,,0,0,0,,and whichever ones get answers, you bubble them up. And
Dialogue: 0,0:52:33.04,0:52:34.99,EN,,0,0,0,,if some go down infinite deductive chain,
Dialogue: 0,0:52:35.02,0:52:38.25,EN,,0,0,0,,well, you just-- you know, memory is cheap and processors are cheap,
Dialogue: 0,0:52:38.28,0:52:40.49,EN,,0,0,0,,you just let them buzz for as for as long as you want.
Dialogue: 0,0:52:43.47,0:52:44.83,EN,,0,0,0,,There's a deeper problem, though,
Dialogue: 0,0:52:45.18,0:52:50.49,EN,,0,0,0,,in comparing this logic language to real logic.
Dialogue: 0,0:52:50.68,0:52:52.52,EN,,0,0,0,,The example I just showed you, it
Dialogue: 0,0:52:52.97,0:52:54.80,EN,,0,0,0,,went into an infinite loop maybe,
Dialogue: 0,0:52:55.37,0:52:56.99,EN,,0,0,0,,but at least it didn't give the wrong answer.
Dialogue: 0,0:52:58.37,0:53:03.64,EN,,0,0,0,,There's an actual deeper problem when we start comparing,
Dialogue: 0,0:53:03.68,0:53:05.24,EN,,0,0,0,,you know, seriously comparing
Dialogue: 0,0:53:05.71,0:53:08.46,EN,,0,0,0,,this logic language with real classical logic.
Dialogue: 0,0:53:09.49,0:53:12.43,EN,,0,0,0,,So let's sort of review real classical logic.
Dialogue: 0,0:53:13.71,0:53:21.04,EN,,0,0,0,,All humans are mortal.
Dialogue: 0,0:53:22.35,0:53:23.45,EN,,0,0,0,,That's pretty classical logic.
Dialogue: 0,0:53:24.39,0:53:28.67,EN,,0,0,0,,Then maybe we'll continue in the very best classical tradition.
Dialogue: 0,0:53:29.24,0:53:32.46,EN,,0,0,0,,We'll say all-- let's make it really classical.
Dialogue: 0,0:53:32.67,0:53:37.16,EN,,0,0,0,,All Greeks are human,
Dialogue: 0,0:53:40.49,0:53:46.06,EN,,0,0,0,,which has the syllogism that Socrates is a Greek.
Dialogue: 0,0:53:48.17,0:53:49.21,EN,,0,0,0,,And then what do you write here?
Dialogue: 0,0:53:49.21,0:53:51.89,EN,,0,0,0,,I think three dots, classical logic.
Dialogue: 0,0:53:51.89,0:53:54.33,EN,,0,0,0,,Therefore, then the syllogism,
Dialogue: 0,0:53:54.64,0:53:59.55,EN,,0,0,0,,Socrates is mortal.
Dialogue: 0,0:54:01.36,0:54:04.91,EN,,0,0,0,,So there's some real honest classical logic.
Dialogue: 0,0:54:05.88,0:54:11.05,EN,,0,0,0,,Let's compare that with our classical logic database.
Dialogue: 0,0:54:12.40,0:54:14.46,EN,,0,0,0,,So here's a classical logic database.
Dialogue: 0,0:54:16.27,0:54:17.48,EN,,0,0,0,,Socrates is a Greek.
Dialogue: 0,0:54:18.03,0:54:18.84,EN,,0,0,0,,Plato is a Greek.
Dialogue: 0,0:54:19.60,0:54:20.40,EN,,0,0,0,,Zeus is a Greek,
Dialogue: 0,0:54:20.84,0:54:21.98,EN,,0,0,0,,and Zeus is a god.
Dialogue: 0,0:54:24.12,0:54:29.96,EN,,0,0,0,,And all humans are mortal.
Dialogue: 0,0:54:30.54,0:54:32.12,EN,,0,0,0,,To show that something is mortal,
Dialogue: 0,0:54:32.16,0:54:33.60,EN,,0,0,0,,it's enough to show that it's human.
Dialogue: 0,0:54:34.65,0:54:35.90,EN,,0,0,0,,All humans are fallible.
Dialogue: 0,0:54:38.90,0:54:40.98,EN,,0,0,0,,And all Greeks are humans is not quite right.
Dialogue: 0,0:54:40.98,0:54:44.41,EN,,0,0,0,,This says that all Greeks who are not gods are human.
Dialogue: 0,0:54:45.71,0:54:47.04,EN,,0,0,0,,So to show something's human,
Dialogue: 0,0:54:47.07,0:54:48.89,EN,,0,0,0,,it's enough to show it's a Greek and not a god.
Dialogue: 0,0:54:49.32,0:54:52.88,EN,,0,0,0,,And the address of any Greek god is Mount Olympus.
Dialogue: 0,0:54:54.32,0:54:57.16,EN,,0,0,0,,So there's a little classical logic database.
Dialogue: 0,0:54:57.39,0:54:59.32,EN,,0,0,0,,And indeed, that would work fairly well.
Dialogue: 0,0:54:59.49,0:55:02.09,EN,,0,0,0,,If we type that in and say
Dialogue: 0,0:55:03.47,0:55:06.57,EN,,0,0,0,,is Socrates mortal or Socrates fallible or mortal?
Dialogue: 0,0:55:06.91,0:55:07.69,EN,,0,0,0,,It'll say yes.
Dialogue: 0,0:55:07.77,0:55:09.71,EN,,0,0,0,,Is Plato mortal and fallible.
Dialogue: 0,0:55:09.71,0:55:10.24,EN,,0,0,0,,It'll say yes.
Dialogue: 0,0:55:10.68,0:55:12.21,EN,,0,0,0,,If we say is Zeus mortal?
Dialogue: 0,0:55:12.21,0:55:13.23,EN,,0,0,0,,It won't find anything.
Dialogue: 0,0:55:14.90,0:55:15.96,EN,,0,0,0,,And it'll work perfectly well.
Dialogue: 0,0:55:16.54,0:55:20.12,EN,,0,0,0,,However, suppose we want to extend this.
Dialogue: 0,0:55:20.12,0:55:23.05,EN,,0,0,0,,Let's define what it means for someone to be a perfect being.
Dialogue: 0,0:55:23.82,0:55:27.21,EN,,0,0,0,,Let's say rule: a perfect being.
Dialogue: 0,0:55:34.05,0:55:35.48,EN,,0,0,0,,And I think this is right.
Dialogue: 0,0:55:35.48,0:55:38.14,EN,,0,0,0,,If you're up on your medieval scholastic philosophy,
Dialogue: 0,0:55:38.44,0:55:40.17,EN,,0,0,0,,I believe that perfect beings are ones
Dialogue: 0,0:55:40.68,0:55:42.65,EN,,0,0,0,,who were neither mortal nor fallible.
Dialogue: 0,0:55:44.10,0:55:56.84,EN,,0,0,0,,AND NOT mortal x, NOT fallible x.
Dialogue: 0,0:55:59.30,0:56:00.89,EN,,0,0,0,,So we'll define this system
Dialogue: 0,0:56:02.67,0:56:04.36,EN,,0,0,0,,to teach it what a perfect being is.
Dialogue: 0,0:56:05.79,0:56:07.69,EN,,0,0,0,,And now what we're going to do is
Dialogue: 0,0:56:08.06,0:56:10.17,EN,,0,0,0,,ask for the address of all the perfect beings.
Dialogue: 0,0:56:11.48,0:56:22.30,EN,,0,0,0,,AND the address of x is y and x is perfect.
Dialogue: 0,0:56:23.48,0:56:24.97,EN,,0,0,0,,And so what we're generating here is
Dialogue: 0,0:56:24.99,0:56:27.80,EN,,0,0,0,,the world's most exclusive mailing list.
Dialogue: 0,0:56:30.16,0:56:32.20,EN,,0,0,0,,For the address of all the perfect beings,
Dialogue: 0,0:56:32.24,0:56:33.47,EN,,0,0,0,,we might have typed this in.
Dialogue: 0,0:56:33.83,0:56:35.44,EN,,0,0,0,,Or we might type in this.
Dialogue: 0,0:56:36.24,0:56:50.57,EN,,0,0,0,,We'll say AND perfect of x and the address of x is y.
Dialogue: 0,0:56:52.06,0:56:54.96,EN,,0,0,0,,Well, suppose we type all that in and we try this query.
Dialogue: 0,0:56:55.19,0:56:56.76,EN,,0,0,0,,This query is going to give us an answer.
Dialogue: 0,0:56:57.65,0:57:00.00,EN,,0,0,0,,This query will say, yeah, Mount Olympus.
Dialogue: 0,0:57:04.23,0:57:06.57,EN,,0,0,0,,This query, in fact, is going to give us nothing.
Dialogue: 0,0:57:06.74,0:57:09.58,EN,,0,0,0,,It will say no addresses of perfect beings.
Dialogue: 0,0:57:11.64,0:57:12.51,EN,,0,0,0,,Now, why is that?
Dialogue: 0,0:57:12.51,0:57:13.44,EN,,0,0,0,,Why is there a difference?
Dialogue: 0,0:57:14.23,0:57:15.69,EN,,0,0,0,,This is not an infinite loop question.
Dialogue: 0,0:57:15.69,0:57:17.08,EN,,0,0,0,,This is a different answer question.
Dialogue: 0,0:57:19.48,0:57:20.09,EN,,0,0,0,,The reason is
Dialogue: 0,0:57:20.38,0:57:22.32,EN,,0,0,0,,that if you remember the implementation of NOT,
Dialogue: 0,0:57:23.50,0:57:24.84,EN,,0,0,0,,NOT acted as a filter.
Dialogue: 0,0:57:25.88,0:57:29.00,EN,,0,0,0,,NOT said I'm going to take some possible dictionaries,
Dialogue: 0,0:57:29.05,0:57:31.56,EN,,0,0,0,,some possible frames, some possible answers,
Dialogue: 0,0:57:31.79,0:57:33.16,EN,,0,0,0,,and filter out the ones
Dialogue: 0,0:57:33.29,0:57:34.94,EN,,0,0,0,,that happened to satisfy some condition,
Dialogue: 0,0:57:34.97,0:57:36.11,EN,,0,0,0,,and that's how I implement NOT.
Dialogue: 0,0:57:36.92,0:57:38.43,EN,,0,0,0,,If you think about what's going on here,
Dialogue: 0,0:57:40.11,0:57:42.65,EN,,0,0,0,,I'll build this query box where the address piece
Dialogue: 0,0:57:43.32,0:57:47.39,EN,,0,0,0,,the output of an address piece gets fed into a perfect piece.
Dialogue: 0,0:57:50.29,0:57:51.00,EN,,0,0,0,,What will happen is
Dialogue: 0,0:57:51.32,0:57:53.26,EN,,0,0,0,,the address piece will set up some things of
Dialogue: 0,0:57:53.32,0:57:54.83,EN,,0,0,0,,everyone whose address I know.
Dialogue: 0,0:57:55.29,0:57:57.64,EN,,0,0,0,,Those will get filtered by the NOTs inside perfect here.
Dialogue: 0,0:57:59.88,0:58:04.19,EN,,0,0,0,,So it will throw out the ones which happened to be either mortal or fallible.
Dialogue: 0,0:58:04.91,0:58:06.38,EN,,0,0,0,,In the other order what happens
Dialogue: 0,0:58:06.73,0:58:09.12,EN,,0,0,0,,is I set this up, started up with an empty frame.
Dialogue: 0,0:58:09.52,0:58:12.35,EN,,0,0,0,,The perfect in here doesn't find anything for the NOTs to filter,
Dialogue: 0,0:58:12.38,0:58:13.98,EN,,0,0,0,,so nothing comes out here at all.
Dialogue: 0,0:58:18.83,0:58:21.50,EN,,0,0,0,,And there's sort of nothing there that gets fed into the address thing.
Dialogue: 0,0:58:21.94,0:58:23.15,EN,,0,0,0,,So here, I don't get an answer.
Dialogue: 0,0:58:23.93,0:58:27.04,EN,,0,0,0,,And again, the reason for that is NOT isn't generating anything.
Dialogue: 0,0:58:27.44,0:58:28.80,EN,,0,0,0,,NOT's only throwing out things.
Dialogue: 0,0:58:29.08,0:58:30.51,EN,,0,0,0,,And if I never started up with anything,
Dialogue: 0,0:58:30.52,0:58:31.74,EN,,0,0,0,,there's nothing for it to throw out.
Dialogue: 0,0:58:32.02,0:58:33.77,EN,,0,0,0,,So out of this thing, I get the wrong answer.
Dialogue: 0,0:58:37.20,0:58:37.97,EN,,0,0,0,,How can you fix that?
Dialogue: 0,0:58:37.97,0:58:39.07,EN,,0,0,0,,Well, there are ways to fix that.
Dialogue: 0,0:58:39.36,0:58:40.91,EN,,0,0,0,,So you might say, well, that's sort of stupid.
Dialogue: 0,0:58:41.41,0:58:44.90,EN,,0,0,0,,Why are you just doing all your NOT stuff at the beginning?
Dialogue: 0,0:58:44.96,0:58:47.48,EN,,0,0,0,,The right way to implement NOT is to realize
Dialogue: 0,0:58:47.84,0:58:50.08,EN,,0,0,0,,that when you have conditions like NOT,
Dialogue: 0,0:58:50.33,0:58:52.09,EN,,0,0,0,,you should generate all your answers first,
Dialogue: 0,0:58:52.80,0:58:54.97,EN,,0,0,0,,and then with each of these dictionaries pass along
Dialogue: 0,0:58:55.52,0:58:57.85,EN,,0,0,0,,Gee, at the very end I'll do filtering.
Dialogue: 0,0:58:58.56,0:59:02.01,EN,,0,0,0,,And there are implementations of logic languages that work like that
Dialogue: 0,0:59:02.41,0:59:04.05,EN,,0,0,0,,that solve this particular problem.
Dialogue: 0,0:59:06.80,0:59:08.97,EN,,0,0,0,,However, there's a more profound problem,
Dialogue: 0,0:59:09.60,0:59:11.53,EN,,0,0,0,,which is which one of these is the right answer?
Dialogue: 0,0:59:12.53,0:59:14.24,EN,,0,0,0,,Is it Mount Olympus or is it nothing?
Dialogue: 0,0:59:15.37,0:59:18.73,EN,,0,0,0,,So you might say it's Mount Olympus,
Dialogue: 0,0:59:18.76,0:59:20.73,EN,,0,0,0,,because after all, Zeus is in that database,
Dialogue: 0,0:59:22.52,0:59:25.10,EN,,0,0,0,,and Zeus was neither mortal nor fallible.
Dialogue: 0,0:59:29.55,0:59:32.44,EN,,0,0,0,,So you might say Zeus wants to satisfy
Dialogue: 0,0:59:34.30,0:59:44.03,EN,,0,0,0,,NOT mortal Zeus or NOT fallible Zeus.
Dialogue: 0,0:59:44.12,0:59:45.85,EN,,0,0,0,,But let's actually look at that database.
Dialogue: 0,0:59:47.92,0:59:48.46,EN,,0,0,0,,Let's look at it.
Dialogue: 0,0:59:49.36,0:59:53.24,EN,,0,0,0,,There's no way-- how does it know that Zeus is not fallible?
Dialogue: 0,0:59:54.81,0:59:56.11,EN,,0,0,0,,There's nothing in there about that.
Dialogue: 0,0:59:57.93,0:59:59.66,EN,,0,0,0,,What's in there is that humans are fallible.
Dialogue: 0,1:00:02.16,1:00:04.12,EN,,0,0,0,,How does it know that Zeus is not mortal?
Dialogue: 0,1:00:04.48,1:00:05.93,EN,,0,0,0,,There's nothing in there about that.
Dialogue: 0,1:00:07.98,1:00:11.00,EN,,0,0,0,,It just said I don't have any rule, which--
Dialogue: 0,1:00:11.68,1:00:14.06,EN,,0,0,0,,see the only way I can deduce something's mortal is if it's human
Dialogue: 0,1:00:14.08,1:00:15.68,EN,,0,0,0,,and that's all it really knows about mortal.
Dialogue: 0,1:00:16.69,1:00:19.85,EN,,0,0,0,,And in fact, if you remember your classical mythology,
Dialogue: 0,1:00:19.87,1:00:23.48,EN,,0,0,0,,you know that the Greek gods were not mortal but fallible.
Dialogue: 0,1:00:25.05,1:00:28.65,EN,,0,0,0,,So the answer is not in the rules there.
Dialogue: 0,1:00:30.85,1:00:32.10,EN,,0,0,0,,See, why does it deduce that?
Dialogue: 0,1:00:34.49,1:00:38.32,EN,,0,0,0,,See, Socrates would certainly not have made this error of logic.
Dialogue: 0,1:00:40.08,1:00:42.67,EN,,0,0,0,,What NOT means in this language is not NOT.
Dialogue: 0,1:00:43.37,1:00:44.32,EN,,0,0,0,,It's not the NOT of logic.
Dialogue: 0,1:00:44.93,1:00:46.40,EN,,0,0,0,,What NOT needs in this language is
Dialogue: 0,1:00:47.16,1:00:49.96,EN,,0,0,0,,not deducible from things in the database
Dialogue: 0,1:00:50.75,1:00:53.34,EN,,0,0,0,,as opposed to not true.
Dialogue: 0,1:00:55.02,1:00:56.30,EN,,0,0,0,,That's a very big difference.
Dialogue: 0,1:00:57.30,1:00:58.64,EN,,0,0,0,,Subtle, but big.
Dialogue: 0,1:00:59.25,1:01:00.27,EN,,0,0,0,,So, in fact,
Dialogue: 0,1:01:00.76,1:01:03.92,EN,,0,0,0,,this is perfectly happy to say not anything that it doesn't know about.
Dialogue: 0,1:01:04.68,1:01:06.14,EN,,0,0,0,,So if you ask it is it not true
Dialogue: 0,1:01:06.16,1:01:07.83,EN,,0,0,0,,that Zeus likes chocolate ice cream?
Dialogue: 0,1:01:07.85,1:01:09.12,EN,,0,0,0,,It will say sure, it's not true.
Dialogue: 0,1:01:10.64,1:01:12.51,EN,,0,0,0,,Or anything else or anything it doesn't know about.
Dialogue: 0,1:01:12.59,1:01:17.34,EN,,0,0,0,,NOT means not deducible from the things you've told me.
Dialogue: 0,1:01:18.28,1:01:22.44,EN,,0,0,0,,In a world where you're identifying not deducible
Dialogue: 0,1:01:22.65,1:01:24.00,EN,,0,0,0,,with, in fact, not true,
Dialogue: 0,1:01:24.41,1:01:26.30,EN,,0,0,0,,this is called the closed world assumption.
Dialogue: 0,1:01:37.37,1:01:38.17,EN,,0,0,0,,closed world assumption.
Dialogue: 0,1:01:38.20,1:01:42.38,EN,,0,0,0,,Anything that I cannot deduce from what I know
Dialogue: 0,1:01:43.50,1:01:44.36,EN,,0,0,0,,is not true,
Dialogue: 0,1:01:46.24,1:01:48.01,EN,,0,0,0,,Right? If I don't know anything about x,
Dialogue: 0,1:01:48.22,1:01:49.21,EN,,0,0,0,,the x isn't true.
Dialogue: 0,1:01:49.29,1:01:50.33,EN,,0,0,0,,That's very dangerous.
Dialogue: 0,1:01:51.29,1:01:52.44,EN,,0,0,0,,From a logical point of view,
Dialogue: 0,1:01:52.46,1:01:53.76,EN,,0,0,0,,first of all, it doesn't really makes sense.
Dialogue: 0,1:01:54.48,1:01:56.33,EN,,0,0,0,,Because if I don't know anything about x,
Dialogue: 0,1:01:58.38,1:01:59.69,EN,,0,0,0,,I'm willing to say not x.
Dialogue: 0,1:02:00.24,1:02:03.32,EN,,0,0,0,,But am I willing to say not not x?
Dialogue: 0,1:02:03.85,1:02:05.66,EN,,0,0,0,,Well, sure, I don't know anything about that either maybe.
Dialogue: 0,1:02:06.47,1:02:08.65,EN,,0,0,0,,So not not x is not necessarily the same as x
Dialogue: 0,1:02:09.24,1:02:10.94,EN,,0,0,0,,and so on and so on and so on, so
Dialogue: 0,1:02:11.71,1:02:13.93,EN,,0,0,0,,there's some sort of funny bias in there.
Dialogue: 0,1:02:15.97,1:02:17.29,EN,,0,0,0,,So that's sort of funny.
Dialogue: 0,1:02:17.29,1:02:18.09,EN,,0,0,0,,The second thing,
Dialogue: 0,1:02:20.14,1:02:24.12,EN,,0,0,0,,if you start building up real reasoning programs based on this,
Dialogue: 0,1:02:24.70,1:02:26.11,EN,,0,0,0,,think how dangerous that is.
Dialogue: 0,1:02:27.07,1:02:32.00,EN,,0,0,0,,You're saying I know I'm in a position
Dialogue: 0,1:02:32.22,1:02:36.22,EN,,0,0,0,,to deduce everything true that's relevant to this problem.
Dialogue: 0,1:02:37.44,1:02:40.78,EN,,0,0,0,,I'm reasoning, and built into my reasoning mechanism
Dialogue: 0,1:02:41.23,1:02:44.20,EN,,0,0,0,,is the assumption that anything that I don't know
Dialogue: 0,1:02:44.24,1:02:46.27,EN,,0,0,0,,can't possibly be relevant to this problem.
Dialogue: 0,1:02:48.44,1:02:53.04,EN,,0,0,0,,Right? There are a lot of big organizations that work like that, right?
Dialogue: 0,1:02:53.16,1:02:56.83,EN,,0,0,0,,Most corporate marketing divisions work like that.
Dialogue: 0,1:02:56.83,1:02:59.12,EN,,0,0,0,,You know the consequences to that.
Dialogue: 0,1:03:00.33,1:03:03.45,EN,,0,0,0,,So it's very dangerous to start really
Dialogue: 0,1:03:03.84,1:03:06.25,EN,,0,0,0,,typing in these big logical implication systems
Dialogue: 0,1:03:07.05,1:03:09.00,EN,,0,0,0,,and going on what they say,
Dialogue: 0,1:03:09.02,1:03:11.28,EN,,0,0,0,,because they have this really limiting assumption built in.
Dialogue: 0,1:03:12.60,1:03:14.36,EN,,0,0,0,,So you have to be very, very careful about that.
Dialogue: 0,1:03:15.29,1:03:16.28,EN,,0,0,0,,And that's a deep problem.
Dialogue: 0,1:03:16.56,1:03:17.82,EN,,0,0,0,,That's not a problem about
Dialogue: 0,1:03:18.22,1:03:20.14,EN,,0,0,0,,we can make a little bit cleverer implementation
Dialogue: 0,1:03:20.16,1:03:21.85,EN,,0,0,0,,and do the filters and organize the
Dialogue: 0,1:03:22.16,1:03:23.84,EN,,0,0,0,,the infinite loops to make them go away.
Dialogue: 0,1:03:23.84,1:03:25.08,EN,,0,0,0,,It's a different kind of problem.
Dialogue: 0,1:03:25.92,1:03:26.89,EN,,0,0,0,,It's a different semantics.
Dialogue: 0,1:03:27.06,1:03:30.51,EN,,0,0,0,,So I think to wrap this up, it's fair to say
Dialogue: 0,1:03:31.34,1:03:34.43,EN,,0,0,0,,that logic programming I think is a terrifically exciting idea,
Dialogue: 0,1:03:34.60,1:03:37.00,EN,,0,0,0,,the idea that you can bridge this
Dialogue: 0,1:03:37.04,1:03:38.78,EN,,0,0,0,,gap from the imperative to the declarative,
Dialogue: 0,1:03:39.90,1:03:42.94,EN,,0,0,0,,that you can start talking about relations
Dialogue: 0,1:03:43.58,1:03:45.08,EN,,0,0,0,,and really get tremendous power
Dialogue: 0,1:03:46.09,1:03:49.48,EN,,0,0,0,,by going above the abstraction of what's my input and what's my output.
Dialogue: 0,1:03:50.56,1:03:51.53,EN,,0,0,0,,And linked to logic,
Dialogue: 0,1:03:52.46,1:03:56.46,EN,,0,0,0,,the problem is it's a goal that I think has yet to be realized.
Dialogue: 0,1:03:58.03,1:04:01.80,EN,,0,0,0,,And probably one of the very most interesting
Dialogue: 0,1:04:02.27,1:04:04.41,EN,,0,0,0,,research questions going on now in languages
Dialogue: 0,1:04:04.67,1:04:08.28,EN,,0,0,0,,is how do you somehow make a real logic language?
Dialogue: 0,1:04:09.46,1:04:11.05,EN,,0,0,0,,And secondly, how do you bridge the gap
Dialogue: 0,1:04:11.31,1:04:13.15,EN,,0,0,0,,this world of logic and relations
Dialogue: 0,1:04:13.52,1:04:16.43,EN,,0,0,0,,to the worlds of more traditional languages
Dialogue: 0,1:04:16.46,1:04:17.98,EN,,0,0,0,,and somehow combine the power of both.
Dialogue: 0,1:04:18.88,1:04:19.68,EN,,0,0,0,,OK, let's break.
Dialogue: 0,1:04:23.29,1:04:25.29,EN,,0,0,0,,AUDIENCE: Couldn't you solve that last problem
Dialogue: 0,1:04:25.29,1:04:27.74,EN,,0,0,0,,by having the extra rules that imply it?
Dialogue: 0,1:04:27.96,1:04:29.85,EN,,0,0,0,,The problem here is you have the definition of something,
Dialogue: 0,1:04:29.88,1:04:31.82,EN,,0,0,0,,but you don't have the definition of its opposite.
Dialogue: 0,1:04:32.08,1:04:33.92,EN,,0,0,0,,If you include in the database something that says
Dialogue: 0,1:04:34.14,1:04:36.89,EN,,0,0,0,,uh... something implies mortal x,
Dialogue: 0,1:04:36.99,1:04:38.70,EN,,0,0,0,,something else implies not mortal x,
Dialogue: 0,1:04:38.75,1:04:40.37,EN,,0,0,0,,haven't you basically solved the problem?
Dialogue: 0,1:04:43.37,1:04:44.14,EN,,0,0,0,,PROFESSOR: But the issue is
Dialogue: 0,1:04:44.75,1:04:46.38,EN,,0,0,0,,do you put a finite number of those in?
Dialogue: 0,1:04:48.65,1:04:53.13,EN,,0,0,0,,AUDIENCE: If things are specified always in pairs--
Dialogue: 0,1:04:53.61,1:04:57.07,EN,,0,0,0,,PROFESSOR: But the question is then what do you do about deduction?
Dialogue: 0,1:05:00.20,1:05:02.11,EN,,0,0,0,,See, you can't specify NOTs.
Dialogue: 0,1:05:03.40,1:05:04.76,EN,,0,0,0,,But the problem is, in a big system,
Dialogue: 0,1:05:04.78,1:05:07.96,EN,,0,0,0,,it turns out that might not be a finite number of things.
Dialogue: 0,1:05:12.82,1:05:15.29,EN,,0,0,0,,There are also sort of two issues.
Dialogue: 0,1:05:15.29,1:05:16.56,EN,,0,0,0,,Partly it might not be finite.
Dialogue: 0,1:05:16.69,1:05:19.39,EN,,0,0,0,,Partly it might be that's not what you want.
Dialogue: 0,1:05:21.51,1:05:24.52,EN,,0,0,0,,So a good example would be suppose I want to do connectivity.
Dialogue: 0,1:05:25.12,1:05:26.54,EN,,0,0,0,,I want a reason about connectivity.
Dialogue: 0,1:05:28.05,1:05:30.38,EN,,0,0,0,,And I'm going to tell you there's four things:
Dialogue: 0,1:05:30.40,1:05:33.74,EN,,0,0,0,,a and b and c and d.
Dialogue: 0,1:05:35.48,1:05:38.19,EN,,0,0,0,,And I'll tell you a is connected to b
Dialogue: 0,1:05:38.64,1:05:41.42,EN,,0,0,0,,and c's connected to d.
Dialogue: 0,1:05:43.20,1:05:44.80,EN,,0,0,0,,And now I'll tell you is a connected to d?
Dialogue: 0,1:05:45.05,1:05:46.03,EN,,0,0,0,,That's the question.
Dialogue: 0,1:05:46.78,1:05:48.52,EN,,0,0,0,,There's an example where I would like
Dialogue: 0,1:05:48.70,1:05:50.35,EN,,0,0,0,,something like the closed world assumption.
Dialogue: 0,1:05:54.43,1:05:55.66,EN,,0,0,0,,That's a tiny toy,
Dialogue: 0,1:05:56.24,1:05:58.30,EN,,0,0,0,,but a lot of times, I want to be able to say something like
Dialogue: 0,1:05:58.48,1:06:01.34,EN,,0,0,0,,anything that I haven't told you, assume is not true.
Dialogue: 0,1:06:04.26,1:06:06.27,EN,,0,0,0,,So it's not as simple as you only want to put in
Dialogue: 0,1:06:06.27,1:06:08.09,EN,,0,0,0,,explicit NOTs all over the place.
Dialogue: 0,1:06:09.47,1:06:12.70,EN,,0,0,0,,It's that sometimes it really isn't clear what you even want.
Dialogue: 0,1:06:14.15,1:06:17.92,EN,,0,0,0,,That having to specify both everything and not everything is too precise,
Dialogue: 0,1:06:17.93,1:06:20.00,EN,,0,0,0,,and then you get down into problems there.
Dialogue: 0,1:06:20.96,1:06:22.68,EN,,0,0,0,,But there are a lot of approaches that
Dialogue: 0,1:06:23.32,1:06:25.93,EN,,0,0,0,,you know, that explicitly put in NOTs and reason based on that.
Dialogue: 0,1:06:26.51,1:06:27.66,EN,,0,0,0,,So it's a very good idea.
Dialogue: 0,1:06:28.07,1:06:31.45,EN,,0,0,0,,It's just that then it starts becoming a little cumbersome
Dialogue: 0,1:06:31.48,1:06:33.49,EN,,0,0,0,,in the very large problems you'd like to use.
Dialogue: 0,1:06:43.46,1:06:45.96,EN,,0,0,0,,AUDIENCE: I'm not sure how directly related to the argument this is,
Dialogue: 0,1:06:46.00,1:06:47.98,EN,,0,0,0,,but one of your points was that
Dialogue: 0,1:06:48.49,1:06:50.16,EN,,0,0,0,,one of the dangers of the closed world rule is
Dialogue: 0,1:06:50.19,1:06:52.06,EN,,0,0,0,,you never really know all the things that are there.
Dialogue: 0,1:06:53.44,1:06:55.32,EN,,0,0,0,,You never really know all the parts to it.
Dialogue: 0,1:06:55.87,1:06:58.16,EN,,0,0,0,,Isn't that a major problem with any programming?
Dialogue: 0,1:06:58.16,1:06:59.64,EN,,0,0,0,,I always write programs where I
Dialogue: 0,1:06:59.90,1:07:01.56,EN,,0,0,0,,I assume that I've got all the cases,
Dialogue: 0,1:07:01.58,1:07:03.40,EN,,0,0,0,,and so I check for them all or whatever, and i
Dialogue: 0,1:07:04.06,1:07:04.99,EN,,0,0,0,,and somewhere down the road, I
Dialogue: 0,1:07:05.02,1:07:06.52,EN,,0,0,0,,I find out that I didn't check for one of them.
Dialogue: 0,1:07:07.39,1:07:08.54,EN,,0,0,0,,PROFESSOR: Well, sure, it's true.
Dialogue: 0,1:07:08.54,1:07:09.76,EN,,0,0,0,,But the problem here is
Dialogue: 0,1:07:11.96,1:07:15.47,EN,,0,0,0,,it's that assumption which is the thing that you're making
Dialogue: 0,1:07:15.48,1:07:17.34,EN,,0,0,0,,if you believe you're identifying this with logic.
Dialogue: 0,1:07:19.60,1:07:20.51,EN,,0,0,0,,So you're quite right.
Dialogue: 0,1:07:20.51,1:07:22.22,EN,,0,0,0,,It's a situation you're never in.
Dialogue: 0,1:07:22.22,1:07:24.14,EN,,0,0,0,,The problem is if you're starting to believe that
Dialogue: 0,1:07:24.17,1:07:25.44,EN,,0,0,0,,what this is doing is logic
Dialogue: 0,1:07:26.17,1:07:27.32,EN,,0,0,0,,and you look at the rules you write down
Dialogue: 0,1:07:27.34,1:07:28.89,EN,,0,0,0,,and say what can I deduce from them,
Dialogue: 0,1:07:29.53,1:07:32.80,EN,,0,0,0,,you have to be very careful to remember that NOT means something else.
Dialogue: 0,1:07:33.47,1:07:35.21,EN,,0,0,0,,And it means something else based on an assumption
Dialogue: 0,1:07:35.24,1:07:36.70,EN,,0,0,0,,which is probably not true.
Dialogue: 0,1:07:39.03,1:07:40.19,EN,,0,0,0,,AUDIENCE: Do I understand you correctly that
Dialogue: 0,1:07:40.25,1:07:41.84,EN,,0,0,0,,you cannot fix this problem
Dialogue: 0,1:07:42.25,1:07:46.08,EN,,0,0,0,,without killing off all possibilities of inference through altering NOT?
Dialogue: 0,1:07:46.54,1:07:49.80,EN,,0,0,0,,PROFESSOR: No, that's not quite right.
Dialogue: 0,1:07:52.96,1:07:55.08,EN,,0,0,0,,There are ways to do logic with real NOTs.
Dialogue: 0,1:07:56.34,1:07:58.03,EN,,0,0,0,,There are actually ways to do that.
Dialogue: 0,1:07:58.54,1:08:00.84,EN,,0,0,0,,But they're very inefficient as far as anybody knows.
Dialogue: 0,1:08:01.61,1:08:02.56,EN,,0,0,0,,And they're much more--
Dialogue: 0,1:08:04.09,1:08:06.89,EN,,0,0,0,,they don't--  the, quote, inference in here
Dialogue: 0,1:08:07.39,1:08:08.83,EN,,0,0,0,,is built into this unifier
Dialogue: 0,1:08:08.91,1:08:11.29,EN,,0,0,0,,and this pattern matching unification algorithm.
Dialogue: 0,1:08:11.98,1:08:16.19,EN,,0,0,0,,There are ways to automate real logical reasoning.
Dialogue: 0,1:08:16.59,1:08:18.19,EN,,0,0,0,,But it's not based on that,
Dialogue: 0,1:08:18.51,1:08:20.73,EN,,0,0,0,,and logic programming languages don't tend to do that
Dialogue: 0,1:08:20.75,1:08:23.85,EN,,0,0,0,,because it's very inefficient as far as anybody knows.
Dialogue: 0,1:08:29.39,1:08:30.03,EN,,0,0,0,,All right, thank you.
Dialogue: 0,0:00:00.00,0:00:02.14,Declare,,0,0,0,,{\an2\fad(500,500)}Learning-SICP 学习小组\N倾情制作
Dialogue: 0,0:00:02.40,0:00:09.84,title,,0,0,0,,{\fad(600,800)\pos(324,32)}《计算机程序的构造和解释》
Dialogue: 0,0:00:02.40,0:00:09.84,staff,,0,0,0,,{\fad(600,800)\pos(110.666,403.334)}翻译&&时间轴\N邓雄飞\N（Dysprosium）
Dialogue: 0,0:00:02.40,0:00:09.84,staff,,0,0,0,,{\fad(600,800)\pos(534.666,404)}压制&&特效\N邓雄飞\N（Dysprosium）
Dialogue: 0,0:00:02.40,0:00:09.84,staff,,0,0,0,,{\fad(600,800)\pos(574.667,277.333)}校对\N邓雄飞
Dialogue: 0,0:00:02.40,0:00:09.84,staff,,0,0,0,,{\fad(600,800)\pos(89.334,273.333)}特别感谢\N裘宗燕教授
Dialogue: 0,0:00:09.90,0:00:16.04,Declare,,0,0,0,,{\an2\fad(500,500)}逻辑式程序设计 II
Dialogue: 0,0:00:18.91,0:00:21.79,Default,,0,0,0,,我们已经了解了查询语言的使用方式
Dialogue: 0,0:00:22.64,0:00:25.07,Default,,0,0,0,,现在该来讨论如何实现了
Dialogue: 0,0:00:26.28,0:00:27.98,Default,,0,0,0,,你们也应该能够猜到
Dialogue: 0,0:00:28.59,0:00:29.47,Default,,0,0,0,,它其中的原理了
Dialogue: 0,0:00:29.47,0:00:31.64,Default,,0,0,0,,它的最底层是一个模式匹配器
Dialogue: 0,0:00:32.81,0:00:34.25,Default,,0,0,0,,我们在《基于规则的控制语言》一课中
Dialogue: 0,0:00:34.67,0:00:36.94,Default,,0,0,0,,已经介绍过模式匹配器了
Dialogue: 0,0:00:38.11,0:00:40.59,Default,,0,0,0,,我举个例子来让你们温习一下
Dialogue: 0,0:00:41.52,0:00:43.68,Default,,0,0,0,,这个模式会匹配
Dialogue: 0,0:00:43.80,0:00:44.92,Default,,0,0,0,,一个含有三个元素的表
Dialogue: 0,0:00:44.96,0:00:47.10,Default,,0,0,0,,其中 首元素为A
Dialogue: 0,0:00:47.16,0:00:48.33,Default,,0,0,0,,其次是C
Dialogue: 0,0:00:48.48,0:00:50.19,Default,,0,0,0,,而中间可以为任意元素
Dialogue: 0,0:00:50.65,0:00:52.27,Default,,0,0,0,,所以在这个小型的模式匹配语言中
Dialogue: 0,0:00:52.30,0:00:54.05,Default,,0,0,0,,你只能区分一种类型
Dialogue: 0,0:00:54.05,0:00:57.20,Default,,0,0,0,,也就是区分字面量或者变量
Dialogue: 0,0:00:57.23,0:00:58.86,Default,,0,0,0,,以问号开头的就是变量
Dialogue: 0,0:01:01.37,0:01:03.64,Default,,0,0,0,,因此这个模式会匹配任意的三元表
Dialogue: 0,0:01:04.44,0:01:06.50,Default,,0,0,0,,只要它的首元素为A 而第三个元素为C
Dialogue: 0,0:01:06.50,0:01:09.00,Default,,0,0,0,,而这个模式匹配的三元表
Dialogue: 0,0:01:10.43,0:01:12.53,Default,,0,0,0,,它的首元素必须是符号'JOB
Dialogue: 0,0:01:12.53,0:01:13.90,Default,,0,0,0,,第二个元素为任意值
Dialogue: 0,0:01:14.21,0:01:15.90,Default,,0,0,0,,第三个元素必须是一个二元表
Dialogue: 0,0:01:15.95,0:01:17.72,Default,,0,0,0,,二元表的首元素为符号'COMPUTER
Dialogue: 0,0:01:17.88,0:01:19.42,Default,,0,0,0,,第二个元素可以为任意值
Dialogue: 0,0:01:20.48,0:01:25.55,Default,,0,0,0,,而下一条模式所匹配的三元表
Dialogue: 0,0:01:25.87,0:01:26.99,Default,,0,0,0,,区别就在于
Dialogue: 0,0:01:28.40,0:01:31.32,Default,,0,0,0,,在于第三个元素的首元素必须为符号'COMPUTER
Dialogue: 0,0:01:31.76,0:01:33.29,Default,,0,0,0,,表剩余部分可以是任意值
Dialogue: 0,0:01:35.04,0:01:37.53,Default,,0,0,0,,也就是说 上面是二元表 而下面没有限定数目
Dialogue: 0,0:01:37.86,0:01:39.74,Default,,0,0,0,,然而我们的语言实现
Dialogue: 0,0:01:39.85,0:01:42.06,Default,,0,0,0,,根本不用操心如何去实现这个点号
Dialogue: 0,0:01:42.11,0:01:44.17,Default,,0,0,0,,因为这个由Lisp读取器自动地完成
Dialogue: 0,0:01:48.34,0:01:50.31,Default,,0,0,0,,要注意 匹配器还要保持一致性
Dialogue: 0,0:01:50.31,0:01:52.32,Default,,0,0,0,,这个模式匹配一个三元表
Dialogue: 0,0:01:52.59,0:01:53.98,Default,,0,0,0,,表的首元素是A
Dialogue: 0,0:01:54.43,0:01:55.79,Default,,0,0,0,,而第二个元素和第三个元素可以是任意值
Dialogue: 0,0:01:55.80,0:01:57.08,Default,,0,0,0,,但它们必须是相同的
Dialogue: 0,0:01:57.94,0:01:58.84,Default,,0,0,0,,它们都是?X
Dialogue: 0,0:01:59.60,0:02:01.55,Default,,0,0,0,,而这个模式匹配一个四元表
Dialogue: 0,0:02:01.96,0:02:03.26,Default,,0,0,0,,其中第一个元素与第四个元素相同
Dialogue: 0,0:02:03.66,0:02:05.15,Default,,0,0,0,,而第二个元素与第三个元素相同
Dialogue: 0,0:02:05.59,0:02:08.60,Default,,0,0,0,,最后一个模式匹配以A开头的任意表
Dialogue: 0,0:02:09.68,0:02:11.05,Default,,0,0,0,,以A开头
Dialogue: 0,0:02:11.23,0:02:12.56,Default,,0,0,0,,余下的可以是任意值
Dialogue: 0,0:02:14.04,0:02:16.60,Default,,0,0,0,,这是对我们已经学习过的模式匹配语言
Dialogue: 0,0:02:16.62,0:02:17.87,Default,,0,0,0,,的一个回顾
Dialogue: 0,0:02:18.78,0:02:19.64,Default,,0,0,0,,还记得吗
Dialogue: 0,0:02:19.79,0:02:22.28,Default,,0,0,0,,这是由一个叫做MATCH的过程实现的
Dialogue: 0,0:02:24.87,0:02:36.06,Default,,0,0,0,,MATCH有三个参数：PAT、DATA以及DICTIONARY
Dialogue: 0,0:02:43.20,0:02:47.12,Default,,0,0,0,,MATCH考虑的是
Dialogue: 0,0:02:47.79,0:02:52.64,Default,,0,0,0,,利用给定DICTIONAY中的绑定
Dialogue: 0,0:02:53.55,0:02:56.73,Default,,0,0,0,,能够找到一种方法把模式与数据对象匹配起来吗？
Dialogue: 0,0:02:58.16,0:02:59.21,Default,,0,0,0,,比如说
Dialogue: 0,0:02:59.56,0:03:06.43,Default,,0,0,0,,如果我们想要把模式(?X ?Y ?Y ?X)
Dialogue: 0,0:03:07.71,0:03:13.84,Default,,0,0,0,,与数据对象(A B B A)相匹配
Dialogue: 0,0:03:15.12,0:03:20.52,Default,,0,0,0,,又给定了一个字典 X=A
Dialogue: 0,0:03:22.01,0:03:25.23,Default,,0,0,0,,MATCH就会说：“它们是一致的”
Dialogue: 0,0:03:25.26,0:03:27.16,Default,,0,0,0,,再给定的字典说 X=A 的情况下
Dialogue: 0,0:03:27.80,0:03:30.20,Default,,0,0,0,,模式与数据相匹配
Dialogue: 0,0:03:30.32,0:03:31.60,Default,,0,0,0,,而匹配的结果则是
Dialogue: 0,0:03:32.25,0:03:34.30,Default,,0,0,0,,一个扩展了的词典
Dialogue: 0,0:03:34.46,0:03:37.60,Default,,0,0,0,,其中包含 X=A Y=B
Dialogue: 0,0:03:39.49,0:03:42.24,Default,,0,0,0,,MATCH接收模式、数据以及字典
Dialogue: 0,0:03:42.38,0:03:44.54,Default,,0,0,0,,如果成功匹配就输出一个扩展后的词典
Dialogue: 0,0:03:44.97,0:03:46.84,Default,,0,0,0,,否则就报错
Dialogue: 0,0:03:46.84,0:03:47.71,Default,,0,0,0,,因此 比如说
Dialogue: 0,0:03:47.88,0:03:50.38,Default,,0,0,0,,如果我在这里使用同样的模式
Dialogue: 0,0:03:50.97,0:03:55.12,Default,,0,0,0,,如果我用模式(?X ?Y ?Y ?X)
Dialogue: 0,0:03:55.66,0:03:58.49,Default,,0,0,0,,去匹配(A B B A)
Dialogue: 0,0:03:59.47,0:04:02.84,Default,,0,0,0,,并给定词典 Y=A
Dialogue: 0,0:04:05.15,0:04:06.81,Default,,0,0,0,,那么MATCH就会输出FAIL
Dialogue: 0,0:04:12.52,0:04:14.65,Default,,0,0,0,,你们已经见过模式匹配器的代码了
Dialogue: 0,0:04:15.00,0:04:16.17,Default,,0,0,0,,我就不会再去细讲
Dialogue: 0,0:04:16.64,0:04:19.77,Default,,0,0,0,,这跟我们以前做的类似
Dialogue: 0,0:04:21.19,0:04:23.22,Default,,0,0,0,,我们在《基于规则的系统》中已经见过了
Dialogue: 0,0:04:23.22,0:04:24.56,Default,,0,0,0,,基本上是同样的匹配器
Dialogue: 0,0:04:24.95,0:04:27.66,Default,,0,0,0,,实际上 我认为这里的语法还更简单一点
Dialogue: 0,0:04:28.16,0:04:29.31,Default,,0,0,0,,因为我们不用去关心
Dialogue: 0,0:04:29.40,0:04:31.40,Default,,0,0,0,,任意变量、任意表达式之类的东西
Dialogue: 0,0:04:31.40,0:04:32.88,Default,,0,0,0,,这里面只区分变量和常量
Dialogue: 0,0:04:35.79,0:04:37.32,Default,,0,0,0,,那么 有了模式匹配器以后
Dialogue: 0,0:04:38.46,0:04:39.61,Default,,0,0,0,,基本查询又是怎么样的呢？
Dialogue: 0,0:04:42.97,0:04:45.34,Default,,0,0,0,,基本查询将会是一个相当复杂的东西
Dialogue: 0,0:04:46.67,0:05:03.58,Default,,0,0,0,,就拿查询(JOB ?X (?D . ?Y))来说
Dialogue: 0,0:05:07.04,0:05:08.73,Default,,0,0,0,,我们可能会输入这样的查询
Dialogue: 0,0:05:09.40,0:05:11.39,Default,,0,0,0,,这又将如何在系统内实现呢？
Dialogue: 0,0:05:14.14,0:05:15.66,Default,,0,0,0,,我们可以把它想做这个小盒子
Dialogue: 0,0:05:15.70,0:05:16.80,Default,,0,0,0,,这是一条基本查询
Dialogue: 0,0:05:18.88,0:05:20.30,Default,,0,0,0,,这个小盒子将会
Dialogue: 0,0:05:22.24,0:05:27.28,Default,,0,0,0,,以两条流作为输入
Dialogue: 0,0:05:31.96,0:05:33.20,Default,,0,0,0,,并输出一条流
Dialogue: 0,0:05:34.03,0:05:36.19,Default,,0,0,0,,因此一条基本查询的形状
Dialogue: 0,0:05:36.51,0:05:38.46,Default,,0,0,0,,就将是有两条输入流
Dialogue: 0,0:05:38.67,0:05:39.96,Default,,0,0,0,,和一条输出流
Dialogue: 0,0:05:41.12,0:05:46.20,Default,,0,0,0,,而这些流 来自于这里的数据库
Dialogue: 0,0:05:51.95,0:05:53.93,Default,,0,0,0,,因此我们把数据库中的所有数据
Dialogue: 0,0:05:55.93,0:05:57.20,Default,,0,0,0,,想象成一条流
Dialogue: 0,0:05:57.31,0:05:58.40,Default,,0,0,0,,而这个盒子不断地吸取
Dialogue: 0,0:06:00.36,0:06:02.43,Default,,0,0,0,,那么 数据库中有什么呢？
Dialogue: 0,0:06:08.43,0:06:20.32,Default,,0,0,0,,首先是(JOB (ALYSSA ...))
Dialogue: 0,0:06:21.96,0:06:23.71,Default,,0,0,0,,以及还有其它的JOB数据
Dialogue: 0,0:06:25.77,0:06:30.41,Default,,0,0,0,,想象一下 数据库中的所有事实都在这条流中
Dialogue: 0,0:06:32.04,0:06:33.10,Default,,0,0,0,,都到了这里
Dialogue: 0,0:06:33.36,0:06:34.52,Default,,0,0,0,,而这条流送来的
Dialogue: 0,0:06:34.89,0:06:36.52,Default,,0,0,0,,是一些字典
Dialogue: 0,0:06:38.51,0:06:41.40,Default,,0,0,0,,其中一个就可能是
Dialogue: 0,0:06:46.70,0:06:49.31,Default,,0,0,0,,Y=PROG
Dialogue: 0,0:06:55.47,0:06:56.64,Default,,0,0,0,,现在 查询工作就是要
Dialogue: 0,0:06:57.07,0:06:59.80,Default,,0,0,0,,当它从这条流中取得一个字典后
Dialogue: 0,0:07:02.01,0:07:06.67,Default,,0,0,0,,它会搜寻数据库中的东西
Dialogue: 0,0:07:07.45,0:07:10.24,Default,,0,0,0,,来尽可能产生所有匹配结果
Dialogue: 0,0:07:11.39,0:07:12.89,Default,,0,0,0,,它把查询视作一种模式
Dialogue: 0,0:07:13.15,0:07:16.72,Default,,0,0,0,,并将它们与数据库中的事实匹配起来
Dialogue: 0,0:07:16.96,0:07:21.98,Default,,0,0,0,,结合着相应的字典中的数据
Dialogue: 0,0:07:22.94,0:07:25.68,Default,,0,0,0,,找到数据库中所有匹配的结果
Dialogue: 0,0:07:27.55,0:07:29.69,Default,,0,0,0,,所以针对数据库中的每条事实
Dialogue: 0,0:07:29.72,0:07:34.35,Default,,0,0,0,,它都会调用(MATCH PAT FACT DICTIONAY)来检查
Dialogue: 0,0:07:35.11,0:07:37.68,Default,,0,0,0,,如果成功匹配
Dialogue: 0,0:07:38.19,0:07:39.93,Default,,0,0,0,,它就输出一个扩展了的字典
Dialogue: 0,0:07:40.67,0:07:42.32,Default,,0,0,0,,比如说 这里进来了一本字典
Dialogue: 0,0:07:43.00,0:07:44.09,Default,,0,0,0,,并且成功匹配
Dialogue: 0,0:07:44.51,0:07:45.87,Default,,0,0,0,,那么就会输出一本字典
Dialogue: 0,0:07:46.81,0:07:49.79,Default,,0,0,0,,本例中就是Y=PROG
Dialogue: 0,0:07:51.52,0:07:52.97,Default,,0,0,0,,X=...
Dialogue: 0,0:07:56.54,0:07:58.75,Default,,0,0,0,,Y=PROG X=...
Dialogue: 0,0:07:58.96,0:08:00.54,Default,,0,0,0,,D又是一个新的项
Dialogue: 0,0:08:01.72,0:08:02.27,Default,,0,0,0,,像这样扩展
Dialogue: 0,0:08:03.52,0:08:07.82,Default,,0,0,0,,当然 它会针对数据库中的所有事实做同样的尝试
Dialogue: 0,0:08:07.98,0:08:09.25,Default,,0,0,0,,所以就可能有很多的结果
Dialogue: 0,0:08:09.56,0:08:10.59,Default,,0,0,0,,可能会产生另一本字典
Dialogue: 0,0:08:11.28,0:08:17.12,Default,,0,0,0,,其中 Y=PROG X=... D=...
Dialogue: 0,0:08:19.18,0:08:21.55,Default,,0,0,0,,因此 对于每个输入的框架
Dialogue: 0,0:08:21.76,0:08:23.69,Default,,0,0,0,,对于每输入一本字典
Dialogue: 0,0:08:23.72,0:08:25.24,Default,,0,0,0,,它可能输出很多本字典
Dialogue: 0,0:08:26.54,0:08:28.67,Default,,0,0,0,,或者什么也不输出
Dialogue: 0,0:08:30.47,0:08:38.48,Default,,0,0,0,,可能会有一些不匹配的情况 比如X=FOO
Dialogue: 0,0:08:39.02,0:08:40.89,Default,,0,0,0,,这个条目不会匹配任何东西
Dialogue: 0,0:08:41.52,0:08:45.12,Default,,0,0,0,,就这个框架来说 不会向输出流中输出东西
Dialogue: 0,0:08:47.51,0:08:51.28,Default,,0,0,0,,或者你也可以输入一个空框架
Dialogue: 0,0:08:52.91,0:08:56.24,Default,,0,0,0,,空框架是用来
Dialogue: 0,0:08:59.87,0:09:02.33,Default,,0,0,0,,在没有任何约束的情况下
Dialogue: 0,0:09:02.57,0:09:06.14,Default,,0,0,0,,匹配数据库中所有可能的结果
Dialogue: 0,0:09:07.57,0:09:09.16,Default,,0,0,0,,这仅仅代表着
Dialogue: 0,0:09:10.32,0:09:13.87,Default,,0,0,0,,处理你输入的查询 最初所进行的计算
Dialogue: 0,0:09:14.20,0:09:15.56,Default,,0,0,0,,它试图找出所有的匹配
Dialogue: 0,0:09:16.65,0:09:18.83,Default,,0,0,0,,基本查询建立了这种机制
Dialogue: 0,0:09:19.37,0:09:20.57,Default,,0,0,0,,而语言要做的是
Dialogue: 0,0:09:22.75,0:09:24.67,Default,,0,0,0,,当你在顶层输入这条查询时
Dialogue: 0,0:09:24.84,0:09:26.14,Default,,0,0,0,,它基于这种机制
Dialogue: 0,0:09:26.16,0:09:28.35,Default,,0,0,0,,它会输入一本空的字典
Dialogue: 0,0:09:30.86,0:09:32.56,Default,,0,0,0,,而对于输出的每个东西
Dialogue: 0,0:09:33.08,0:09:35.88,Default,,0,0,0,,然后把最初的查询
Dialogue: 0,0:09:36.56,0:09:40.44,Default,,0,0,0,,用不同的字典来实例化
Dialogue: 0,0:09:40.81,0:09:44.36,Default,,0,0,0,,于是实例化后的模式就形成了一条新的流
Dialogue: 0,0:09:44.99,0:09:46.51,Default,,0,0,0,,这就是在终端上打印出来的内容
Dialogue: 0,0:09:48.17,0:09:51.24,Default,,0,0,0,,这也就是其中的基本原理
Dialogue: 0,0:09:53.51,0:09:55.48,Default,,0,0,0,,那么 这又为什么复杂呢？
Dialogue: 0,0:09:57.71,0:10:01.00,Default,,0,0,0,,除了使用这种基于流的方法
Dialogue: 0,0:10:01.37,0:10:04.25,Default,,0,0,0,,你们可以想出很多更简单的方法来组织基本查询
Dialogue: 0,0:10:05.18,0:10:06.09,Default,,0,0,0,,而答案就在于
Dialogue: 0,0:10:07.15,0:10:08.51,Default,,0,0,0,,你们可能已经在想了
Dialogue: 0,0:10:10.86,0:10:14.09,Default,,0,0,0,,答案就是 这种方法能够优雅地
Dialogue: 0,0:10:14.56,0:10:16.76,Default,,0,0,0,,实现组合手段
Dialogue: 0,0:10:17.79,0:10:18.80,Default,,0,0,0,,比如说
Dialogue: 0,0:10:20.65,0:10:22.47,Default,,0,0,0,,假设我还想实现其它的效果
Dialogue: 0,0:10:22.47,0:10:26.96,Default,,0,0,0,,我不只是想查询所有人的工作信息
Dialogue: 0,0:10:27.23,0:10:28.35,Default,,0,0,0,,假设我还想查询
Dialogue: 0,0:10:29.47,0:10:35.92,Default,,0,0,0,,(AND (JOB ?X (?D . ?Y))
Dialogue: 0,0:10:36.80,0:10:47.04,Default,,0,0,0,,(SUPERVIOSR ?X ?Z))
Dialogue: 0,0:10:48.80,0:10:50.67,Default,,0,0,0,,(SUPERVISOR ?X ?Z)这条查询
Dialogue: 0,0:10:51.39,0:10:52.96,Default,,0,0,0,,是另外的一条基本查询
Dialogue: 0,0:10:53.71,0:10:58.43,Default,,0,0,0,,它也有类似的形状——接收一条数据对象流
Dialogue: 0,0:10:59.18,0:11:01.64,Default,,0,0,0,,一条初始字典流
Dialogue: 0,0:11:01.68,0:11:05.52,Default,,0,0,0,,字典是你在进行匹配时 需要遵循的约束
Dialogue: 0,0:11:05.53,0:11:07.44,Default,,0,0,0,,然后它会输出一条字典流
Dialogue: 0,0:11:08.70,0:11:10.80,Default,,0,0,0,,这就是这条基本查询的形状
Dialogue: 0,0:11:11.50,0:11:12.91,Default,,0,0,0,,我又该如何实现AND呢？
Dialogue: 0,0:11:12.91,0:11:13.45,Default,,0,0,0,,其实很简单
Dialogue: 0,0:11:13.45,0:11:14.44,Default,,0,0,0,,把它们连接起来就好了
Dialogue: 0,0:11:14.88,0:11:16.28,Default,,0,0,0,,我把这条查询的输出
Dialogue: 0,0:11:16.96,0:11:18.81,Default,,0,0,0,,连接在这条查询的输入上
Dialogue: 0,0:11:19.83,0:11:21.84,Default,,0,0,0,,然后把这里的字典扇出开来
Dialogue: 0,0:11:26.57,0:11:27.96,Default,,0,0,0,,你们就能发现它是如何工作的了
Dialogue: 0,0:11:29.05,0:11:32.44,Default,,0,0,0,,这里会输出一个框架
Dialogue: 0,0:11:32.51,0:11:36.84,Default,,0,0,0,,其中有X、Y和D的绑定
Dialogue: 0,0:11:37.92,0:11:39.28,Default,,0,0,0,,当后面的查询接收到结果后
Dialogue: 0,0:11:39.29,0:11:41.60,Default,,0,0,0,,当它了解了这些约束后
Dialogue: 0,0:11:42.17,0:11:49.24,Default,,0,0,0,,字典中的是Y、X和D的值
Dialogue: 0,0:11:51.80,0:11:53.08,Default,,0,0,0,,它会搜寻数据库
Dialogue: 0,0:11:53.12,0:11:54.92,Default,,0,0,0,,试图找到有关SUPERVISOR关系的事实
Dialogue: 0,0:11:56.04,0:11:58.51,Default,,0,0,0,,如果找到了的话 它就会输出一些词典
Dialogue: 0,0:11:59.58,0:12:09.34,Default,,0,0,0,,其中有Y、X、D以及Z的绑定
Dialogue: 0,0:12:12.07,0:12:14.09,Default,,0,0,0,,不过要注意
Dialogue: 0,0:12:14.19,0:12:17.24,Default,,0,0,0,,因为这里输入的框架建立了约束
Dialogue: 0,0:12:17.61,0:12:20.28,Default,,0,0,0,,它保证了当你执行AND运算时
Dialogue: 0,0:12:20.49,0:12:24.62,Default,,0,0,0,,这两个X是相同的
Dialogue: 0,0:12:26.47,0:12:28.96,Default,,0,0,0,,这是因为通过这条流输出时
Dialogue: 0,0:12:29.96,0:12:32.65,Default,,0,0,0,,X已经有值了 你要确保匹配的一致性
Dialogue: 0,0:12:34.46,0:12:36.17,Default,,0,0,0,,然后我们想起在MATCH的代码中
Dialogue: 0,0:12:36.19,0:12:38.17,Default,,0,0,0,,有一种操作字典的特殊组织方法
Dialogue: 0,0:12:38.20,0:12:39.82,Default,,0,0,0,,确保了匹配的一致性
Dialogue: 0,0:12:40.92,0:12:41.77,Default,,0,0,0,,这就是AND的实现
Dialogue: 0,0:12:44.08,0:12:46.94,Default,,0,0,0,,关键是要注意它的一般性形状
Dialogue: 0,0:12:48.49,0:12:51.55,Default,,0,0,0,,我们来看看(AND P Q)
Dialogue: 0,0:12:52.88,0:12:55.61,Default,,0,0,0,,这里是P和Q
Dialogue: 0,0:12:57.29,0:12:58.60,Default,,0,0,0,,两条查询的AND
Dialogue: 0,0:13:00.27,0:13:01.19,Default,,0,0,0,,看起来像是这样
Dialogue: 0,0:13:01.19,0:13:04.44,Default,,0,0,0,,每一条查询都通过一条流连接数据库
Dialogue: 0,0:13:04.54,0:13:05.71,Default,,0,0,0,,一条输入流
Dialogue: 0,0:13:06.33,0:13:08.17,Default,,0,0,0,,并输出一条输出流
Dialogue: 0,0:13:10.23,0:13:11.72,Default,,0,0,0,,关键是要注意
Dialogue: 0,0:13:12.20,0:13:15.02,Default,,0,0,0,,如果我在它们周围画一个盒子
Dialogue: 0,0:13:19.26,0:13:23.64,Default,,0,0,0,,这就是(AND P Q)
Dialogue: 0,0:13:25.66,0:13:30.38,Default,,0,0,0,,那么这个盒子也有同样的形状
Dialogue: 0,0:13:32.04,0:13:34.20,Default,,0,0,0,,它也有一条连接数据库的流
Dialogue: 0,0:13:34.20,0:13:35.74,Default,,0,0,0,,但是在内部会扇出开来
Dialogue: 0,0:13:36.60,0:13:37.93,Default,,0,0,0,,但是在外部你看不到
Dialogue: 0,0:13:38.16,0:13:40.64,Default,,0,0,0,,它接收一个流 并输出一个流
Dialogue: 0,0:13:42.06,0:13:43.16,Default,,0,0,0,,这就是AND
Dialogue: 0,0:13:43.57,0:13:45.72,Default,,0,0,0,,类似地 OR可能看起像这样
Dialogue: 0,0:13:46.02,0:13:49.58,Default,,0,0,0,,虽然我没给你们演示过OR的用法
Dialogue: 0,0:13:49.84,0:13:54.70,Default,,0,0,0,,OR会尝试找出P或Q所有匹配的事实
Dialogue: 0,0:13:55.80,0:13:58.07,Default,,0,0,0,,P、Q两条查询都有各自的形状
Dialogue: 0,0:14:04.46,0:14:06.68,Default,,0,0,0,,OR的实现则是
Dialogue: 0,0:14:08.54,0:14:10.91,Default,,0,0,0,,我把来自于数据库的流
Dialogue: 0,0:14:12.50,0:14:13.49,Default,,0,0,0,,扇出开来
Dialogue: 0,0:14:13.49,0:14:16.04,Default,,0,0,0,,把它们分别送给P和Q
Dialogue: 0,0:14:17.44,0:14:21.98,Default,,0,0,0,,我把最初的查询流也给扇出开来
Dialogue: 0,0:14:26.75,0:14:29.16,Default,,0,0,0,,这样我不但能够得到P的所有结果
Dialogue: 0,0:14:29.29,0:14:31.08,Default,,0,0,0,,也能得到Q的所有结果
Dialogue: 0,0:14:31.61,0:14:34.56,Default,,0,0,0,,把这些输出送入某种“附加器”中
Dialogue: 0,0:14:34.62,0:14:37.48,Default,,0,0,0,,或者把它们“合并”到一条流中
Dialogue: 0,0:14:39.64,0:14:40.88,Default,,0,0,0,,然后得到输出
Dialogue: 0,0:14:41.08,0:14:48.24,Default,,0,0,0,,而从外部来看 这整个东西就是OR
Dialogue: 0,0:14:52.35,0:14:54.89,Default,,0,0,0,,同样的 当你们从外部观察它时
Dialogue: 0,0:14:55.07,0:14:56.54,Default,,0,0,0,,你会发现它具有相同的形状
Dialogue: 0,0:15:01.00,0:15:01.61,Default,,0,0,0,,NOT又如何实现呢？
Dialogue: 0,0:15:02.02,0:15:03.45,Default,,0,0,0,,NOT的原理有些类似
Dialogue: 0,0:15:04.31,0:15:05.95,Default,,0,0,0,,如果我有一条查询P
Dialogue: 0,0:15:06.86,0:15:13.50,Default,,0,0,0,,这是一条基本查询P
Dialogue: 0,0:15:14.69,0:15:16.32,Default,,0,0,0,,现在我要实现(NOT P)
Dialogue: 0,0:15:18.68,0:15:20.54,Default,,0,0,0,,NOT的作用像是一个过滤器
Dialogue: 0,0:15:20.72,0:15:21.95,Default,,0,0,0,,这里连接数据库
Dialogue: 0,0:15:23.84,0:15:28.28,Default,,0,0,0,,这里是输入的字典流
Dialogue: 0,0:15:28.78,0:15:31.53,Default,,0,0,0,,(NOT P)要做的就是
Dialogue: 0,0:15:31.88,0:15:37.40,Default,,0,0,0,,对这些东西做过滤
Dialogue: 0,0:15:39.02,0:15:40.09,Default,,0,0,0,,过滤的方法则是
Dialogue: 0,0:15:40.19,0:15:42.70,Default,,0,0,0,,如果我在这里获得了一本字典
Dialogue: 0,0:15:43.42,0:15:44.65,Default,,0,0,0,,那么我就去找所有的匹配
Dialogue: 0,0:15:44.83,0:15:46.48,Default,,0,0,0,,然后丢弃找到的结果
Dialogue: 0,0:15:47.46,0:15:49.93,Default,,0,0,0,,如果我没有在这里找到匹配
Dialogue: 0,0:15:50.12,0:15:51.37,Default,,0,0,0,,我就把它传递过去
Dialogue: 0,0:15:52.40,0:15:53.55,Default,,0,0,0,,NOT就是一个纯粹的过滤器
Dialogue: 0,0:15:55.34,0:15:59.98,Default,,0,0,0,,因此AND就类似于一个电阻
Dialogue: 0,0:15:59.98,0:16:01.85,Default,,0,0,0,,AND是串行的组合
Dialogue: 0,0:16:02.49,0:16:04.14,Default,,0,0,0,,OR是并行组合
Dialogue: 0,0:16:04.96,0:16:07.46,Default,,0,0,0,,然而NOT并不会对字典做任何扩展
Dialogue: 0,0:16:07.46,0:16:08.40,Default,,0,0,0,,它只会做过滤
Dialogue: 0,0:16:08.75,0:16:11.79,Default,,0,0,0,,它会丢弃那些能够匹配的结果
Dialogue: 0,0:16:12.64,0:16:14.19,Default,,0,0,0,,LISP-VALUE的原理类似
Dialogue: 0,0:16:14.84,0:16:16.60,Default,,0,0,0,,它的过滤器会复杂点
Dialogue: 0,0:16:16.60,0:16:17.37,Default,,0,0,0,,因为要应用到谓词上
Dialogue: 0,0:16:19.93,0:16:21.64,Default,,0,0,0,,这里需要注意的关键点是
Dialogue: 0,0:16:21.92,0:16:23.55,Default,,0,0,0,,我们之前也强调过了
Dialogue: 0,0:16:23.64,0:16:25.29,Default,,0,0,0,,就是关于“闭包性质”的思想
Dialogue: 0,0:16:28.22,0:16:31.80,Default,,0,0,0,,我们通过组合手段构建的东西
Dialogue: 0,0:16:31.95,0:16:34.51,Default,,0,0,0,,跟所使用的基本物件
Dialogue: 0,0:16:35.69,0:16:37.58,Default,,0,0,0,,有同样的结构
Dialogue: 0,0:16:39.75,0:16:41.68,Default,,0,0,0,,所以从外面看
Dialogue: 0,0:16:41.71,0:16:43.72,Default,,0,0,0,,查询的AND与基本查询结构相同
Dialogue: 0,0:16:44.63,0:16:46.14,Default,,0,0,0,,这就意味着
Dialogue: 0,0:16:46.94,0:16:50.28,Default,,0,0,0,,这里的盒子可以是AND、OR、NOT或者其它的
Dialogue: 0,0:16:50.30,0:16:54.22,Default,,0,0,0,,因为它具有相同的形状来连接更大的东西
Dialogue: 0,0:16:54.95,0:16:56.68,Default,,0,0,0,,这种思想能够让我们获得
Dialogue: 0,0:16:56.92,0:16:58.96,Default,,0,0,0,,Escher绘图语言中的那种复杂度
Dialogue: 0,0:16:59.55,0:17:01.31,Default,,0,0,0,,让你能够仅仅使用序对
Dialogue: 0,0:17:01.34,0:17:03.26,Default,,0,0,0,,构建出这些复杂结构
Dialogue: 0,0:17:03.93,0:17:04.78,Default,,0,0,0,,这就是“闭包性质”
Dialogue: 0,0:17:06.28,0:17:08.06,Default,,0,0,0,,这种性质
Dialogue: 0,0:17:09.64,0:17:11.72,Default,,0,0,0,,能够让我完成你们现在觉得理所当然的事儿
Dialogue: 0,0:17:11.76,0:17:14.91,Default,,0,0,0,,比如我可以查询(AND JOB SALARY)
Dialogue: 0,0:17:14.91,0:17:18.80,Default,,0,0,0,,当然我也可以查询(AND JOB (NOT ...))等等
Dialogue: 0,0:17:19.26,0:17:20.92,Default,,0,0,0,,这种便利是由
Dialogue: 0,0:17:20.94,0:17:22.91,Default,,0,0,0,,这种“闭包原则”直接带给我们的
Dialogue: 0,0:17:25.18,0:17:27.08,Default,,0,0,0,,好吧 提问时间
Dialogue: 0,0:17:29.32,0:17:30.89,Default,,0,0,0,,学生：字典是从哪里来的？
Dialogue: 0,0:17:30.99,0:17:36.03,Default,,0,0,0,,教授：字典最初来自于你的输入
Dialogue: 0,0:17:36.09,0:17:37.32,Default,,0,0,0,,因此当你最初进行查询时
Dialogue: 0,0:17:39.16,0:17:41.09,Default,,0,0,0,,它首先会建立起这整个结构
Dialogue: 0,0:17:41.09,0:17:42.64,Default,,0,0,0,,它先输入一个空字典
Dialogue: 0,0:17:45.00,0:17:47.24,Default,,0,0,0,,如果你只有一条基本查询的话
Dialogue: 0,0:17:48.24,0:17:51.10,Default,,0,0,0,,那么它就会输出一系列具有内容的字典
Dialogue: 0,0:17:52.31,0:17:54.33,Default,,0,0,0,,这里演示的一般性情况是
Dialogue: 0,0:17:54.51,0:17:59.71,Default,,0,0,0,,某个嵌套组合查询的中间过程
Dialogue: 0,0:18:01.55,0:18:02.30,Default,,0,0,0,,所以在那时
Dialogue: 0,0:18:02.38,0:18:03.79,Default,,0,0,0,,让我们来看看这里
Dialogue: 0,0:18:04.38,0:18:06.73,Default,,0,0,0,,这条SUPERVISOR查询得到了某本字典
Dialogue: 0,0:18:06.73,0:18:08.03,Default,,0,0,0,,这本字典来自于哪里呢？
Dialogue: 0,0:18:08.73,0:18:11.15,Default,,0,0,0,,它来自于
Dialogue: 0,0:18:12.84,0:18:14.89,Default,,0,0,0,,这条基本查询的输出
Dialogue: 0,0:18:16.26,0:18:17.88,Default,,0,0,0,,说得更具体一点
Dialogue: 0,0:18:18.35,0:18:21.72,Default,,0,0,0,,如果我最初在顶层只输入了这条查询
Dialogue: 0,0:18:22.27,0:18:22.92,Default,,0,0,0,,这整条AND查询
Dialogue: 0,0:18:23.07,0:18:25.28,Default,,0,0,0,,它实际上会构建这种结构
Dialogue: 0,0:18:25.50,0:18:30.24,Default,,0,0,0,,并使用一本空字典来启动整个过程
Dialogue: 0,0:18:31.77,0:18:34.33,Default,,0,0,0,,处理过程开始后 会产生一系列的字典
Dialogue: 0,0:18:34.36,0:18:37.36,Default,,0,0,0,,其中就有X、Y以及D
Dialogue: 0,0:18:38.64,0:18:39.58,Default,,0,0,0,,向这边传递
Dialogue: 0,0:18:40.19,0:18:42.16,Default,,0,0,0,,这就是这条查询的输入
Dialogue: 0,0:18:42.16,0:18:43.72,Default,,0,0,0,,这条查询也会生成其它的东西
Dialogue: 0,0:18:45.04,0:18:48.22,Default,,0,0,0,,如果这整个查询是构建在一个更大的查询中的话
Dialogue: 0,0:18:49.31,0:18:51.00,Default,,0,0,0,,比如说一条OR查询
Dialogue: 0,0:18:53.42,0:18:55.71,Default,,0,0,0,,那么它将输出到下一个查询中
Dialogue: 0,0:18:58.56,0:19:01.28,Default,,0,0,0,,因此最初开始处理时 只有一本空字典
Dialogue: 0,0:19:01.68,0:19:04.08,Default,,0,0,0,,但是在处理这些复合查询的过程中
Dialogue: 0,0:19:04.11,0:19:06.65,Default,,0,0,0,,会生成各种不同的字典
Dialogue: 0,0:19:07.66,0:19:12.28,Default,,0,0,0,,学生：字典都是查询的结果吗？
Dialogue: 0,0:19:15.12,0:19:17.69,Default,,0,0,0,,它们会变成
Dialogue: 0,0:19:18.84,0:19:22.81,Default,,0,0,0,,它们存储在数据库中吗？
Dialogue: 0,0:19:23.68,0:19:24.98,Default,,0,0,0,,它们是临时数据吗？
Dialogue: 0,0:19:24.98,0:19:27.18,Default,,0,0,0,,教授：它们是在MATCH过程中临时创建的
Dialogue: 0,0:19:28.03,0:19:29.88,Default,,0,0,0,,但它们实际存放在内存中
Dialogue: 0,0:19:29.88,0:19:33.02,Default,,0,0,0,,最初 某人创建了一本THE-EMPTY-DICT字典
Dialogue: 0,0:19:34.22,0:19:36.80,Default,,0,0,0,,送入这个匹配过程
Dialogue: 0,0:19:36.81,0:19:39.05,Default,,0,0,0,,MATCH过程据此构建新字典
Dialogue: 0,0:19:39.07,0:19:40.27,Default,,0,0,0,,并把它们传递下去
Dialogue: 0,0:19:40.76,0:19:42.48,Default,,0,0,0,,学生：因此匹配完成后它们就被丢弃了？
Dialogue: 0,0:19:43.64,0:19:46.25,Default,,0,0,0,,教授：实际上 当没人需要它们后（就被废料回收了）
Dialogue: 0,0:19:51.90,0:19:53.60,Default,,0,0,0,,学生：似乎AND查询对数据库
Dialogue: 0,0:19:53.63,0:19:55.37,Default,,0,0,0,,进行了一些冗余操作
Dialogue: 0,0:19:55.96,0:19:57.48,Default,,0,0,0,,如果第一条子句扫描过了
Dialogue: 0,0:19:57.50,0:19:59.90,Default,,0,0,0,,比如说前两个元素没有匹配 而第三个元素匹配了
Dialogue: 0,0:20:00.25,0:20:03.64,Default,,0,0,0,,然而第二条子句又会检查这两个元素
Dialogue: 0,0:20:04.32,0:20:06.59,Default,,0,0,0,,然后又一次丢弃这些不匹配的元素
Dialogue: 0,0:20:06.64,0:20:08.72,Default,,0,0,0,,而字典中已经有匹配的项了
Dialogue: 0,0:20:10.00,0:20:12.56,Default,,0,0,0,,如果我们把数据库中的数据
Dialogue: 0,0:20:12.57,0:20:14.43,Default,,0,0,0,,跟字典同时传递 这样可行么？
Dialogue: 0,0:20:15.69,0:20:17.60,Default,,0,0,0,,教授：实际上 通常来说
Dialogue: 0,0:20:17.63,0:20:19.48,Default,,0,0,0,,我们能够以其它方式来安排这些搜索
Dialogue: 0,0:20:20.12,0:20:21.74,Default,,0,0,0,,你也可以做一些分析
Dialogue: 0,0:20:21.74,0:20:23.16,Default,,0,0,0,,我记得书里面就有这样的习题
Dialogue: 0,0:20:23.87,0:20:26.65,Default,,0,0,0,,是考察通过安排AND子句的顺序
Dialogue: 0,0:20:27.00,0:20:29.20,Default,,0,0,0,,来消除不同类型的冗余
Dialogue: 0,0:20:29.85,0:20:30.72,Default,,0,0,0,,而这里只是为了
Dialogue: 0,0:20:31.32,0:20:34.54,Default,,0,0,0,,用非常简单的情况来向你们展示它们是如何配合的
Dialogue: 0,0:20:34.70,0:20:35.38,Default,,0,0,0,,但是你说得非常对
Dialogue: 0,0:20:35.38,0:20:37.32,Default,,0,0,0,,这些冗余是可以避免的
Dialogue: 0,0:20:38.37,0:20:40.80,Default,,0,0,0,,这也是这门语言缓慢的原因之一
Dialogue: 0,0:20:41.19,0:20:42.70,Default,,0,0,0,,你们可以让它变得更聪明
Dialogue: 0,0:20:42.93,0:20:46.22,Default,,0,0,0,,我只是为了向你们演示非常简单的、原理性的实现
Dialogue: 0,0:20:51.22,0:20:53.23,Default,,0,0,0,,学生：您是根据Prolog来建模这门语言的
Dialogue: 0,0:20:53.24,0:20:55.13,Default,,0,0,0,,还是说它只是偶然地像Prolog？
Dialogue: 0,0:21:04.96,0:21:07.08,Default,,0,0,0,,教授：Gerry教授昨天羞辱了一大堆人
Dialogue: 0,0:21:07.24,0:21:09.92,Default,,0,0,0,,我想说真实的情况是
Dialogue: 0,0:21:10.19,0:21:12.60,Default,,0,0,0,,MIT的研究人员在1971年做了类似的事
Dialogue: 0,0:21:12.64,0:21:15.60,Default,,0,0,0,,但是发现这个方向并不正确 并停止了研究
Dialogue: 0,0:21:16.12,0:21:22.80,Default,,0,0,0,,因此我们是根据查询处理的基本原理建模的
Dialogue: 0,0:21:22.84,0:21:24.73,Default,,0,0,0,,大概在1971年左右
Dialogue: 0,0:21:25.13,0:21:27.24,Default,,0,0,0,,只是说 那时候我们还没有用流来实现
Dialogue: 0,0:21:28.27,0:21:33.04,Default,,0,0,0,,然后我们 -- 但我们使用了它差不多六个月后
Dialogue: 0,0:21:33.08,0:21:34.91,Default,,0,0,0,,发现它存在各种各样的问题
Dialogue: 0,0:21:34.94,0:21:36.30,Default,,0,0,0,,稍后我会解释
Dialogue: 0,0:21:37.33,0:21:38.19,Default,,0,0,0,,然后我们就想
Dialogue: 0,0:21:38.44,0:21:39.92,Default,,0,0,0,,Prolog一定解决了这些问题
Dialogue: 0,0:21:39.93,0:21:41.21,Default,,0,0,0,,但却发现它并没有
Dialogue: 0,0:21:41.25,0:21:43.02,Default,,0,0,0,,从这种意义上来说 它确实跟Prolog一样
Dialogue: 0,0:21:43.60,0:21:44.95,Default,,0,0,0,,学生：Prolog基于流么？
Dialogue: 0,0:21:44.95,0:21:46.20,Default,,0,0,0,,教授：不 Prolog基于的是
Dialogue: 0,0:21:46.78,0:21:51.04,Default,,0,0,0,,就行为上来说 我们的语言很像Prolog
Dialogue: 0,0:21:51.04,0:21:52.96,Default,,0,0,0,,Prolog使用回溯策略
Dialogue: 0,0:21:53.80,0:21:55.71,Default,,0,0,0,,但是Prolog有一个优点非常好
Dialogue: 0,0:21:55.72,0:21:57.98,Default,,0,0,0,,也使得它变得实用
Dialogue: 0,0:21:58.28,0:22:01.50,Default,,0,0,0,,你知道吗
Dialogue: 0,0:22:01.68,0:22:04.09,Default,,0,0,0,,它们精心设计了Prolog的编译器
Dialogue: 0,0:22:04.11,0:22:05.32,Default,,0,0,0,,使得它能够高速运行
Dialogue: 0,0:22:06.65,0:22:10.81,Default,,0,0,0,,因此 虽然我们这门语言非常缓慢地输出答案
Dialogue: 0,0:22:11.66,0:22:13.61,Default,,0,0,0,,真正的Prolog程序却运行得非常快
Dialogue: 0,0:22:14.70,0:22:16.48,Default,,0,0,0,,这是因为 尽管搜索过程十分低效
Dialogue: 0,0:22:16.67,0:22:20.81,Default,,0,0,0,,Prolog卓越的编译器也会高效地完成工作
Dialogue: 0,0:22:24.30,0:22:25.21,Default,,0,0,0,,休息一下吧
Dialogue: 0,0:22:25.42,0:22:36.17,Default,,0,0,0,,[音乐]
Dialogue: 0,0:22:36.35,0:22:39.87,Declare,,0,0,0,,{\an2\fad(500,500)}《计算机程序的构造和解释》
Dialogue: 0,0:23:01.48,0:23:05.12,Declare,,0,0,0,,{\an2\fad(500,500)}讲师：哈罗德·艾伯森教授 及 格兰德·杰·萨斯曼教授
Dialogue: 0,0:23:05.18,0:23:09.05,Declare,,0,0,0,,{\an2\fad(500,500)}《计算机程序的构造和解释》
Dialogue: 0,0:23:09.12,0:23:13.66,Declare,,0,0,0,,{\an2\fad(500,500)}逻辑式程序设计 II
Dialogue: 0,0:23:16.65,0:23:18.83,Default,,0,0,0,,我们已经考察过了基本查询
Dialogue: 0,0:23:19.21,0:23:23.52,Default,,0,0,0,,以及如何使用流来实现组合手段
Dialogue: 0,0:23:23.79,0:23:25.72,Default,,0,0,0,,AND、OR以及NOT
Dialogue: 0,0:23:26.95,0:23:28.43,Default,,0,0,0,,现在 该讨论抽象手段了
Dialogue: 0,0:23:29.58,0:23:32.80,Default,,0,0,0,,回想一下 我们这门语言的抽象手段是RULE
Dialogue: 0,0:23:35.15,0:23:37.79,Default,,0,0,0,,(BOSS ?Z ?D)描述的是
Dialogue: 0,0:23:39.18,0:23:43.77,Default,,0,0,0,,如果某人在D部门工作
Dialogue: 0,0:23:45.68,0:23:47.47,Default,,0,0,0,,并且Z是X的上司
Dialogue: 0,0:23:48.90,0:23:50.60,Default,,0,0,0,,这就是所谓的“BOSS”
Dialogue: 0,0:23:52.26,0:23:53.15,Default,,0,0,0,,并且 实际上
Dialogue: 0,0:23:53.34,0:23:55.61,Default,,0,0,0,,如果我们考察一下编写的规则与这边的关系
Dialogue: 0,0:23:56.80,0:23:57.90,Default,,0,0,0,,这是我们编写的查询
Dialogue: 0,0:23:57.93,0:24:01.90,Default,,0,0,0,,这个是(JOB ?X ?D) 而这个是(SUPERVISOR ?X ?Z)
Dialogue: 0,0:24:02.19,0:24:04.28,Default,,0,0,0,,我们实际想要把这一大堆东西
Dialogue: 0,0:24:05.07,0:24:06.57,Default,,0,0,0,,用一个盒子封装起来
Dialogue: 0,0:24:19.08,0:24:24.54,Default,,0,0,0,,然后把这个盒子里的所有东西
Dialogue: 0,0:24:25.15,0:24:32.48,Default,,0,0,0,,认为是(BOSS ?Z ?D)
Dialogue: 0,0:24:33.90,0:24:35.25,Default,,0,0,0,,这是我们想要达到的效果
Dialogue: 0,0:24:38.72,0:24:39.72,Default,,0,0,0,,因此 比如说
Dialogue: 0,0:24:43.18,0:24:44.08,Default,,0,0,0,,我们这样做了过后
Dialogue: 0,0:24:45.00,0:24:47.84,Default,,0,0,0,,我们想要检查
Dialogue: 0,0:24:47.95,0:24:50.51,Default,,0,0,0,,Ben Bitdiddle是否为计算机分部的BOSS
Dialogue: 0,0:24:51.10,0:25:02.86,Default,,0,0,0,,如果我想查询 (BOSS (BITDIDDLE BEN) COMPUTER)
Dialogue: 0,0:25:04.78,0:25:07.08,Default,,0,0,0,,想象一下把这条查询输入系统
Dialogue: 0,0:25:07.12,0:25:09.16,Default,,0,0,0,,实际上发生的是
Dialogue: 0,0:25:10.67,0:25:12.92,Default,,0,0,0,,在这里先构建一本字典
Dialogue: 0,0:25:15.82,0:25:23.63,Default,,0,0,0,,其中 ?Z=BITDIDDLE
Dialogue: 0,0:25:28.88,0:25:33.31,Default,,0,0,0,,?D=COMPUTER
Dialogue: 0,0:25:37.08,0:25:38.62,Default,,0,0,0,,这个字典又是来自于哪里呢？
Dialogue: 0,0:25:38.68,0:25:40.71,Default,,0,0,0,,我们来看下幻灯片
Dialogue: 0,0:25:40.71,0:25:43.71,Default,,0,0,0,,这本字典是通过把
Dialogue: 0,0:25:44.30,0:25:46.33,Default,,0,0,0,,查询(BOSS (BITDIDDLE BEN) COMPUTER)
Dialogue: 0,0:25:46.51,0:25:49.63,Default,,0,0,0,,与规则的结论(BOSS ?Z ?D)相匹配得到
Dialogue: 0,0:25:51.65,0:25:54.11,Default,,0,0,0,,所以我们把规则的结论和查询匹配了起来
Dialogue: 0,0:25:54.19,0:25:55.53,Default,,0,0,0,,这样我们就获得了一本字典
Dialogue: 0,0:25:58.99,0:26:02.54,Default,,0,0,0,,现在我们就要把这本字典输入到这整个结构中
Dialogue: 0,0:26:02.92,0:26:05.56,Default,,0,0,0,,进行处理 并观察是否有输出
Dialogue: 0,0:26:06.67,0:26:09.88,Default,,0,0,0,,如果输出了结果 那么查询就为真
Dialogue: 0,0:26:11.33,0:26:12.37,Default,,0,0,0,,这是基本的思想
Dialogue: 0,0:26:12.37,0:26:13.24,Default,,0,0,0,,因此 通常来说
Dialogue: 0,0:26:14.03,0:26:15.40,Default,,0,0,0,,我们实现规则的方法就是
Dialogue: 0,0:26:15.85,0:26:18.89,Default,,0,0,0,,用规则的结论去匹配
Dialogue: 0,0:26:20.86,0:26:22.96,Default,,0,0,0,,假设为真的查询
Dialogue: 0,0:26:23.58,0:26:25.12,Default,,0,0,0,,这个过程会产生一本字典
Dialogue: 0,0:26:25.29,0:26:28.22,Default,,0,0,0,,在有了相关字典后
Dialogue: 0,0:26:30.35,0:26:34.51,Default,,0,0,0,,我们来处理规则的体
Dialogue: 0,0:26:36.33,0:26:37.68,Default,,0,0,0,,基本上就是这样了
Dialogue: 0,0:26:38.64,0:26:41.44,Default,,0,0,0,,但还有两个技术点
Dialogue: 0,0:26:43.04,0:26:44.32,Default,,0,0,0,,首先就是
Dialogue: 0,0:26:45.74,0:26:47.26,Default,,0,0,0,,我也可能有其它的问法
Dialogue: 0,0:26:47.51,0:26:48.41,Default,,0,0,0,,比如说
Dialogue: 0,0:26:50.54,0:26:52.36,Default,,0,0,0,,查询计算机分部的BOSS
Dialogue: 0,0:26:52.54,0:26:56.32,Default,,0,0,0,,就可以查询 (BOSS ?WHO COMPUTER)
Dialogue: 0,0:27:00.78,0:27:01.63,Default,,0,0,0,,这样做了以后
Dialogue: 0,0:27:02.57,0:27:04.62,Default,,0,0,0,,我真正想要做的
Dialogue: 0,0:27:05.04,0:27:06.49,Default,,0,0,0,,就是先建立一本字典
Dialogue: 0,0:27:08.35,0:27:09.88,Default,,0,0,0,,其中有一些约束
Dialogue: 0,0:27:09.93,0:27:11.20,Default,,0,0,0,,比如 ?D=COMPUTER
Dialogue: 0,0:27:14.35,0:27:18.48,Default,,0,0,0,,而?Z等同于?WHO
Dialogue: 0,0:27:21.70,0:27:23.22,Default,,0,0,0,,我们的匹配器不会那么做
Dialogue: 0,0:27:23.22,0:27:27.00,Default,,0,0,0,,这不是模式和数据的匹配方式
Dialogue: 0,0:27:28.58,0:27:29.72,Default,,0,0,0,,这是在匹配两个模式
Dialogue: 0,0:27:29.74,0:27:31.58,Default,,0,0,0,,并判断它们是否一致
Dialogue: 0,0:27:31.90,0:27:33.48,Default,,0,0,0,,又是什么使它们不一致
Dialogue: 0,0:27:33.48,0:27:36.43,Default,,0,0,0,,换句话说 我们需要的不是一个模式匹配器
Dialogue: 0,0:27:36.96,0:27:38.91,Default,,0,0,0,,而是一种更一般性的东西
Dialogue: 0,0:27:39.13,0:27:40.11,Default,,0,0,0,,就是“合一”算法
Dialogue: 0,0:27:44.42,0:27:48.06,Default,,0,0,0,,“合一”是更为一般化的模式匹配算法
Dialogue: 0,0:27:49.53,0:27:52.17,Default,,0,0,0,,合一算法接收两条模式
Dialogue: 0,0:27:53.23,0:27:57.53,Default,,0,0,0,,它考虑的是：可以找到哪些一般性的元素
Dialogue: 0,0:27:58.20,0:28:00.01,Default,,0,0,0,,用来代换模式中的变量
Dialogue: 0,0:28:02.68,0:28:05.08,Default,,0,0,0,,使得它俩能够同时满足
Dialogue: 0,0:28:05.68,0:28:06.60,Default,,0,0,0,,让我来举个例子
Dialogue: 0,0:28:08.86,0:28:14.49,Default,,0,0,0,,我有一个含有两个元素的模式：(?X ?X)
Dialogue: 0,0:28:15.76,0:28:17.15,Default,,0,0,0,,它描述的是一个二元表
Dialogue: 0,0:28:17.32,0:28:18.64,Default,,0,0,0,,不管元素具体是什么
Dialogue: 0,0:28:18.67,0:28:20.04,Default,,0,0,0,,但两个元素是相同的
Dialogue: 0,0:28:20.40,0:28:22.83,Default,,0,0,0,,我把它与另一个模式进行“合一”
Dialogue: 0,0:28:22.92,0:28:24.62,Default,,0,0,0,,后者描述的是一个二元表
Dialogue: 0,0:28:24.65,0:28:27.61,Default,,0,0,0,,首元素一张由A、?Y、C构成的表
Dialogue: 0,0:28:28.00,0:28:30.14,Default,,0,0,0,,而第二个元素是由A、B、?Z构成的表
Dialogue: 0,0:28:33.07,0:28:34.88,Default,,0,0,0,,那么 合一算法能够告诉我
Dialogue: 0,0:28:34.89,0:28:36.17,Default,,0,0,0,,在生成的字典中
Dialogue: 0,0:28:36.35,0:28:37.96,Default,,0,0,0,,?X必须是(A B C)
Dialogue: 0,0:28:39.34,0:28:41.92,Default,,0,0,0,,?Y必须为B ?Z必须为C
Dialogue: 0,0:28:43.44,0:28:46.28,Default,,0,0,0,,这些是我必须对X、Y以及Z施加的约束
Dialogue: 0,0:28:46.33,0:28:47.58,Default,,0,0,0,,以便让两个模式合一
Dialogue: 0,0:28:48.12,0:28:50.84,Default,,0,0,0,,或者换句话来说 让它匹配这个?X
Dialogue: 0,0:28:51.15,0:28:53.37,Default,,0,0,0,,让它匹配这个?X
Dialogue: 0,0:28:55.28,0:28:57.76,Default,,0,0,0,,合一算法需要能够推断出这些
Dialogue: 0,0:28:58.54,0:29:01.08,Default,,0,0,0,,但是合一算法也会遇到复杂的情况
Dialogue: 0,0:29:01.08,0:29:03.07,Default,,0,0,0,,我可能会询问一些复杂的查询
Dialogue: 0,0:29:03.48,0:29:05.74,Default,,0,0,0,,比如这是一个二元表
Dialogue: 0,0:29:07.00,0:29:08.28,Default,,0,0,0,,其中的元素都是相同的
Dialogue: 0,0:29:08.86,0:29:11.15,Default,,0,0,0,,它要与这个模式进行合一
Dialogue: 0,0:29:12.65,0:29:15.36,Default,,0,0,0,,合一算法也要能够从中推断出
Dialogue: 0,0:29:16.89,0:29:19.57,Default,,0,0,0,,?Y必须为B
Dialogue: 0,0:29:19.57,0:29:22.12,Default,,0,0,0,,因为这两个是一样的
Dialogue: 0,0:29:22.22,0:29:23.52,Default,,0,0,0,,因此?Y就是B
Dialogue: 0,0:29:24.34,0:29:27.53,Default,,0,0,0,,这里 ?V应该为A
Dialogue: 0,0:29:28.94,0:29:30.99,Default,,0,0,0,,只要?Z和?W取值相同
Dialogue: 0,0:29:31.00,0:29:32.43,Default,,0,0,0,,它们就可以是任意值
Dialogue: 0,0:29:35.71,0:29:41.76,Default,,0,0,0,,?X就应该是(B A ?W) 其中?W为任意值
Dialogue: 0,0:29:42.83,0:29:44.68,Default,,0,0,0,,或者是?Z -- 因为?Z和?W是一致的
Dialogue: 0,0:29:44.70,0:29:49.42,Default,,0,0,0,,发现了么 合一算法需要从这些模式中推断出信息
Dialogue: 0,0:29:50.88,0:29:53.52,Default,,0,0,0,,所以你们可能认为 这其中有某种魔法般的推理
Dialogue: 0,0:29:54.27,0:29:55.23,Default,,0,0,0,,但其实并不是
Dialogue: 0,0:29:55.85,0:29:59.88,Default,,0,0,0,,合一算法基本上只是对模式匹配的小小修改
Dialogue: 0,0:30:00.15,0:30:01.85,Default,,0,0,0,,如果你们翻阅教材 就会发现
Dialogue: 0,0:30:02.25,0:30:06.16,Default,,0,0,0,,在模式匹配算法中加入了三到四行代码
Dialogue: 0,0:30:06.49,0:30:08.17,Default,,0,0,0,,来处理对称的情况
Dialogue: 0,0:30:08.28,0:30:10.81,Default,,0,0,0,,还记得吗 模式匹配中有一处代码判断
Dialogue: 0,0:30:11.66,0:30:14.28,Default,,0,0,0,,这个变量匹配一个常量吗？
Dialogue: 0,0:30:14.98,0:30:16.42,Default,,0,0,0,,如果是的话 就在字典中进行检查
Dialogue: 0,0:30:16.42,0:30:18.25,Default,,0,0,0,,在合一算法中只有另一条子句
Dialogue: 0,0:30:18.49,0:30:20.75,Default,,0,0,0,,它判断两个变量是否相匹配
Dialogue: 0,0:30:22.00,0:30:23.42,Default,,0,0,0,,这种情况下你去查询字典
Dialogue: 0,0:30:23.45,0:30:25.68,Default,,0,0,0,,看它们在字典的约束下是否一致
Dialogue: 0,0:30:27.03,0:30:31.13,Default,,0,0,0,,因此 这门语言中的所有“推断”
Dialogue: 0,0:30:31.28,0:30:34.59,Default,,0,0,0,,你会发现它蕴含在规则应用中
Dialogue: 0,0:30:34.99,0:30:37.88,Default,,0,0,0,,更进一步地考察 你会发现在合一算法中
Dialogue: 0,0:30:38.36,0:30:40.32,Default,,0,0,0,,如果更进一步地用“显微镜”观察
Dialogue: 0,0:30:40.56,0:30:43.96,Default,,0,0,0,,基本上就在模式匹配算法中
Dialogue: 0,0:30:44.94,0:30:47.07,Default,,0,0,0,,这其中并没有什么魔法
Dialogue: 0,0:30:47.41,0:30:50.25,Default,,0,0,0,,而你们所见到的“推断”
Dialogue: 0,0:30:50.94,0:30:52.89,Default,,0,0,0,,只是因为其中的递归
Dialogue: 0,0:30:52.92,0:30:55.69,Default,,0,0,0,,它一点一点地回绕MATCH过程
Dialogue: 0,0:30:56.03,0:30:58.03,Default,,0,0,0,,它让这个过程看起来很聪明
Dialogue: 0,0:30:58.44,0:31:00.36,Default,,0,0,0,,但它实际上并不是那么聪明
Dialogue: 0,0:31:02.14,0:31:04.41,Default,,0,0,0,,当然 合一算法需要聪明地识别出一些情况
Dialogue: 0,0:31:04.88,0:31:05.87,Default,,0,0,0,,我来举个例子吧
Dialogue: 0,0:31:11.07,0:31:13.36,Default,,0,0,0,,假设我想要用一个二元表进行合一
Dialogue: 0,0:31:13.48,0:31:14.81,Default,,0,0,0,,(?X ?X)
Dialogue: 0,0:31:17.24,0:31:22.14,Default,,0,0,0,,另一个模式则是 (?Y (a . ?Y))
Dialogue: 0,0:31:24.37,0:31:26.12,Default,,0,0,0,,现在 如果你想一想它所表达的意思
Dialogue: 0,0:31:26.86,0:31:29.71,Default,,0,0,0,,它表示了?X应该跟?Y一致
Dialogue: 0,0:31:30.92,0:31:31.66,Default,,0,0,0,,同时呢
Dialogue: 0,0:31:31.82,0:31:36.16,Default,,0,0,0,,?X又应该跟(A . ?Y)相同
Dialogue: 0,0:31:37.33,0:31:39.45,Default,,0,0,0,,如果你仔细思考它成立的条件
Dialogue: 0,0:31:42.27,0:31:44.71,Default,,0,0,0,,你会发现 ?Y必须是一个由A构成的无穷表
Dialogue: 0,0:31:47.50,0:31:48.35,Default,,0,0,0,,从某种角度来说
Dialogue: 0,0:31:49.21,0:31:52.40,Default,,0,0,0,,为了完成这样的合一
Dialogue: 0,0:31:52.60,0:31:54.84,Default,,0,0,0,,我需要求解一个不动点方程
Dialogue: 0,0:31:55.05,0:32:01.84,Default,,0,0,0,,(CONS 'A Y)=Y
Dialogue: 0,0:32:04.57,0:32:06.96,Default,,0,0,0,,通常来说 --- 我这个例子很简单
Dialogue: 0,0:32:07.29,0:32:08.67,Default,,0,0,0,,但实际进行合一时
Dialogue: 0,0:32:08.97,0:32:11.98,Default,,0,0,0,,我们可能要求解一个任意的不动点方程
Dialogue: 0,0:32:12.01,0:32:13.42,Default,,0,0,0,,(F Y)=Y
Dialogue: 0,0:32:15.53,0:32:17.08,Default,,0,0,0,,你基本上不能保证
Dialogue: 0,0:32:17.10,0:32:19.47,Default,,0,0,0,,在有穷时间内找到解
Dialogue: 0,0:32:20.57,0:32:23.60,Default,,0,0,0,,我们的逻辑语言又该如何处理这类情况呢？
Dialogue: 0,0:32:24.89,0:32:26.48,Default,,0,0,0,,答案就是：“不处理”
Dialogue: 0,0:32:27.16,0:32:28.04,Default,,0,0,0,,它会撒手不干
Dialogue: 0,0:32:28.73,0:32:31.07,Default,,0,0,0,,合一算法中有一处小检查
Dialogue: 0,0:32:31.31,0:32:33.82,Default,,0,0,0,,用来判断是否为困难的情况
Dialogue: 0,0:32:34.44,0:32:38.00,Default,,0,0,0,,也就是 匹配这些东西需要求解不动点方程
Dialogue: 0,0:32:38.65,0:32:40.81,Default,,0,0,0,,遇到这类情况 我就撒手不干
Dialogue: 0,0:32:42.84,0:32:44.65,Default,,0,0,0,,如果不进行这样的检查
Dialogue: 0,0:32:45.00,0:32:45.88,Default,,0,0,0,,会发生什么情况？
Dialogue: 0,0:32:47.99,0:32:49.10,Default,,0,0,0,,大多数情况就是
Dialogue: 0,0:32:49.13,0:32:51.31,Default,,0,0,0,,合一算法会陷入无穷循环
Dialogue: 0,0:32:53.74,0:32:56.54,Default,,0,0,0,,其它的逻辑语言有类似的工作原理
Dialogue: 0,0:32:56.80,0:32:58.14,Default,,0,0,0,,因此这其中没有什么魔法
Dialogue: 0,0:32:58.22,0:32:59.93,Default,,0,0,0,,简单的情况由匹配器完成
Dialogue: 0,0:33:00.10,0:33:01.58,Default,,0,0,0,,困难的情况根本不去处理
Dialogue: 0,0:33:02.96,0:33:05.47,Default,,0,0,0,,这就是这种技术的现状
Dialogue: 0,0:33:11.88,0:33:14.24,Default,,0,0,0,,现在 我来形式化地描述一下
Dialogue: 0,0:33:14.27,0:33:16.38,Default,,0,0,0,,规则系统的运行原理 -- 也就是合一算法
Dialogue: 0,0:33:17.39,0:33:18.75,Default,,0,0,0,,因此 正式的定义就是
Dialogue: 0,0:33:19.20,0:33:20.96,Default,,0,0,0,,应用一条规则
Dialogue: 0,0:33:24.17,0:33:27.13,Default,,0,0,0,,我们需要使用一些之前的术语
Dialogue: 0,0:33:28.27,0:33:32.01,Default,,0,0,0,,我们把向查询的盒子中
Dialogue: 0,0:33:32.88,0:33:34.78,Default,,0,0,0,,塞入字典称作是
Dialogue: 0,0:33:34.81,0:33:38.54,Default,,0,0,0,,相对一个环境或者框架
Dialogue: 0,0:33:39.95,0:33:43.85,Default,,0,0,0,,对这些大型查询求值
Dialogue: 0,0:33:43.85,0:33:45.04,Default,,0,0,0,,因此 当我们谈及“字典”的时候
Dialogue: 0,0:33:45.07,0:33:46.28,Default,,0,0,0,,“字典”究竟是什么？
Dialogue: 0,0:33:46.72,0:33:48.18,Default,,0,0,0,,它是符号的一系列语义
Dialogue: 0,0:33:48.18,0:33:50.22,Default,,0,0,0,,我们把它叫做“框架”或者“环境”
Dialogue: 0,0:33:51.80,0:33:55.97,Default,,0,0,0,,根据环境进行操作 又是什么？
Dialogue: 0,0:33:55.97,0:33:57.42,Default,,0,0,0,,我们把这个叫做“求值”
Dialogue: 0,0:33:58.33,0:34:01.56,Default,,0,0,0,,因此我们就说 应用一条规则的方法是
Dialogue: 0,0:34:01.92,0:34:06.16,Default,,0,0,0,,先通过将给定的查询与规则的结论合一 得到环境
Dialogue: 0,0:34:06.67,0:34:11.58,Default,,0,0,0,,再在该环境中求值相应规则的体
Dialogue: 0,0:34:13.23,0:34:14.51,Default,,0,0,0,,我想要让你们注意的是
Dialogue: 0,0:34:14.80,0:34:17.08,Default,,0,0,0,,这非常像是
Dialogue: 0,0:34:18.16,0:34:21.50,Default,,0,0,0,,元循环求值器以及代换模型
Dialogue: 0,0:34:21.63,0:34:22.73,Default,,0,0,0,,规则的应用就是
Dialogue: 0,0:34:22.86,0:34:28.36,Default,,0,0,0,,在一个环境中求值规则的体
Dialogue: 0,0:34:28.54,0:34:33.13,Default,,0,0,0,,环境是通过将实际参数与形式参数绑定起来得到的
Dialogue: 0,0:34:34.56,0:34:36.41,Default,,0,0,0,,规则、规则的应用、过程的应用
Dialogue: 0,0:34:36.44,0:34:40.41,Default,,0,0,0,,它们在形式上完全相似
Dialogue: 0,0:34:40.57,0:34:42.30,Default,,0,0,0,,尽管它们又非常不同
Dialogue: 0,0:34:43.65,0:34:45.61,Default,,0,0,0,,再一次地出现了EVAL-APPLY循环
Dialogue: 0,0:34:47.29,0:34:49.52,Default,,0,0,0,,EVAL-APPLY
Dialogue: 0,0:34:53.39,0:34:57.39,Default,,0,0,0,,因此通常来说 我们可能会处理一些复合表达式
Dialogue: 0,0:34:57.42,0:34:59.13,Default,,0,0,0,,它们会变成规则的应用
Dialogue: 0,0:35:00.70,0:35:03.28,Default,,0,0,0,,进一步又会产生字典、框架或者环境
Dialogue: 0,0:35:03.31,0:35:04.72,Default,,0,0,0,,不管你要怎么叫它
Dialogue: 0,0:35:05.02,0:35:08.43,Default,,0,0,0,,它们随后又会作为某个大的复合对象的输入
Dialogue: 0,0:35:08.66,0:35:11.77,Default,,0,0,0,,这有它的一部分 并可能有其它规则的应用
Dialogue: 0,0:35:13.58,0:35:15.68,Default,,0,0,0,,这基本上就是相同的循环
Dialogue: 0,0:35:15.72,0:35:18.68,Default,,0,0,0,,尽管这里没有什么东西看起来像过程
Dialogue: 0,0:35:19.68,0:35:21.87,Default,,0,0,0,,这是因为我们创建的语言
Dialogue: 0,0:35:22.08,0:35:25.49,Default,,0,0,0,,它们的组合手段和抽象手段以某种方式展开
Dialogue: 0,0:35:28.77,0:35:29.52,Default,,0,0,0,,通常来说
Dialogue: 0,0:35:29.77,0:35:31.39,Default,,0,0,0,,最顶层所发生的是
Dialogue: 0,0:35:33.79,0:35:35.96,Default,,0,0,0,,数据库中也有一些规则
Dialogue: 0,0:35:36.65,0:35:38.70,Default,,0,0,0,,数据库中的数据也可能是规则
Dialogue: 0,0:35:40.46,0:35:42.06,Default,,0,0,0,,它们用来检查对象是否为真
Dialogue: 0,0:35:42.92,0:35:44.89,Default,,0,0,0,,所以这里可能会有规则检查
Dialogue: 0,0:35:46.75,0:35:48.16,Default,,0,0,0,,然后就会有一些控制结构
Dialogue: 0,0:35:48.19,0:35:50.48,Default,,0,0,0,,用来判断你访问的是规则
Dialogue: 0,0:35:50.51,0:35:51.80,Default,,0,0,0,,还是数据元素
Dialogue: 0,0:35:51.84,0:35:53.12,Default,,0,0,0,,然后不断地把它们扇出来开
Dialogue: 0,0:35:53.35,0:35:55.48,Default,,0,0,0,,所以基本上不可能说清楚
Dialogue: 0,0:35:55.68,0:35:57.69,Default,,0,0,0,,是用什么样的顺序来查询这些东西的
Dialogue: 0,0:35:58.20,0:36:00.27,Default,,0,0,0,,是广度优先还是深度优先
Dialogue: 0,0:36:00.28,0:36:01.64,Default,,0,0,0,,另外一个原因是
Dialogue: 0,0:36:01.66,0:36:05.58,Default,,0,0,0,,我们通过惰性流隐藏了实际执行顺序
Dialogue: 0,0:36:07.69,0:36:11.16,Default,,0,0,0,,因此很难说清楚它的扫描顺序
Dialogue: 0,0:36:11.27,0:36:12.16,Default,,0,0,0,,但真实的是
Dialogue: 0,0:36:12.19,0:36:13.64,Default,,0,0,0,,由于你是在流视图观察它的
Dialogue: 0,0:36:13.90,0:36:15.82,Default,,0,0,0,,而它们最终都要被扫描到
Dialogue: 0,0:36:24.98,0:36:28.15,Default,,0,0,0,,这里还有一个小小的技术问题
Dialogue: 0,0:36:30.88,0:36:33.55,Default,,0,0,0,,假设我在这里输入
Dialogue: 0,0:36:37.53,0:36:41.00,Default,,0,0,0,,假设我输入(BOSS ?Y COMPUTER)
Dialogue: 0,0:36:44.22,0:36:45.78,Default,,0,0,0,,然后就会发生一件有意思的事儿
Dialogue: 0,0:36:45.78,0:36:50.25,Default,,0,0,0,,这里的字典就有一项?Y
Dialogue: 0,0:36:52.73,0:36:57.37,Default,,0,0,0,,而这两个?Y是不相同的
Dialogue: 0,0:36:57.42,0:37:00.62,Default,,0,0,0,,后者是其它人的工作描述
Dialogue: 0,0:37:01.58,0:37:03.80,Default,,0,0,0,,因此 按照输入“照本宣科”地执行的话
Dialogue: 0,0:37:04.22,0:37:06.44,Default,,0,0,0,,我们就会遇到变量冲突的问题
Dialogue: 0,0:37:09.28,0:37:10.48,Default,,0,0,0,,所以我骗了你们一下
Dialogue: 0,0:37:10.93,0:37:13.84,Default,,0,0,0,,注意 我们之前也遇到过同样的问题
Dialogue: 0,0:37:14.27,0:37:15.56,Default,,0,0,0,,具体来说就是
Dialogue: 0,0:37:15.96,0:37:18.36,Default,,0,0,0,,一门语言需要局部变量
Dialogue: 0,0:37:19.24,0:37:21.74,Default,,0,0,0,,当我计算SQUARE和SUM-SQUARES的时候
Dialogue: 0,0:37:21.79,0:37:23.39,Default,,0,0,0,,这两个X应该是不同的
Dialogue: 0,0:37:24.96,0:37:26.32,Default,,0,0,0,,同样的道理
Dialogue: 0,0:37:27.39,0:37:29.77,Default,,0,0,0,,这两个?Y应该也不相同
Dialogue: 0,0:37:31.80,0:37:32.75,Default,,0,0,0,,我们知道该如何解决
Dialogue: 0,0:37:32.78,0:37:34.49,Default,,0,0,0,,就是引入环境模型
Dialogue: 0,0:37:34.51,0:37:37.04,Default,,0,0,0,,我们构建类似于“框架链”一类的东西
Dialogue: 0,0:37:37.71,0:37:39.10,Default,,0,0,0,,还有更加“粗暴”的解决方法
Dialogue: 0,0:37:39.10,0:37:41.73,Default,,0,0,0,,在查询语言中 我们根本不这么做
Dialogue: 0,0:37:41.73,0:37:43.18,Default,,0,0,0,,我们的解决方法非常粗暴
Dialogue: 0,0:37:43.54,0:37:45.93,Default,,0,0,0,,我们规定 每次你在应用一条规则的时候
Dialogue: 0,0:37:47.26,0:37:49.63,Default,,0,0,0,,用一个不会引起冲突的唯一名字
Dialogue: 0,0:37:49.77,0:37:53.50,Default,,0,0,0,,统一地为规则中的所有变量更名
Dialogue: 0,0:37:54.04,0:37:57.10,Default,,0,0,0,,这个从概念上来说更简单
Dialogue: 0,0:37:57.12,0:37:59.24,Default,,0,0,0,,但既粗暴 又不是很有效
Dialogue: 0,0:37:59.97,0:38:01.15,Default,,0,0,0,,但是请注意
Dialogue: 0,0:38:01.39,0:38:04.68,Default,,0,0,0,,如果我们对Lisp中定义的过程也这么处理
Dialogue: 0,0:38:05.50,0:38:08.72,Default,,0,0,0,,那么就不需要环境模型了
Dialogue: 0,0:38:08.75,0:38:11.56,Default,,0,0,0,,如果我们每次在应用一个过程的时候
Dialogue: 0,0:38:11.87,0:38:13.90,Default,,0,0,0,,我们为过程中的所有变量更名
Dialogue: 0,0:38:14.19,0:38:16.28,Default,,0,0,0,,那么我们就不需要担心局部变量了
Dialogue: 0,0:38:16.33,0:38:17.39,Default,,0,0,0,,因为它们不会出现
Dialogue: 0,0:38:19.04,0:38:20.41,Default,,0,0,0,,但这种做法比较低效
Dialogue: 0,0:38:20.91,0:38:23.04,Default,,0,0,0,,在我们的查询语言中同样也比较低效
Dialogue: 0,0:38:23.29,0:38:24.59,Default,,0,0,0,,但我们还是这样做了 并让它保持简单
Dialogue: 0,0:38:25.61,0:38:26.67,Default,,0,0,0,,有问题吗？
Dialogue: 0,0:38:30.88,0:38:33.39,Default,,0,0,0,,学生：您这一小节开始的时候
Dialogue: 0,0:38:33.40,0:38:39.60,Default,,0,0,0,,就强调APPLY-EVAL模型是多么的强大
Dialogue: 0,0:38:39.63,0:38:41.17,Default,,0,0,0,,以至于任何语言都适用
Dialogue: 0,0:38:41.17,0:38:43.39,Default,,0,0,0,,但你又说这门语言将会非常不同
Dialogue: 0,0:38:43.95,0:38:45.13,Default,,0,0,0,,但最后却发现这门语言
Dialogue: 0,0:38:45.58,0:38:47.88,Default,,0,0,0,,就像你指出的那样--也是同样的
Dialogue: 0,0:38:47.88,0:38:49.85,Default,,0,0,0,,我在想 您是否是在论证
Dialogue: 0,0:38:50.48,0:38:54.57,Default,,0,0,0,,所有的语言都可以转化成 规则或过程的应用
Dialogue: 0,0:38:55.12,0:38:55.98,Default,,0,0,0,,或者类似的
Dialogue: 0,0:38:57.07,0:38:58.88,Default,,0,0,0,,教授：可以说 几乎所有语言
Dialogue: 0,0:38:58.92,0:39:00.30,Default,,0,0,0,,我们通过组合手段构建对象
Dialogue: 0,0:39:00.92,0:39:04.40,Default,,0,0,0,,用简单的名字给它们命名
Dialogue: 0,0:39:04.70,0:39:06.86,Default,,0,0,0,,你可以把任何类似的 比如
Dialogue: 0,0:39:07.79,0:39:09.90,Default,,0,0,0,,有一种一般性的表达式
Dialogue: 0,0:39:09.98,0:39:11.40,Default,,0,0,0,,比如说如何计算某数的平方
Dialogue: 0,0:39:12.03,0:39:14.20,Default,,0,0,0,,几乎所有的东西都可以称为“过程”
Dialogue: 0,0:39:14.88,0:39:15.88,Default,,0,0,0,,如果语言中有这么一部分的话
Dialogue: 0,0:39:15.90,0:39:17.24,Default,,0,0,0,,那么你就需要能够展开它们
Dialogue: 0,0:39:18.02,0:39:20.19,Default,,0,0,0,,你需要有某种组织 使得
Dialogue: 0,0:39:20.57,0:39:24.03,Default,,0,0,0,,当你查看这些抽象变量 或者说标签的时候
Dialogue: 0,0:39:24.06,0:39:27.10,Default,,0,0,0,,它们可能代表着某些特定的东西
Dialogue: 0,0:39:28.33,0:39:29.34,Default,,0,0,0,,你必须一直跟踪它们
Dialogue: 0,0:39:29.39,0:39:30.91,Default,,0,0,0,,这就会形成类似于环境的结构
Dialogue: 0,0:39:31.72,0:39:32.54,Default,,0,0,0,,让后当你要
Dialogue: 0,0:39:32.70,0:39:35.26,Default,,0,0,0,,展开复合对象其中的一个部分的时候
Dialogue: 0,0:39:35.80,0:39:37.44,Default,,0,0,0,,你就需要EVAL-APPLY循环了
Dialogue: 0,0:39:39.97,0:39:43.20,Default,,0,0,0,,有很多很多的语言有这样的特点
Dialogue: 0,0:39:43.36,0:39:45.40,Default,,0,0,0,,它们也是按这种方式组织的
Dialogue: 0,0:39:45.59,0:39:47.20,Default,,0,0,0,,而这门语言特殊之处在于
Dialogue: 0,0:39:47.21,0:39:49.50,Default,,0,0,0,,从外界看 并没有“过程”
Dialogue: 0,0:39:50.69,0:39:52.68,Default,,0,0,0,,而当你剖开表层 深入到实现中去
Dialogue: 0,0:39:52.70,0:39:54.24,Default,,0,0,0,,当然 你会发现本质是一样的
Dialogue: 0,0:39:54.87,0:39:56.95,Default,,0,0,0,,但是从外界来看 这是一种非常不同的世界观
Dialogue: 0,0:39:56.95,0:39:58.54,Default,,0,0,0,,你没有计算输入的函数
Dialogue: 0,0:40:03.97,0:40:05.71,Default,,0,0,0,,学生：您之前提到过
Dialogue: 0,0:40:06.60,0:40:09.55,Default,,0,0,0,,当用模式匹配来实现这些规则时
Dialogue: 0,0:40:10.01,0:40:11.42,Default,,0,0,0,,由于使用了流实现延迟求值
Dialogue: 0,0:40:11.45,0:40:12.72,Default,,0,0,0,,所以没有办法知道
Dialogue: 0,0:40:13.37,0:40:15.36,Default,,0,0,0,,对象的求值顺序
Dialogue: 0,0:40:15.58,0:40:15.94,Default,,0,0,0,,教授：是这样的
Dialogue: 0,0:40:15.94,0:40:18.28,Default,,0,0,0,,学生：但这就表明
Dialogue: 0,0:40:18.94,0:40:22.28,Default,,0,0,0,,我们只能表达总是为真的陈述性知识
Dialogue: 0,0:40:22.30,0:40:23.79,Default,,0,0,0,,语言并不支持时间序列
Dialogue: 0,0:40:23.95,0:40:25.47,Default,,0,0,0,,否则的话 后果就会--
Dialogue: 0,0:40:27.39,0:40:28.76,Default,,0,0,0,,教授：是的 非常正确
Dialogue: 0,0:40:28.82,0:40:29.48,Default,,0,0,0,,问题在于
Dialogue: 0,0:40:30.06,0:40:32.60,Default,,0,0,0,,这个本来就是用来处理陈述性知识的
Dialogue: 0,0:40:33.26,0:40:34.81,Default,,0,0,0,,而就我目前所演示的来说 不支持
Dialogue: 0,0:40:35.71,0:40:39.56,Default,,0,0,0,,休息之后我会向你们揭露这其中的丑陋之处
Dialogue: 0,0:40:40.83,0:40:42.60,Default,,0,0,0,,就如我目前所展示的 它只是进行逻辑运算
Dialogue: 0,0:40:43.07,0:40:44.52,Default,,0,0,0,,原理上来说 如果我们做的是逻辑运算
Dialogue: 0,0:40:44.54,0:40:46.81,Default,,0,0,0,,用什么顺序完成并不会造成影响
Dialogue: 0,0:40:48.84,0:40:51.55,Default,,0,0,0,,但是呢
Dialogue: 0,0:40:51.60,0:40:53.61,Default,,0,0,0,,当你在进行一些具有副作用的操作的时候
Dialogue: 0,0:40:53.68,0:40:55.20,Default,,0,0,0,,比如向数据库中添加项
Dialogue: 0,0:40:55.23,0:40:58.16,Default,,0,0,0,,从中取出项 等等操作
Dialogue: 0,0:40:58.75,0:41:00.83,Default,,0,0,0,,你就丧失了这类控制
Dialogue: 0,0:41:01.29,0:41:02.94,Default,,0,0,0,,因此 这就与Prolog完全不同
Dialogue: 0,0:41:02.94,0:41:05.15,Default,,0,0,0,,Prolog有各种功能
Dialogue: 0,0:41:05.16,0:41:07.79,Default,,0,0,0,,能够让你利用求值的顺序
Dialogue: 0,0:41:09.64,0:41:11.77,Default,,0,0,0,,人们也这么来写Prolog
Dialogue: 0,0:41:11.77,0:41:14.04,Default,,0,0,0,,结果发现这样变得非常困难
Dialogue: 0,0:41:14.32,0:41:17.55,Default,,0,0,0,,但如果你是Prolog程序专家 你就可以这么做
Dialogue: 0,0:41:18.59,0:41:20.21,Default,,0,0,0,,但是我认为你们现在并不可以
Dialogue: 0,0:41:20.21,0:41:21.24,Default,,0,0,0,,它相当复杂
Dialogue: 0,0:41:21.72,0:41:23.64,Default,,0,0,0,,因为你们放弃了对事先安排的
Dialogue: 0,0:41:23.77,0:41:25.72,Default,,0,0,0,,求值顺序的控制权
Dialogue: 0,0:41:27.15,0:41:30.16,Default,,0,0,0,,学生：这就表明 当你有一个函数式映射时
Dialogue: 0,0:41:30.67,0:41:32.51,Default,,0,0,0,,而你最初在讲这门课的时候
Dialogue: 0,0:41:32.99,0:41:34.08,Default,,0,0,0,,你说过
Dialogue: 0,0:41:34.67,0:41:36.70,Default,,0,0,0,,我们在表述作为关系的陈述性知识
Dialogue: 0,0:41:37.15,0:41:38.81,Default,,0,0,0,,因为我们讨论的不是输入和输出
Dialogue: 0,0:41:41.21,0:41:43.37,Default,,0,0,0,,教授：这是关于“函数式”的双关语
Dialogue: 0,0:41:43.37,0:41:45.79,Default,,0,0,0,,一种是没有副作用
Dialogue: 0,0:41:46.20,0:41:48.16,Default,,0,0,0,,因此并不依赖于求值的顺序
Dialogue: 0,0:41:48.70,0:41:51.04,Default,,0,0,0,,还有就是数学意义上的“函数”
Dialogue: 0,0:41:51.07,0:41:52.22,Default,,0,0,0,,有关于输入和输出
Dialogue: 0,0:41:52.59,0:41:54.36,Default,,0,0,0,,我想这就是你想表达的双关
Dialogue: 0,0:41:56.51,0:41:58.51,Default,,0,0,0,,学生：我对其中两条语句不太明白
Dialogue: 0,0:41:58.81,0:42:00.70,Default,,0,0,0,,也就是那两条有关BOSS的语句
Dialogue: 0,0:42:01.27,0:42:05.74,Default,,0,0,0,,是不是 第一条查询构建了一个数据库
Dialogue: 0,0:42:05.76,0:42:08.08,Default,,0,0,0,,然后第二条查询--
Dialogue: 0,0:42:09.07,0:42:10.12,Default,,0,0,0,,教授：抱歉
Dialogue: 0,0:42:12.44,0:42:15.16,Default,,0,0,0,,这里的意思是 如果我输入这样的查询
Dialogue: 0,0:42:16.12,0:42:18.44,Default,,0,0,0,,我应该最初就给你们举这个例子
Dialogue: 0,0:42:19.47,0:42:23.52,Default,,0,0,0,,如果我输入(JOB (BITDIDDLE BEN) (COMPUTER WIZARD))
Dialogue: 0,0:42:25.04,0:42:27.77,Default,,0,0,0,,系统会找到一处事实
Dialogue: 0,0:42:28.30,0:42:30.28,Default,,0,0,0,,来完全匹配这条查询
Dialogue: 0,0:42:30.86,0:42:33.28,Default,,0,0,0,,然后输出(JOB (BITDIDDLE BEN) (COMPUTER WIZARD))
Dialogue: 0,0:42:34.22,0:42:35.60,Default,,0,0,0,,如果没找到这样的匹配
Dialogue: 0,0:42:35.69,0:42:36.75,Default,,0,0,0,,它就什么也不输出
Dialogue: 0,0:42:37.40,0:42:39.55,Default,,0,0,0,,我应该这么来表述
Dialogue: 0,0:42:39.56,0:42:42.27,Default,,0,0,0,,这门语言是用来查询某个表述是否为真
Dialogue: 0,0:42:43.40,0:42:45.77,Default,,0,0,0,,这是逻辑式编程的目的之一
Dialogue: 0,0:42:46.41,0:42:49.34,Default,,0,0,0,,输入一条查询 要么得到结果 要么没有
Dialogue: 0,0:42:50.68,0:42:52.38,Default,,0,0,0,,因此 我这里想要演示的是
Dialogue: 0,0:42:52.41,0:42:54.80,Default,,0,0,0,,我想要在介绍合一算法前
Dialogue: 0,0:42:54.83,0:42:56.62,Default,,0,0,0,,举一个简单的例子
Dialogue: 0,0:42:57.48,0:42:58.11,Default,,0,0,0,,所以 我应该说
Dialogue: 0,0:42:58.14,0:43:00.96,Default,,0,0,0,,如果我想要检查 这个是否为真
Dialogue: 0,0:43:01.18,0:43:03.28,Default,,0,0,0,,我就可以将它输入 并看有没有任何输出
Dialogue: 0,0:43:05.16,0:43:06.27,Default,,0,0,0,,学生：然后第二条查询
Dialogue: 0,0:43:06.28,0:43:07.84,Default,,0,0,0,,教授：第二条就是真正意义上的“查询”
Dialogue: 0,0:43:07.88,0:43:09.12,Default,,0,0,0,,学生：好的 真正的查询
Dialogue: 0,0:43:10.77,0:43:13.10,Default,,0,0,0,,教授：在这里它就会输出与?WHO相关的信息
Dialogue: 0,0:43:13.90,0:43:15.74,Default,,0,0,0,,就会有一个框架 存储着
Dialogue: 0,0:43:16.62,0:43:18.81,Default,,0,0,0,,?Z=?WHO ?D=COMPUTER
Dialogue: 0,0:43:19.56,0:43:20.49,Default,,0,0,0,,这个会传递下去
Dialogue: 0,0:43:20.51,0:43:21.95,Default,,0,0,0,,传递到这里的时候
Dialogue: 0,0:43:22.01,0:43:23.25,Default,,0,0,0,,?WHO就会被绑定起来
Dialogue: 0,0:43:26.95,0:43:28.76,Default,,0,0,0,,学生：在合一那里
Dialogue: 0,0:43:29.18,0:43:35.96,Default,,0,0,0,,我还是不太清楚?WHO和?Z之间发生了什么
Dialogue: 0,0:43:36.46,0:43:39.58,Default,,0,0,0,,要进行合一的话 这里的规则说
Dialogue: 0,0:43:42.03,0:43:46.22,Default,,0,0,0,,你说过 两个模式变量之间不能互相绑定
Dialogue: 0,0:43:46.26,0:43:48.08,Default,,0,0,0,,教授：模式匹配器确实不能这样
Dialogue: 0,0:43:48.36,0:43:50.83,Default,,0,0,0,,但对合一算法来说
Dialogue: 0,0:43:51.92,0:43:54.01,Default,,0,0,0,,就是一个有存储三个变量的环境
Dialogue: 0,0:43:56.69,0:43:57.90,Default,,0,0,0,,其中?D=COMPUTER
Dialogue: 0,0:43:58.52,0:44:00.19,Default,,0,0,0,,?Z=?WHO
Dialogue: 0,0:44:01.83,0:44:05.26,Default,,0,0,0,,所以在稍后的匹配过程中
Dialogue: 0,0:44:07.20,0:44:10.38,Default,,0,0,0,,如果?WHO=3
Dialogue: 0,0:44:12.06,0:44:13.66,Default,,0,0,0,,那么当我再查找字典的时候
Dialogue: 0,0:44:14.00,0:44:16.40,Default,,0,0,0,,它会告诉我 因为?Z=?WHO 所以?Z=3
Dialogue: 0,0:44:18.36,0:44:20.44,Default,,0,0,0,,从某种意义上来说 你就只需要修改这一点
Dialogue: 0,0:44:20.46,0:44:21.98,Default,,0,0,0,,就可以把合一算法变成模式匹配器
Dialogue: 0,0:44:22.48,0:44:24.80,Default,,0,0,0,,学生：但是看起来你好像告诉了它 如何进行合一
Dialogue: 0,0:44:24.83,0:44:26.96,Default,,0,0,0,,就像你已经解好了方程 准备好了值
Dialogue: 0,0:44:26.99,0:44:29.23,Default,,0,0,0,,并把它们安排成这样
Dialogue: 0,0:44:29.77,0:44:31.24,Default,,0,0,0,,现在看起来就像是
Dialogue: 0,0:44:31.28,0:44:32.83,Default,,0,0,0,,你传递了一本字典
Dialogue: 0,0:44:32.88,0:44:34.86,Default,,0,0,0,,其中的两个变量是关联起来的
Dialogue: 0,0:44:34.88,0:44:37.23,Default,,0,0,0,,教授：实际上 我们在同时求解它们
Dialogue: 0,0:44:37.52,0:44:39.74,Default,,0,0,0,,这是因为我们想要一下得到整个答案
Dialogue: 0,0:44:40.54,0:44:42.81,Default,,0,0,0,,如果你观察它们是如何被递归地构建的
Dialogue: 0,0:44:42.81,0:44:43.74,Default,,0,0,0,,基本上就是这样了
Dialogue: 0,0:44:44.98,0:44:48.40,Default,,0,0,0,,学生：也就是确实要传递含有两个变量的字典？
Dialogue: 0,0:44:48.40,0:44:49.11,Default,,0,0,0,,教授：是的
Dialogue: 0,0:44:49.11,0:44:49.68,Default,,0,0,0,,学生：然后把它们关联起来？
Dialogue: 0,0:44:50.38,0:44:52.91,Default,,0,0,0,,教授：就像通常的字典那样
Dialogue: 0,0:44:54.35,0:44:56.06,Default,,0,0,0,,学生：你在讨论合一算法的时候
Dialogue: 0,0:44:56.09,0:45:00.19,Default,,0,0,0,,你说过在某些情况下
Dialogue: 0,0:45:00.75,0:45:03.98,Default,,0,0,0,,合一不能够完成
Dialogue: 0,0:45:04.03,0:45:04.30,Default,,0,0,0,,教授：是的
Dialogue: 0,0:45:04.97,0:45:08.46,Default,,0,0,0,,学生：那么 是否可以通过编写规则
Dialogue: 0,0:45:09.16,0:45:15.93,Default,,0,0,0,,或者 写入那些事先知道可解的形式
Dialogue: 0,0:45:16.48,0:45:18.54,Default,,0,0,0,,来使得合一算法能够完成
Dialogue: 0,0:45:18.76,0:45:22.94,Default,,0,0,0,,是否可以在规则中添加一些属性
Dialogue: 0,0:45:23.18,0:45:25.45,Default,,0,0,0,,或者向输入的形式中添加属性
Dialogue: 0,0:45:25.82,0:45:29.04,Default,,0,0,0,,来避免无法进行合一的窘境
Dialogue: 0,0:45:29.18,0:45:31.15,Default,,0,0,0,,PROFESSOR: 我想 你也同意
Dialogue: 0,0:45:31.47,0:45:35.26,Default,,0,0,0,,用非常受限的方式来编写查询
Dialogue: 0,0:45:35.60,0:45:36.67,Default,,0,0,0,,看 你遇到的是
Dialogue: 0,0:45:36.88,0:45:39.12,Default,,0,0,0,,仔细看 你遇到问题是在
Dialogue: 0,0:45:39.68,0:45:44.25,Default,,0,0,0,,用像这样的东西去匹配
Dialogue: 0,0:45:44.59,0:45:47.20,Default,,0,0,0,,具有这样结构的模式时
Dialogue: 0,0:45:47.55,0:45:55.30,Default,,0,0,0,,比如((A ?Y B) ?Y)
Dialogue: 0,0:45:58.98,0:46:01.48,Default,,0,0,0,,这是你可能遇到问题的一个地方
Dialogue: 0,0:46:03.07,0:46:05.80,Default,,0,0,0,,学生：所以你可以在语法层次上处理它么？
Dialogue: 0,0:46:06.14,0:46:08.76,Default,,0,0,0,,教授：你可以在写查询时
Dialogue: 0,0:46:08.76,0:46:10.49,Default,,0,0,0,,注意你的规则
Dialogue: 0,0:46:11.90,0:46:14.08,Default,,0,0,0,,学生：这个问题应该由
Dialogue: 0,0:46:14.11,0:46:16.27,Default,,0,0,0,,数据库的构建者考虑么？
Dialogue: 0,0:46:16.57,0:46:17.80,Default,,0,0,0,,教授：这个问题
Dialogue: 0,0:46:19.93,0:46:22.01,Default,,0,0,0,,不完全是数据库的构建者
Dialogue: 0,0:46:22.04,0:46:23.61,Default,,0,0,0,,或者是表述规则的人
Dialogue: 0,0:46:24.01,0:46:25.31,Default,,0,0,0,,所需要考虑的
Dialogue: 0,0:46:25.80,0:46:29.79,Default,,0,0,0,,当你们仔细审查合一算法的代码时
Dialogue: 0,0:46:29.92,0:46:31.87,Default,,0,0,0,,你们会发现
Dialogue: 0,0:46:32.41,0:46:34.76,Default,,0,0,0,,它实际上在查询一个字典
Dialogue: 0,0:46:34.94,0:46:36.83,Default,,0,0,0,,它会问 ?Y的取值应该是什么？
Dialogue: 0,0:46:37.26,0:46:41.42,Default,,0,0,0,,?Y应该是一个含有自包含的表达式么？
Dialogue: 0,0:46:41.96,0:46:43.26,Default,,0,0,0,,这时候 合一算法就会说
Dialogue: 0,0:46:43.28,0:46:46.24,Default,,0,0,0,,哦 我正在求解一个不动点方程
Dialogue: 0,0:46:46.24,0:46:46.99,Default,,0,0,0,,我还是放弃吧
Dialogue: 0,0:46:48.59,0:46:51.91,Default,,0,0,0,,学生：你区分过数据库中的规则
Dialogue: 0,0:46:51.91,0:46:56.48,Default,,0,0,0,,这些规则是加入数据库的么？
Dialogue: 0,0:46:56.95,0:46:57.36,Default,,0,0,0,,教授：是的
Dialogue: 0,0:46:57.87,0:46:58.87,Default,,0,0,0,,我应该这么来说
Dialogue: 0,0:46:58.87,0:47:00.33,Default,,0,0,0,,你们可以把规则看作
Dialogue: 0,0:47:00.60,0:47:02.65,Default,,0,0,0,,数据库中的其它东西
Dialogue: 0,0:47:03.71,0:47:06.81,Default,,0,0,0,,如果你想要检查数据库中需要检查的东西
Dialogue: 0,0:47:06.83,0:47:09.44,Default,,0,0,0,,它们就是存在于数据库中的虚拟事实
Dialogue: 0,0:47:09.44,0:47:12.32,Default,,0,0,0,,学生：但是在这个解释中
Dialogue: 0,0:47:12.43,0:47:17.26,Default,,0,0,0,,你就已经区分了数据库和规则本身
Dialogue: 0,0:47:18.23,0:47:19.90,Default,,0,0,0,,教授：是的 我应该不这么来说
Dialogue: 0,0:47:20.49,0:47:23.31,Default,,0,0,0,,这样做的唯一理由就是实现
Dialogue: 0,0:47:23.54,0:47:24.67,Default,,0,0,0,,当你们查看具体实现时
Dialogue: 0,0:47:24.68,0:47:27.50,Default,,0,0,0,,会发现其中有部分用来检查数据库中的
Dialogue: 0,0:47:27.55,0:47:29.85,Default,,0,0,0,,基本断言或者规则
Dialogue: 0,0:47:30.47,0:47:32.72,Default,,0,0,0,,这其中的真正原因就是
Dialogue: 0,0:47:32.78,0:47:34.56,Default,,0,0,0,,你不知道查询结果是以什么顺序输出的
Dialogue: 0,0:47:34.96,0:47:40.46,Default,,0,0,0,,而规则数据库和数据数据库
Dialogue: 0,0:47:40.48,0:47:43.68,Default,,0,0,0,,是通过某种延迟求值的方式合并的
Dialogue: 0,0:47:44.60,0:47:46.80,Default,,0,0,0,,这就使得顺序变得非常复杂
Dialogue: 0,0:47:55.44,0:47:56.09,Default,,0,0,0,,那好 我们休息一下
Dialogue: 0,0:47:56.30,0:48:09.90,Default,,0,0,0,,[音乐]
Dialogue: 0,0:48:10.04,0:48:14.41,Declare,,0,0,0,,{\an2\fad(500,500)}《计算机程序的构造和解释》
Dialogue: 0,0:48:18.68,0:48:22.09,Declare,,0,0,0,,{\an2\fad(500,500)}讲师：哈罗德·艾伯森教授 及 格兰德·杰·萨斯曼教授
Dialogue: 0,0:48:22.09,0:48:25.96,Declare,,0,0,0,,{\an2\fad(500,500)}《计算机程序的构造和解释》
Dialogue: 0,0:48:26.00,0:48:29.87,Declare,,0,0,0,,{\an2\fad(500,500)}逻辑式程序设计 II
Dialogue: 0,0:48:33.16,0:48:35.37,Default,,0,0,0,,我们已经学习了逻辑式语言与
Dialogue: 0,0:48:35.39,0:48:36.41,Default,,0,0,0,,规则系统的运行原理
Dialogue: 0,0:48:37.23,0:48:39.37,Default,,0,0,0,,现在 让我们来探讨一个更加深刻的问题
Dialogue: 0,0:48:40.12,0:48:41.28,Default,,0,0,0,,来看下它们意味着什么
Dialogue: 0,0:48:43.18,0:48:46.86,Default,,0,0,0,,这把我们带入到整个查询语言中
Dialogue: 0,0:48:46.99,0:48:48.67,Default,,0,0,0,,最微妙的部分
Dialogue: 0,0:48:49.21,0:48:53.07,Default,,0,0,0,,也就是它看起来与想象中不同的地方
Dialogue: 0,0:48:53.57,0:48:56.22,Default,,0,0,0,,AND、OR以及NOT
Dialogue: 0,0:48:57.02,0:48:58.88,Default,,0,0,0,,以及规则的逻辑蕴含
Dialogue: 0,0:48:59.69,0:49:06.64,Default,,0,0,0,,并不是逻辑学中的与、或、非以及蕴含
Dialogue: 0,0:49:07.69,0:49:09.71,Default,,0,0,0,,让我来举一个实例
Dialogue: 0,0:49:09.91,0:49:12.22,Default,,0,0,0,,当然 如果我们有两个逻辑命题
Dialogue: 0,0:49:12.40,0:49:19.44,Default,,0,0,0,,那么(AND P Q)就应该
Dialogue: 0,0:49:20.00,0:49:22.59,Default,,0,0,0,,等同于(AND Q P)
Dialogue: 0,0:49:23.10,0:49:24.51,Default,,0,0,0,,而(OR P Q)就应该
Dialogue: 0,0:49:24.78,0:49:26.51,Default,,0,0,0,,等同于(OR Q P)
Dialogue: 0,0:49:28.67,0:49:30.09,Default,,0,0,0,,但我们来看看这里
Dialogue: 0,0:49:30.10,0:49:32.01,Default,,0,0,0,,这里是一个例子
Dialogue: 0,0:49:32.18,0:49:36.16,Default,,0,0,0,,来看看 在我们的数据库中
Dialogue: 0,0:49:36.28,0:49:40.14,Default,,0,0,0,,如何表示某人的级别高于他人
Dialogue: 0,0:49:40.14,0:49:42.89,Default,,0,0,0,,我们定义(OUTRANKED-BY ?S ?B)为
Dialogue: 0,0:49:44.64,0:49:48.62,Default,,0,0,0,,或者S是B的上司
Dialogue: 0,0:49:49.63,0:49:51.07,Default,,0,0,0,,或者这其中有某个中间经理M
Dialogue: 0,0:49:51.10,0:49:55.82,Default,,0,0,0,,其中S是M的上司 M的级别又比B高
Dialogue: 0,0:49:59.64,0:50:02.31,Default,,0,0,0,,这是定义OUTRANKED-BY的一种方式
Dialogue: 0,0:50:02.31,0:50:04.16,Default,,0,0,0,,或者我们可以原封不动地写过来
Dialogue: 0,0:50:05.08,0:50:06.91,Default,,0,0,0,,除了在最底部的这里
Dialogue: 0,0:50:07.21,0:50:09.88,Default,,0,0,0,,我们颠倒一下这两个子句的顺序
Dialogue: 0,0:50:11.63,0:50:12.99,Default,,0,0,0,,当然 如果它们都是逻辑表达式的话
Dialogue: 0,0:50:13.00,0:50:14.88,Default,,0,0,0,,它们应该表示的是相同的东西
Dialogue: 0,0:50:16.69,0:50:17.31,Default,,0,0,0,,然而
Dialogue: 0,0:50:17.71,0:50:19.61,Default,,0,0,0,,在我们这个特定的实现中
Dialogue: 0,0:50:19.64,0:50:22.88,Default,,0,0,0,,如果你查询(OUTRANDKED-BY ?WHO (BITDIIDLE BEN))
Dialogue: 0,0:50:23.48,0:50:25.36,Default,,0,0,0,,你会发现 这条规则
Dialogue: 0,0:50:26.76,0:50:28.72,Default,,0,0,0,,会完美地生成答案
Dialogue: 0,0:50:30.04,0:50:31.98,Default,,0,0,0,,然而 这条规则会陷入无穷循环
Dialogue: 0,0:50:34.11,0:50:36.27,Default,,0,0,0,,其中的原因就是
Dialogue: 0,0:50:36.33,0:50:40.33,Default,,0,0,0,,这条规则会问谁比BEN BITDIDDLE级别高？
Dialogue: 0,0:50:41.92,0:50:43.53,Default,,0,0,0,,它试图寻找一个S
Dialogue: 0,0:50:43.88,0:50:46.22,Default,,0,0,0,,使得S比B的级别更高 其中B是BEN BITDIDDLE
Dialogue: 0,0:50:47.50,0:50:49.63,Default,,0,0,0,,这会在一个子问题中重复出现
Dialogue: 0,0:50:50.33,0:50:51.98,Default,,0,0,0,,找到一个M
Dialogue: 0,0:50:52.24,0:50:54.57,Default,,0,0,0,,使得M的级别高于BEN BITDIDDLE
Dialogue: 0,0:50:55.61,0:50:57.36,Default,,0,0,0,,而对M没有限制
Dialogue: 0,0:50:58.56,0:51:00.40,Default,,0,0,0,,这就相当于为了解决这个问题
Dialogue: 0,0:51:01.42,0:51:03.29,Default,,0,0,0,,我就还需要求解同样的问题
Dialogue: 0,0:51:04.57,0:51:07.23,Default,,0,0,0,,在把它解出来后 我才检查SUPERVISOR关系
Dialogue: 0,0:51:08.00,0:51:09.16,Default,,0,0,0,,然而这条规则没有这样的问题
Dialogue: 0,0:51:09.18,0:51:12.35,Default,,0,0,0,,因为在它尝试找出这条OUTRANKED-BY规则之前
Dialogue: 0,0:51:12.94,0:51:15.26,Default,,0,0,0,,在这里已经对M施加过约束了
Dialogue: 0,0:51:18.38,0:51:20.94,Default,,0,0,0,,随意 这两条规则理论上是相同的
Dialogue: 0,0:51:20.99,0:51:22.67,Default,,0,0,0,,但实际上 其中一条会陷入无穷循环
Dialogue: 0,0:51:22.86,0:51:25.04,Default,,0,0,0,,而另一条不会
Dialogue: 0,0:51:26.72,0:51:29.77,Default,,0,0,0,,通过这个非常极端的例子
Dialogue: 0,0:51:29.79,0:51:32.65,Default,,0,0,0,,你会发现在逻辑式程序设计中
Dialogue: 0,0:51:34.28,0:51:38.70,Default,,0,0,0,,如果你改变了AND或OR所连接子句的顺序
Dialogue: 0,0:51:39.34,0:51:41.58,Default,,0,0,0,,你会发现效率上的巨大差异
Dialogue: 0,0:51:42.24,0:51:43.21,Default,,0,0,0,,我们刚刚就看到了
Dialogue: 0,0:51:43.55,0:51:46.54,Default,,0,0,0,,在无穷循环方面的巨大差异
Dialogue: 0,0:51:49.19,0:51:51.74,Default,,0,0,0,,同样的 这也跟输入规则
Dialogue: 0,0:51:52.00,0:51:53.31,Default,,0,0,0,,的顺序有关
Dialogue: 0,0:51:54.07,0:51:56.48,Default,,0,0,0,,向数据库查询规则的顺序
Dialogue: 0,0:51:56.70,0:51:59.95,Default,,0,0,0,,会极大程度上影响效率：比如得到答案
Dialogue: 0,0:52:00.46,0:52:02.60,Default,,0,0,0,,或者在某些顺序下陷入无穷循环
Dialogue: 0,0:52:03.84,0:52:07.29,Default,,0,0,0,,这些都跟
Dialogue: 0,0:52:07.63,0:52:10.04,Default,,0,0,0,,你检查这些规则的顺序有关
Dialogue: 0,0:52:10.95,0:52:14.41,Default,,0,0,0,,有些规则的蕴含路径会相当的长
Dialogue: 0,0:52:14.44,0:52:16.06,Default,,0,0,0,,而另外一些不会
Dialogue: 0,0:52:16.44,0:52:17.68,Default,,0,0,0,,但你事先并不知道
Dialogue: 0,0:52:17.72,0:52:19.16,Default,,0,0,0,,哪一个长 哪一个短
Dialogue: 0,0:52:19.30,0:52:21.48,Default,,0,0,0,,有很多研究都与此有关
Dialogue: 0,0:52:22.16,0:52:23.76,Default,,0,0,0,,其中大多数都是想通过
Dialogue: 0,0:52:23.95,0:52:26.97,Default,,0,0,0,,用并行的方法来实现逻辑式程序设计语言
Dialogue: 0,0:52:27.32,0:52:29.90,Default,,0,0,0,,某种意义上来说 就是并行地检查所有规则
Dialogue: 0,0:52:30.36,0:52:32.80,Default,,0,0,0,,一旦有一条搜索得到答案 就返回结果
Dialogue: 0,0:52:33.04,0:52:34.99,Default,,0,0,0,,如果某条路径陷入了无穷的推导
Dialogue: 0,0:52:35.02,0:52:38.25,Default,,0,0,0,,那么 你只需知道 内存和处理器都非常廉价
Dialogue: 0,0:52:38.28,0:52:40.49,Default,,0,0,0,,让它们根据你的需要一直搜寻就好了
Dialogue: 0,0:52:43.47,0:52:44.83,Default,,0,0,0,,尽管如此 与真正的逻辑相比
Dialogue: 0,0:52:45.18,0:52:50.49,Default,,0,0,0,,这门逻辑式语言还有一个更深刻的问题
Dialogue: 0,0:52:50.68,0:52:52.52,Default,,0,0,0,,我给你们演示的例子
Dialogue: 0,0:52:52.97,0:52:54.80,Default,,0,0,0,,只是会陷入无穷循环
Dialogue: 0,0:52:55.37,0:52:56.99,Default,,0,0,0,,但至少不会给你错误的答案
Dialogue: 0,0:52:58.37,0:53:03.64,Default,,0,0,0,,当我们开始严肃地把这门逻辑式语言
Dialogue: 0,0:53:03.68,0:53:05.24,Default,,0,0,0,,与真正的经典逻辑作比较时
Dialogue: 0,0:53:05.71,0:53:08.46,Default,,0,0,0,,就会发现其中最深层次的问题
Dialogue: 0,0:53:09.49,0:53:12.43,Default,,0,0,0,,让我们来看看真正的经典逻辑
Dialogue: 0,0:53:13.71,0:53:21.04,Default,,0,0,0,,所有的人类都是凡人
Dialogue: 0,0:53:22.35,0:53:23.45,Default,,0,0,0,,相当经典的逻辑命题
Dialogue: 0,0:53:24.39,0:53:28.67,Default,,0,0,0,,然后我们就依照最经典的传统
Dialogue: 0,0:53:29.24,0:53:32.46,Default,,0,0,0,,我们按照最传统的方式来做
Dialogue: 0,0:53:32.67,0:53:37.16,Default,,0,0,0,,所有的希腊人都是人类
Dialogue: 0,0:53:40.49,0:53:46.06,Default,,0,0,0,,苏格拉底是希腊人
Dialogue: 0,0:53:48.17,0:53:49.21,Default,,0,0,0,,然后我们又该写什么呢？
Dialogue: 0,0:53:49.21,0:53:51.89,Default,,0,0,0,,经典逻辑中有一个三点符号
Dialogue: 0,0:53:51.89,0:53:54.33,Default,,0,0,0,,因此 我们得到了一个三段论
Dialogue: 0,0:53:54.64,0:53:59.55,Default,,0,0,0,,苏格拉底是凡人
Dialogue: 0,0:54:01.36,0:54:04.91,Default,,0,0,0,,这些都是真正的经典逻辑
Dialogue: 0,0:54:05.88,0:54:11.05,Default,,0,0,0,,把它跟我们经典逻辑数据库比较一下
Dialogue: 0,0:54:12.40,0:54:14.46,Default,,0,0,0,,这是一个经典逻辑数据库
Dialogue: 0,0:54:16.27,0:54:17.48,Default,,0,0,0,,(GREEK SOCRATES)
Dialogue: 0,0:54:18.03,0:54:18.84,Default,,0,0,0,,(GREEK PLATO)
Dialogue: 0,0:54:19.60,0:54:20.40,Default,,0,0,0,,(GREEK ZEUS)
Dialogue: 0,0:54:20.84,0:54:21.98,Default,,0,0,0,,(GOD ZEUS)
Dialogue: 0,0:54:24.12,0:54:29.96,Default,,0,0,0,,所有的人类都是凡人
Dialogue: 0,0:54:30.54,0:54:32.12,Default,,0,0,0,,为了证明某人是平凡的
Dialogue: 0,0:54:32.16,0:54:33.60,Default,,0,0,0,,只需要证明他是人类
Dialogue: 0,0:54:34.65,0:54:35.90,Default,,0,0,0,,所有的人类都是不可靠的
Dialogue: 0,0:54:38.90,0:54:40.98,Default,,0,0,0,,并且说所有的希腊人都是人类 并不正确
Dialogue: 0,0:54:40.98,0:54:44.41,Default,,0,0,0,,这条规则说 所有不是神的希腊人都是人类
Dialogue: 0,0:54:45.71,0:54:47.04,Default,,0,0,0,,因此为了证明某人是人类
Dialogue: 0,0:54:47.07,0:54:48.89,Default,,0,0,0,,只需要说明他是一个希腊人 并且不是神
Dialogue: 0,0:54:49.32,0:54:52.88,Default,,0,0,0,,任何一个希腊神的住址是奥林匹斯山
Dialogue: 0,0:54:54.32,0:54:57.16,Default,,0,0,0,,这就是一个小型经典逻辑数据库
Dialogue: 0,0:54:57.39,0:54:59.32,Default,,0,0,0,,确实 它运行得相当好
Dialogue: 0,0:54:59.49,0:55:02.09,Default,,0,0,0,,如果我们向其询问
Dialogue: 0,0:55:03.47,0:55:06.57,Default,,0,0,0,,苏格拉底是凡人么 不可靠么？
Dialogue: 0,0:55:06.91,0:55:07.69,Default,,0,0,0,,它会输出：是
Dialogue: 0,0:55:07.77,0:55:09.71,Default,,0,0,0,,柏拉图是凡人并且不可靠么？
Dialogue: 0,0:55:09.71,0:55:10.24,Default,,0,0,0,,它会回答：是
Dialogue: 0,0:55:10.68,0:55:12.21,Default,,0,0,0,,如果我们问宙斯是凡人么
Dialogue: 0,0:55:12.21,0:55:13.23,Default,,0,0,0,,它什么都不会找到
Dialogue: 0,0:55:14.90,0:55:15.96,Default,,0,0,0,,运行得非常完美
Dialogue: 0,0:55:16.54,0:55:20.12,Default,,0,0,0,,然而 如果我们想要把它扩展一下
Dialogue: 0,0:55:20.12,0:55:23.05,Default,,0,0,0,,让我们来定义一下什么是“完美生命体”
Dialogue: 0,0:55:23.82,0:55:27.21,Default,,0,0,0,,我们把规则PERFECT定义为
Dialogue: 0,0:55:34.05,0:55:35.48,Default,,0,0,0,,我想这样来定义是正确的
Dialogue: 0,0:55:35.48,0:55:38.14,Default,,0,0,0,,如果你熟悉中世纪经院哲学
Dialogue: 0,0:55:38.44,0:55:40.17,Default,,0,0,0,,我想所谓“完美生命体”一定
Dialogue: 0,0:55:40.68,0:55:42.65,Default,,0,0,0,,既不是凡人 又不会不可靠
Dialogue: 0,0:55:44.10,0:55:56.84,Default,,0,0,0,,(AND (NOT (MORTAL ?X)) (NOT (FALLIBLE ?X)))
Dialogue: 0,0:55:59.30,0:56:00.89,Default,,0,0,0,,这样 我们就定义了一个规则
Dialogue: 0,0:56:02.67,0:56:04.36,Default,,0,0,0,,来告诉系统 什么是“完美生命体”
Dialogue: 0,0:56:05.79,0:56:07.69,Default,,0,0,0,,现在 我们就要
Dialogue: 0,0:56:08.06,0:56:10.17,Default,,0,0,0,,询问所有“完美生命体”的地址
Dialogue: 0,0:56:11.48,0:56:22.30,Default,,0,0,0,,(AND (ADDRESS ?X ?Y) (PERFECT ?X))
Dialogue: 0,0:56:23.48,0:56:24.97,Default,,0,0,0,,在这里 我们生成了
Dialogue: 0,0:56:24.99,0:56:27.80,Default,,0,0,0,,世界上最独有的邮件列表
Dialogue: 0,0:56:30.16,0:56:32.20,Default,,0,0,0,,为了查询所有完美生命体的地址
Dialogue: 0,0:56:32.24,0:56:33.47,Default,,0,0,0,,我们会输入像这样的查询
Dialogue: 0,0:56:33.83,0:56:35.44,Default,,0,0,0,,或者像这样输入
Dialogue: 0,0:56:36.24,0:56:50.57,Default,,0,0,0,,(AND (PERFECT ?X) (ADDRESS ?X ?Y))
Dialogue: 0,0:56:52.06,0:56:54.96,Default,,0,0,0,,假设我们把它输入进去 并尝试查询
Dialogue: 0,0:56:55.19,0:56:56.76,Default,,0,0,0,,这条查询会给我们答案
Dialogue: 0,0:56:57.65,0:57:00.00,Default,,0,0,0,,这条查询会输出：奥林匹斯山
Dialogue: 0,0:57:04.23,0:57:06.57,Default,,0,0,0,,而这条查询 什么也不会输出
Dialogue: 0,0:57:06.74,0:57:09.58,Default,,0,0,0,,它找不到完美生命体的地址
Dialogue: 0,0:57:11.64,0:57:12.51,Default,,0,0,0,,为什么会这样？
Dialogue: 0,0:57:12.51,0:57:13.44,Default,,0,0,0,,这又为什么不同？
Dialogue: 0,0:57:14.23,0:57:15.69,Default,,0,0,0,,这个问题跟无穷循环没什么关系
Dialogue: 0,0:57:15.69,0:57:17.08,Default,,0,0,0,,这个的问题是答案不相同
Dialogue: 0,0:57:19.48,0:57:20.09,Default,,0,0,0,,原因就是
Dialogue: 0,0:57:20.38,0:57:22.32,Default,,0,0,0,,如果你们还记得NOT的实现的话
Dialogue: 0,0:57:23.50,0:57:24.84,Default,,0,0,0,,NOT是作为一个过滤器
Dialogue: 0,0:57:25.88,0:57:29.00,Default,,0,0,0,,NOT会接收一本字典
Dialogue: 0,0:57:29.05,0:57:31.56,Default,,0,0,0,,里面有可行解构成的框架
Dialogue: 0,0:57:31.79,0:57:33.16,Default,,0,0,0,,然后过滤出那些
Dialogue: 0,0:57:33.29,0:57:34.94,Default,,0,0,0,,满足某个条件的解
Dialogue: 0,0:57:34.97,0:57:36.11,Default,,0,0,0,,这就是我如何实现NOT的
Dialogue: 0,0:57:36.92,0:57:38.43,Default,,0,0,0,,如果你们仔细想想其中的原理
Dialogue: 0,0:57:40.11,0:57:42.65,Default,,0,0,0,,我创建了一个查询盒子
Dialogue: 0,0:57:43.32,0:57:47.39,Default,,0,0,0,,ADDRESS盒子的输出作为了PERFECT的输入
Dialogue: 0,0:57:50.29,0:57:51.00,Default,,0,0,0,,这就使得
Dialogue: 0,0:57:51.32,0:57:53.26,Default,,0,0,0,,ADDRESS盒子会创建出
Dialogue: 0,0:57:53.32,0:57:54.83,Default,,0,0,0,,我知道地址的人
Dialogue: 0,0:57:55.29,0:57:57.64,Default,,0,0,0,,这些都会被PERFECT中的NOT给过滤掉
Dialogue: 0,0:57:59.88,0:58:04.19,Default,,0,0,0,,所以它会丢弃掉那些满足平凡的或者不可靠的数据
Dialogue: 0,0:58:04.91,0:58:06.38,Default,,0,0,0,,而对于另外一种顺序来说
Dialogue: 0,0:58:06.73,0:58:09.12,Default,,0,0,0,,我以一个空框架开始的
Dialogue: 0,0:58:09.52,0:58:12.35,Default,,0,0,0,,但是这里PERFECT没有可以给NOT过滤的东西
Dialogue: 0,0:58:12.38,0:58:13.98,Default,,0,0,0,,所以这里不会有什么输出
Dialogue: 0,0:58:18.83,0:58:21.50,Default,,0,0,0,,这也就导致没有东西输入到ADDRESS中
Dialogue: 0,0:58:21.94,0:58:23.15,Default,,0,0,0,,因此 我得不到答案
Dialogue: 0,0:58:23.93,0:58:27.04,Default,,0,0,0,,在强调一下 这是因为NOT不会生成任何东西
Dialogue: 0,0:58:27.44,0:58:28.80,Default,,0,0,0,,NOT只会丢弃数据
Dialogue: 0,0:58:29.08,0:58:30.51,Default,,0,0,0,,如果我不向NOT传递东西的话
Dialogue: 0,0:58:30.52,0:58:31.74,Default,,0,0,0,,它也就不会输出
Dialogue: 0,0:58:32.02,0:58:33.77,Default,,0,0,0,,这样我就得到了错误的答案
Dialogue: 0,0:58:37.20,0:58:37.97,Default,,0,0,0,,我们又该如何修复它呢？
Dialogue: 0,0:58:37.97,0:58:39.07,Default,,0,0,0,,当然 有很多办法
Dialogue: 0,0:58:39.36,0:58:40.91,Default,,0,0,0,,你可能认为 现在这样有点愚蠢
Dialogue: 0,0:58:41.41,0:58:44.90,Default,,0,0,0,,为什么要一开始就执行NOT呢？
Dialogue: 0,0:58:44.96,0:58:47.48,Default,,0,0,0,,想要正确地实现NOT
Dialogue: 0,0:58:47.84,0:58:50.08,Default,,0,0,0,,就是要认识到当你遇到NOT时
Dialogue: 0,0:58:50.33,0:58:52.09,Default,,0,0,0,,你应该首先生成好答案
Dialogue: 0,0:58:52.80,0:58:54.97,Default,,0,0,0,,然后通过字典把它们传递过来
Dialogue: 0,0:58:55.52,0:58:57.85,Default,,0,0,0,,然后再最后再做过滤
Dialogue: 0,0:58:58.56,0:59:02.01,Default,,0,0,0,,有些按照这种方式实现的逻辑式语言
Dialogue: 0,0:59:02.41,0:59:04.05,Default,,0,0,0,,能够解决这个问题
Dialogue: 0,0:59:06.80,0:59:08.97,Default,,0,0,0,,然而 还有一个更深刻的问题
Dialogue: 0,0:59:09.60,0:59:11.53,Default,,0,0,0,,也就是 哪个才是正确答案呢？
Dialogue: 0,0:59:12.53,0:59:14.24,Default,,0,0,0,,是奥林匹斯山 还是没有呢？
Dialogue: 0,0:59:15.37,0:59:18.73,Default,,0,0,0,,你可能会认为是奥林匹斯山
Dialogue: 0,0:59:18.76,0:59:20.73,Default,,0,0,0,,毕竟 宙斯在数据库中
Dialogue: 0,0:59:22.52,0:59:25.10,Default,,0,0,0,,宙斯不是平凡的 也不是不可靠的
Dialogue: 0,0:59:29.55,0:59:32.44,Default,,0,0,0,,因此你可能会认为宙斯满足
Dialogue: 0,0:59:34.30,0:59:44.03,Default,,0,0,0,,(NOT (MORTAL ZEUS))或者(NOT (FALLIBLE ZEUS))
Dialogue: 0,0:59:44.12,0:59:45.85,Default,,0,0,0,,但我们实际来看一看数据库
Dialogue: 0,0:59:47.92,0:59:48.46,Default,,0,0,0,,来看一下
Dialogue: 0,0:59:49.36,0:59:53.24,Default,,0,0,0,,它要如何知道宙斯不是不可靠的？
Dialogue: 0,0:59:54.81,0:59:56.11,Default,,0,0,0,,这里面没有关于它的知识
Dialogue: 0,0:59:57.93,0:59:59.66,Default,,0,0,0,,里面只能得到人类是不可靠的
Dialogue: 0,1:00:02.16,1:00:04.12,Default,,0,0,0,,它又如何知道宙斯不是不可靠的呢？
Dialogue: 0,1:00:04.48,1:00:05.93,Default,,0,0,0,,这其中没有相关的规则
Dialogue: 0,1:00:07.98,1:00:11.00,Default,,0,0,0,,它只是说 我没有这样的规则
Dialogue: 0,1:00:11.68,1:00:14.06,Default,,0,0,0,,我只能通过某人是人类来推断出他是平凡的
Dialogue: 0,1:00:14.08,1:00:15.68,Default,,0,0,0,,这也是它所知道关于“平凡”的所有东西
Dialogue: 0,1:00:16.69,1:00:19.85,Default,,0,0,0,,然而 如果你还记得古典神话的话
Dialogue: 0,1:00:19.87,1:00:23.48,Default,,0,0,0,,你就知道 古希腊众神是不平凡的 但都不可靠
Dialogue: 0,1:00:25.05,1:00:28.65,Default,,0,0,0,,所以 不能通过这些规则得到答案
Dialogue: 0,1:00:30.85,1:00:32.10,Default,,0,0,0,,但它又为什么推导出这些呢？
Dialogue: 0,1:00:34.49,1:00:38.32,Default,,0,0,0,,显然 苏格拉底不会犯这类逻辑错误
Dialogue: 0,1:00:40.08,1:00:42.67,Default,,0,0,0,,在这门语言中 NOT并不是NOT
Dialogue: 0,1:00:43.37,1:00:44.32,Default,,0,0,0,,不是逻辑非运算
Dialogue: 0,1:00:44.93,1:00:46.40,Default,,0,0,0,,这门语言中 NOT表示的是
Dialogue: 0,1:00:47.16,1:00:49.96,Default,,0,0,0,,不可以从数据库中推断出结果
Dialogue: 0,1:00:50.75,1:00:53.34,Default,,0,0,0,,而不是“非真”
Dialogue: 0,1:00:55.02,1:00:56.30,Default,,0,0,0,,完全是天壤之别
Dialogue: 0,1:00:57.30,1:00:58.64,Default,,0,0,0,,很细微 但也很巨大
Dialogue: 0,1:00:59.25,1:01:00.27,Default,,0,0,0,,因此 实际上
Dialogue: 0,1:01:00.76,1:01:03.92,Default,,0,0,0,,如果什么都不知道 最好就说NOT
Dialogue: 0,1:01:04.68,1:01:06.14,Default,,0,0,0,,如果你问它
Dialogue: 0,1:01:06.16,1:01:07.83,Default,,0,0,0,,宙斯是否喜欢巧克力冰激凌
Dialogue: 0,1:01:07.85,1:01:09.12,Default,,0,0,0,,它会说 这个查询当然非真
Dialogue: 0,1:01:10.64,1:01:12.51,Default,,0,0,0,,这些事情它都不知道
Dialogue: 0,1:01:12.59,1:01:17.34,Default,,0,0,0,,NOT表示：不能从你告知它的事实中推断出来
Dialogue: 0,1:01:18.28,1:01:22.44,Default,,0,0,0,,换句话说 你要把“无法推断出”
Dialogue: 0,1:01:22.65,1:01:24.00,Default,,0,0,0,,与“命题非真”区别开来
Dialogue: 0,1:01:24.41,1:01:26.30,Default,,0,0,0,,这被称作是“封闭世界假说”
Dialogue: 0,1:01:37.37,1:01:38.17,Default,,0,0,0,,封闭世界假说
Dialogue: 0,1:01:38.20,1:01:42.38,Default,,0,0,0,,只要结论不能通过我所知道的知识推断出来
Dialogue: 0,1:01:43.50,1:01:44.36,Default,,0,0,0,,那么就不是真的
Dialogue: 0,1:01:46.24,1:01:48.01,Default,,0,0,0,,对吧 如果我对X一无所知
Dialogue: 0,1:01:48.22,1:01:49.21,Default,,0,0,0,,那么X就非真
Dialogue: 0,1:01:49.29,1:01:50.33,Default,,0,0,0,,这相当危险
Dialogue: 0,1:01:51.29,1:01:52.44,Default,,0,0,0,,首先 从逻辑学的角度来说
Dialogue: 0,1:01:52.46,1:01:53.76,Default,,0,0,0,,它一点也说不通
Dialogue: 0,1:01:54.48,1:01:56.33,Default,,0,0,0,,因为如果我对X一无所知的话
Dialogue: 0,1:01:58.38,1:01:59.69,Default,,0,0,0,,就说X非真
Dialogue: 0,1:02:00.24,1:02:03.32,Default,,0,0,0,,但为什么不说“X非真”非真
Dialogue: 0,1:02:03.85,1:02:05.66,Default,,0,0,0,,当然 我也许对后面那个命题也一无所知
Dialogue: 0,1:02:06.47,1:02:08.65,Default,,0,0,0,,因此(NOT (NOT X))就没有必要与X一致
Dialogue: 0,1:02:09.24,1:02:10.94,Default,,0,0,0,,等等等等
Dialogue: 0,1:02:11.71,1:02:13.93,Default,,0,0,0,,因此 这里面一定有某种“偏见”
Dialogue: 0,1:02:15.97,1:02:17.29,Default,,0,0,0,,这相当有趣
Dialogue: 0,1:02:17.29,1:02:18.09,Default,,0,0,0,,第二点就是
Dialogue: 0,1:02:20.14,1:02:24.12,Default,,0,0,0,,如果你基于此 构建一个真正的推理程序
Dialogue: 0,1:02:24.70,1:02:26.11,Default,,0,0,0,,想一想是多么地危险
Dialogue: 0,1:02:27.07,1:02:32.00,Default,,0,0,0,,你说我知道我可以推断出
Dialogue: 0,1:02:32.22,1:02:36.22,Default,,0,0,0,,与这个问题有关的所有事情
Dialogue: 0,1:02:37.44,1:02:40.78,Default,,0,0,0,,因为在我推理机制的内部
Dialogue: 0,1:02:41.23,1:02:44.20,Default,,0,0,0,,会认为所有与问题有关的知识
Dialogue: 0,1:02:44.24,1:02:46.27,Default,,0,0,0,,我都已经知道了
Dialogue: 0,1:02:48.44,1:02:53.04,Default,,0,0,0,,有相当多的大型组织都像这样运作 对吧？
Dialogue: 0,1:02:53.16,1:02:56.83,Default,,0,0,0,,大多数公司的市场部门都是这样工作的。
Dialogue: 0,1:02:56.83,1:02:59.12,Default,,0,0,0,,你们也知道这样做的后果
Dialogue: 0,1:03:00.33,1:03:03.45,Default,,0,0,0,,因此 向这个大型逻辑推理系统
Dialogue: 0,1:03:03.84,1:03:06.25,Default,,0,0,0,,输入各种查询 根据输出继续工作
Dialogue: 0,1:03:07.05,1:03:09.00,Default,,0,0,0,,的做法相当危险
Dialogue: 0,1:03:09.02,1:03:11.28,Default,,0,0,0,,因为它们内建的假说非常地有限
Dialogue: 0,1:03:12.60,1:03:14.36,Default,,0,0,0,,因此你对此需要非常非常地小心
Dialogue: 0,1:03:15.29,1:03:16.28,Default,,0,0,0,,就是这么一个深层次问题
Dialogue: 0,1:03:16.56,1:03:17.82,Default,,0,0,0,,这个问题并不是
Dialogue: 0,1:03:18.22,1:03:20.14,Default,,0,0,0,,通过构建更加聪明的实现
Dialogue: 0,1:03:20.16,1:03:21.85,Default,,0,0,0,,或者通过组织无穷循环
Dialogue: 0,1:03:22.16,1:03:23.84,Default,,0,0,0,,以及过滤器就可以消除的
Dialogue: 0,1:03:23.84,1:03:25.08,Default,,0,0,0,,这是完全不同的一类问题
Dialogue: 0,1:03:25.92,1:03:26.89,Default,,0,0,0,,完全不同的语义
Dialogue: 0,1:03:27.06,1:03:30.51,Default,,0,0,0,,我想该总结一下了 平心而论
Dialogue: 0,1:03:31.34,1:03:34.43,Default,,0,0,0,,逻辑式程序设计是一个振奋人心的想法
Dialogue: 0,1:03:34.60,1:03:37.00,Default,,0,0,0,,这个想法使你能够弥合
Dialogue: 0,1:03:37.04,1:03:38.78,Default,,0,0,0,,命令式与声明式语言的鸿沟
Dialogue: 0,1:03:39.90,1:03:42.94,Default,,0,0,0,,使得你可以谈论关系
Dialogue: 0,1:03:43.58,1:03:45.08,Default,,0,0,0,,从而获得惊人的力量
Dialogue: 0,1:03:46.09,1:03:49.48,Default,,0,0,0,,让你超越输入和输出的抽象
Dialogue: 0,1:03:50.56,1:03:51.53,Default,,0,0,0,,而关于逻辑
Dialogue: 0,1:03:52.46,1:03:56.46,Default,,0,0,0,,我认为这个问题还尚未解决
Dialogue: 0,1:03:58.03,1:04:01.80,Default,,0,0,0,,也许现在语言中最令人感兴趣的
Dialogue: 0,1:04:02.27,1:04:04.41,Default,,0,0,0,,研究问题之一就是
Dialogue: 0,1:04:04.67,1:04:08.28,Default,,0,0,0,,你该如何创建一门真正的逻辑语言？
Dialogue: 0,1:04:09.46,1:04:11.05,Default,,0,0,0,,其次 你如何从
Dialogue: 0,1:04:11.31,1:04:13.15,Default,,0,0,0,,这个逻辑和关系的世界
Dialogue: 0,1:04:13.52,1:04:16.43,Default,,0,0,0,,到更传统语言的世界之间
Dialogue: 0,1:04:16.46,1:04:17.98,Default,,0,0,0,,架起桥梁并结合两者的力量
Dialogue: 0,1:04:18.88,1:04:19.68,Default,,0,0,0,,有什么问题吗？
Dialogue: 0,1:04:23.29,1:04:25.29,Default,,0,0,0,,学生：你能够通过添加额外的规则
Dialogue: 0,1:04:25.29,1:04:27.74,Default,,0,0,0,,来解决最后一个问题么？
Dialogue: 0,1:04:27.96,1:04:29.85,Default,,0,0,0,,这里的困境是：你有某物的定义
Dialogue: 0,1:04:29.88,1:04:31.82,Default,,0,0,0,,但没有它对立面的定义
Dialogue: 0,1:04:32.08,1:04:33.92,Default,,0,0,0,,如果你在数据库中有
Dialogue: 0,1:04:34.14,1:04:36.89,Default,,0,0,0,,某些规则推导出(MORTAL X)
Dialogue: 0,1:04:36.99,1:04:38.70,Default,,0,0,0,,另外一些规则推导出(NOT (MORTAL X))
Dialogue: 0,1:04:38.75,1:04:40.37,Default,,0,0,0,,这不就基本上解决这个问题么？
Dialogue: 0,1:04:43.37,1:04:44.14,Default,,0,0,0,,教授：但问题就是
Dialogue: 0,1:04:44.75,1:04:46.38,Default,,0,0,0,,添加的这些规则是有穷个么？
Dialogue: 0,1:04:48.65,1:04:53.13,Default,,0,0,0,,学生：如果你同时定义正、反两面 --
Dialogue: 0,1:04:53.61,1:04:57.07,Default,,0,0,0,,教授：但问题就是 你该如何去做推断？
Dialogue: 0,1:05:00.20,1:05:02.11,Default,,0,0,0,,要知道 你不能直接定义命题的非
Dialogue: 0,1:05:03.40,1:05:04.76,Default,,0,0,0,,而问题就在于 在大型系统中
Dialogue: 0,1:05:04.78,1:05:07.96,Default,,0,0,0,,可能含有无穷个数的东西
Dialogue: 0,1:05:12.82,1:05:15.29,Default,,0,0,0,,这其中有两个问题
Dialogue: 0,1:05:15.29,1:05:16.56,Default,,0,0,0,,其一是可能有无穷项
Dialogue: 0,1:05:16.69,1:05:19.39,Default,,0,0,0,,另外是因为可能不向你想的那样
Dialogue: 0,1:05:21.51,1:05:24.52,Default,,0,0,0,,一个极好的例子 就是连通性
Dialogue: 0,1:05:25.12,1:05:26.54,Default,,0,0,0,,我想对连通性做推理
Dialogue: 0,1:05:28.05,1:05:30.38,Default,,0,0,0,,我会告诉你这有四个对象
Dialogue: 0,1:05:30.40,1:05:33.74,Default,,0,0,0,,A、B、C和D
Dialogue: 0,1:05:35.48,1:05:38.19,Default,,0,0,0,,我会告诉你A和B相连
Dialogue: 0,1:05:38.64,1:05:41.42,Default,,0,0,0,,C和D相连
Dialogue: 0,1:05:43.20,1:05:44.80,Default,,0,0,0,,然后我再告诉你A和D相连
Dialogue: 0,1:05:45.05,1:05:46.03,Default,,0,0,0,,就是这种情况
Dialogue: 0,1:05:46.78,1:05:48.52,Default,,0,0,0,,在这个例子中
Dialogue: 0,1:05:48.70,1:05:50.35,Default,,0,0,0,,我就希望有“封闭世界假说”这样的东西
Dialogue: 0,1:05:54.43,1:05:55.66,Default,,0,0,0,,这是个小玩具
Dialogue: 0,1:05:56.24,1:05:58.30,Default,,0,0,0,,但是很多时候 我都想说
Dialogue: 0,1:05:58.48,1:06:01.34,Default,,0,0,0,,我没告诉你的事 都假设非真
Dialogue: 0,1:06:04.26,1:06:06.27,Default,,0,0,0,,所以这并不是你显式地
Dialogue: 0,1:06:06.27,1:06:08.09,Default,,0,0,0,,为所有命题定义否命题就可以解决的
Dialogue: 0,1:06:09.47,1:06:12.70,Default,,0,0,0,,而是有些时候 你不清楚自己真正想要什么
Dialogue: 0,1:06:14.15,1:06:17.92,Default,,0,0,0,,同时定义原命题与否命题又太过于精细
Dialogue: 0,1:06:17.93,1:06:20.00,Default,,0,0,0,,这会使你陷入困境
Dialogue: 0,1:06:20.96,1:06:22.68,Default,,0,0,0,,但还是有很多方法
Dialogue: 0,1:06:23.32,1:06:25.93,Default,,0,0,0,,显式地定义否命题 并基于此进行推理
Dialogue: 0,1:06:26.51,1:06:27.66,Default,,0,0,0,,这个想法非常好
Dialogue: 0,1:06:28.07,1:06:31.45,Default,,0,0,0,,只是在一些复杂的大型问题中
Dialogue: 0,1:06:31.48,1:06:33.49,Default,,0,0,0,,这么做就变得有些笨重了
Dialogue: 0,1:06:43.46,1:06:45.96,Default,,0,0,0,,学生：有个论点 我不知道它和本节课的直接关系
Dialogue: 0,1:06:46.00,1:06:47.98,Default,,0,0,0,,但你想要表达的是
Dialogue: 0,1:06:48.49,1:06:50.16,Default,,0,0,0,,封闭世界假说的危害之一就是
Dialogue: 0,1:06:50.19,1:06:52.06,Default,,0,0,0,,你永远不会真正了解那里的所有事物
Dialogue: 0,1:06:53.44,1:06:55.32,Default,,0,0,0,,你永远不会知道它们的每个部分
Dialogue: 0,1:06:55.87,1:06:58.16,Default,,0,0,0,,这难道不是任何一门程序设计语言的主要问题吗？
Dialogue: 0,1:06:58.16,1:06:59.64,Default,,0,0,0,,写程序时 我总是
Dialogue: 0,1:06:59.90,1:07:01.56,Default,,0,0,0,,假设我考虑了所有的情况
Dialogue: 0,1:07:01.58,1:07:03.40,Default,,0,0,0,,然后我检查了每一种情况
Dialogue: 0,1:07:04.06,1:07:04.99,Default,,0,0,0,,然而在某处
Dialogue: 0,1:07:05.02,1:07:06.52,Default,,0,0,0,,我发现了我遗漏了其中的一个
Dialogue: 0,1:07:07.39,1:07:08.54,Default,,0,0,0,,教授：你说得很对
Dialogue: 0,1:07:08.54,1:07:09.76,Default,,0,0,0,,但这里的问题在于
Dialogue: 0,1:07:11.96,1:07:15.47,Default,,0,0,0,,对于你所做的事情
Dialogue: 0,1:07:15.48,1:07:17.34,Default,,0,0,0,,你是否认为它是逻辑问题
Dialogue: 0,1:07:19.60,1:07:20.51,Default,,0,0,0,,你说得非常正确
Dialogue: 0,1:07:20.51,1:07:22.22,Default,,0,0,0,,这是你永远不会遇到的情况
Dialogue: 0,1:07:22.22,1:07:24.14,Default,,0,0,0,,问题在于 如果你认为
Dialogue: 0,1:07:24.17,1:07:25.44,Default,,0,0,0,,你在进行逻辑式程序设计
Dialogue: 0,1:07:26.17,1:07:27.32,Default,,0,0,0,,然后审视你所编写的规则
Dialogue: 0,1:07:27.34,1:07:28.89,Default,,0,0,0,,并思考能从中推断出什么
Dialogue: 0,1:07:29.53,1:07:32.80,Default,,0,0,0,,你就需要清醒地认识到NOT具有另外的意义
Dialogue: 0,1:07:33.47,1:07:35.21,Default,,0,0,0,,它的意义基于某种假设
Dialogue: 0,1:07:35.24,1:07:36.70,Default,,0,0,0,,并且可能并不正确
Dialogue: 0,1:07:39.03,1:07:40.19,Default,,0,0,0,,学生：我不知道这样理解是否正确
Dialogue: 0,1:07:40.25,1:07:41.84,Default,,0,0,0,,也就是我们无法通过改变NOT
Dialogue: 0,1:07:42.25,1:07:46.08,Default,,0,0,0,,来消灭推断的所有可能性 从而解决这个问题？
Dialogue: 0,1:07:46.54,1:07:49.80,Default,,0,0,0,,教授：不 并不是这样
Dialogue: 0,1:07:52.96,1:07:55.08,Default,,0,0,0,,有很多种方法可以实现真正的逻辑非
Dialogue: 0,1:07:56.34,1:07:58.03,Default,,0,0,0,,实际上有很多种方法
Dialogue: 0,1:07:58.54,1:08:00.84,Default,,0,0,0,,但目前没有一个广为人知的高效算法
Dialogue: 0,1:08:01.61,1:08:02.56,Default,,0,0,0,,而且他们还--
Dialogue: 0,1:08:04.09,1:08:06.89,Default,,0,0,0,,这里所谓的“推论”
Dialogue: 0,1:08:07.39,1:08:08.83,Default,,0,0,0,,是建立在这个合一算法
Dialogue: 0,1:08:08.91,1:08:11.29,Default,,0,0,0,,以及模式匹配算法之中的
Dialogue: 0,1:08:11.98,1:08:16.19,Default,,0,0,0,,有多种方法可以实现真正的逻辑推理
Dialogue: 0,1:08:16.59,1:08:18.19,Default,,0,0,0,,但它们并不基于此
Dialogue: 0,1:08:18.51,1:08:20.73,Default,,0,0,0,,而逻辑式程序设计语言也不倾向于这么做
Dialogue: 0,1:08:20.75,1:08:23.85,Default,,0,0,0,,因为大家都知道 那样做非常低效
Dialogue: 0,1:08:29.39,1:08:30.03,Default,,0,0,0,,好吧 下课
Dialogue: 0,1:08:30.03,1:08:42.68,Declare,,0,0,0,,{\fad(500,500)}MIT OpenCourseWare\Nhttp://ocw.mit.edu
Dialogue: 0,1:08:30.03,1:08:42.68,Declare,,0,0,0,,{\an2\fad(500,500)}本项目主页\Nhttps://github.com/DeathKing/Learning-SICP
