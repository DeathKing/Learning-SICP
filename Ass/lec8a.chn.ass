[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 640
PlayResY: 480

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: EN,Calisto MT,21,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,1,0,2,10,10,30,1
Style: Declare,微软雅黑,30,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,2,0,8,10,10,10,1
Style: staff,微软雅黑,30,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,0,2,5,10,10,10,1
Style: title,微软雅黑,35,&H001D64D9,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,0,1,5,10,10,10,1
Style: Default,雅黑宋体,20,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,1,0,2,10,10,30,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.00,0:00:02.67,Declare,,0,0,0,,{\an2\fad(500,500)}Learning-SICP学习小组\N倾情制作
Dialogue: 0,0:00:02.70,0:00:10.27,title,,0,0,0,,{\fad(600,800)\pos(324,32)}计算机程序的构造和解释
Dialogue: 0,0:00:02.70,0:00:10.27,staff,,0,0,0,,{\fad(600,800)\pos(110.666,403.334)}翻译&&时间轴\N邓雄飞\N（Dysprosium）
Dialogue: 0,0:00:02.70,0:00:10.27,staff,,0,0,0,,{\fad(600,800)\pos(534.666,404)}压制&&特效\N邓雄飞\N（Dysprosium）
Dialogue: 0,0:00:02.70,0:00:10.27,staff,,0,0,0,,{\fad(600,800)\pos(574.667,277.333)}校对\N邓雄飞
Dialogue: 0,0:00:02.70,0:00:10.27,staff,,0,0,0,,{\fad(600,800)\pos(89.334,273.333)}特别感谢\N裘宗燕教授
Dialogue: 0,0:00:10.28,0:00:15.24,Declare,,0,0,0,,{\an2\fad(500,500)}逻辑式程序设计 I
Dialogue: 0,0:00:18.27,0:00:19.68,Default,,0,0,0,,教授：上节课中 我们学习了
Dialogue: 0,0:00:19.72,0:00:21.26,Default,,0,0,0,,如何构造语言
Dialogue: 0,0:00:22.41,0:00:25.88,Default,,0,0,0,,核心点就是 像Lisp这样的求值器
Dialogue: 0,0:00:26.08,0:00:27.58,Default,,0,0,0,,有两个主要部分
Dialogue: 0,0:00:27.58,0:00:28.40,Default,,0,0,0,,一个是EVAL
Dialogue: 0,0:00:31.04,0:00:37.42,Default,,0,0,0,,EVAL接受一个表达式EXP和环境ENV
Dialogue: 0,0:00:38.91,0:00:44.44,Default,,0,0,0,,然后返回一个过程和相关的实际参数
Dialogue: 0,0:00:45.42,0:00:47.05,Default,,0,0,0,,并把它们传递给APPLY
Dialogue: 0,0:00:49.41,0:00:51.29,Default,,0,0,0,,APPLY接收这些过程和实际参数
Dialogue: 0,0:00:51.69,0:00:55.12,Default,,0,0,0,,通常来说 APPLY会返回另一个表达式
Dialogue: 0,0:00:55.39,0:00:57.71,Default,,0,0,0,,返回一个在其它环境中求值的表达式
Dialogue: 0,0:00:57.74,0:01:00.00,Default,,0,0,0,,表达式就像这样在EVAL-APPLY之间传递
Dialogue: 0,0:01:00.27,0:01:01.44,Default,,0,0,0,,这就是整个元循环
Dialogue: 0,0:01:01.47,0:01:02.94,Default,,0,0,0,,表达式在这里面循环往复
Dialogue: 0,0:01:03.02,0:01:06.56,Default,,0,0,0,,直到最后求值为基本数据或基本过程
Dialogue: 0,0:01:07.74,0:01:09.24,Default,,0,0,0,,这个循环要做的就是
Dialogue: 0,0:01:09.44,0:01:12.57,Default,,0,0,0,,把语言中的组合手段
Dialogue: 0,0:01:12.59,0:01:14.36,Default,,0,0,0,,和抽象手段展开
Dialogue: 0,0:01:15.02,0:01:17.72,Default,,0,0,0,,比如说在Lisp中 你有一个过程
Dialogue: 0,0:01:17.74,0:01:20.52,Default,,0,0,0,,定义过程是为了
Dialogue: 0,0:01:20.54,0:01:22.57,Default,,0,0,0,,让表达式的计算过程
Dialogue: 0,0:01:22.67,0:01:24.41,Default,,0,0,0,,适用于任意的参数
Dialogue: 0,0:01:25.76,0:01:27.18,Default,,0,0,0,,这就是这里面发生的事情
Dialogue: 0,0:01:27.67,0:01:28.51,Default,,0,0,0,,这就是APPLY做的事
Dialogue: 0,0:01:28.51,0:01:30.68,Default,,0,0,0,,当一个带参数的一般性表达式进入以后
Dialogue: 0,0:01:30.72,0:01:32.70,Default,,0,0,0,,它将其归约为过程体的表达式
Dialogue: 0,0:01:33.05,0:01:34.72,Default,,0,0,0,,如果归约得到的是复合表达式
Dialogue: 0,0:01:34.83,0:01:36.46,Default,,0,0,0,,或者是另外的过程应用
Dialogue: 0,0:01:36.78,0:01:38.44,Default,,0,0,0,,那么这个循环就会不断地进行
Dialogue: 0,0:01:40.33,0:01:44.08,Default,,0,0,0,,这基本上就是 -- 大部分解释器的基本结构了
Dialogue: 0,0:01:45.20,0:01:46.25,Default,,0,0,0,,另外一点就是
Dialogue: 0,0:01:46.28,0:01:47.66,Default,,0,0,0,,一旦你有了一个解释器
Dialogue: 0,0:01:47.69,0:01:49.87,Default,,0,0,0,,你就有了操作这门语言的所有能力
Dialogue: 0,0:01:49.87,0:01:51.52,Default,,0,0,0,,因此你可以让它成为动态作用域
Dialogue: 0,0:01:51.84,0:01:54.56,Default,,0,0,0,,你也可以引入正则序求值
Dialogue: 0,0:01:54.59,0:01:56.48,Default,,0,0,0,,你也可以为语言添加新的形式
Dialogue: 0,0:01:56.86,0:01:57.50,Default,,0,0,0,,想怎么样都行
Dialogue: 0,0:01:57.58,0:01:58.62,Default,,0,0,0,,或者更一般地说
Dialogue: 0,0:01:58.76,0:02:01.32,Default,,0,0,0,,这种元语言抽象的概念
Dialogue: 0,0:02:02.64,0:02:06.01,Default,,0,0,0,,它告诉我们 作为一名软件工程师
Dialogue: 0,0:02:07.61,0:02:10.52,Default,,0,0,0,,从广义的“工程师”的角度来看
Dialogue: 0,0:02:11.39,0:02:13.88,Default,,0,0,0,,有时你可以通过发明新的语言
Dialogue: 0,0:02:14.96,0:02:17.16,Default,,0,0,0,,来获得控制复杂度的能力
Dialogue: 0,0:02:18.01,0:02:20.81,Default,,0,0,0,,一种思考计算机程序设计的方法就是
Dialogue: 0,0:02:21.55,0:02:26.27,Default,,0,0,0,,它只是偶然地让计算机执行某事儿
Dialogue: 0,0:02:26.44,0:02:28.97,Default,,0,0,0,,计算机程序的主要工作却是
Dialogue: 0,0:02:29.00,0:02:32.52,Default,,0,0,0,,用来表达和交换想法
Dialogue: 0,0:02:33.16,0:02:34.04,Default,,0,0,0,,有时
Dialogue: 0,0:02:34.89,0:02:36.62,Default,,0,0,0,,当我们想要表达新的想法时
Dialogue: 0,0:02:36.65,0:02:38.73,Default,,0,0,0,,我们就想要发明新的模式来表达它们
Dialogue: 0,0:02:39.82,0:02:44.99,Default,,0,0,0,,那么 今天我们就将按照这个框架来创建新语言
Dialogue: 0,0:02:45.73,0:02:48.00,Default,,0,0,0,,一旦我们了解了解释器的基本结构
Dialogue: 0,0:02:48.03,0:02:50.27,Default,,0,0,0,,我们就可以按意愿来构造任意的语言
Dialogue: 0,0:02:50.83,0:02:53.21,Default,,0,0,0,,比如说 我们可以构造Pascal（的解释器）
Dialogue: 0,0:02:54.37,0:02:55.15,Default,,0,0,0,,以及
Dialogue: 0,0:02:56.17,0:02:58.19,Default,,0,0,0,,我们需要操心语法的表示与解析
Dialogue: 0,0:02:58.19,0:03:00.51,Default,,0,0,0,,还有一大堆的编译器优化
Dialogue: 0,0:03:01.12,0:03:03.29,Default,,0,0,0,,还有一些人会这样做
Dialogue: 0,0:03:03.85,0:03:07.60,Default,,0,0,0,,但是就在我们所讨论的抽象层次来说
Dialogue: 0,0:03:08.04,0:03:10.99,Default,,0,0,0,,一个Pascal语言的解释器看起来
Dialogue: 0,0:03:12.03,0:03:13.76,Default,,0,0,0,,跟Gerry教授上节课所讲的大同小异
Dialogue: 0,0:03:15.02,0:03:18.96,Default,,0,0,0,,但是今天 我们要构建一门与众不同的语言
Dialogue: 0,0:03:20.51,0:03:22.81,Default,,0,0,0,,这门语言
Dialogue: 0,0:03:23.05,0:03:26.04,Default,,0,0,0,,不推荐你用过程式的思维来思考程序设计
Dialogue: 0,0:03:26.24,0:03:27.64,Default,,0,0,0,,而是用一种非常不同的方式
Dialogue: 0,0:03:29.09,0:03:31.02,Default,,0,0,0,,今天的课程呢
Dialogue: 0,0:03:31.74,0:03:34.64,Default,,0,0,0,,将会在两个层次中同时进行
Dialogue: 0,0:03:34.81,0:03:35.52,Default,,0,0,0,,一方面
Dialogue: 0,0:03:35.90,0:03:37.71,Default,,0,0,0,,我会向大家介绍这门语言是如何使用的
Dialogue: 0,0:03:38.96,0:03:41.08,Default,,0,0,0,,另一方面呢 我会带领大家实现这门语言
Dialogue: 0,0:03:41.32,0:03:42.96,Default,,0,0,0,,我们将会用Lisp来实现
Dialogue: 0,0:03:42.99,0:03:43.90,Default,,0,0,0,,并观察它的运行原理
Dialogue: 0,0:03:44.04,0:03:48.25,Default,,0,0,0,,你应该在两个层次上学到知识
Dialogue: 0,0:03:48.68,0:03:53.00,Default,,0,0,0,,首先要认识到 语言之间可以有多么地“不同”
Dialogue: 0,0:03:53.79,0:03:58.14,Default,,0,0,0,,如果你认为Fortran和Lisp算是天差地别的话
Dialogue: 0,0:03:58.24,0:03:59.36,Default,,0,0,0,,那就小巫见大巫了
Dialogue: 0,0:04:01.56,0:04:03.68,Default,,0,0,0,,其次
Dialogue: 0,0:04:03.77,0:04:06.54,Default,,0,0,0,,甚至于在这门与众不同的语言中
Dialogue: 0,0:04:07.36,0:04:09.52,Default,,0,0,0,,这门既不讨论函数
Dialogue: 0,0:04:09.92,0:04:11.64,Default,,0,0,0,,也没有过程的语言中
Dialogue: 0,0:04:12.20,0:04:15.72,Default,,0,0,0,,其中也有基本的EVAL-APPLY循环
Dialogue: 0,0:04:16.19,0:04:19.98,Default,,0,0,0,,也就是对组合手段和抽象手段的展开
Dialogue: 0,0:04:20.95,0:04:24.68,Default,,0,0,0,,第三点 是一个不太重要但非常优雅的技术技巧
Dialogue: 0,0:04:24.89,0:04:28.52,Default,,0,0,0,,就是如何巧妙地使用流来避免回溯
Dialogue: 0,0:04:32.33,0:04:34.40,Default,,0,0,0,,好吧 我说过这门语言与众不同
Dialogue: 0,0:04:35.86,0:04:36.64,Default,,0,0,0,,为了解释这点
Dialogue: 0,0:04:37.05,0:04:42.81,Default,,0,0,0,,让我们回到这门课最初的理念上
Dialogue: 0,0:04:43.26,0:04:46.54,Default,,0,0,0,,就是要区别
Dialogue: 0,0:04:46.72,0:04:49.52,Default,,0,0,0,,数学中“陈述性”的知识
Dialogue: 0,0:04:50.19,0:04:54.14,Default,,0,0,0,,比如平方根的定义就是一条数学事实
Dialogue: 0,0:04:55.48,0:04:59.56,Default,,0,0,0,,而计算机科学讨论的是“如何做”的知识
Dialogue: 0,0:04:59.76,0:05:04.59,Default,,0,0,0,,“什么是平方根”和“如何计算平方根”是不同的
Dialogue: 0,0:05:05.97,0:05:07.07,Default,,0,0,0,,我们是从这里开始的
Dialogue: 0,0:05:08.51,0:05:09.52,Default,,0,0,0,,如果我们能够通过某种方式
Dialogue: 0,0:05:09.88,0:05:12.16,Default,,0,0,0,,弥合这种差距 岂不是更好么？
Dialogue: 0,0:05:12.81,0:05:16.43,Default,,0,0,0,,我们创建一门这样的语言
Dialogue: 0,0:05:16.67,0:05:21.61,Default,,0,0,0,,以声明式的方式、用数学事实来完成计算
Dialogue: 0,0:05:22.38,0:05:25.50,Default,,0,0,0,,你用这种该语言来指定事实
Dialogue: 0,0:05:27.69,0:05:28.88,Default,,0,0,0,,你告诉它
Dialogue: 0,0:05:28.88,0:05:29.96,Default,,0,0,0,,什么是事实
Dialogue: 0,0:05:30.95,0:05:33.07,Default,,0,0,0,,而当你需要一个答案时
Dialogue: 0,0:05:33.21,0:05:36.38,Default,,0,0,0,,语言已经自动地内建了
Dialogue: 0,0:05:37.60,0:05:39.45,Default,,0,0,0,,有关于“如何做”的一般性知识
Dialogue: 0,0:05:39.47,0:05:40.64,Default,,0,0,0,,这样它就可以根据你给出的事实
Dialogue: 0,0:05:40.89,0:05:42.83,Default,,0,0,0,,自行地演进这些方法
Dialogue: 0,0:05:43.31,0:05:46.12,Default,,0,0,0,,通过你给定的事实和某种一般性的逻辑规则
Dialogue: 0,0:05:49.33,0:05:50.54,Default,,0,0,0,,就比如说
Dialogue: 0,0:05:52.06,0:05:55.12,Default,,0,0,0,,我会告诉程序下述事实
Dialogue: 0,0:05:56.00,0:06:07.08,Default,,0,0,0,,我告诉它 (SON-OF ADAM ABEL)
Dialogue: 0,0:06:08.92,0:06:16.51,Default,,0,0,0,,同时告诉它 (SON-OF ADAM CAIN)
Dialogue: 0,0:06:17.66,0:06:25.08,Default,,0,0,0,,以及 (SON-OF CAIN ENOCH)
Dialogue: 0,0:06:27.79,0:06:34.89,Default,,0,0,0,,还有 (SON-OF ENOCH IRAD)
Dialogue: 0,0:06:37.02,0:06:40.72,Default,,0,0,0,,以及《创世纪》章节中的其它人物
Dialogue: 0,0:06:41.15,0:06:43.18,Default,,0,0,0,,最后终止于ADAH
Dialogue: 0,0:06:43.32,0:06:46.78,Default,,0,0,0,,这些是从ADAH到CAIN的家谱
Dialogue: 0,0:06:48.44,0:06:50.67,Default,,0,0,0,,总之 一旦你指明了这些事实
Dialogue: 0,0:06:52.35,0:06:53.40,Default,,0,0,0,,你就可以提出问题
Dialogue: 0,0:06:53.51,0:06:55.05,Default,,0,0,0,,你可以对语言系统发问
Dialogue: 0,0:06:56.06,0:06:59.29,Default,,0,0,0,,谁是ADAM的孩子？
Dialogue: 0,0:07:00.42,0:07:04.91,Default,,0,0,0,,可以很容易地想到一个通用搜索程序
Dialogue: 0,0:07:05.52,0:07:06.96,Default,,0,0,0,,它会遍历所有的事实
Dialogue: 0,0:07:07.00,0:07:09.26,Default,,0,0,0,,然后回答：“哦 有两个答案”
Dialogue: 0,0:07:09.29,0:07:10.44,Default,,0,0,0,,ABEL是ADAM的孩子
Dialogue: 0,0:07:10.68,0:07:12.17,Default,,0,0,0,,CAIN也是ADAM的孩子
Dialogue: 0,0:07:14.14,0:07:14.97,Default,,0,0,0,,你也可以这样问
Dialogue: 0,0:07:15.07,0:07:16.89,Default,,0,0,0,,基于同样的事实
Dialogue: 0,0:07:18.04,0:07:19.95,Default,,0,0,0,,CAIN是谁的孩子？
Dialogue: 0,0:07:21.95,0:07:27.02,Default,,0,0,0,,你们就会想到生成另外一个略微不同的搜索程序
Dialogue: 0,0:07:27.92,0:07:29.21,Default,,0,0,0,,它也会遍历所有的事实
Dialogue: 0,0:07:29.45,0:07:33.05,Default,,0,0,0,,检查谁的孩子是CAIN
Dialogue: 0,0:07:33.52,0:07:34.44,Default,,0,0,0,,发现结果是ADAM
Dialogue: 0,0:07:35.89,0:07:36.99,Default,,0,0,0,,你也可以问
Dialogue: 0,0:07:38.01,0:07:41.40,Default,,0,0,0,,CAIN和ENOCH之间是什么关系？
Dialogue: 0,0:07:42.07,0:07:45.08,Default,,0,0,0,,又会生成另一个略微不同的搜索程序
Dialogue: 0,0:07:46.34,0:07:48.16,Default,,0,0,0,,得到的结果是亲子关系（SON-OF）
Dialogue: 0,0:07:52.88,0:07:54.92,Default,,0,0,0,,在这个非常简单的例子中
Dialogue: 0,0:07:56.14,0:07:58.44,Default,,0,0,0,,我们发现 即使是单条事实
Dialogue: 0,0:07:58.81,0:08:01.52,Default,,0,0,0,,比如说 (SON-OF ADAM CAIN)
Dialogue: 0,0:08:02.84,0:08:05.52,Default,,0,0,0,,可以被用来回答不同种类的问题
Dialogue: 0,0:08:06.52,0:08:08.12,Default,,0,0,0,,你可以问CAIN是谁的孩子？
Dialogue: 0,0:08:08.14,0:08:10.92,Default,,0,0,0,,你也可以问ADAM的孩子是谁？
Dialogue: 0,0:08:10.94,0:08:12.86,Default,,0,0,0,,你也可以问ADAM和CAIN之间的关系是什么？
Dialogue: 0,0:08:12.88,0:08:14.48,Default,,0,0,0,,这些由不同的传统程序
Dialogue: 0,0:08:15.53,0:08:18.54,Default,,0,0,0,,所解答的不同的问题
Dialogue: 0,0:08:18.68,0:08:20.72,Default,,0,0,0,,都基于同样的事实
Dialogue: 0,0:08:22.75,0:08:25.92,Default,,0,0,0,,这正是这种程序设计风格的威力所在
Dialogue: 0,0:08:26.91,0:08:29.50,Default,,0,0,0,,也就是一条陈述性知识
Dialogue: 0,0:08:30.04,0:08:34.01,Default,,0,0,0,,可以作为大量关于“如何做”的各种知识的基础
Dialogue: 0,0:08:34.81,0:08:37.08,Default,,0,0,0,,这跟我们正在编写的过程是不同的
Dialogue: 0,0:08:37.15,0:08:39.55,Default,,0,0,0,,我们编写的过程描述了输入
Dialogue: 0,0:08:39.61,0:08:40.65,Default,,0,0,0,,以及想要的输出
Dialogue: 0,0:08:41.49,0:08:44.70,Default,,0,0,0,,比如说 我们的平方根程序可以完美地回答
Dialogue: 0,0:08:44.76,0:08:47.16,Default,,0,0,0,,144的平方根是多少？
Dialogue: 0,0:08:48.90,0:08:49.77,Default,,0,0,0,,但从原理上来说
Dialogue: 0,0:08:49.82,0:08:52.83,Default,,0,0,0,,平方根的数学定义告诉了你另外的东西
Dialogue: 0,0:08:52.84,0:08:56.43,Default,,0,0,0,,就比如说 17是谁的平方根
Dialogue: 0,0:08:57.59,0:08:59.71,Default,,0,0,0,,这就需要另外一个程序来解答
Dialogue: 0,0:09:01.92,0:09:03.50,Default,,0,0,0,,因此 数学定义
Dialogue: 0,0:09:03.98,0:09:05.12,Default,,0,0,0,,或者更一般地说
Dialogue: 0,0:09:05.53,0:09:10.30,Default,,0,0,0,,你给定的事实 对于问题是没有偏向性的
Dialogue: 0,0:09:10.90,0:09:12.81,Default,,0,0,0,,而我们倾向于编写专门的程序
Dialogue: 0,0:09:12.83,0:09:14.20,Default,,0,0,0,,因为它们是关于“如何做”的知识
Dialogue: 0,0:09:14.24,0:09:16.36,Default,,0,0,0,,倾向于寻找特定的答案
Dialogue: 0,0:09:17.56,0:09:20.12,Default,,0,0,0,,所以这是我们正在讨论的一个特点
Dialogue: 0,0:09:21.81,0:09:22.60,Default,,0,0,0,,然而我们可以更进一步
Dialogue: 0,0:09:23.48,0:09:27.52,Default,,0,0,0,,想象一下 我们可以向语言给定一些事实
Dialogue: 0,0:09:27.71,0:09:29.61,Default,,0,0,0,,现在 我们给它一些推理规则
Dialogue: 0,0:09:30.02,0:09:31.36,Default,,0,0,0,,比如说
Dialogue: 0,0:09:31.95,0:09:36.19,Default,,0,0,0,,这里 我们先用某种语法表示
Dialogue: 0,0:09:36.44,0:09:41.53,Default,,0,0,0,,如果(SON-OF ?X ?Y)成立
Dialogue: 0,0:09:41.68,0:09:45.21,Default,,0,0,0,,在这里 我用问号来标识变量
Dialogue: 0,0:09:45.61,0:09:56.06,Default,,0,0,0,,如果(SON-OF ?X ?Y)和(SON-OF ?Y ?Z)都成立
Dialogue: 0,0:09:58.96,0:10:08.46,Default,,0,0,0,,那么就有(GRANSON ?X ?Z)
Dialogue: 0,0:10:09.32,0:10:13.40,Default,,0,0,0,,想象一下 如果把这条规则告诉机器
Dialogue: 0,0:10:15.00,0:10:17.28,Default,,0,0,0,,那么我们就可以这么来询问
Dialogue: 0,0:10:17.44,0:10:18.68,Default,,0,0,0,,谁是ADAM的孙子？
Dialogue: 0,0:10:20.61,0:10:23.64,Default,,0,0,0,,或者说 IRAD是谁的孙子？
Dialogue: 0,0:10:24.79,0:10:29.08,Default,,0,0,0,,或者从这些信息中尽可能地推断出所有的祖孙关系
Dialogue: 0,0:10:31.13,0:10:35.60,Default,,0,0,0,,我们可以想象 语言知道如何自动求解
Dialogue: 0,0:10:40.22,0:10:45.20,Default,,0,0,0,,好吧 我再举一个更具体一点的例子
Dialogue: 0,0:10:45.77,0:10:51.95,Default,,0,0,0,,这是个用来合并两个有序表的过程
Dialogue: 0,0:10:53.92,0:11:00.27,Default,,0,0,0,,X和Y是两个由数字构成的表
Dialogue: 0,0:11:00.30,0:11:04.20,Default,,0,0,0,,我们可以认为它们是严格升序的表
Dialogue: 0,0:11:04.76,0:11:07.53,Default,,0,0,0,,MERGE会把这两个表
Dialogue: 0,0:11:07.71,0:11:10.38,Default,,0,0,0,,合并成一个有序的表
Dialogue: 0,0:11:11.21,0:11:15.00,Default,,0,0,0,,这个程序非常简单
Dialogue: 0,0:11:15.02,0:11:16.14,Default,,0,0,0,,你们可以轻松地写出来
Dialogue: 0,0:11:16.39,0:11:18.64,Default,,0,0,0,,也就是 如果X为空 那么结果就是Y
Dialogue: 0,0:11:18.86,0:11:20.46,Default,,0,0,0,,如果Y为空 那结果就是X
Dialogue: 0,0:11:21.18,0:11:22.99,Default,,0,0,0,,否则的话 就要比较为首的两个元素
Dialogue: 0,0:11:22.99,0:11:24.46,Default,,0,0,0,,取出X中的第一个元素
Dialogue: 0,0:11:24.84,0:11:26.01,Default,,0,0,0,,以及Y中的第一个元素
Dialogue: 0,0:11:26.81,0:11:31.68,Default,,0,0,0,,把它们当中谁是最小的那一个
Dialogue: 0,0:11:32.83,0:11:36.60,Default,,0,0,0,,CONS在递归地调用MERGE的结果上
Dialogue: 0,0:11:37.87,0:11:39.92,Default,,0,0,0,,要么就是(MERGE (CDR X) Y)
Dialogue: 0,0:11:40.11,0:11:41.61,Default,,0,0,0,,要么就是(MERGE X (CDR Y))
Dialogue: 0,0:11:42.40,0:11:43.96,Default,,0,0,0,,这是标准的程序
Dialogue: 0,0:11:46.47,0:11:48.41,Default,,0,0,0,,我们来考察下其中的逻辑
Dialogue: 0,0:11:48.62,0:11:49.79,Default,,0,0,0,,先不考虑程序
Dialogue: 0,0:11:50.28,0:11:52.76,Default,,0,0,0,,来看看这个过程所基于的逻辑
Dialogue: 0,0:11:53.82,0:11:55.00,Default,,0,0,0,,这其中的逻辑是
Dialogue: 0,0:11:55.02,0:11:57.21,Default,,0,0,0,,如果第一个元素较小
Dialogue: 0,0:11:57.53,0:12:00.00,Default,,0,0,0,,那么最后的结果就是把它
Dialogue: 0,0:12:00.16,0:12:02.12,Default,,0,0,0,,跟递归MERGE的结果CONS起来
Dialogue: 0,0:12:02.84,0:12:04.09,Default,,0,0,0,,让我们试着把
Dialogue: 0,0:12:04.24,0:12:06.41,Default,,0,0,0,,使这个程序运作的逻辑说清楚一点
Dialogue: 0,0:12:08.30,0:12:09.44,Default,,0,0,0,,这是一部分
Dialogue: 0,0:12:10.13,0:12:11.53,Default,,0,0,0,,这段程序
Dialogue: 0,0:12:12.64,0:12:15.26,Default,,0,0,0,,递归地剥离X
Dialogue: 0,0:12:15.66,0:12:17.82,Default,,0,0,0,,如果X中的首元素较小的话
Dialogue: 0,0:12:19.98,0:12:22.54,Default,,0,0,0,,如果要显式地指出其中的逻辑的话
Dialogue: 0,0:12:23.45,0:12:26.49,Default,,0,0,0,,它其实就是演绎推理
Dialogue: 0,0:12:26.72,0:12:32.38,Default,,0,0,0,,其中 如果知道表CDR-X和表Y
Dialogue: 0,0:12:33.29,0:12:35.44,Default,,0,0,0,,能够通过MERGE-TO-FORM形成Z
Dialogue: 0,0:12:37.84,0:12:41.52,Default,,0,0,0,,并且还知道A比Y中的第一个元素小
Dialogue: 0,0:12:43.60,0:12:48.52,Default,,0,0,0,,那么你就知道 如果你把A和CDR-X给CONS起来
Dialogue: 0,0:12:49.74,0:12:51.85,Default,,0,0,0,,得到的结果和Y一起
Dialogue: 0,0:12:52.60,0:12:54.99,Default,,0,0,0,,可以通过MERGE-TO-FORM形成Z
Dialogue: 0,0:12:55.82,0:12:58.09,Default,,0,0,0,,这就是它所基于的逻辑
Dialogue: 0,0:12:58.72,0:12:59.95,Default,,0,0,0,,我没有把它写成程序
Dialogue: 0,0:12:59.96,0:13:02.00,Default,,0,0,0,,我把它写成了某种演绎
Dialogue: 0,0:13:02.03,0:13:04.89,Default,,0,0,0,,正是属于这个特定子句的
Dialogue: 0,0:13:05.21,0:13:07.26,Default,,0,0,0,,它告诉我们可以在这里使用递归
Dialogue: 0,0:13:09.41,0:13:12.78,Default,,0,0,0,,同样地 这里还有些句子来补全其中的逻辑
Dialogue: 0,0:13:14.00,0:13:15.87,Default,,0,0,0,,其它的句子都是基于这些逻辑
Dialogue: 0,0:13:15.92,0:13:18.35,Default,,0,0,0,,由于它们大部分是相同的 我就不细讲了
Dialogue: 0,0:13:19.00,0:13:20.35,Default,,0,0,0,,然后就是终止条件
Dialogue: 0,0:13:20.41,0:13:22.01,Default,,0,0,0,,是用来检查NULL的
Dialogue: 0,0:13:22.03,0:13:24.04,Default,,0,0,0,,其基本想法是 对于任意的X
Dialogue: 0,0:13:24.51,0:13:27.20,Default,,0,0,0,,X和空表可以通过MERGE-TO-FORM形成X
Dialogue: 0,0:13:28.04,0:13:30.86,Default,,0,0,0,,而空表可以和任意的Y通过MERGE-TO-FORM形成Y
Dialogue: 0,0:13:33.36,0:13:38.12,Default,,0,0,0,,这就是一段过程的代码
Dialogue: 0,0:13:38.43,0:13:40.11,Default,,0,0,0,,以及它所基于的逻辑
Dialogue: 0,0:13:41.74,0:13:42.97,Default,,0,0,0,,请注意其中的巨大差异
Dialogue: 0,0:13:45.10,0:13:50.52,Default,,0,0,0,,过程看起来是像这样的：
Dialogue: 0,0:13:50.65,0:13:52.28,Default,,0,0,0,,首先这有一个盒子
Dialogue: 0,0:13:52.86,0:13:55.39,Default,,0,0,0,,我们到目前为止所做的事都有这样的特征
Dialogue: 0,0:13:55.40,0:13:57.69,Default,,0,0,0,,我们有一个盒子 有东西进去 也有东西出来
Dialogue: 0,0:13:58.08,0:13:59.61,Default,,0,0,0,,这儿有个MERGE盒子
Dialogue: 0,0:14:01.29,0:14:03.85,Default,,0,0,0,,输入是X和Y
Dialogue: 0,0:14:04.44,0:14:05.37,Default,,0,0,0,,输出ANS
Dialogue: 0,0:14:07.63,0:14:09.48,Default,,0,0,0,,这是我们所编写的程序的特征
Dialogue: 0,0:14:13.02,0:14:14.66,Default,,0,0,0,,但是规则并不像这样
Dialogue: 0,0:14:14.66,0:14:16.76,Default,,0,0,0,,规则讨论的是关系
Dialogue: 0,0:14:17.92,0:14:24.16,Default,,0,0,0,,也就是在幻灯片中我称作MERGE-TO-FORM的关系
Dialogue: 0,0:14:25.37,0:14:28.76,Default,,0,0,0,,每当我说X和Y通过MERGE-TO-FORM形成Z
Dialogue: 0,0:14:29.00,0:14:32.33,Default,,0,0,0,,这个是一个函数
Dialogue: 0,0:14:32.61,0:14:32.85,Default,,0,0,0,,对吧？
Dialogue: 0,0:14:32.85,0:14:34.41,Default,,0,0,0,,ANS是X和Y的函数
Dialogue: 0,0:14:34.59,0:14:38.19,Default,,0,0,0,,而我这里得到的是三个东西之间的关系
Dialogue: 0,0:14:39.72,0:14:41.32,Default,,0,0,0,,我不会指明
Dialogue: 0,0:14:42.09,0:14:43.77,Default,,0,0,0,,哪个是输入 哪个是输出
Dialogue: 0,0:14:44.20,0:14:47.40,Default,,0,0,0,,我之所以这么说 是因为原理上
Dialogue: 0,0:14:48.64,0:14:50.83,Default,,0,0,0,,我们可以用同样的逻辑规则
Dialogue: 0,0:14:50.84,0:14:52.44,Default,,0,0,0,,来回答相当多的问题
Dialogue: 0,0:14:54.57,0:14:56.30,Default,,0,0,0,,比如 我们可以问
Dialogue: 0,0:14:56.72,0:14:59.05,Default,,0,0,0,,想象一下 如果把这些逻辑规则输入机器
Dialogue: 0,0:14:59.05,0:15:01.20,Default,,0,0,0,,不是输入程序 而是其中依赖的逻辑
Dialogue: 0,0:15:01.40,0:15:03.12,Default,,0,0,0,,那么 它也就应该回答--
Dialogue: 0,0:15:04.75,0:15:05.52,Default,,0,0,0,,我们可以问它
Dialogue: 0,0:15:06.73,0:15:19.18,Default,,0,0,0,,(1 3 7)和(2 4 8)可以通过MERGE-TO-FORM形成什么？
Dialogue: 0,0:15:20.91,0:15:23.42,Default,,0,0,0,,机器能够回答这样的问题
Dialogue: 0,0:15:23.88,0:15:27.36,Default,,0,0,0,,这同样也是我们的Lisp程序所回答的问题
Dialogue: 0,0:15:28.18,0:15:30.14,Default,,0,0,0,,但这同样的规则
Dialogue: 0,0:15:30.89,0:15:34.80,Default,,0,0,0,,也能够回答像这样的问题：
Dialogue: 0,0:15:36.19,0:15:43.24,Default,,0,0,0,,(1 3 7)和什么能够通过MERGE-TO-FORM形成(1 2 3 4 7 8)
Dialogue: 0,0:15:45.56,0:15:47.80,Default,,0,0,0,,同样的逻辑规则也能够回答这个
Dialogue: 0,0:15:47.84,0:15:49.90,Default,,0,0,0,,但我们编写的过程却无法回答这个问题
Dialogue: 0,0:15:50.80,0:15:52.33,Default,,0,0,0,,又或者 我们可以问
Dialogue: 0,0:15:53.71,0:16:01.12,Default,,0,0,0,,什么和什么能通过MERGE-TO-FORM
Dialogue: 0,0:16:04.28,0:16:12.68,Default,,0,0,0,,哪两个东西可以通过MERGE-TO-FORM形成(1 2 3 4 7 8)？
Dialogue: 0,0:16:13.78,0:16:15.34,Default,,0,0,0,,机器能够进行遍历
Dialogue: 0,0:16:15.84,0:16:17.31,Default,,0,0,0,,如果它能应用这些逻辑规则的话
Dialogue: 0,0:16:17.79,0:16:22.54,Default,,0,0,0,,就能够推断出这个问题所有的2^6种答案
Dialogue: 0,0:16:25.60,0:16:27.69,Default,,0,0,0,,因为可以分别是 (1)和其余的
Dialogue: 0,0:16:27.69,0:16:28.75,Default,,0,0,0,,也可以是 (1 2)和其余的
Dialogue: 0,0:16:28.79,0:16:31.53,Default,,0,0,0,,也可以是(1 3 7)和其余的
Dialogue: 0,0:16:32.01,0:16:33.26,Default,,0,0,0,,有一大堆的答案
Dialogue: 0,0:16:33.41,0:16:37.76,Default,,0,0,0,,但原理上来说 逻辑能推断出所有的答案
Dialogue: 0,0:16:38.55,0:16:42.03,Default,,0,0,0,,因此这里面就有两个巨大的不同
Dialogue: 0,0:16:44.04,0:16:46.00,Default,,0,0,0,,在我们所编写的程序中
Dialogue: 0,0:16:46.54,0:16:48.19,Default,,0,0,0,,不只是Lisp程序
Dialogue: 0,0:16:48.20,0:16:50.56,Default,,0,0,0,,基本上是你们目前编写过的所有程序
Dialogue: 0,0:16:52.03,0:16:53.60,Default,,0,0,0,,用你能叫出名字的程序语言所编写的程序
Dialogue: 0,0:16:54.15,0:16:57.79,Default,,0,0,0,,首先 我们并不准备计算一个函数
Dialogue: 0,0:17:00.62,0:17:02.01,Default,,0,0,0,,我们将要讨论的东西
Dialogue: 0,0:17:02.62,0:17:04.41,Default,,0,0,0,,并不具有输入和输出
Dialogue: 0,0:17:04.41,0:17:05.82,Default,,0,0,0,,我们讨论的是关系
Dialogue: 0,0:17:06.89,0:17:10.00,Default,,0,0,0,,也就是说 原理上 关系是没有方向性的
Dialogue: 0,0:17:11.08,0:17:15.05,Default,,0,0,0,,所以你指明用来回答这个问题的知识
Dialogue: 0,0:17:16.46,0:17:18.41,Default,,0,0,0,,也同样应该能够反过来
Dialogue: 0,0:17:18.43,0:17:21.80,Default,,0,0,0,,让你回答其它的这些问题
Dialogue: 0,0:17:26.60,0:17:29.40,Default,,0,0,0,,其次则是
Dialogue: 0,0:17:29.61,0:17:31.23,Default,,0,0,0,,因为我们讨论的是关系
Dialogue: 0,0:17:32.32,0:17:34.44,Default,,0,0,0,,关系的答案并不唯一
Dialogue: 0,0:17:35.61,0:17:37.00,Default,,0,0,0,,所以在第三个问题中
Dialogue: 0,0:17:37.02,0:17:38.36,Default,,0,0,0,,并没有特定的答案
Dialogue: 0,0:17:38.40,0:17:39.58,Default,,0,0,0,,它有很多的答案
Dialogue: 0,0:17:42.27,0:17:44.64,Default,,0,0,0,,这就是我们的目标
Dialogue: 0,0:17:44.64,0:17:45.90,Default,,0,0,0,,顺便说一下
Dialogue: 0,0:17:46.72,0:17:49.21,Default,,0,0,0,,这种程序设计风格被称作逻辑式程序设计
Dialogue: 0,0:17:50.22,0:17:51.58,Default,,0,0,0,,原因是显而易见的
Dialogue: 0,0:17:56.16,0:18:00.38,Default,,0,0,0,,用逻辑式进行程序设计的那群人之间
Dialogue: 0,0:18:00.40,0:18:03.15,Default,,0,0,0,,流传着几句箴言
Dialogue: 0,0:18:03.16,0:18:04.67,Default,,0,0,0,,他们把逻辑式程序设计的要点归纳为
Dialogue: 0,0:18:04.76,0:18:09.00,Default,,0,0,0,,用逻辑来表达 什么算是“真的”
Dialogue: 0,0:18:10.09,0:18:13.88,Default,,0,0,0,,用逻辑来检测 是否是“真的”
Dialogue: 0,0:18:14.67,0:18:17.24,Default,,0,0,0,,用逻辑来找出这些“真的”
Dialogue: 0,0:18:19.20,0:18:22.09,Default,,0,0,0,,最为大家所熟知的逻辑式程序设计语言
Dialogue: 0,0:18:22.97,0:18:24.78,Default,,0,0,0,,你们可能也听过 -- 叫做Prolog
Dialogue: 0,0:18:25.78,0:18:28.88,Default,,0,0,0,,今天早上我们将要实现的这门语言
Dialogue: 0,0:18:29.82,0:18:32.32,Default,,0,0,0,,是一种查询语言
Dialogue: 0,0:18:32.48,0:18:34.41,Default,,0,0,0,,它基本上就是Prolog的本质了
Dialogue: 0,0:18:35.32,0:18:36.73,Default,,0,0,0,,它可以完成相同的工作
Dialogue: 0,0:18:37.29,0:18:38.73,Default,,0,0,0,,虽然它比Prolog慢得多
Dialogue: 0,0:18:38.73,0:18:40.01,Default,,0,0,0,,这是因为我们是通过Lisp来解释的
Dialogue: 0,0:18:41.90,0:18:44.36,Default,,0,0,0,,而非构造一个专门的编译器
Dialogue: 0,0:18:44.46,0:18:46.62,Default,,0,0,0,,对它的解释 将运行在Lisp解释器之上
Dialogue: 0,0:18:47.51,0:18:49.84,Default,,0,0,0,,除此之外 它可以完成与Prolog相同的事儿
Dialogue: 0,0:18:49.88,0:18:52.78,Default,,0,0,0,,不但同样的能力 也有同样的局限
Dialogue: 0,0:18:55.08,0:18:56.17,Default,,0,0,0,,好吧 先解答一下疑惑
Dialogue: 0,0:19:00.43,0:19:02.84,Default,,0,0,0,,学生：您能再重复一下
Dialogue: 0,0:19:03.48,0:19:06.09,Default,,0,0,0,,用逻辑去寻找的三件事么？
Dialogue: 0,0:19:06.72,0:19:09.84,Default,,0,0,0,,就是那些 找出什么为真 知道什么是真 等等
Dialogue: 0,0:19:09.84,0:19:10.52,Default,,0,0,0,,教授：好的
Dialogue: 0,0:19:10.56,0:19:15.74,Default,,0,0,0,,这算是程序员的某种“教义问答”
Dialogue: 0,0:19:15.85,0:19:19.16,Default,,0,0,0,,我们用逻辑来表达怎么算是“真的”
Dialogue: 0,0:19:20.80,0:19:21.79,Default,,0,0,0,,就像这些规则一样
Dialogue: 0,0:19:22.61,0:19:25.56,Default,,0,0,0,,我们用逻辑来检测某事是否是“真的”
Dialogue: 0,0:19:25.60,0:19:27.76,Default,,0,0,0,,但在这里我没有回答这个问题
Dialogue: 0,0:19:28.55,0:19:29.29,Default,,0,0,0,,我可以问
Dialogue: 0,0:19:29.68,0:19:32.14,Default,,0,0,0,,在这里我可以这样来问
Dialogue: 0,0:19:33.26,0:19:36.56,Default,,0,0,0,,(1 3 7)和(2 4 8)是否能够
Dialogue: 0,0:19:36.91,0:19:40.38,Default,,0,0,0,,通过MERGE-TO-FORM形成(1 2 6 19)
Dialogue: 0,0:19:41.12,0:19:44.68,Default,,0,0,0,,同样的逻辑规则会告诉我们不行
Dialogue: 0,0:19:45.69,0:19:47.93,Default,,0,0,0,,这里 我使用逻辑来检测是否为真
Dialogue: 0,0:19:48.28,0:19:50.48,Default,,0,0,0,,然后 我们也可以使用逻辑来找出为真的东西
Dialogue: 0,0:20:04.46,0:20:05.16,Default,,0,0,0,,休息一下吧
Dialogue: 0,0:20:06.13,0:20:17.02,Default,,0,0,0,,[音乐]
Dialogue: 0,0:20:17.05,0:20:20.68,Declare,,0,0,0,,{\an2\fad(500,500)}《计算机程序的构造和解释》
Dialogue: 0,0:20:47.59,0:20:51.02,Declare,,0,0,0,,{\an2\fad(500,500)}讲师：哈罗德·艾伯森教授 及 格兰德·杰·萨斯曼教授
Dialogue: 0,0:20:51.07,0:20:55.60,Declare,,0,0,0,,{\an2\fad(500,500)}《计算机程序的构造和解释》
Dialogue: 0,0:20:55.63,0:21:00.68,Declare,,0,0,0,,{\an2\fad(500,500)}逻辑式程序设计 I
Dialogue: 0,0:21:03.24,0:21:04.97,Default,,0,0,0,,教授：让我们继续来看一看
Dialogue: 0,0:21:05.84,0:21:08.44,Default,,0,0,0,,这个查询语言及其操作
Dialogue: 0,0:21:10.52,0:21:11.84,Default,,0,0,0,,首先需要注意到
Dialogue: 0,0:21:12.24,0:21:14.14,Default,,0,0,0,,当我建立好那个小型的圣经数据库后
Dialogue: 0,0:21:14.16,0:21:17.24,Default,,0,0,0,,我们就能够针对一系列的事实
Dialogue: 0,0:21:17.48,0:21:19.92,Default,,0,0,0,,以关系的方式来向这个语言提问
Dialogue: 0,0:21:21.33,0:21:25.15,Default,,0,0,0,,因此 我们先来陈述一些事实
Dialogue: 0,0:21:26.06,0:21:29.68,Default,,0,0,0,,这是波士顿一家高科技公司的
Dialogue: 0,0:21:30.08,0:21:32.62,Default,,0,0,0,,一小部分人事档案
Dialogue: 0,0:21:33.05,0:21:36.80,Default,,0,0,0,,这部分档案是Ben Bitdiddle的
Dialogue: 0,0:21:37.50,0:21:41.95,Default,,0,0,0,,Bitdiddle是这家公司的计算机向导
Dialogue: 0,0:21:42.84,0:21:45.80,Default,,0,0,0,,他是这家公司的低薪向导
Dialogue: 0,0:21:46.42,0:21:48.78,Default,,0,0,0,,他的上司是Oliver Warbucks
Dialogue: 0,0:21:49.28,0:21:50.70,Default,,0,0,0,,这里是他的住址
Dialogue: 0,0:21:52.15,0:21:56.54,Default,,0,0,0,,我们按照这样的格式给出信息：职务、薪水、上司、住址
Dialogue: 0,0:21:57.56,0:21:59.25,Default,,0,0,0,,还有一些其它的约定
Dialogue: 0,0:21:59.25,0:22:02.22,Default,,0,0,0,,这里的COMPUTER表示BEN在计算机分部工作
Dialogue: 0,0:22:02.76,0:22:04.94,Default,,0,0,0,,而他在这个分部的工作是向导
Dialogue: 0,0:22:05.66,0:22:07.15,Default,,0,0,0,,这里是其他人的
Dialogue: 0,0:22:07.16,0:22:12.28,Default,,0,0,0,,Alyssa P.Hacker是一名计算机程序员
Dialogue: 0,0:22:13.36,0:22:14.60,Default,,0,0,0,,她的上司是Ben
Dialogue: 0,0:22:15.21,0:22:16.54,Default,,0,0,0,,而她住在Cambridge
Dialogue: 0,0:22:17.55,0:22:19.42,Default,,0,0,0,,Ben手下的另外一个程序员
Dialogue: 0,0:22:20.03,0:22:21.44,Default,,0,0,0,,叫做Lem E. Tweakit
Dialogue: 0,0:22:22.82,0:22:26.73,Default,,0,0,0,,实习程序员 Louis Reasoner
Dialogue: 0,0:22:27.42,0:22:28.62,Default,,0,0,0,,在Alyssa手下工作
Dialogue: 0,0:22:30.10,0:22:35.45,Default,,0,0,0,,公司里的“大老板”不为任何人工作
Dialogue: 0,0:22:36.81,0:22:38.11,Default,,0,0,0,,这就是Oliver Warbucks的档案了
Dialogue: 0,0:22:38.11,0:22:39.31,Default,,0,0,0,,我们将要做的就是
Dialogue: 0,0:22:40.94,0:22:43.66,Default,,0,0,0,,对这个小型的世界提问
Dialogue: 0,0:22:44.97,0:22:48.40,Default,,0,0,0,,这将是我们进行逻辑运算的样本世界
Dialogue: 0,0:22:51.42,0:22:54.96,Default,,0,0,0,,我再最后一次强调一下
Dialogue: 0,0:22:55.60,0:22:58.20,Default,,0,0,0,,你们应该从这门课中学到的最重要的知识
Dialogue: 0,0:22:58.80,0:23:01.66,Default,,0,0,0,,也就是 当别人向你介绍语言时
Dialogue: 0,0:23:02.25,0:23:04.43,Default,,0,0,0,,你要问：“它的基本元素是什么？”
Dialogue: 0,0:23:06.12,0:23:07.79,Default,,0,0,0,,组合的手段有哪些？
Dialogue: 0,0:23:14.70,0:23:16.40,Default,,0,0,0,,如何把基本元素组织在一起
Dialogue: 0,0:23:16.67,0:23:19.37,Default,,0,0,0,,然后把它们抽象出来？
Dialogue: 0,0:23:19.96,0:23:21.93,Default,,0,0,0,,如何抽象这些复合元素
Dialogue: 0,0:23:24.68,0:23:27.58,Default,,0,0,0,,以便于你能够复用它们构造更复杂的东西？
Dialogue: 0,0:23:29.02,0:23:30.81,Default,,0,0,0,,我已经强调过很多次了
Dialogue: 0,0:23:31.16,0:23:32.48,Default,,0,0,0,,但还是值得重申一遍
Dialogue: 0,0:23:35.00,0:23:36.67,Default,,0,0,0,,记住了么？我们开始了
Dialogue: 0,0:23:36.67,0:23:37.34,Default,,0,0,0,,首先是基本元素
Dialogue: 0,0:23:37.77,0:23:39.44,Default,,0,0,0,,这其中 只有唯一的基本元素
Dialogue: 0,0:23:40.96,0:23:43.20,Default,,0,0,0,,这门语言中的基本元素就是“查询”
Dialogue: 0,0:23:44.14,0:23:45.74,Default,,0,0,0,,一条基本查询
Dialogue: 0,0:23:46.81,0:23:48.25,Default,,0,0,0,,我们先来看几条基本查询
Dialogue: 0,0:23:51.82,0:23:53.02,Default,,0,0,0,,首先 这条查询问的是
Dialogue: 0,0:23:53.10,0:23:54.81,Default,,0,0,0,,“谁是计算机程序员？”
Dialogue: 0,0:23:55.55,0:23:59.88,Default,,0,0,0,,或者可以解释为：找出数据库中
Dialogue: 0,0:24:01.55,0:24:06.14,Default,,0,0,0,,所有JOB栏为COMPUTER PROGRAMMER的事实
Dialogue: 0,0:24:06.64,0:24:08.01,Default,,0,0,0,,这里有一些小语法
Dialogue: 0,0:24:08.47,0:24:10.59,Default,,0,0,0,,不带问号的都是字面量
Dialogue: 0,0:24:11.28,0:24:13.15,Default,,0,0,0,,?X表示X是变量
Dialogue: 0,0:24:13.31,0:24:15.56,Default,,0,0,0,,而这条查询会匹配 比如说 --
Dialogue: 0,0:24:16.03,0:24:19.00,Default,,0,0,0,,Alyssa P. Hacker 是程序员
Dialogue: 0,0:24:19.28,0:24:21.93,Default,,0,0,0,,其中X为Alyssa P. Hacker这条事实
Dialogue: 0,0:24:26.82,0:24:29.98,Default,,0,0,0,,或者更一般地 我可以在一条查询中引入两个变量
Dialogue: 0,0:24:30.75,0:24:31.45,Default,,0,0,0,,我可以问
Dialogue: 0,0:24:31.60,0:24:35.88,Default,,0,0,0,,?X的JOB必须是COMPUTER ?TYPE
Dialogue: 0,0:24:39.34,0:24:41.39,Default,,0,0,0,,也就是会匹配COMPUTER WIZARD
Dialogue: 0,0:24:42.14,0:24:44.28,Default,,0,0,0,,所以这里?TYPE可能会匹配WIZARD
Dialogue: 0,0:24:44.92,0:24:46.46,Default,,0,0,0,,也可能会匹配PROGRAMMER
Dialogue: 0,0:24:47.48,0:24:50.37,Default,,0,0,0,,而?X会匹配不同的东西
Dialogue: 0,0:24:50.37,0:24:52.24,Default,,0,0,0,,但在我们的这个小例子中
Dialogue: 0,0:24:52.25,0:24:55.15,Default,,0,0,0,,数据库中只有三条事实符合那条查询
Dialogue: 0,0:24:59.12,0:25:02.08,Default,,0,0,0,,把语法说得再清楚一点 同样的查询
Dialogue: 0,0:25:05.29,0:25:08.09,Default,,0,0,0,,同样的这条指定了?X的JOB的查询
Dialogue: 0,0:25:09.85,0:25:11.79,Default,,0,0,0,,并不能够与Lewis Reasoner匹配
Dialogue: 0,0:25:11.84,0:25:13.64,Default,,0,0,0,,这是因为我这里所写的
Dialogue: 0,0:25:14.22,0:25:17.74,Default,,0,0,0,,表示要匹配的是由两个符号构成的表
Dialogue: 0,0:25:19.96,0:25:21.96,Default,,0,0,0,,其中首元素必须为单词“COMPUTER”
Dialogue: 0,0:25:22.32,0:25:23.80,Default,,0,0,0,,而第二个可以匹配任意的东西
Dialogue: 0,0:25:25.08,0:25:27.32,Default,,0,0,0,,而Lewis这里的工作描述有三个符号
Dialogue: 0,0:25:27.80,0:25:28.83,Default,,0,0,0,,因此不匹配
Dialogue: 0,0:25:30.34,0:25:32.19,Default,,0,0,0,,你们还需要知道的一种语法是
Dialogue: 0,0:25:35.04,0:25:38.32,Default,,0,0,0,,更具一般性的点记号
Dialogue: 0,0:25:40.17,0:25:42.92,Default,,0,0,0,,这个标准的表记号表示的是
Dialogue: 0,0:25:43.04,0:25:43.82,Default,,0,0,0,,首先这是一个表
Dialogue: 0,0:25:44.12,0:25:47.32,Default,,0,0,0,,它的首元素为单词“COMPUTER”
Dialogue: 0,0:25:47.58,0:25:50.22,Default,,0,0,0,,而其余的部分 我们把它们称作?TYPE
Dialogue: 0,0:25:53.73,0:25:55.50,Default,,0,0,0,,因此这条查询就会匹配上
Dialogue: 0,0:25:56.93,0:25:59.31,Default,,0,0,0,,Lewis的工作是COMPUTER PROGRAMMER TRAINEE
Dialogue: 0,0:25:59.44,0:26:03.29,Default,,0,0,0,,而?TYPE的值将会是这个表的CDR部分
Dialogue: 0,0:26:03.32,0:26:05.64,Default,,0,0,0,,也就是表(PROGRAMMER TRAINEE)
Dialogue: 0,0:26:06.96,0:26:10.46,Default,,0,0,0,,Lisp源码读取器会自动完成对点记号的处理
Dialogue: 0,0:26:15.90,0:26:17.76,Default,,0,0,0,,让我们来实际操作一下
Dialogue: 0,0:26:17.76,0:26:20.51,Default,,0,0,0,,我将向语言系统输入这些查询
Dialogue: 0,0:26:20.76,0:26:21.82,Default,,0,0,0,,然后得到结果
Dialogue: 0,0:26:22.54,0:26:24.48,Default,,0,0,0,,让我们在计算机中试试
Dialogue: 0,0:26:25.18,0:26:26.51,Default,,0,0,0,,我可以问
Dialogue: 0,0:26:27.34,0:26:28.88,Default,,0,0,0,,谁在计算机分部工作？
Dialogue: 0,0:26:30.00,0:26:38.22,Default,,0,0,0,,(JOB ?X (COMPUTER . ?Y)
Dialogue: 0,0:26:39.73,0:26:41.48,Default,,0,0,0,,哑变量的名字并不重要
Dialogue: 0,0:26:42.76,0:26:44.14,Default,,0,0,0,,查询的结果是
Dialogue: 0,0:26:44.41,0:26:45.68,Default,,0,0,0,,有四条记录
Dialogue: 0,0:26:48.65,0:26:50.09,Default,,0,0,0,,我也可以问
Dialogue: 0,0:26:50.56,0:26:52.38,Default,,0,0,0,,大家的上司都是谁？
Dialogue: 0,0:26:52.81,0:26:54.88,Default,,0,0,0,,我输入一条基本查询
Dialogue: 0,0:26:56.52,0:26:59.39,Default,,0,0,0,,(SUPERVISOR ?X ?Y)
Dialogue: 0,0:27:02.56,0:27:05.42,Default,,0,0,0,,这些都是我所知道的上下级关系
Dialogue: 0,0:27:05.54,0:27:08.83,Default,,0,0,0,,或者我也可以问：“谁住在Cambridge？”
Dialogue: 0,0:27:08.83,0:27:09.47,Default,,0,0,0,,我就这么输入：
Dialogue: 0,0:27:10.24,0:27:20.92,Default,,0,0,0,,(ADDRESS ?X (CAMBRIDGE . ?T))
Dialogue: 0,0:27:25.09,0:27:26.89,Default,,0,0,0,,只有一个人住在Cambridge
Dialogue: 0,0:27:30.82,0:27:32.17,Default,,0,0,0,,这些就是基本查询
Dialogue: 0,0:27:32.17,0:27:34.96,Default,,0,0,0,,你们看到的这些 就是与系统的基础交互
Dialogue: 0,0:27:35.29,0:27:39.24,Default,,0,0,0,,你输入一条查询 他输出所有可能的查询
Dialogue: 0,0:27:39.62,0:27:40.65,Default,,0,0,0,,换句话说 也就是
Dialogue: 0,0:27:40.67,0:27:44.16,Default,,0,0,0,,它找出这些变量所有可能的值
Dialogue: 0,0:27:44.19,0:27:45.87,Default,,0,0,0,,不管它是叫X、Y还是T
Dialogue: 0,0:27:46.09,0:27:52.08,Default,,0,0,0,,然后它输出的是用所有可行值实例化该条查询的结果
Dialogue: 0,0:27:52.92,0:27:55.16,Default,,0,0,0,,也就是规则系统那一课讲的“实例化”
Dialogue: 0,0:27:55.16,0:27:58.83,Default,,0,0,0,,用变量所有可能的值来实例化查询
Dialogue: 0,0:27:59.00,0:28:00.35,Default,,0,0,0,,然后输出所有的结果
Dialogue: 0,0:28:01.00,0:28:03.35,Default,,0,0,0,,当然 还有不同的呈现结果的方式
Dialogue: 0,0:28:03.35,0:28:06.01,Default,,0,0,0,,比如说 Prolog就有些不一样
Dialogue: 0,0:28:06.01,0:28:07.44,Default,,0,0,0,,它并不向你返回查询
Dialogue: 0,0:28:07.76,0:28:10.78,Default,,0,0,0,,Prolog会输出X=这个 Y=那个
Dialogue: 0,0:28:10.97,0:28:12.94,Default,,0,0,0,,又或者X=这个 Y=那个
Dialogue: 0,0:28:13.66,0:28:15.48,Default,,0,0,0,,这是使用界面层次的差别
Dialogue: 0,0:28:15.71,0:28:17.05,Default,,0,0,0,,你可以根据你的喜好来决定
Dialogue: 0,0:28:18.97,0:28:19.58,Default,,0,0,0,,我们继续
Dialogue: 0,0:28:21.00,0:28:22.68,Default,,0,0,0,,也就是说 这个语言中的基本元素
Dialogue: 0,0:28:23.39,0:28:24.57,Default,,0,0,0,,只有一个 对吧？
Dialogue: 0,0:28:24.57,0:28:27.23,Default,,0,0,0,,也就是基本查询
Dialogue: 0,0:28:31.31,0:28:32.56,Default,,0,0,0,,来看看组合的手段
Dialogue: 0,0:28:34.33,0:28:37.68,Default,,0,0,0,,我们来考察一下这个语言中的复合查询
Dialogue: 0,0:28:39.77,0:28:40.46,Default,,0,0,0,,比如这条
Dialogue: 0,0:28:41.79,0:28:42.51,Default,,0,0,0,,这条查询是说
Dialogue: 0,0:28:45.05,0:28:48.22,Default,,0,0,0,,列举出所有在计算机分部工作的人
Dialogue: 0,0:28:49.81,0:28:52.00,Default,,0,0,0,,在计算机分部工作的人
Dialogue: 0,0:28:52.54,0:28:53.96,Default,,0,0,0,,以及他们的上司
Dialogue: 0,0:28:56.80,0:28:58.83,Default,,0,0,0,,我使用AND来编写这条查询
Dialogue: 0,0:29:00.22,0:29:04.06,Default,,0,0,0,,(AND (JOB ?X (COMPUTER . ?Y))
Dialogue: 0,0:29:04.92,0:29:06.83,Default,,0,0,0,,(JOB ?X (COMPUTER . ?Y))
Dialogue: 0,0:29:07.56,0:29:10.03,Default,,0,0,0,,并且(SUPERVISOR ?X ?Z)
Dialogue: 0,0:29:11.44,0:29:14.16,Default,,0,0,0,,找出所有在计算机分部工作的人 -- 对应这条
Dialogue: 0,0:29:14.30,0:29:15.88,Default,,0,0,0,,以及它们的上司
Dialogue: 0,0:29:16.46,0:29:17.82,Default,,0,0,0,,注意这条查询中
Dialogue: 0,0:29:18.67,0:29:22.41,Default,,0,0,0,,我引入了三个变量 ?X ?Y 以及 ?Z
Dialogue: 0,0:29:23.58,0:29:28.65,Default,,0,0,0,,并且 这两个?X应该匹配同样的东西
Dialogue: 0,0:29:29.45,0:29:31.16,Default,,0,0,0,,?X被约束在了计算机分部中
Dialogue: 0,0:29:31.31,0:29:33.00,Default,,0,0,0,,并且?X的上司是?Z
Dialogue: 0,0:29:34.81,0:29:35.80,Default,,0,0,0,,我们再来看一条
Dialogue: 0,0:29:37.25,0:29:39.28,Default,,0,0,0,,AND算是一种组合手段
Dialogue: 0,0:29:41.44,0:29:43.96,Default,,0,0,0,,哪些人的薪水超过$30,000？
Dialogue: 0,0:29:45.71,0:29:51.71,Default,,0,0,0,,(AND (SALARY ?P ?A)
Dialogue: 0,0:29:54.59,0:29:57.45,Default,,0,0,0,,而关于?A的要求则是
Dialogue: 0,0:29:57.48,0:30:00.12,Default,,0,0,0,,(LISP-VALUE > ?A 300000)
Dialogue: 0,0:30:00.60,0:30:03.23,Default,,0,0,0,,这里的LISP-VALUE是一个接口
Dialogue: 0,0:30:04.30,0:30:10.04,Default,,0,0,0,,用来连接查询语言与其底层的Lisp
Dialogue: 0,0:30:10.60,0:30:12.72,Default,,0,0,0,,LISP-VALUE让你能够在查询
Dialogue: 0,0:30:12.75,0:30:16.91,Default,,0,0,0,,中调用任意的Lisp谓词
Dialogue: 0,0:30:17.18,0:30:20.11,Default,,0,0,0,,因为我要用Lisp中的谓词> 所以我用LISP-VALUE
Dialogue: 0,0:30:21.02,0:30:21.75,Default,,0,0,0,,所以这里我用了AND
Dialogue: 0,0:30:21.75,0:30:24.48,Default,,0,0,0,,因此这样就查询出了薪水超过$30000的人
Dialogue: 0,0:30:28.19,0:30:30.03,Default,,0,0,0,,或者这条更复杂的查询
Dialogue: 0,0:30:31.27,0:30:35.02,Default,,0,0,0,,告诉我所有那些 在计算机分部中工作
Dialogue: 0,0:30:36.25,0:30:39.36,Default,,0,0,0,,但他的上司不在计算机分部工作的人
Dialogue: 0,0:30:42.79,0:30:45.51,Default,,0,0,0,,(AND (JOB ?X (COMPUTER . ?Y))
Dialogue: 0,0:30:45.51,0:30:47.32,Default,,0,0,0,,表示?X在计算机分部工作
Dialogue: 0,0:30:47.78,0:30:49.24,Default,,0,0,0,,但是呢
Dialogue: 0,0:30:50.49,0:30:54.25,Default,,0,0,0,,?X的上司?Z
Dialogue: 0,0:30:55.37,0:30:57.87,Default,,0,0,0,,?Z的JOB不是形如(COMPUTER ...)一类的
Dialogue: 0,0:30:59.62,0:31:00.35,Default,,0,0,0,,同样的
Dialogue: 0,0:31:00.51,0:31:02.38,Default,,0,0,0,,这两个?X应该是一致的
Dialogue: 0,0:31:03.20,0:31:05.76,Default,,0,0,0,,而这两个?Z也应该是一致的
Dialogue: 0,0:31:09.39,0:31:11.38,Default,,0,0,0,,你又了解了另一种组合手段 -- NOT
Dialogue: 0,0:31:17.71,0:31:18.67,Default,,0,0,0,,好了 再让我们来试试这些
Dialogue: 0,0:31:20.88,0:31:22.08,Default,,0,0,0,,它同样起效
Dialogue: 0,0:31:22.40,0:31:24.12,Default,,0,0,0,,我可以问计算机：
Dialogue: 0,0:31:26.89,0:31:35.40,Default,,0,0,0,,(AND (JOB ?X (COMPUTER . ?Y)))
Dialogue: 0,0:31:38.84,0:31:45.95,Default,,0,0,0,,另一个条件是(SUPERVISOR ?X ?Z)
Dialogue: 0,0:31:46.83,0:31:49.53,Default,,0,0,0,,我把这条查询输入进去
Dialogue: 0,0:31:51.07,0:31:52.97,Default,,0,0,0,,计算机返回给我们的
Dialogue: 0,0:31:54.00,0:31:58.73,Default,,0,0,0,,计算机利用所有可能的答案把我的查询实例化了
Dialogue: 0,0:31:58.93,0:32:00.08,Default,,0,0,0,,你会发现有很多的答案
Dialogue: 0,0:32:01.69,0:32:02.14,Default,,0,0,0,,好
Dialogue: 0,0:32:02.19,0:32:04.04,Default,,0,0,0,,之所以把这门语言称作“逻辑语言”
Dialogue: 0,0:32:05.21,0:32:06.60,Default,,0,0,0,,是因为这门语言中的组合手段
Dialogue: 0,0:32:06.64,0:32:09.47,Default,,0,0,0,,都是逻辑运算
Dialogue: 0,0:32:09.80,0:32:15.68,Default,,0,0,0,,组合的手段有AND和NOT
Dialogue: 0,0:32:15.96,0:32:17.92,Default,,0,0,0,,以及我还没有告诉你的OR
Dialogue: 0,0:32:18.49,0:32:20.36,Default,,0,0,0,,我还告诉过你LISP-VALUE
Dialogue: 0,0:32:20.72,0:32:24.48,Default,,0,0,0,,当然 虽然它不是一个逻辑运算
Dialogue: 0,0:32:24.51,0:32:26.89,Default,,0,0,0,,但是这个特殊的小技巧把它跟Lisp连接在了一起
Dialogue: 0,0:32:27.34,0:32:28.75,Default,,0,0,0,,让你获得了更多的力量
Dialogue: 0,0:32:29.25,0:32:30.67,Default,,0,0,0,,这些就是组合手段
Dialogue: 0,0:32:32.59,0:32:33.98,Default,,0,0,0,,好 接着是抽象手段
Dialogue: 0,0:32:34.16,0:32:35.21,Default,,0,0,0,,我们想要的是
Dialogue: 0,0:32:38.27,0:32:41.24,Default,,0,0,0,,想让我们回过头来看上一张幻灯片
Dialogue: 0,0:32:42.26,0:32:44.25,Default,,0,0,0,,我们想要把一些非常复杂的东西
Dialogue: 0,0:32:44.46,0:32:48.00,Default,,0,0,0,,比如不与上司在同一部门工作
Dialogue: 0,0:32:48.01,0:32:50.09,Default,,0,0,0,,的人的这种概念
Dialogue: 0,0:32:52.40,0:32:55.10,Default,,0,0,0,,像以前一样 给它命名
Dialogue: 0,0:32:56.09,0:32:58.12,Default,,0,0,0,,如果在某个分部工作的人
Dialogue: 0,0:32:58.17,0:33:00.25,Default,,0,0,0,,他的上司却不在那个分部工作
Dialogue: 0,0:33:00.48,0:33:01.93,Default,,0,0,0,,这就意味着他是个“大腕”
Dialogue: 0,0:33:02.75,0:33:05.13,Default,,0,0,0,,这样 我们就定义一条规则指明
Dialogue: 0,0:33:06.43,0:33:09.16,Default,,0,0,0,,如果?X是某个部门的BIGSHOT
Dialogue: 0,0:33:10.91,0:33:14.68,Default,,0,0,0,,如果他在该部门工作
Dialogue: 0,0:33:16.04,0:33:20.08,Default,,0,0,0,,并且他的上司不在该部门工作
Dialogue: 0,0:33:21.51,0:33:22.94,Default,,0,0,0,,因此这就是我们的抽象手段
Dialogue: 0,0:33:22.94,0:33:23.90,Default,,0,0,0,,这是一条规则
Dialogue: 0,0:33:26.22,0:33:27.58,Default,,0,0,0,,规则由三部分构成
Dialogue: 0,0:33:31.00,0:33:32.48,Default,,0,0,0,,关键字RULE表明这是一条规则
Dialogue: 0,0:33:33.40,0:33:35.48,Default,,0,0,0,,接着是规则的结论
Dialogue: 0,0:33:37.53,0:33:39.07,Default,,0,0,0,,然后是规则的体
Dialogue: 0,0:33:40.00,0:33:41.88,Default,,0,0,0,,你可以把它解读为这样的一段逻辑：
Dialogue: 0,0:33:41.92,0:33:45.15,Default,,0,0,0,,如果你知道规则的体为真
Dialogue: 0,0:33:46.40,0:33:48.72,Default,,0,0,0,,那么你就可以推导出结论为真
Dialogue: 0,0:33:49.45,0:33:53.28,Default,,0,0,0,,或者说为了推断出?X是某个部门的“大腕”
Dialogue: 0,0:33:53.79,0:33:55.71,Default,,0,0,0,,这些条件足够验证了
Dialogue: 0,0:33:57.48,0:33:58.82,Default,,0,0,0,,这就是规则的形式
Dialogue: 0,0:34:03.28,0:34:06.16,Default,,0,0,0,,让我们回过头来看看
Dialogue: 0,0:34:06.73,0:34:07.92,Default,,0,0,0,,课间休息前我举的那个例子
Dialogue: 0,0:34:08.11,0:34:10.68,Default,,0,0,0,,我们来看看 如果用规则来描述会是什么样的
Dialogue: 0,0:34:11.44,0:34:12.84,Default,,0,0,0,,我会抽取出其中的逻辑
Dialogue: 0,0:34:13.08,0:34:15.50,Default,,0,0,0,,并将它们变为这种格式的规则
Dialogue: 0,0:34:18.73,0:34:19.35,Default,,0,0,0,,就有了下面的规则
Dialogue: 0,0:34:19.35,0:34:20.96,Default,,0,0,0,,这就是MERGE-TO-FORM的规则
Dialogue: 0,0:34:21.71,0:34:22.97,Default,,0,0,0,,这个规则是说
Dialogue: 0,0:34:26.28,0:34:29.62,Default,,0,0,0,,'()与?Y可以通过MERGE-TO-FORM形成?Y
Dialogue: 0,0:34:29.62,0:34:30.87,Default,,0,0,0,,这是规则的结论
Dialogue: 0,0:34:33.21,0:34:35.74,Default,,0,0,0,,需要注意的是 这个特定的规则没有体
Dialogue: 0,0:34:36.65,0:34:37.66,Default,,0,0,0,,在这门语言中
Dialogue: 0,0:34:38.11,0:34:40.86,Default,,0,0,0,,没有体的规则总是真的
Dialogue: 0,0:34:41.23,0:34:42.51,Default,,0,0,0,,你总是可以假设它们为真
Dialogue: 0,0:34:45.19,0:34:46.49,Default,,0,0,0,,另一条规则说的是
Dialogue: 0,0:34:46.64,0:34:49.46,Default,,0,0,0,,任意对象与空表进行MERGE-TO-FORM 得到的任然是原物
Dialogue: 0,0:34:49.46,0:34:50.12,Default,,0,0,0,,就是这条
Dialogue: 0,0:34:50.90,0:34:53.55,Default,,0,0,0,,(MERGE-TO-FORM ?Y '() ?Y)
Dialogue: 0,0:34:55.51,0:34:58.40,Default,,0,0,0,,它们对应了我们MERGE过程中的两个终止条件
Dialogue: 0,0:34:58.44,0:34:59.77,Default,,0,0,0,,但我们现在讨论的是逻辑
Dialogue: 0,0:35:00.41,0:35:01.45,Default,,0,0,0,,而非过程
Dialogue: 0,0:35:03.49,0:35:04.48,Default,,0,0,0,,我们还有另外一条规则
Dialogue: 0,0:35:04.83,0:35:08.73,Default,,0,0,0,,描述的是 如果你知道如何MERGE较短的表
Dialogue: 0,0:35:08.91,0:35:09.83,Default,,0,0,0,,那么你就可以把它们结合在一起
Dialogue: 0,0:35:09.83,0:35:14.16,Default,,0,0,0,,这条规则说：如果你有表?X、?Y以及?Z
Dialogue: 0,0:35:14.92,0:35:17.61,Default,,0,0,0,,如果你想推断出(?A . ?X)
Dialogue: 0,0:35:17.63,0:35:19.08,Default,,0,0,0,,这个记法表示(CONS ?A ?X)
Dialogue: 0,0:35:19.48,0:35:22.36,Default,,0,0,0,,或者说首元素是'A、剩余元素是'X的表
Dialogue: 0,0:35:23.16,0:35:27.40,Default,,0,0,0,,由此 如果你想推断(MERGE-TO-FROM (?A . ?X) (?B . ?Y) (?B . ?Z))
Dialogue: 0,0:35:30.36,0:35:33.90,Default,,0,0,0,,毋宁说如果你想要把表(?A ?X)和表(?B ?Y)合并得到
Dialogue: 0,0:35:33.92,0:35:35.85,Default,,0,0,0,,一个以?B为首的表
Dialogue: 0,0:35:36.76,0:35:40.67,Default,,0,0,0,,你想要推断出这个结果 就要满足
Dialogue: 0,0:35:40.91,0:35:44.48,Default,,0,0,0,,不但(MERGE-TP-FORM (?A . ?X) ?Y ?Z)
Dialogue: 0,0:35:45.18,0:35:47.24,Default,,0,0,0,,并且(LISP-VALUE > ?A ?B)
Dialogue: 0,0:35:48.69,0:35:50.59,Default,,0,0,0,,因此当我在合并它们时 ?B会首先出现在表中
Dialogue: 0,0:35:51.82,0:35:54.91,Default,,0,0,0,,这就是简单的把我之前写的伪代码
Dialogue: 0,0:35:55.24,0:35:57.18,Default,,0,0,0,,翻译成逻辑的语言
Dialogue: 0,0:35:57.96,0:36:01.63,Default,,0,0,0,,为了翻译完整 这还里有种情况
Dialogue: 0,0:36:02.88,0:36:05.95,Default,,0,0,0,,(MERGE-TO-FORM (?A . ?X) (?B . ?Y) (?A . ?Z))成立
Dialogue: 0,0:36:06.08,0:36:09.16,Default,,0,0,0,,就需要(MERGE-TO-FORM ?X (?B . ?Y) ?Z)
Dialogue: 0,0:36:09.47,0:36:11.00,Default,,0,0,0,,和(LISP-VALUE > ?B ?A)都成立
Dialogue: 0,0:36:12.19,0:36:15.98,Default,,0,0,0,,我已经把这个用逻辑语言编写的小程序输入计算机了
Dialogue: 0,0:36:16.01,0:36:17.07,Default,,0,0,0,,现在让我们来试着运行一下
Dialogue: 0,0:36:21.90,0:36:23.90,Default,,0,0,0,,由于我已经输入过MERGE-TO-FORM的规则了
Dialogue: 0,0:36:24.62,0:36:25.77,Default,,0,0,0,,我就可以
Dialogue: 0,0:36:27.04,0:36:28.51,Default,,0,0,0,,我可以像过程一样使用它
Dialogue: 0,0:36:28.51,0:36:38.24,Default,,0,0,0,,我可以问(MERGE-TO-FORM (1 3) (2 7) ?X)
Dialogue: 0,0:36:39.42,0:36:41.55,Default,,0,0,0,,这里 我把它当作一个Lisp过程来使用
Dialogue: 0,0:36:43.16,0:36:44.97,Default,,0,0,0,,它先会思考一会儿
Dialogue: 0,0:36:46.43,0:36:47.56,Default,,0,0,0,,然后应用这些规则
Dialogue: 0,0:36:50.78,0:36:51.92,Default,,0,0,0,,它找到了一个答案
Dialogue: 0,0:36:52.80,0:36:54.54,Default,,0,0,0,,现在它还要继续寻找其它的答案
Dialogue: 0,0:36:55.07,0:36:57.32,Default,,0,0,0,,因为它事先不知道这里答案只有一个
Dialogue: 0,0:36:57.81,0:36:59.90,Default,,0,0,0,,因此它就在这里检查所有的可能性
Dialogue: 0,0:37:00.41,0:37:02.54,Default,,0,0,0,,确认没有后 输出'DONE'
Dialogue: 0,0:37:03.16,0:37:05.07,Default,,0,0,0,,这里 我把它们当作过程来使用
Dialogue: 0,0:37:05.21,0:37:09.05,Default,,0,0,0,,不过要注意 我还可以问不同类型的问题
Dialogue: 0,0:37:10.22,0:37:11.07,Default,,0,0,0,,我可以问
Dialogue: 0,0:37:18.56,0:37:24.59,Default,,0,0,0,,(MERGE-TO-FORM (2 ?A)
Dialogue: 0,0:37:24.59,0:37:27.90,Default,,0,0,0,,一个我已知是以2为首的二元表
Dialogue: 0,0:37:29.37,0:37:31.26,Default,,0,0,0,,而另外一个东西是未知的
Dialogue: 0,0:37:33.05,0:37:35.04,Default,,0,0,0,,用?X来表示这个未知的表
Dialogue: 0,0:37:36.48,0:37:39.51,Default,,0,0,0,,可以通过MERGE-TO-FORM形成(1 2 3 4)
Dialogue: 0,0:37:42.76,0:37:44.11,Default,,0,0,0,,现在它将思考这个问题
Dialogue: 0,0:37:44.59,0:37:49.40,Default,,0,0,0,,它会找到 -- 它找到了一种可能
Dialogue: 0,0:37:49.52,0:37:52.46,Default,,0,0,0,,比如A=3 X=(1 4)
Dialogue: 0,0:37:53.72,0:37:55.16,Default,,0,0,0,,现在 它又要继续检查
Dialogue: 0,0:37:56.56,0:37:57.71,Default,,0,0,0,,因为它事先并不知道
Dialogue: 0,0:37:57.74,0:38:00.30,Default,,0,0,0,,这里并没有其它的可能了
Dialogue: 0,0:38:03.68,0:38:06.57,Default,,0,0,0,,或者 就像我说过的
Dialogue: 0,0:38:07.00,0:38:09.84,Default,,0,0,0,,我可以问
Dialogue: 0,0:38:10.54,0:38:17.55,Default,,0,0,0,,能够通过MERGE-TO-FORM形成(1 2 3 4 5)的?X和?Y分别是什么？
Dialogue: 0,0:38:23.68,0:38:25.53,Default,,0,0,0,,语言系统又要思考这个问题
Dialogue: 0,0:38:28.49,0:38:30.31,Default,,0,0,0,,它可能会得到很多答案
Dialogue: 0,0:38:35.18,0:38:38.57,Default,,0,0,0,,这里我们就体会到了缓慢的代价
Dialogue: 0,0:38:42.21,0:38:43.88,Default,,0,0,0,,大概是有三种原因造成这样
Dialogue: 0,0:38:43.88,0:38:46.22,Default,,0,0,0,,首先 这门语言经过了两次解释
Dialogue: 0,0:38:47.63,0:38:49.72,Default,,0,0,0,,然而在真正的实现中
Dialogue: 0,0:38:49.76,0:38:52.04,Default,,0,0,0,,你应该把这些编译成基本运算
Dialogue: 0,0:38:52.19,0:38:53.87,Default,,0,0,0,,其次就是
Dialogue: 0,0:38:53.88,0:38:58.11,Default,,0,0,0,,这个MERGE算法 是双重递归的
Dialogue: 0,0:38:58.38,0:39:00.06,Default,,0,0,0,,因此它需要花费很长的时间
Dialogue: 0,0:39:01.02,0:39:04.33,Default,,0,0,0,,最后呢 它又要遍历所有的情况
Dialogue: 0,0:39:04.59,0:39:07.13,Default,,0,0,0,,找出 -- 找出什么呢？
Dialogue: 0,0:39:07.13,0:39:08.73,Default,,0,0,0,,所有的2^5种可行解
Dialogue: 0,0:39:12.14,0:39:14.96,Default,,0,0,0,,我们发现它们以某种相当随意的顺序输出
Dialogue: 0,0:39:15.00,0:39:18.14,Default,,0,0,0,,这取决于它们用什么样的顺序尝试这些规则
Dialogue: 0,0:39:20.16,0:39:22.11,Default,,0,0,0,,事实上 在后期制作本视频时
Dialogue: 0,0:39:22.40,0:39:23.48,Default,,0,0,0,,我们将加速这段
Dialogue: 0,0:39:24.08,0:39:26.60,Default,,0,0,0,,我们就不再这里浪费时间了
Dialogue: 0,0:39:26.60,0:39:28.27,Default,,0,0,0,,课后你们可以自行尝试
Dialogue: 0,0:39:29.48,0:39:34.24,Default,,0,0,0,,好吧 它还在运行
Dialogue: 0,0:39:39.22,0:39:41.12,Default,,0,0,0,,总之 一共有32种可能
Dialogue: 0,0:39:41.13,0:39:42.63,Default,,0,0,0,,我们就不等到输出所有的结果了
Dialogue: 0,0:39:47.85,0:39:50.44,Default,,0,0,0,,因此 这门语言中的抽象手段就是RULE
Dialogue: 0,0:39:53.53,0:39:58.01,Default,,0,0,0,,我们用逻辑把事物组织在一起
Dialogue: 0,0:39:59.12,0:40:00.08,Default,,0,0,0,,并为它们命名
Dialogue: 0,0:40:00.35,0:40:03.41,Default,,0,0,0,,你们可以认为这是为一组特定的逻辑模式命名
Dialogue: 0,0:40:03.41,0:40:04.54,Default,,0,0,0,,你们可以把它想做
Dialogue: 0,0:40:04.56,0:40:06.75,Default,,0,0,0,,如果我们想要推断出某个结论
Dialogue: 0,0:40:07.90,0:40:09.52,Default,,0,0,0,,就可以应用这些逻辑规则
Dialogue: 0,0:40:10.66,0:40:13.20,Default,,0,0,0,,这些就是这门语言中的三种要素
Dialogue: 0,0:40:13.42,0:40:14.56,Default,,0,0,0,,我们先休息一会儿
Dialogue: 0,0:40:14.60,0:40:16.59,Default,,0,0,0,,然后再来讨论如何实际实现
Dialogue: 0,0:40:23.61,0:40:28.84,Default,,0,0,0,,学生：使用LISP-VALUE之类的基本过程会影响
Dialogue: 0,0:40:29.15,0:40:30.64,Default,,0,0,0,,查询的双向性吗？
Dialogue: 0,0:40:31.77,0:40:34.48,Default,,0,0,0,,教授：这个问题 -- 你问的是
Dialogue: 0,0:40:35.08,0:40:36.92,Default,,0,0,0,,使用LISP-VALUE是否会影响
Dialogue: 0,0:40:37.53,0:40:40.09,Default,,0,0,0,,双向地推断一条查询
Dialogue: 0,0:40:40.09,0:40:42.81,Default,,0,0,0,,虽然我们还没有实际讨论具体实现
Dialogue: 0,0:40:43.68,0:40:45.52,Default,,0,0,0,,但是它们确实会造成影响
Dialogue: 0,0:40:46.89,0:40:50.20,Default,,0,0,0,,通常来说 我们最后将会发现
Dialogue: 0,0:40:50.22,0:40:52.17,Default,,0,0,0,,虽然我不会讲得太细
Dialogue: 0,0:40:53.21,0:40:59.36,Default,,0,0,0,,当你使用NOT和LISP-VALUE时 会变得相当复杂
Dialogue: 0,0:40:59.55,0:41:02.89,Default,,0,0,0,,或者实际上 只要你用了除AND以外的东西
Dialogue: 0,0:41:04.12,0:41:08.19,Default,,0,0,0,,很难再说清楚这些东西是否会起效了
Dialogue: 0,0:41:08.20,0:41:10.36,Default,,0,0,0,,它们并不是在任何情况下都有效
Dialogue: 0,0:41:10.36,0:41:13.39,Default,,0,0,0,,我会在下一堂课的最后讨论这个问题
Dialogue: 0,0:41:14.30,0:41:15.84,Default,,0,0,0,,但对于你的问题来说：答案是“会影响”
Dialogue: 0,0:41:16.19,0:41:19.21,Default,,0,0,0,,用LISP-VALUE一方面从Lisp中获得了巨大威力
Dialogue: 0,0:41:19.40,0:41:23.77,Default,,0,0,0,,另一方面你失去了逻辑式程序设计的重要威力
Dialogue: 0,0:41:24.17,0:41:25.56,Default,,0,0,0,,这是你需要做出的取舍
Dialogue: 0,0:41:28.48,0:41:29.39,Default,,0,0,0,,好吧 先休息一会儿
Dialogue: 0,0:41:30.17,0:41:44.30,Declare,,0,0,0,,{\fad(500,500)}MIT OpenCourseWare\Nhttp://ocw.mit.edu
Dialogue: 0,0:41:30.17,0:41:44.30,Declare,,0,0,0,,{\an2\fad(500,500)}本项目主页\Nhttps://github.com/DeathKing/Learning-SICP
