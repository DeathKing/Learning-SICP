[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 640
PlayResY: 480

[Aegisub Project Garbage]
Audio File: ../../../../Movies/Lec10b_480_muxed.mp4
Video File: ../../../../Movies/Lec10b_480_muxed.mp4
Video AR Mode: 4
Video AR Value: 1.333333
Video Zoom Percent: 2.000000
Scroll Position: 1311
Active Line: 1321
Video Position: 105851

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: EN,Calisto MT,21,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,1,0,2,10,10,30,1
Style: Declare,微软雅黑,30,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,2,0,8,10,10,10,1
Style: staff,微软雅黑,30,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,0,2,5,10,10,10,1
Style: title,微软雅黑,35,&H001D64D9,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,0,1,5,10,10,10,1
Style: Default,雅黑宋体,20,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,1,0,2,10,10,30,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.00,0:00:03.48,Declare,,0,0,0,,{\an2\fad(500,500)}Learning-SICP学习小组\N倾情制作
Dialogue: 0,0:00:00.00,0:00:03.48,Declare,,0,0,0,,{\fad(500,500)\pos(316,274)}“让我们举杯，祝福那些\N\N\N\N将他们的思想镶嵌在\N\N\N\N　　　重重括号之间的Lisp程序员。”
Dialogue: 0,0:00:04.75,0:00:11.77,staff,,0,0,0,,{\fad(600,800)\pos(110.666,403.334)}翻译&&时间轴\N杨启钊\N（windfarer）
Dialogue: 0,0:00:04.75,0:00:11.77,staff,,0,0,0,,{\fad(600,800)\pos(534.666,404)}压制&&特效\N邓雄飞\N（Dysprosium）
Dialogue: 0,0:00:04.75,0:00:11.77,staff,,0,0,0,,{\fad(600,800)\pos(574.667,277.333)}校对\N邓雄飞
Dialogue: 0,0:00:04.75,0:00:11.77,staff,,0,0,0,,{\fad(600,800)\pos(89.334,273.333)}特别感谢\N裘宗燕教授
Dialogue: 0,0:00:04.75,0:00:11.77,title,,0,0,0,,{\fad(600,800)\pos(324,32)}《计算机程序的构造和解释》
Dialogue: 0,0:00:11.88,0:00:15.72,Declare,,0,0,0,,{\an2\fad(500,500)}存储分配与垃圾收集
Dialogue: 0,0:00:18.91,0:00:20.61,Default,,0,0,0,,教授: 接下来我要解开
Dialogue: 0,0:00:21.16,0:00:23.36,Default,,0,0,0,,目前仅剩的谜团
Dialogue: 0,0:00:24.44,0:00:28.80,Default,,0,0,0,,我们能毫无顾虑地进行CONS
Dialogue: 0,0:00:30.00,0:00:31.62,Default,,0,0,0,,就好像空间足够多一样
Dialogue: 0,0:00:32.80,0:00:36.32,Default,,0,0,0,,我们总是在使用
Dialogue: 0,0:00:36.51,0:00:37.44,Default,,0,0,0,,CAR和CDR
Dialogue: 0,0:00:37.47,0:00:38.72,Default,,0,0,0,,并假设知道我们知道
Dialogue: 0,0:00:38.75,0:00:39.74,Default,,0,0,0,,它们是如何实现的
Dialogue: 0,0:00:40.02,0:00:40.67,Default,,0,0,0,,事实上
Dialogue: 0,0:00:41.07,0:00:44.40,Default,,0,0,0,,我们认为它们是基本过程
Dialogue: 0,0:00:45.37,0:00:47.57,Default,,0,0,0,,但这没有真正解决问题
Dialogue: 0,0:00:47.73,0:00:50.25,Default,,0,0,0,,因为过程依赖各种复杂的机制
Dialogue: 0,0:00:50.27,0:00:51.37,Default,,0,0,0,,需要诸如环境结构之类的东西
Dialogue: 0,0:00:51.64,0:00:52.76,Default,,0,0,0,,才能运行起来
Dialogue: 0,0:00:53.01,0:00:54.89,Default,,0,0,0,,而归根结底它们也是
Dialogue: 0,0:00:54.89,0:00:56.42,Default,,0,0,0,,由CONS之类的东西构成的
Dialogue: 0,0:00:56.70,0:00:58.47,Default,,0,0,0,,这的确没有解决问题
Dialogue: 0,0:00:59.38,0:01:01.13,Default,,0,0,0,,目前的问题是
Dialogue: 0,0:01:01.31,0:01:03.97,Default,,0,0,0,,粘合这些数据结构的是什么东西？
Dialogue: 0,0:01:04.76,0:01:06.40,Default,,0,0,0,,它可能是怎样的一个东西?
Dialogue: 0,0:01:07.04,0:01:10.46,Default,,0,0,0,,我们已经见过了一台机器
Dialogue: 0,0:01:10.46,0:01:13.96,Default,,0,0,0,,一台计算机具有一个控制器
Dialogue: 0,0:01:14.27,0:01:15.45,Default,,0,0,0,,和一些寄存器
Dialogue: 0,0:01:15.45,0:01:16.47,Default,,0,0,0,,还可能有一个栈
Dialogue: 0,0:01:16.98,0:01:18.12,Default,,0,0,0,,但是我们还没提到一些东西
Dialogue: 0,0:01:18.16,0:01:19.95,Default,,0,0,0,,例如 大内存
Dialogue: 0,0:01:20.57,0:01:22.38,Default,,0,0,0,,我想 现在是时候讨论它们了
Dialogue: 0,0:01:23.74,0:01:26.56,Default,,0,0,0,,但是先要说清楚
Dialogue: 0,0:01:26.59,0:01:27.88,Default,,0,0,0,,这个并不是必须的
Dialogue: 0,0:01:28.82,0:01:30.79,Default,,0,0,0,,只是一些实现上的细节
Dialogue: 0,0:01:31.10,0:01:32.60,Default,,0,0,0,,让我举个例子
Dialogue: 0,0:01:32.60,0:01:34.20,Default,,0,0,0,,如何用数字来表示这些东西
Dialogue: 0,0:01:35.23,0:01:36.82,Default,,0,0,0,,有个比较简单的方法
Dialogue: 0,0:01:37.59,0:01:39.00,Default,,0,0,0,,一位著名的逻辑学家 哥德尔
Dialogue: 0,0:01:44.09,0:01:46.01,Default,,0,0,0,,在20世纪30年代末
Dialogue: 0,0:01:46.38,0:01:48.70,Default,,0,0,0,,发明了一个很巧妙的方法
Dialogue: 0,0:01:48.70,0:01:52.27,Default,,0,0,0,,能够把复杂的表达式
Dialogue: 0,0:01:52.81,0:01:53.52,Default,,0,0,0,,表示成数字
Dialogue: 0,0:01:54.32,0:01:55.05,Default,,0,0,0,,例如
Dialogue: 0,0:01:55.05,0:01:58.00,Default,,0,0,0,,我不会照搬哥德尔的方法
Dialogue: 0,0:01:58.00,0:01:59.48,Default,,0,0,0,,因为他没有使用CONS之类的术语
Dialogue: 0,0:01:59.66,0:02:00.60,Default,,0,0,0,,他使用了其它的组合手段
Dialogue: 0,0:02:00.91,0:02:02.60,Default,,0,0,0,,来编码表达式
Dialogue: 0,0:02:03.09,0:02:03.88,Default,,0,0,0,,他的思路是
Dialogue: 0,0:02:03.92,0:02:06.81,Default,,0,0,0,,用不同数字分别代表每个代数式
Dialogue: 0,0:02:07.92,0:02:09.72,Default,,0,0,0,,通过组合各个部分的数字
Dialogue: 0,0:02:09.72,0:02:11.65,Default,,0,0,0,,来形成新的表达式
Dialogue: 0,0:02:12.47,0:02:13.45,Default,,0,0,0,,举例来说
Dialogue: 0,0:02:13.62,0:02:15.35,Default,,0,0,0,,我们在创造世界的时候
Dialogue: 0,0:02:15.35,0:02:18.01,Default,,0,0,0,,如果用数字
Dialogue: 0,0:02:20.78,0:02:22.22,Default,,0,0,0,,来表示对象
Dialogue: 0,0:02:30.67,0:02:37.93,Default,,0,0,0,,那么(CONS X Y)
Dialogue: 0,0:02:38.04,0:02:41.07,Default,,0,0,0,,就可以表示为
Dialogue: 0,0:02:41.55,0:02:43.77,Default,,0,0,0,,2^X * 3^Y
Dialogue: 0,0:02:46.13,0:02:48.03,Default,,0,0,0,,因为这样我们还能取出它的每一部分
Dialogue: 0,0:02:49.56,0:02:50.97,Default,,0,0,0,,举例来说
Dialogue: 0,0:02:51.18,0:02:55.88,Default,,0,0,0,,(CAR X)
Dialogue: 0,0:02:56.55,0:03:05.18,Default,,0,0,0,,就是X中因数2的个数
Dialogue: 0,0:03:06.69,0:03:08.78,Default,,0,0,0,,当然(CDR X)是一样的
Dialogue: 0,0:03:10.69,0:03:15.57,Default,,0,0,0,,它就X中因数3的个数
Dialogue: 0,0:03:16.51,0:03:18.65,Default,,0,0,0,,这是个非常合理的方案
Dialogue: 0,0:03:19.10,0:03:20.11,Default,,0,0,0,,只不过就是
Dialogue: 0,0:03:20.12,0:03:22.52,Default,,0,0,0,,数字的位数
Dialogue: 0,0:03:22.83,0:03:23.98,Default,,0,0,0,,会急剧地增大
Dialogue: 0,0:03:24.32,0:03:26.55,Default,,0,0,0,,甚至比宇宙中的粒子还多
Dialogue: 0,0:03:27.95,0:03:29.88,Default,,0,0,0,,所以除了在理论中
Dialogue: 0,0:03:29.90,0:03:31.21,Default,,0,0,0,,没有实现这种方案的好办法
Dialogue: 0,0:03:33.43,0:03:34.48,Default,,0,0,0,,另一方面
Dialogue: 0,0:03:35.12,0:03:37.55,Default,,0,0,0,,也有其它的表示方式
Dialogue: 0,0:03:38.45,0:03:40.01,Default,,0,0,0,,我们把它们表示为
Dialogue: 0,0:03:40.25,0:03:42.42,Default,,0,0,0,,一些小盒子
Dialogue: 0,0:03:43.32,0:03:46.43,Default,,0,0,0,,我们把CONS结构
Dialogue: 0,0:03:46.50,0:03:48.05,Default,,0,0,0,,想象为这样的东西
Dialogue: 0,0:03:50.28,0:03:52.57,Default,,0,0,0,,它们是里面装着东西的小隔间
Dialogue: 0,0:03:53.56,0:03:55.47,Default,,0,0,0,,这些格子组成一个树
Dialogue: 0,0:03:57.21,0:03:59.97,Default,,0,0,0,,我希望半导体制造商
Dialogue: 0,0:03:59.97,0:04:02.07,Default,,0,0,0,,能够提供适配这样需求的芯片
Dialogue: 0,0:04:02.70,0:04:03.76,Default,,0,0,0,,但事实上
Dialogue: 0,0:04:03.85,0:04:05.31,Default,,0,0,0,,他们提供给我的却是
Dialogue: 0,0:04:06.20,0:04:07.96,Default,,0,0,0,,线性的内存
Dialogue: 0,0:04:09.38,0:04:13.46,Default,,0,0,0,,内存是一串小隔间
Dialogue: 0,0:04:15.12,0:04:16.34,Default,,0,0,0,,像这样的小隔间
Dialogue: 0,0:04:17.72,0:04:20.25,Default,,0,0,0,,每个小隔间里可以保存确定大小的对象
Dialogue: 0,0:04:20.94,0:04:22.20,Default,,0,0,0,,一个尺寸固定的对象
Dialogue: 0,0:04:23.39,0:04:24.07,Default,,0,0,0,,例如
Dialogue: 0,0:04:24.07,0:04:25.66,Default,,0,0,0,,一个含25个元素的表
Dialogue: 0,0:04:25.66,0:04:26.64,Default,,0,0,0,,就放不进这里
Dialogue: 0,0:04:28.55,0:04:29.26,Default,,0,0,0,,然而 它们中的每一个
Dialogue: 0,0:04:29.29,0:04:30.88,Default,,0,0,0,,都是由地址索引的
Dialogue: 0,0:04:33.97,0:04:34.99,Default,,0,0,0,,因此它们的地址可能是
Dialogue: 0,0:04:35.02,0:04:35.50,Default,,0,0,0,,这里是0
Dialogue: 0,0:04:35.50,0:04:36.22,Default,,0,0,0,,这里是1
Dialogue: 0,0:04:36.22,0:04:36.70,Default,,0,0,0,,这里是2
Dialogue: 0,0:04:36.70,0:04:37.25,Default,,0,0,0,,这里是3
Dialogue: 0,0:04:37.25,0:04:37.94,Default,,0,0,0,,以此类推
Dialogue: 0,0:04:38.06,0:04:40.40,Default,,0,0,0,,这里写的数字并不重要
Dialogue: 0,0:04:40.40,0:04:41.68,Default,,0,0,0,,重要的是 它们不重复
Dialogue: 0,0:04:41.95,0:04:43.42,Default,,0,0,0,,有了它们就能找到下一个在哪
Dialogue: 0,0:04:44.97,0:04:46.14,Default,,0,0,0,,在其中每一个小隔间里面
Dialogue: 0,0:04:46.36,0:04:49.11,Default,,0,0,0,,我们可以把东西放进去
Dialogue: 0,0:04:49.53,0:04:50.77,Default,,0,0,0,,对于没有造过计算机的我们来说
Dialogue: 0,0:04:51.02,0:04:53.66,Default,,0,0,0,,内存就是这样子的
Dialogue: 0,0:04:54.15,0:04:54.65,Default,,0,0,0,,现在
Dialogue: 0,0:04:56.69,0:04:57.53,Default,,0,0,0,,现在的问题是
Dialogue: 0,0:04:57.53,0:04:59.97,Default,,0,0,0,,如何用这样的结构
Dialogue: 0,0:05:00.42,0:05:01.72,Default,,0,0,0,,来实现这个树形结构
Dialogue: 0,0:05:03.29,0:05:04.57,Default,,0,0,0,,其实并不难
Dialogue: 0,0:05:04.57,0:05:06.35,Default,,0,0,0,,已经有大量的方案来做这个了
Dialogue: 0,0:05:06.87,0:05:08.80,Default,,0,0,0,,最重要的一个方案是
Dialogue: 0,0:05:08.80,0:05:11.18,Default,,0,0,0,,假设半导体制造商
Dialogue: 0,0:05:11.20,0:05:13.90,Default,,0,0,0,,允许我安排自己的内存
Dialogue: 0,0:05:13.98,0:05:15.77,Default,,0,0,0,,使得其中每个小隔间都足够大
Dialogue: 0,0:05:16.28,0:05:18.20,Default,,0,0,0,,能够装得下另一个的地址
Dialogue: 0,0:05:19.35,0:05:20.83,Default,,0,0,0,,我需要这么来安排
Dialogue: 0,0:05:22.05,0:05:23.45,Default,,0,0,0,,事实上它需要更大一点
Dialogue: 0,0:05:23.48,0:05:27.52,Default,,0,0,0,,因为我还要在里面存放一些信息
Dialogue: 0,0:05:27.56,0:05:30.09,Default,,0,0,0,,它标示了这里面是什么东西
Dialogue: 0,0:05:30.39,0:05:31.64,Default,,0,0,0,,我们过一会就能看到
Dialogue: 0,0:05:32.62,0:05:34.40,Default,,0,0,0,,当然 如果半导体制造商
Dialogue: 0,0:05:34.43,0:05:35.88,Default,,0,0,0,,没有这么来制造
Dialogue: 0,0:05:36.08,0:05:38.44,Default,,0,0,0,,我就需要用一些机智的方式
Dialogue: 0,0:05:38.57,0:05:41.82,Default,,0,0,0,,把它们组合起来以供使用
Dialogue: 0,0:05:43.77,0:05:47.05,Default,,0,0,0,,我们想象一下
Dialogue: 0,0:05:47.05,0:05:49.54,Default,,0,0,0,,把这个复杂的树形结构
Dialogue: 0,0:05:49.54,0:05:51.20,Default,,0,0,0,,塞进线性内存里
Dialogue: 0,0:05:51.74,0:05:54.47,Default,,0,0,0,,我们来看第一张幻灯片
Dialogue: 0,0:05:54.47,0:05:58.30,Default,,0,0,0,,可以看到一个传统的实现方案
Dialogue: 0,0:05:59.49,0:06:02.62,Default,,0,0,0,,它是把表结构放入线性内存
Dialogue: 0,0:06:03.22,0:06:05.87,Default,,0,0,0,,的标准方式
Dialogue: 0,0:06:06.27,0:06:08.32,Default,,0,0,0,,我们把这块内存
Dialogue: 0,0:06:08.88,0:06:11.12,Default,,0,0,0,,分为两部分
Dialogue: 0,0:06:12.03,0:06:13.42,Default,,0,0,0,,一个叫THE-CARS的数组
Dialogue: 0,0:06:14.45,0:06:15.88,Default,,0,0,0,,一个叫THE-CDRS的数组
Dialogue: 0,0:06:17.58,0:06:18.86,Default,,0,0,0,,无论它们是
Dialogue: 0,0:06:18.88,0:06:21.04,Default,,0,0,0,,顺序的地址或是其它的
Dialogue: 0,0:06:21.12,0:06:22.00,Default,,0,0,0,,其实并不重要
Dialogue: 0,0:06:22.87,0:06:25.20,Default,,0,0,0,,这是实现细节了
Dialogue: 0,0:06:25.80,0:06:28.40,Default,,0,0,0,,但有两个数组
Dialogue: 0,0:06:28.96,0:06:30.36,Default,,0,0,0,,线性数组是由
Dialogue: 0,0:06:30.46,0:06:32.59,Default,,0,0,0,,顺序的下标索引的
Dialogue: 0,0:06:34.84,0:06:36.85,Default,,0,0,0,,每个小格子里存的
Dialogue: 0,0:06:37.46,0:06:39.85,Default,,0,0,0,,是一个带类型的对象
Dialogue: 0,0:06:41.43,0:06:42.57,Default,,0,0,0,,这里的类型
Dialogue: 0,0:06:42.57,0:06:45.71,Default,,0,0,0,,以字母P开头
Dialogue: 0,0:06:45.71,0:06:46.57,Default,,0,0,0,,表示序对
Dialogue: 0,0:06:47.79,0:06:49.37,Default,,0,0,0,,以N开头 表示数字
Dialogue: 0,0:06:50.04,0:06:52.25,Default,,0,0,0,,E开头 表示空表
Dialogue: 0,0:06:54.81,0:06:55.83,Default,,0,0,0,,也就是表尾标志
Dialogue: 0,0:06:57.02,0:06:58.59,Default,,0,0,0,,如果我们想表示
Dialogue: 0,0:06:58.99,0:06:59.97,Default,,0,0,0,,这样一个对象
Dialogue: 0,0:07:00.01,0:07:02.16,Default,,0,0,0,,首元素为(1 2)
Dialogue: 0,0:07:02.65,0:07:04.01,Default,,0,0,0,,然后3、4分别作为
Dialogue: 0,0:07:04.01,0:07:05.50,Default,,0,0,0,,它的第二和第三个元素
Dialogue: 0,0:07:06.43,0:07:08.83,Default,,0,0,0,,这个表的第一部分也是一个表
Dialogue: 0,0:07:09.35,0:07:10.65,Default,,0,0,0,,后面接着是两个数字
Dialogue: 0,0:07:10.65,0:07:12.00,Default,,0,0,0,,分别为第二和第三部分
Dialogue: 0,0:07:12.87,0:07:14.81,Default,,0,0,0,,现在我们用盒子-指针表示法
Dialogue: 0,0:07:14.84,0:07:16.67,Default,,0,0,0,,来描绘它
Dialogue: 0,0:07:17.32,0:07:18.00,Default,,0,0,0,,你能发现
Dialogue: 0,0:07:18.00,0:07:20.04,Default,,0,0,0,,这里有三个单元
Dialogue: 0,0:07:20.25,0:07:22.01,Default,,0,0,0,,它们的CAR指针
Dialogue: 0,0:07:22.27,0:07:27.10,Default,,0,0,0,,分别指向对象(1 2)、3以及4
Dialogue: 0,0:07:28.39,0:07:29.75,Default,,0,0,0,,当然这个(1 2)
Dialogue: 0,0:07:29.75,0:07:31.32,Default,,0,0,0,,即整个结构的CAR
Dialogue: 0,0:07:31.32,0:07:32.65,Default,,0,0,0,,本身就是一个子结构
Dialogue: 0,0:07:32.88,0:07:34.75,Default,,0,0,0,,包含一个像这样的子表
Dialogue: 0,0:07:35.94,0:07:37.07,Default,,0,0,0,,我要做的是
Dialogue: 0,0:07:37.20,0:07:39.92,Default,,0,0,0,,就是按照下标
Dialogue: 0,0:07:39.95,0:07:41.46,Default,,0,0,0,,把它们放进去
Dialogue: 0,0:07:41.84,0:07:43.40,Default,,0,0,0,,像这里的1
Dialogue: 0,0:07:43.56,0:07:47.05,Default,,0,0,0,,代表了这个格子的下标
Dialogue: 0,0:07:49.85,0:07:51.47,Default,,0,0,0,,这里的指针
Dialogue: 0,0:07:52.37,0:07:54.86,Default,,0,0,0,,是对THE-CARS
Dialogue: 0,0:07:55.07,0:07:57.29,Default,,0,0,0,,和THE-CDRS里的小格子的引用
Dialogue: 0,0:07:57.40,0:07:58.67,Default,,0,0,0,,它在我的线性内存中
Dialogue: 0,0:07:58.76,0:08:00.33,Default,,0,0,0,,被标记为1的地方
Dialogue: 0,0:08:02.00,0:08:04.06,Default,,0,0,0,,如果我想把这个结构
Dialogue: 0,0:08:04.16,0:08:05.26,Default,,0,0,0,,塞进线性内存中
Dialogue: 0,0:08:05.85,0:08:07.52,Default,,0,0,0,,要做的是
Dialogue: 0,0:08:07.52,0:08:11.88,Default,,0,0,0,,把它放进格子1中
Dialogue: 0,0:08:11.95,0:08:12.66,Default,,0,0,0,,我要选取1号格子
Dialogue: 0,0:08:12.66,0:08:13.85,Default,,0,0,0,,这个就是1号格子
Dialogue: 0,0:08:14.27,0:08:16.22,Default,,0,0,0,,这是它的CAR
Dialogue: 0,0:08:16.22,0:08:17.74,Default,,0,0,0,,我要把它赋值给一个序对
Dialogue: 0,0:08:17.95,0:08:18.72,Default,,0,0,0,,这个序对
Dialogue: 0,0:08:20.02,0:08:21.55,Default,,0,0,0,,序号是5
Dialogue: 0,0:08:22.59,0:08:23.90,Default,,0,0,0,,它的CDR
Dialogue: 0,0:08:23.90,0:08:25.13,Default,,0,0,0,,就是这个
Dialogue: 0,0:08:25.39,0:08:26.13,Default,,0,0,0,,它是个序对
Dialogue: 0,0:08:26.13,0:08:27.70,Default,,0,0,0,,我会把它放到2的位置
Dialogue: 0,0:08:28.34,0:08:28.98,Default,,0,0,0,,即P2
Dialogue: 0,0:08:30.89,0:08:32.95,Default,,0,0,0,,我们看P2
Dialogue: 0,0:08:32.95,0:08:34.72,Default,,0,0,0,,P2的CAR
Dialogue: 0,0:08:34.90,0:08:37.22,Default,,0,0,0,,是数字3
Dialogue: 0,0:08:37.34,0:08:38.64,Default,,0,0,0,,如你所见N3
Dialogue: 0,0:08:39.52,0:08:41.52,Default,,0,0,0,,这里 它的CDR
Dialogue: 0,0:08:41.72,0:08:43.40,Default,,0,0,0,,是一个序对
Dialogue: 0,0:08:43.97,0:08:45.81,Default,,0,0,0,,在位置4
Dialogue: 0,0:08:46.64,0:08:47.79,Default,,0,0,0,,这就是P4
Dialogue: 0,0:08:48.65,0:08:51.16,Default,,0,0,0,,P4是一个数字
Dialogue: 0,0:08:51.85,0:08:53.87,Default,,0,0,0,,它的CAR部分是数字4
Dialogue: 0,0:08:54.60,0:08:55.65,Default,,0,0,0,,它的CDR
Dialogue: 0,0:08:55.84,0:08:58.48,Default,,0,0,0,,是个空表 就在这儿
Dialogue: 0,0:08:59.17,0:08:59.90,Default,,0,0,0,,这个表就结束了
Dialogue: 0,0:09:00.69,0:09:04.57,Default,,0,0,0,,这就是在线性内存中
Dialogue: 0,0:09:04.90,0:09:09.55,Default,,0,0,0,,表示二叉树的传统方式
Dialogue: 0,0:09:11.62,0:09:15.10,Default,,0,0,0,,那么 下一个问题是
Dialogue: 0,0:09:15.10,0:09:16.36,Default,,0,0,0,,我们需要关心
Dialogue: 0,0:09:16.60,0:09:18.19,Default,,0,0,0,,如何去实现
Dialogue: 0,0:09:18.44,0:09:20.33,Default,,0,0,0,,这意味着当我写下一个过程
Dialogue: 0,0:09:20.36,0:09:23.62,Default,,0,0,0,,用来给A赋值时
Dialogue: 0,0:09:24.54,0:09:27.10,Default,,0,0,0,,使用寄存机器的代码来编写的
Dialogue: 0,0:09:27.21,0:09:30.14,Default,,0,0,0,,(ASSIGN A (FETCH B))
Dialogue: 0,0:09:30.84,0:09:31.85,Default,,0,0,0,,我实际上想做的是
Dialogue: 0,0:09:31.97,0:09:37.10,Default,,0,0,0,,定位这些元素
Dialogue: 0,0:09:38.74,0:09:40.25,Default,,0,0,0,,那段机器代码只是
Dialogue: 0,0:09:40.68,0:09:42.94,Default,,0,0,0,,这个复杂过程的简写
Dialogue: 0,0:09:44.47,0:09:46.33,Default,,0,0,0,,当然 为了把它“写下来”
Dialogue: 0,0:09:46.35,0:09:48.59,Default,,0,0,0,,我要引入一种
Dialogue: 0,0:09:48.62,0:09:49.42,Default,,0,0,0,,称为“向量”的结构
Dialogue: 0,0:09:52.12,0:09:53.31,Default,,0,0,0,,我们得有一种东西
Dialogue: 0,0:09:53.48,0:09:54.54,Default,,0,0,0,,用来引用向量
Dialogue: 0,0:09:56.84,0:09:58.51,Default,,0,0,0,,这样我们就能把它写下来
Dialogue: 0,0:09:58.71,0:10:00.22,Default,,0,0,0,,它的参数之一是向量的名字
Dialogue: 0,0:10:01.02,0:10:03.97,Default,,0,0,0,,我觉得这个名字起得不太靠谱
Dialogue: 0,0:10:03.97,0:10:09.40,Default,,0,0,0,,它接受VECTOR和INDEX两个参数
Dialogue: 0,0:10:11.20,0:10:13.05,Default,,0,0,0,,我可以用VECTOR-SET!
Dialogue: 0,0:10:13.10,0:10:14.27,Default,,0,0,0,,来为其中的分量赋值
Dialogue: 0,0:10:14.65,0:10:15.60,Default,,0,0,0,,我不太在意
Dialogue: 0,0:10:16.28,0:10:17.55,Default,,0,0,0,,我们来看一看
Dialogue: 0,0:10:18.11,0:10:20.42,Default,,0,0,0,,在这种实现中
Dialogue: 0,0:10:21.25,0:10:23.18,Default,,0,0,0,,CAR和CDR是什么样子的
Dialogue: 0,0:10:26.47,0:10:28.41,Default,,0,0,0,,比如说 如果我刚好有
Dialogue: 0,0:10:28.88,0:10:30.80,Default,,0,0,0,,一个寄存器B
Dialogue: 0,0:10:31.15,0:10:34.64,Default,,0,0,0,,它存了一个序对的下标
Dialogue: 0,0:10:35.95,0:10:38.80,Default,,0,0,0,,即它是指向一个序对的指针
Dialogue: 0,0:10:39.35,0:10:40.85,Default,,0,0,0,,我可以取它的CAR
Dialogue: 0,0:10:41.55,0:10:44.11,Default,,0,0,0,,存到寄存器A里面
Dialogue: 0,0:10:44.49,0:10:46.86,Default,,0,0,0,,事实上它是
Dialogue: 0,0:10:47.37,0:10:50.19,Default,,0,0,0,,把A赋值为--
Dialogue: 0,0:10:50.19,0:10:51.92,Default,,0,0,0,,引用向量的一个分量--
Dialogue: 0,0:10:52.80,0:10:55.24,Default,,0,0,0,,或者你可以把它叫做索引一个数组
Dialogue: 0,0:10:55.42,0:10:57.63,Default,,0,0,0,,目标向量为THE-CARS
Dialogue: 0,0:10:58.40,0:11:00.92,Default,,0,0,0,,而目标分量是B
Dialogue: 0,0:11:02.65,0:11:03.63,Default,,0,0,0,,CDR的操作也类似
Dialogue: 0,0:11:04.10,0:11:05.72,Default,,0,0,0,,我们可以用同样的方式
Dialogue: 0,0:11:05.90,0:11:08.32,Default,,0,0,0,,来对数据结构赋值
Dialogue: 0,0:11:08.92,0:11:10.92,Default,,0,0,0,,如果我们需要这么做的话
Dialogue: 0,0:11:11.84,0:11:13.80,Default,,0,0,0,,构建这个并不太难
Dialogue: 0,0:11:14.58,0:11:15.72,Default,,0,0,0,,下一个问题是
Dialogue: 0,0:11:15.72,0:11:17.00,Default,,0,0,0,,我们如何分配它们
Dialogue: 0,0:11:18.01,0:11:20.13,Default,,0,0,0,,我们经常需要一个新的序对
Dialogue: 0,0:11:21.40,0:11:23.42,Default,,0,0,0,,当然 CONS并没有长在树上
Dialogue: 0,0:11:23.79,0:11:24.81,Default,,0,0,0,,或许它们应该那样
Dialogue: 0,0:11:25.34,0:11:26.56,Default,,0,0,0,,我必须得有某种方法
Dialogue: 0,0:11:26.70,0:11:28.97,Default,,0,0,0,,来获得一个可用的序对
Dialogue: 0,0:11:29.98,0:11:31.47,Default,,0,0,0,,我需要某种方案
Dialogue: 0,0:11:31.47,0:11:33.04,Default,,0,0,0,,当内存不再使用的时候
Dialogue: 0,0:11:33.69,0:11:35.05,Default,,0,0,0,,我可以重新分配它们
Dialogue: 0,0:11:35.63,0:11:37.38,Default,,0,0,0,,有很多方案可以实现这一点
Dialogue: 0,0:11:37.38,0:11:39.07,Default,,0,0,0,,现在我给你们展示的这个东西
Dialogue: 0,0:11:39.23,0:11:40.45,Default,,0,0,0,,并是不必要的
Dialogue: 0,0:11:42.10,0:11:43.18,Default,,0,0,0,,然而它很方便
Dialogue: 0,0:11:43.20,0:11:44.44,Default,,0,0,0,,并且被实现很多次了
Dialogue: 0,0:11:44.60,0:11:47.20,Default,,0,0,0,,其中一种基于“空闲表”的分配方案
Dialogue: 0,0:11:47.66,0:11:48.68,Default,,0,0,0,,它的意思就是
Dialogue: 0,0:11:48.68,0:11:51.12,Default,,0,0,0,,世界上所有的空闲内存
Dialogue: 0,0:11:51.55,0:11:53.08,Default,,0,0,0,,都连在一个链表中
Dialogue: 0,0:11:54.55,0:11:56.22,Default,,0,0,0,,就像其它东西一样
Dialogue: 0,0:11:56.96,0:11:59.07,Default,,0,0,0,,每当你需要一个新的格子
Dialogue: 0,0:11:59.07,0:12:00.12,Default,,0,0,0,,来进行CONS的时候
Dialogue: 0,0:12:00.95,0:12:02.26,Default,,0,0,0,,你选择第一个格子
Dialogue: 0,0:12:02.26,0:12:03.82,Default,,0,0,0,,将它的CDR指向空闲表
Dialogue: 0,0:12:04.32,0:12:05.55,Default,,0,0,0,,然后分配它
Dialogue: 0,0:12:06.03,0:12:08.32,Default,,0,0,0,,就像这样
Dialogue: 0,0:12:09.53,0:12:13.32,Default,,0,0,0,,这里 我们的空闲表
Dialogue: 0,0:12:13.95,0:12:16.81,Default,,0,0,0,,就是从6开始
Dialogue: 0,0:12:18.51,0:12:23.47,Default,,0,0,0,,它是一个指向8的指针
Dialogue: 0,0:12:24.86,0:12:25.62,Default,,0,0,0,,它表示
Dialogue: 0,0:12:25.62,0:12:26.55,Default,,0,0,0,,当前这个是空闲的
Dialogue: 0,0:12:26.55,0:12:27.95,Default,,0,0,0,,下一个在位置8
Dialogue: 0,0:12:28.87,0:12:29.88,Default,,0,0,0,,这个是空闲的
Dialogue: 0,0:12:30.04,0:12:32.08,Default,,0,0,0,,下一个在位置3
Dialogue: 0,0:12:32.32,0:12:33.45,Default,,0,0,0,,下一个是空闲的
Dialogue: 0,0:12:33.93,0:12:34.95,Default,,0,0,0,,这个是空闲的
Dialogue: 0,0:12:35.04,0:12:37.68,Default,,0,0,0,,下一个在位置0
Dialogue: 0,0:12:37.87,0:12:38.49,Default,,0,0,0,,这个是空闲的
Dialogue: 0,0:12:38.52,0:12:39.82,Default,,0,0,0,,下一个在位置15
Dialogue: 0,0:12:40.94,0:12:41.84,Default,,0,0,0,,以此类推
Dialogue: 0,0:12:42.78,0:12:44.64,Default,,0,0,0,,我们可以想象有这样的结构
Dialogue: 0,0:12:46.40,0:12:48.03,Default,,0,0,0,,一旦我们有了这样的机制
Dialogue: 0,0:12:49.45,0:12:50.92,Default,,0,0,0,,那么当你需要空间的时候
Dialogue: 0,0:12:50.92,0:12:52.22,Default,,0,0,0,,就能获取一个
Dialogue: 0,0:12:53.82,0:12:56.46,Default,,0,0,0,,那些使用了CONS的程序
Dialogue: 0,0:12:57.45,0:12:59.13,Default,,0,0,0,,内存可能就是像这样的
Dialogue: 0,0:12:59.32,0:13:02.57,Default,,0,0,0,,把B和C进行CONS之后的值
Dialogue: 0,0:13:02.95,0:13:05.82,Default,,0,0,0,,赋值给A寄存器
Dialogue: 0,0:13:06.20,0:13:09.04,Default,,0,0,0,,结果包括B和C
Dialogue: 0,0:13:09.27,0:13:10.52,Default,,0,0,0,,我们要做的是
Dialogue: 0,0:13:10.56,0:13:12.24,Default,,0,0,0,,把当前的尾部格子 即空闲表的前个格子
Dialogue: 0,0:13:12.47,0:13:14.30,Default,,0,0,0,,让它的CDR指向空闲表
Dialogue: 0,0:13:15.64,0:13:18.33,Default,,0,0,0,,我们要把THE-CARS中
Dialogue: 0,0:13:18.41,0:13:22.49,Default,,0,0,0,,由A索引的格子
Dialogue: 0,0:13:23.13,0:13:25.45,Default,,0,0,0,,修改为B中的内容
Dialogue: 0,0:13:25.90,0:13:28.65,Default,,0,0,0,,THE-CDRS中由A索引的格子
Dialogue: 0,0:13:29.20,0:13:31.72,Default,,0,0,0,,修改为C的值
Dialogue: 0,0:13:33.20,0:13:34.76,Default,,0,0,0,,现在A所指的格子里面
Dialogue: 0,0:13:34.78,0:13:36.65,Default,,0,0,0,,就是新构建好的对象了
Dialogue: 0,0:13:36.81,0:13:37.92,Default,,0,0,0,,这就是我们要的对象
Dialogue: 0,0:13:40.47,0:13:42.50,Default,,0,0,0,,我之前告诉过你们
Dialogue: 0,0:13:42.50,0:13:43.97,Default,,0,0,0,,这里撒了个谎
Dialogue: 0,0:13:43.97,0:13:45.32,Default,,0,0,0,,也就是在这里的某处
Dialogue: 0,0:13:45.53,0:13:47.32,Default,,0,0,0,,我本来应该
Dialogue: 0,0:13:48.45,0:13:50.48,Default,,0,0,0,,把我CONS起来的对象
Dialogue: 0,0:13:50.51,0:13:51.87,Default,,0,0,0,,设置为序对类型
Dialogue: 0,0:13:52.30,0:13:53.05,Default,,0,0,0,,但我没有
Dialogue: 0,0:13:53.51,0:13:56.57,Default,,0,0,0,,因此这里应该需要设置一些比特位
Dialogue: 0,0:13:56.60,0:13:57.76,Default,,0,0,0,,我只是还没把它写下来
Dialogue: 0,0:13:59.81,0:14:00.86,Default,,0,0,0,,当然 这个很好实现
Dialogue: 0,0:14:00.89,0:14:02.45,Default,,0,0,0,,因为空闲表本来就是用序对实现的
Dialogue: 0,0:14:03.10,0:14:04.88,Default,,0,0,0,,因此这是没问题的
Dialogue: 0,0:14:06.43,0:14:07.74,Default,,0,0,0,,但这也就是--
Dialogue: 0,0:14:07.82,0:14:09.92,Default,,0,0,0,,这些都是无关紧要的细节
Dialogue: 0,0:14:10.22,0:14:12.88,Default,,0,0,0,,取决于那些想要自制
Dialogue: 0,0:14:12.92,0:14:14.27,Default,,0,0,0,,计算机或Lisp系统的
Dialogue: 0,0:14:14.33,0:14:16.68,Default,,0,0,0,,程序员或架构师
Dialogue: 0,0:14:17.54,0:14:18.71,Default,,0,0,0,,例如
Dialogue: 0,0:14:19.07,0:14:20.24,Default,,0,0,0,,看这个
Dialogue: 0,0:14:20.65,0:14:23.45,Default,,0,0,0,,假设我们要为
Dialogue: 0,0:14:23.55,0:14:26.83,Default,,0,0,0,,这个之前见过的数据结构分配空间
Dialogue: 0,0:14:27.21,0:14:30.26,Default,,0,0,0,,假设我要分配一个新格子
Dialogue: 0,0:14:30.55,0:14:36.61,Default,,0,0,0,,来表示表(1 1 2)
Dialogue: 0,0:14:37.24,0:14:39.87,Default,,0,0,0,,其中(1 2)又是
Dialogue: 0,0:14:40.28,0:14:42.16,Default,,0,0,0,,之前一个表的CAR元素
Dialogue: 0,0:14:43.43,0:14:44.45,Default,,0,0,0,,这不怎么难
Dialogue: 0,0:14:44.78,0:14:46.20,Default,,0,0,0,,我用1号单元来存放数字“1”
Dialogue: 0,0:14:46.20,0:14:49.17,Default,,0,0,0,,那么P1表示的就是这个单元
Dialogue: 0,0:14:49.53,0:14:50.83,Default,,0,0,0,,这个是P5
Dialogue: 0,0:14:51.67,0:14:53.51,Default,,0,0,0,,它是应该是这个的CDR
Dialogue: 0,0:14:54.07,0:14:55.52,Default,,0,0,0,,现在我们要从空闲表中取出一些东西
Dialogue: 0,0:14:55.52,0:14:57.30,Default,,0,0,0,,空闲表现在是从6开始的
Dialogue: 0,0:14:57.78,0:15:00.18,Default,,0,0,0,,而在分配之后 空闲表将从8开始
Dialogue: 0,0:15:00.60,0:15:02.55,Default,,0,0,0,,一个从8开始的空闲表
Dialogue: 0,0:15:02.89,0:15:03.52,Default,,0,0,0,,当然
Dialogue: 0,0:15:03.72,0:15:06.04,Default,,0,0,0,,现在6里面是数字1
Dialogue: 0,0:15:06.15,0:15:07.10,Default,,0,0,0,,就是我们想要的
Dialogue: 0,0:15:07.39,0:15:11.56,Default,,0,0,0,,它的CDR是在位置5的序对
Dialogue: 0,0:15:13.33,0:15:14.50,Default,,0,0,0,,没费多少力气
Dialogue: 0,0:15:16.81,0:15:20.45,Default,,0,0,0,,这里依然存在的一个问题是
Dialogue: 0,0:15:21.00,0:15:23.40,Default,,0,0,0,,我们没有无限大的内存
Dialogue: 0,0:15:25.08,0:15:26.66,Default,,0,0,0,,如果我像这么操作了一会儿
Dialogue: 0,0:15:27.25,0:15:28.00,Default,,0,0,0,,比如说
Dialogue: 0,0:15:28.01,0:15:30.14,Default,,0,0,0,,假设进行一次CONS花费1微秒
Dialogue: 0,0:15:30.60,0:15:32.97,Default,,0,0,0,,如果要进行一百万次CONS
Dialogue: 0,0:15:33.60,0:15:35.27,Default,,0,0,0,,那么我就要消耗1秒钟的时间
Dialogue: 0,0:15:35.95,0:15:37.00,Default,,0,0,0,,这就很糟糕了
Dialogue: 0,0:15:38.00,0:15:40.62,Default,,0,0,0,,如何预防这样的灾难
Dialogue: 0,0:15:40.62,0:15:42.19,Default,,0,0,0,,这种生态灾难
Dialogue: 0,0:15:42.60,0:15:44.30,Default,,0,0,0,,在提问环节之后我们再继续讨论
Dialogue: 0,0:15:44.30,0:15:45.26,Default,,0,0,0,,有人要提问吗?
Dialogue: 0,0:15:51.50,0:15:51.69,Default,,0,0,0,,请讲
Dialogue: 0,0:15:52.03,0:15:54.67,Default,,0,0,0,,学生：在环境图表中
Dialogue: 0,0:15:54.67,0:15:58.25,Default,,0,0,0,,我们画了过程体
Dialogue: 0,0:15:58.25,0:16:00.67,Default,,0,0,0,,但是在过程应用结束后
Dialogue: 0,0:16:00.80,0:16:03.60,Default,,0,0,0,,这些环境中的东西就不再有用了
Dialogue: 0,0:16:03.60,0:16:04.16,Default,,0,0,0,,教授：说得很对
Dialogue: 0,0:16:04.93,0:16:06.67,Default,,0,0,0,,学生：它是如何表示的？
Dialogue: 0,0:16:06.76,0:16:08.75,Default,,0,0,0,,教授：这其实是两个问题
Dialogue: 0,0:16:09.18,0:16:10.25,Default,,0,0,0,,第一个问题是
Dialogue: 0,0:16:10.25,0:16:13.43,Default,,0,0,0,,材料没用了
Dialogue: 0,0:16:13.87,0:16:14.92,Default,,0,0,0,,我们稍后就会讲
Dialogue: 0,0:16:14.92,0:16:17.00,Default,,0,0,0,,如何预防生态灾难
Dialogue: 0,0:16:17.63,0:16:19.20,Default,,0,0,0,,如果我制造了一堆垃圾
Dialogue: 0,0:16:19.20,0:16:21.39,Default,,0,0,0,,我需要自己清理掉
Dialogue: 0,0:16:21.82,0:16:22.97,Default,,0,0,0,,我们一会儿就要讲
Dialogue: 0,0:16:23.43,0:16:24.57,Default,,0,0,0,,第二个问题
Dialogue: 0,0:16:24.57,0:16:27.21,Default,,0,0,0,,你问的是如何表示环境
Dialogue: 0,0:16:27.28,0:16:27.60,Default,,0,0,0,,学生：对
Dialogue: 0,0:16:27.60,0:16:28.19,Default,,0,0,0,,教授：好
Dialogue: 0,0:16:28.19,0:16:30.62,Default,,0,0,0,,环境结构能够以任意的方式表示
Dialogue: 0,0:16:30.92,0:16:31.78,Default,,0,0,0,,有很多种表示方式
Dialogue: 0,0:16:31.78,0:16:33.34,Default,,0,0,0,,这里 我只讲了基于表结构的内存
Dialogue: 0,0:16:33.63,0:16:34.92,Default,,0,0,0,,当然 每个真实的系统
Dialogue: 0,0:16:34.92,0:16:36.72,Default,,0,0,0,,都有任意长度的向量
Dialogue: 0,0:16:36.72,0:16:39.15,Default,,0,0,0,,也有固定长度的向量
Dialogue: 0,0:16:39.31,0:16:40.51,Default,,0,0,0,,它们都可以作为内存的表示方法
Dialogue: 0,0:16:41.08,0:16:44.90,Default,,0,0,0,,在一个专业的Lisp系统中
Dialogue: 0,0:16:44.90,0:16:46.99,Default,,0,0,0,,环境结构是用
Dialogue: 0,0:16:47.30,0:16:49.69,Default,,0,0,0,,向量表示的
Dialogue: 0,0:16:49.69,0:16:51.92,Default,,0,0,0,,它所包含的元素的数量
Dialogue: 0,0:16:51.92,0:16:54.60,Default,,0,0,0,,比参数的个数稍微多一点
Dialogue: 0,0:16:55.35,0:16:56.86,Default,,0,0,0,,因为你需要某种“粘合剂”
Dialogue: 0,0:16:57.40,0:17:00.74,Default,,0,0,0,,记住环境是在框架里的
Dialogue: 0,0:17:00.74,0:17:03.98,Default,,0,0,0,,框架是应用过程时被构建出来的
Dialogue: 0,0:17:03.98,0:17:04.78,Default,,0,0,0,,这种情况下
Dialogue: 0,0:17:04.80,0:17:07.60,Default,,0,0,0,,所分配的空间大小为
Dialogue: 0,0:17:07.64,0:17:11.27,Default,,0,0,0,,实际参数加上“粘合剂”占用的空间
Dialogue: 0,0:17:11.27,0:17:12.71,Default,,0,0,0,,然后将它连接到某条链上
Dialogue: 0,0:17:13.32,0:17:15.66,Default,,0,0,0,,在这个层次上 和ALGOL差不多
Dialogue: 0,0:17:19.81,0:17:20.72,Default,,0,0,0,,还有其它问题吗?
Dialogue: 0,0:17:23.70,0:17:23.92,Default,,0,0,0,,好
Dialogue: 0,0:17:23.92,0:17:25.55,Default,,0,0,0,,谢谢 我们休息一下
Dialogue: 0,0:17:26.35,0:17:45.48,Default,,0,0,0,,[音乐]
Dialogue: 0,0:17:45.53,0:17:50.01,Declare,,0,0,0,,{\an2\fad(500,500)}《计算机程序的构造和解释》
Dialogue: 0,0:17:55.74,0:17:59.04,Declare,,0,0,0,,{\an2\fad(500,500)}讲师： 哈罗德·艾伯森教授 及 格兰德·杰·萨斯曼教授
Dialogue: 0,0:17:59.13,0:18:04.22,Declare,,0,0,0,,{\an2\fad(500,500)}《计算机程序的构造和解释》
Dialogue: 0,0:18:04.32,0:18:09.87,Declare,,0,0,0,,{\an2\fad(500,500)}存储分配与垃圾收集
Dialogue: 0,0:18:12.27,0:18:14.24,Default,,0,0,0,,教授：如同我刚才说过的那样
Dialogue: 0,0:18:14.55,0:18:15.50,Default,,0,0,0,,半导体厂商
Dialogue: 0,0:18:15.82,0:18:17.96,Default,,0,0,0,,所生产的计算机内存
Dialogue: 0,0:18:18.16,0:18:19.00,Default,,0,0,0,,容量是有限的
Dialogue: 0,0:18:19.42,0:18:20.40,Default,,0,0,0,,这的确很可惜
Dialogue: 0,0:18:21.62,0:18:23.35,Default,,0,0,0,,但它也可能不总是这样
Dialogue: 0,0:18:24.03,0:18:25.40,Default,,0,0,0,,简单算一下
Dialogue: 0,0:18:25.44,0:18:28.86,Default,,0,0,0,,你可以看到 如果内存的价格
Dialogue: 0,0:18:28.86,0:18:30.80,Default,,0,0,0,,继续保持当前的趋势的话
Dialogue: 0,0:18:31.22,0:18:33.68,Default,,0,0,0,,如果你执行CONS的时候也只需要1微秒
Dialogue: 0,0:18:34.42,0:18:35.90,Default,,0,0,0,,那么 首先大家知道
Dialogue: 0,0:18:35.90,0:18:37.07,Default,,0,0,0,,一年大约有
Dialogue: 0,0:18:37.10,0:18:38.86,Default,,0,0,0,,PI*10^7秒
Dialogue: 0,0:18:39.45,0:18:41.12,Default,,0,0,0,,那么就有
Dialogue: 0,0:18:41.50,0:18:42.73,Default,,0,0,0,,10^6乘以10^7
Dialogue: 0,0:18:42.73,0:18:43.94,Default,,0,0,0,,也就是10^13
Dialogue: 0,0:18:43.94,0:18:45.50,Default,,0,0,0,,那么在机器的一生中
Dialogue: 0,0:18:45.50,0:18:46.80,Default,,0,0,0,,就能有10^14个CONS
Dialogue: 0,0:18:47.52,0:18:49.40,Default,,0,0,0,,如果你的机器上
Dialogue: 0,0:18:49.68,0:18:50.57,Default,,0,0,0,,有10^14个字的内存
Dialogue: 0,0:18:51.20,0:18:52.16,Default,,0,0,0,,你就永远不会用完
Dialogue: 0,0:18:53.04,0:18:53.85,Default,,0,0,0,,这样就会……
Dialogue: 0,0:18:53.95,0:18:55.76,Default,,0,0,0,,这并不是完全没有道理
Dialogue: 0,0:18:56.31,0:18:58.46,Default,,0,0,0,,10^14次方不是个非常大的数字
Dialogue: 0,0:19:01.45,0:19:04.70,Default,,0,0,0,,我不觉得它是个很大的数字
Dialogue: 0,0:19:05.18,0:19:07.39,Default,,0,0,0,,但我喜欢在天文学领域进行比较
Dialogue: 0,0:19:07.93,0:19:11.04,Default,,0,0,0,,距离我们最近的星星
Dialogue: 0,0:19:11.10,0:19:12.45,Default,,0,0,0,,至少有10^18次方厘米远
Dialogue: 0,0:19:12.93,0:19:18.85,Default,,0,0,0,,我担心的是
Dialogue: 0,0:19:19.15,0:19:21.27,Default,,0,0,0,,至少以现在的经济状况
Dialogue: 0,0:19:21.27,0:19:23.57,Default,,0,0,0,,10^14大小的内存很贵
Dialogue: 0,0:19:24.20,0:19:26.62,Default,,0,0,0,,因此我认为我们需要
Dialogue: 0,0:19:26.81,0:19:28.51,Default,,0,0,0,,适应更小的内存
Dialogue: 0,0:19:30.02,0:19:30.59,Default,,0,0,0,,现在
Dialogue: 0,0:19:32.84,0:19:35.07,Default,,0,0,0,,广义地说 我们营造一种无限内存的假象
Dialogue: 0,0:19:35.80,0:19:37.22,Default,,0,0,0,,我们需要整理它
Dialogue: 0,0:19:37.82,0:19:39.68,Default,,0,0,0,,以便在我们需要内存的时候就能获得它
Dialogue: 0,0:19:41.92,0:19:45.55,Default,,0,0,0,,这个想法非常重要
Dialogue: 0,0:19:49.54,0:19:51.97,Default,,0,0,0,,人或者计算机只能存在有限的时间
Dialogue: 0,0:19:52.32,0:19:54.59,Default,,0,0,0,,只能看有限的东西
Dialogue: 0,0:19:55.28,0:19:57.37,Default,,0,0,0,,因此你只需要有限的东西
Dialogue: 0,0:19:58.19,0:19:59.00,Default,,0,0,0,,只要你合理地安排它们
Dialogue: 0,0:19:59.00,0:20:00.38,Default,,0,0,0,,使得不管实际有多少内存
Dialogue: 0,0:20:00.77,0:20:03.46,Default,,0,0,0,,你要求这里有多少
Dialogue: 0,0:20:03.46,0:20:04.74,Default,,0,0,0,,当你去看的时候
Dialogue: 0,0:20:04.74,0:20:06.90,Default,,0,0,0,,总有足够的东西
Dialogue: 0,0:20:06.90,0:20:08.15,Default,,0,0,0,,因此你只需要有限的数量
Dialogue: 0,0:20:08.75,0:20:09.94,Default,,0,0,0,,我们来看看
Dialogue: 0,0:20:11.63,0:20:13.32,Default,,0,0,0,,我们之前提过一个问题
Dialogue: 0,0:20:13.92,0:20:15.45,Default,,0,0,0,,在很多情况下
Dialogue: 0,0:20:15.72,0:20:17.84,Default,,0,0,0,,我们制造了大量
Dialogue: 0,0:20:17.88,0:20:19.16,Default,,0,0,0,,不需要的东西
Dialogue: 0,0:20:19.41,0:20:21.81,Default,,0,0,0,,我们可以进行回收再利用
Dialogue: 0,0:20:22.62,0:20:23.53,Default,,0,0,0,,举个例子
Dialogue: 0,0:20:24.15,0:20:25.79,Default,,0,0,0,,事实上
Dialogue: 0,0:20:25.79,0:20:28.40,Default,,0,0,0,,当我们调用一个过程的时候
Dialogue: 0,0:20:28.40,0:20:30.47,Default,,0,0,0,,都会构建环境结构
Dialogue: 0,0:20:30.47,0:20:32.56,Default,,0,0,0,,我们把它构建在一个环境框架中
Dialogue: 0,0:20:33.14,0:20:34.03,Default,,0,0,0,,这个环境框架
Dialogue: 0,0:20:34.22,0:20:36.07,Default,,0,0,0,,不用存在很长时间
Dialogue: 0,0:20:36.73,0:20:38.69,Default,,0,0,0,,只有在进行过程调用的时候
Dialogue: 0,0:20:39.42,0:20:42.60,Default,,0,0,0,,它的存在才是有用的
Dialogue: 0,0:20:42.85,0:20:45.27,Default,,0,0,0,,如果过程把另一个过程
Dialogue: 0,0:20:45.27,0:20:46.67,Default,,0,0,0,,作为返回值返回
Dialogue: 0,0:20:46.87,0:20:48.52,Default,,0,0,0,,并且这个过程是在它的内部定义的
Dialogue: 0,0:20:48.52,0:20:50.80,Default,,0,0,0,,那么外层过程的
Dialogue: 0,0:20:51.07,0:20:53.39,Default,,0,0,0,,存活时间仍然是
Dialogue: 0,0:20:53.50,0:20:56.12,Default,,0,0,0,,被返回的过程的
Dialogue: 0,0:20:57.02,0:20:57.90,Default,,0,0,0,,存活时间
Dialogue: 0,0:20:58.53,0:20:59.57,Default,,0,0,0,,最终
Dialogue: 0,0:20:59.57,0:21:00.97,Default,,0,0,0,,就会制造很多垃圾
Dialogue: 0,0:21:01.96,0:21:04.10,Default,,0,0,0,,还有其它的途径可以制造垃圾
Dialogue: 0,0:21:05.37,0:21:06.67,Default,,0,0,0,,用户也会制造垃圾
Dialogue: 0,0:21:07.24,0:21:08.07,Default,,0,0,0,,举例来说
Dialogue: 0,0:21:08.07,0:21:10.22,Default,,0,0,0,,用户制造的垃圾像是这样
Dialogue: 0,0:21:10.93,0:21:14.00,Default,,0,0,0,,如果我们写个程序
Dialogue: 0,0:21:14.00,0:21:15.80,Default,,0,0,0,,把两个表连接到一起
Dialogue: 0,0:21:16.05,0:21:18.14,Default,,0,0,0,,唯一的办法是
Dialogue: 0,0:21:18.32,0:21:21.37,Default,,0,0,0,,把第一个表逆序塞到空表中
Dialogue: 0,0:21:21.37,0:21:23.72,Default,,0,0,0,,再把新表逆序塞到第二个表中
Dialogue: 0,0:21:24.70,0:21:26.92,Default,,0,0,0,,这种解法并不是很糟糕
Dialogue: 0,0:21:28.16,0:21:28.85,Default,,0,0,0,,然而
Dialogue: 0,0:21:28.85,0:21:30.09,Default,,0,0,0,,程序所生成的
Dialogue: 0,0:21:30.11,0:21:32.02,Default,,0,0,0,,中间结果
Dialogue: 0,0:21:33.87,0:21:35.57,Default,,0,0,0,,即第一个表的逆序表
Dialogue: 0,0:21:36.70,0:21:38.52,Default,,0,0,0,,在它被复制到第二个表之后
Dialogue: 0,0:21:38.52,0:21:40.56,Default,,0,0,0,,就再也不会被用到了
Dialogue: 0,0:21:41.01,0:21:42.23,Default,,0,0,0,,它是个中间结果
Dialogue: 0,0:21:43.58,0:21:45.43,Default,,0,0,0,,它很难被找到
Dialogue: 0,0:21:46.07,0:21:48.05,Default,,0,0,0,,没有人能访问到它
Dialogue: 0,0:21:48.60,0:21:49.84,Default,,0,0,0,,事实上 它会消失掉
Dialogue: 0,0:21:51.05,0:21:52.90,Default,,0,0,0,,如果我们像这样制造了大量的垃圾
Dialogue: 0,0:21:52.90,0:21:54.20,Default,,0,0,0,,系统也应该允许我们这么干
Dialogue: 0,0:21:54.80,0:21:57.29,Default,,0,0,0,,但应该有某些方法去回收这些垃圾
Dialogue: 0,0:21:58.80,0:22:00.90,Default,,0,0,0,,现在 我要告诉你
Dialogue: 0,0:22:01.70,0:22:03.77,Default,,0,0,0,,一个非常聪明的技巧
Dialogue: 0,0:22:04.32,0:22:07.58,Default,,0,0,0,,一个Lisp系统
Dialogue: 0,0:22:07.95,0:22:11.21,Default,,0,0,0,,通常可以证明一条小定理
Dialogue: 0,0:22:11.29,0:22:13.50,Default,,0,0,0,,也就是 某段内存中的值
Dialogue: 0,0:22:14.72,0:22:16.09,Default,,0,0,0,,之后不再会被用到
Dialogue: 0,0:22:17.41,0:22:19.80,Default,,0,0,0,,它对以后的计算没有任何影响
Dialogue: 0,0:22:21.40,0:22:23.61,Default,,0,0,0,,事实上 这基于一个很简单的想法
Dialogue: 0,0:22:24.72,0:22:28.06,Default,,0,0,0,,我们已经把计算机设计成这个样子
Dialogue: 0,0:22:28.95,0:22:30.67,Default,,0,0,0,,有一些数据通路
Dialogue: 0,0:22:31.87,0:22:33.40,Default,,0,0,0,,其中有寄存器
Dialogue: 0,0:22:34.92,0:22:38.04,Default,,0,0,0,,有EXP、ENV
Dialogue: 0,0:22:39.04,0:22:42.19,Default,,0,0,0,,和VAL之类的寄存器
Dialogue: 0,0:22:42.61,0:22:44.02,Default,,0,0,0,,这里有个叫STACK的东西
Dialogue: 0,0:22:46.02,0:22:49.45,Default,,0,0,0,,某种指向一个结构的东西
Dialogue: 0,0:22:49.50,0:22:50.22,Default,,0,0,0,,它是个栈
Dialogue: 0,0:22:50.24,0:22:51.48,Default,,0,0,0,,我们过一会再研究它
Dialogue: 0,0:22:51.64,0:22:53.62,Default,,0,0,0,,这里有一些
Dialogue: 0,0:22:54.38,0:22:56.57,Default,,0,0,0,,有穷状态控制器
Dialogue: 0,0:22:56.73,0:22:59.51,Default,,0,0,0,,控制信号在这之间流通
Dialogue: 0,0:22:59.80,0:23:01.44,Default,,0,0,0,,比如谓词的返回结果
Dialogue: 0,0:23:01.87,0:23:03.13,Default,,0,0,0,,这部分并不太有趣
Dialogue: 0,0:23:03.35,0:23:06.51,Default,,0,0,0,,这里有某种结构化的内存
Dialogue: 0,0:23:06.80,0:23:08.27,Default,,0,0,0,,我刚才给你讲过如何构建它
Dialogue: 0,0:23:08.27,0:23:10.17,Default,,0,0,0,,它可能包括一个栈
Dialogue: 0,0:23:10.46,0:23:11.48,Default,,0,0,0,,我没有告诉你如何把东西
Dialogue: 0,0:23:11.48,0:23:12.43,Default,,0,0,0,,构建成任意形状
Dialogue: 0,0:23:12.56,0:23:13.39,Default,,0,0,0,,只有序对
Dialogue: 0,0:23:13.60,0:23:14.20,Default,,0,0,0,,但事实上
Dialogue: 0,0:23:14.35,0:23:15.44,Default,,0,0,0,,我告诉过你
Dialogue: 0,0:23:15.47,0:23:16.96,Default,,0,0,0,,可以用一张大表来模拟栈
Dialogue: 0,0:23:17.77,0:23:18.85,Default,,0,0,0,,我没准备干这个
Dialogue: 0,0:23:18.85,0:23:20.01,Default,,0,0,0,,这不是个好办法
Dialogue: 0,0:23:20.36,0:23:22.60,Default,,0,0,0,,但是我们可以有这样一个东西
Dialogue: 0,0:23:22.99,0:23:25.28,Default,,0,0,0,,这里有各种数据结构
Dialogue: 0,0:23:25.64,0:23:27.75,Default,,0,0,0,,它们通过有趣的方式互相连接
Dialogue: 0,0:23:30.11,0:23:32.02,Default,,0,0,0,,它们和其它东西连接到一起
Dialogue: 0,0:23:32.56,0:23:33.25,Default,,0,0,0,,以此类推
Dialogue: 0,0:23:33.25,0:23:34.22,Default,,0,0,0,,归根结底
Dialogue: 0,0:23:34.45,0:23:37.19,Default,,0,0,0,,这里的东西是指向这里的指针
Dialogue: 0,0:23:37.19,0:23:38.87,Default,,0,0,0,,寄存器里的指针
Dialogue: 0,0:23:39.40,0:23:41.40,Default,,0,0,0,,指向的是表结构内存中
Dialogue: 0,0:23:41.44,0:23:43.08,Default,,0,0,0,,数据结构
Dialogue: 0,0:23:44.91,0:23:49.80,Default,,0,0,0,,现在 我们的问题是
Dialogue: 0,0:23:51.05,0:23:52.56,Default,,0,0,0,,机器的整个意识
Dialogue: 0,0:23:52.57,0:23:53.92,Default,,0,0,0,,是在寄存器里的
Dialogue: 0,0:23:55.76,0:23:58.51,Default,,0,0,0,,如果这个机器
Dialogue: 0,0:23:58.75,0:24:01.07,Default,,0,0,0,,构建得正确的话
Dialogue: 0,0:24:01.37,0:24:03.41,Default,,0,0,0,,它无法访问表结构内存中任何的东西
Dialogue: 0,0:24:04.57,0:24:07.05,Default,,0,0,0,,除非这个表结构内存中的数据
Dialogue: 0,0:24:08.09,0:24:10.88,Default,,0,0,0,,通过一系列的数据结构
Dialogue: 0,0:24:11.64,0:24:13.06,Default,,0,0,0,,与寄存器相连接
Dialogue: 0,0:24:15.07,0:24:15.98,Default,,0,0,0,,如果它能够
Dialogue: 0,0:24:16.22,0:24:18.31,Default,,0,0,0,,被合法的数据结构选择函数访问到
Dialogue: 0,0:24:19.08,0:24:21.12,Default,,0,0,0,,通过寄存器里保存的指针能够访问它
Dialogue: 0,0:24:22.28,0:24:24.46,Default,,0,0,0,,比如说 数组引用
Dialogue: 0,0:24:24.94,0:24:27.92,Default,,0,0,0,,或者针对序对的引用--CAR或者CDR
Dialogue: 0,0:24:29.08,0:24:30.95,Default,,0,0,0,,但我不能随意访问内存中的位置
Dialogue: 0,0:24:30.95,0:24:31.95,Default,,0,0,0,,因为我找不到它
Dialogue: 0,0:24:32.74,0:24:34.90,Default,,0,0,0,,至少在我求值某条表达式的时候
Dialogue: 0,0:24:37.00,0:24:39.16,Default,,0,0,0,,我是不允许去访问那个任意名字的
Dialogue: 0,0:24:41.62,0:24:42.57,Default,,0,0,0,,如果是这样的话
Dialogue: 0,0:24:43.27,0:24:45.07,Default,,0,0,0,,就可以证明一个简单的理论
Dialogue: 0,0:24:47.16,0:24:47.69,Default,,0,0,0,,就是说
Dialogue: 0,0:24:47.90,0:24:50.52,Default,,0,0,0,,如果我从这些寄存器指向的地方开始
Dialogue: 0,0:24:51.16,0:24:52.55,Default,,0,0,0,,递归地遍历
Dialogue: 0,0:24:52.82,0:24:56.15,Default,,0,0,0,,标记选择函数所有能访问到内存
Dialogue: 0,0:24:56.90,0:24:59.40,Default,,0,0,0,,最终就能标记所有能访问的东西
Dialogue: 0,0:25:00.65,0:25:02.69,Default,,0,0,0,,任何未标记的都是垃圾
Dialogue: 0,0:25:02.69,0:25:03.75,Default,,0,0,0,,它们可以被回收
Dialogue: 0,0:25:05.56,0:25:06.20,Default,,0,0,0,,非常简单
Dialogue: 0,0:25:07.20,0:25:09.10,Default,,0,0,0,,不会影响之后的计算
Dialogue: 0,0:25:11.18,0:25:12.84,Default,,0,0,0,,我来举一个
Dialogue: 0,0:25:13.93,0:25:15.75,Default,,0,0,0,,具体的例子
Dialogue: 0,0:25:17.12,0:25:19.37,Default,,0,0,0,,在此之前 需要给我的表结构内存
Dialogue: 0,0:25:19.69,0:25:22.08,Default,,0,0,0,,添加一个叫MARK的标志位
Dialogue: 0,0:25:23.64,0:25:24.89,Default,,0,0,0,,因此 在这里
Dialogue: 0,0:25:25.37,0:25:27.28,Default,,0,0,0,,就有一个表结构内存
Dialogue: 0,0:25:29.08,0:25:30.32,Default,,0,0,0,,这块表内存中
Dialogue: 0,0:25:30.33,0:25:31.33,Default,,0,0,0,,存放了一个表数据结构
Dialogue: 0,0:25:31.33,0:25:33.95,Default,,0,0,0,,我们把这个起始位置
Dialogue: 0,0:25:35.87,0:25:36.62,Default,,0,0,0,,称为“根”
Dialogue: 0,0:25:38.59,0:25:40.12,Default,,0,0,0,,不一定只有一个根
Dialogue: 0,0:25:40.12,0:25:41.95,Default,,0,0,0,,与寄存器类似 可以有很多这种东西
Dialogue: 0,0:25:42.67,0:25:43.98,Default,,0,0,0,,但我可以巧妙地安排它们
Dialogue: 0,0:25:44.13,0:25:46.30,Default,,0,0,0,,把所有在旧寄存器里的东西
Dialogue: 0,0:25:46.30,0:25:47.77,Default,,0,0,0,,在何时的时间点
Dialogue: 0,0:25:48.28,0:25:50.46,Default,,0,0,0,,放入到这个根结构中
Dialogue: 0,0:25:50.46,0:25:51.85,Default,,0,0,0,,然后用一个指针指向它
Dialogue: 0,0:25:51.85,0:25:52.67,Default,,0,0,0,,这不是重点
Dialogue: 0,0:25:54.57,0:25:55.63,Default,,0,0,0,,思路就是
Dialogue: 0,0:25:55.64,0:25:56.65,Default,,0,0,0,,我们要不断地进行CONS
Dialogue: 0,0:25:56.67,0:25:58.01,Default,,0,0,0,,直到空闲表为空
Dialogue: 0,0:25:58.72,0:25:59.67,Default,,0,0,0,,这样就用尽了所有空间
Dialogue: 0,0:26:00.95,0:26:04.47,Default,,0,0,0,,现在我们要证明这个理论
Dialogue: 0,0:26:04.47,0:26:05.90,Default,,0,0,0,,也就是一部分的内存
Dialogue: 0,0:26:05.95,0:26:06.90,Default,,0,0,0,,已经没有用了
Dialogue: 0,0:26:07.85,0:26:09.15,Default,,0,0,0,,然后我们要回收它
Dialogue: 0,0:26:09.78,0:26:10.87,Default,,0,0,0,,构建一个新的树
Dialogue: 0,0:26:12.19,0:26:14.57,Default,,0,0,0,,这是这些垃圾的标准使用方式
Dialogue: 0,0:26:17.09,0:26:18.64,Default,,0,0,0,,那么我们要做什么呢?
Dialogue: 0,0:26:18.84,0:26:20.78,Default,,0,0,0,,从P5这个位置开始
Dialogue: 0,0:26:20.89,0:26:24.27,Default,,0,0,0,,存了一些数据结构
Dialogue: 0,0:26:25.15,0:26:26.75,Default,,0,0,0,,说错了--是从1开始
Dialogue: 0,0:26:27.27,0:26:28.51,Default,,0,0,0,,事实上
Dialogue: 0,0:26:28.89,0:26:32.20,Default,,0,0,0,,它的CAR部分存放在P5这个位置
Dialogue: 0,0:26:32.27,0:26:33.58,Default,,0,0,0,,而CDR部分存在在P2这个位置
Dialogue: 0,0:26:33.98,0:26:35.64,Default,,0,0,0,,最开始 所有的标记都是0
Dialogue: 0,0:26:36.70,0:26:39.00,Default,,0,0,0,,我们要开始标记了
Dialogue: 0,0:26:39.92,0:26:40.52,Default,,0,0,0,,好
Dialogue: 0,0:26:42.54,0:26:44.27,Default,,0,0,0,,例如
Dialogue: 0,0:26:44.47,0:26:46.95,Default,,0,0,0,,因为我可以从根访问到位置P1
Dialogue: 0,0:26:46.95,0:26:47.82,Default,,0,0,0,,我就标记一下
Dialogue: 0,0:26:48.39,0:26:49.17,Default,,0,0,0,,我来标一下
Dialogue: 0,0:26:50.96,0:26:51.45,Default,,0,0,0,,好了
Dialogue: 0,0:26:52.22,0:26:52.94,Default,,0,0,0,,这个被标记了
Dialogue: 0,0:26:54.41,0:26:57.51,Default,,0,0,0,,因为它指向位置P5
Dialogue: 0,0:26:57.64,0:26:58.64,Default,,0,0,0,,所以我来到了5号格子
Dialogue: 0,0:26:59.02,0:27:00.72,Default,,0,0,0,,然后 我要标记这个
Dialogue: 0,0:27:01.45,0:27:01.76,Default,,0,0,0,,标好了
Dialogue: 0,0:27:01.76,0:27:02.60,Default,,0,0,0,,这个笔真好用
Dialogue: 0,0:27:02.90,0:27:05.10,Default,,0,0,0,,但是5号位置的CAR部分是一个数字
Dialogue: 0,0:27:05.27,0:27:06.65,Default,,0,0,0,,我对标记数字不感兴趣
Dialogue: 0,0:27:06.91,0:27:08.17,Default,,0,0,0,,但它的CDR部分是P7
Dialogue: 0,0:27:08.70,0:27:09.75,Default,,0,0,0,,所以我可以标记它
Dialogue: 0,0:27:10.45,0:27:10.81,Default,,0,0,0,,又标好了
Dialogue: 0,0:27:11.80,0:27:13.40,Default,,0,0,0,,P7的CDR部分是空表
Dialogue: 0,0:27:13.67,0:27:15.10,Default,,0,0,0,,而它唯一所引用的元素则是
Dialogue: 0,0:27:15.59,0:27:17.12,Default,,0,0,0,,它的CAR部分是个数字
Dialogue: 0,0:27:17.12,0:27:17.85,Default,,0,0,0,,我对它不感兴趣
Dialogue: 0,0:27:19.49,0:27:20.50,Default,,0,0,0,,让我们回到这里
Dialogue: 0,0:27:20.50,0:27:21.65,Default,,0,0,0,,我忘记了一些事情
Dialogue: 0,0:27:21.65,0:27:22.17,Default,,0,0,0,,P2
Dialogue: 0,0:27:22.84,0:27:24.85,Default,,0,0,0,,换句话说 如果我看1号格子
Dialogue: 0,0:27:25.42,0:27:29.45,Default,,0,0,0,,1号格子的CDR部分指向P2
Dialogue: 0,0:27:30.37,0:27:31.30,Default,,0,0,0,,一个指向P2的引用
Dialogue: 0,0:27:32.01,0:27:34.97,Default,,0,0,0,,这意味着我应该标记P2
Dialogue: 0,0:27:35.70,0:27:36.27,Default,,0,0,0,,好了
Dialogue: 0,0:27:37.14,0:27:38.89,Default,,0,0,0,,P2包含了了一个到P4的引用
Dialogue: 0,0:27:39.13,0:27:40.27,Default,,0,0,0,,而P2的CAR部分是个数字
Dialogue: 0,0:27:40.27,0:27:41.20,Default,,0,0,0,,我对它不感兴趣
Dialogue: 0,0:27:41.47,0:27:42.60,Default,,0,0,0,,所以我要标记P4
Dialogue: 0,0:27:43.78,0:27:46.10,Default,,0,0,0,,P4的CAR部分引用了P7
Dialogue: 0,0:27:46.75,0:27:48.17,Default,,0,0,0,,它的CDR是空的
Dialogue: 0,0:27:48.47,0:27:49.57,Default,,0,0,0,,但由于我已经标记过P7了
Dialogue: 0,0:27:49.57,0:27:50.75,Default,,0,0,0,,就不再次标记它了
Dialogue: 0,0:27:51.40,0:27:53.05,Default,,0,0,0,,这就是这个地方
Dialogue: 0,0:27:53.07,0:27:53.87,Default,,0,0,0,,所能访问的所有单元
Dialogue: 0,0:27:55.00,0:27:56.57,Default,,0,0,0,,很简单的递归标记算法
Dialogue: 0,0:27:58.71,0:28:01.79,Default,,0,0,0,,这个算法有一些不足的地方
Dialogue: 0,0:28:01.90,0:28:04.02,Default,,0,0,0,,我们稍后会说
Dialogue: 0,0:28:04.92,0:28:06.16,Default,,0,0,0,,但基本上你能看到
Dialogue: 0,0:28:06.19,0:28:07.85,Default,,0,0,0,,所有没被标记的地方
Dialogue: 0,0:28:09.62,0:28:11.50,Default,,0,0,0,,都是无用的
Dialogue: 0,0:28:11.50,0:28:12.41,Default,,0,0,0,,可以回收
Dialogue: 0,0:28:14.25,0:28:15.75,Default,,0,0,0,,所以下一步就是
Dialogue: 0,0:28:15.75,0:28:17.05,Default,,0,0,0,,扫描整个内存
Dialogue: 0,0:28:17.94,0:28:20.35,Default,,0,0,0,,寻找未被标记的格子
Dialogue: 0,0:28:21.18,0:28:22.45,Default,,0,0,0,,每当遇到一个已标记的格子
Dialogue: 0,0:28:22.45,0:28:23.22,Default,,0,0,0,,就把标记去掉
Dialogue: 0,0:28:23.22,0:28:24.86,Default,,0,0,0,,每当遇到未标记的格子时
Dialogue: 0,0:28:25.07,0:28:27.82,Default,,0,0,0,,我就把它连接到我的空闲表中
Dialogue: 0,0:28:28.77,0:28:30.30,Default,,0,0,0,,传统而且非常简单的算法
Dialogue: 0,0:28:32.12,0:28:33.10,Default,,0,0,0,,我们来看看
Dialogue: 0,0:28:33.84,0:28:34.77,Default,,0,0,0,,它很简单吗?
Dialogue: 0,0:28:34.77,0:28:35.42,Default,,0,0,0,,是的
Dialogue: 0,0:28:35.57,0:28:37.79,Default,,0,0,0,,我不会深入代码细节
Dialogue: 0,0:28:38.00,0:28:39.65,Default,,0,0,0,,只是想给你看看它有多长
Dialogue: 0,0:28:40.09,0:28:41.10,Default,,0,0,0,,看这个标记阶段
Dialogue: 0,0:28:41.72,0:28:43.98,Default,,0,0,0,,这是标记阶段的第一部分
Dialogue: 0,0:28:45.06,0:28:46.00,Default,,0,0,0,,我们找到根
Dialogue: 0,0:28:46.32,0:28:47.52,Default,,0,0,0,,我们要
Dialogue: 0,0:28:47.67,0:28:51.05,Default,,0,0,0,,对它进行递归过程调用
Dialogue: 0,0:28:52.38,0:28:54.47,Default,,0,0,0,,当我们完成标记之后
Dialogue: 0,0:28:54.77,0:28:56.95,Default,,0,0,0,,就从这里开始清除
Dialogue: 0,0:28:57.38,0:28:59.79,Default,,0,0,0,,然后我们将执行一些指令
Dialogue: 0,0:28:59.80,0:29:01.36,Default,,0,0,0,,来检查这些标记
Dialogue: 0,0:29:01.39,0:29:03.07,Default,,0,0,0,,或者更改这些标记
Dialogue: 0,0:29:03.07,0:29:04.90,Default,,0,0,0,,按照我刚才讲的那个算法进行
Dialogue: 0,0:29:05.23,0:29:06.47,Default,,0,0,0,,代码在这里
Dialogue: 0,0:29:06.47,0:29:07.65,Default,,0,0,0,,你需要标记它们的CAR
Dialogue: 0,0:29:07.87,0:29:10.21,Default,,0,0,0,,也需要标记它们的CDR
Dialogue: 0,0:29:10.66,0:29:12.10,Default,,0,0,0,,这就是整个标记阶段
Dialogue: 0,0:29:14.37,0:29:16.16,Default,,0,0,0,,我给你讲个关于它的小故事
Dialogue: 0,0:29:16.59,0:29:19.37,Default,,0,0,0,,古董货DEC PDP-6计算机
Dialogue: 0,0:29:20.93,0:29:22.09,Default,,0,0,0,,它上面的
Dialogue: 0,0:29:22.35,0:29:24.85,Default,,0,0,0,,标记-清除垃圾回收系统就是这么写的
Dialogue: 0,0:29:26.91,0:29:28.40,Default,,0,0,0,,程序很短
Dialogue: 0,0:29:29.25,0:29:31.60,Default,,0,0,0,,以至于它需要的数据
Dialogue: 0,0:29:32.20,0:29:34.87,Default,,0,0,0,,以及用来操作内存的所需的寄存器
Dialogue: 0,0:29:36.16,0:29:38.14,Default,,0,0,0,,都能够放入到计算机的
Dialogue: 0,0:29:38.16,0:29:38.97,Default,,0,0,0,,16个快速寄存器中
Dialogue: 0,0:29:39.28,0:29:39.80,Default,,0,0,0,,整个程序
Dialogue: 0,0:29:40.01,0:29:42.01,Default,,0,0,0,,你可以在快速寄存器里执行指令
Dialogue: 0,0:29:43.17,0:29:44.83,Default,,0,0,0,,所以这是个非常小的程序
Dialogue: 0,0:29:45.85,0:29:46.88,Default,,0,0,0,,它跑得飞快
Dialogue: 0,0:29:48.87,0:29:51.30,Default,,0,0,0,,然而很不幸
Dialogue: 0,0:29:51.61,0:29:54.02,Default,,0,0,0,,因为这个程序是递归的
Dialogue: 0,0:29:54.80,0:29:57.55,Default,,0,0,0,,因为你需要先做某件事儿
Dialogue: 0,0:29:57.55,0:29:58.99,Default,,0,0,0,,然后再去做另外一件事儿
Dialogue: 0,0:29:59.21,0:30:00.88,Default,,0,0,0,,你得先处理CAR 再处理CDR
Dialogue: 0,0:30:01.15,0:30:02.75,Default,,0,0,0,,这就需要辅助内存
Dialogue: 0,0:30:03.41,0:30:05.23,Default,,0,0,0,,所以Lisp系统
Dialogue: 0,0:30:05.44,0:30:07.42,Default,,0,0,0,,需要一个栈来进行标记
Dialogue: 0,0:30:08.26,0:30:11.05,Default,,0,0,0,,Lisp系统通过这样的方式
Dialogue: 0,0:30:11.57,0:30:14.16,Default,,0,0,0,,限制了你在数据结构上
Dialogue: 0,0:30:14.42,0:30:17.37,Default,,0,0,0,,进行CAR或者CDR递归的深度
Dialogue: 0,0:30:17.81,0:30:19.35,Default,,0,0,0,,这并不太靠谱
Dialogue: 0,0:30:19.93,0:30:20.60,Default,,0,0,0,,另外一方面
Dialogue: 0,0:30:20.64,0:30:22.12,Default,,0,0,0,,当它足够大的时候你不会发现
Dialogue: 0,0:30:23.18,0:30:25.13,Default,,0,0,0,,例如 这样的情况
Dialogue: 0,0:30:25.55,0:30:28.17,Default,,0,0,0,,发生在大多数MacLisp系统上
Dialogue: 0,0:30:28.69,0:30:29.88,Default,,0,0,0,,在它上面运行的Macsyma
Dialogue: 0,0:30:29.96,0:30:31.10,Default,,0,0,0,,允许你处理
Dialogue: 0,0:30:31.10,0:30:32.72,Default,,0,0,0,,有成千上万个元素的表达式
Dialogue: 0,0:30:33.56,0:30:36.02,Default,,0,0,0,,有很多代数式有大量的项
Dialogue: 0,0:30:36.82,0:30:38.10,Default,,0,0,0,,这没什么问题
Dialogue: 0,0:30:39.49,0:30:40.82,Default,,0,0,0,,垃圾回收器能正常工作
Dialogue: 0,0:30:42.19,0:30:42.92,Default,,0,0,0,,另一方面
Dialogue: 0,0:30:42.92,0:30:45.37,Default,,0,0,0,,这个算法有个很精妙的修改版
Dialogue: 0,0:30:45.37,0:30:46.47,Default,,0,0,0,,但我不会去讲
Dialogue: 0,0:30:46.80,0:30:48.22,Default,,0,0,0,,它是由Peter Deutsch
Dialogue: 0,0:30:48.64,0:30:51.82,Default,,0,0,0,,来自IBM的Herb Schorr
Dialogue: 0,0:30:51.87,0:30:53.52,Default,,0,0,0,,和我不太认识的Waite所提出
Dialogue: 0,0:30:54.01,0:30:56.51,Default,,0,0,0,,这个算法
Dialogue: 0,0:30:56.67,0:30:57.79,Default,,0,0,0,,可以不使用
Dialogue: 0,0:30:57.84,0:30:59.55,Default,,0,0,0,,额外的辅助内存
Dialogue: 0,0:31:00.50,0:31:02.80,Default,,0,0,0,,只需要在遍历整个数据结构的时候
Dialogue: 0,0:31:02.97,0:31:05.52,Default,,0,0,0,,记住你是从哪里来的并反转指针
Dialogue: 0,0:31:05.52,0:31:07.52,Default,,0,0,0,,回溯的时候 再去反转这个指针
Dialogue: 0,0:31:07.79,0:31:08.99,Default,,0,0,0,,这是个很取巧的算法
Dialogue: 0,0:31:09.13,0:31:10.24,Default,,0,0,0,,你第一次写它的时候
Dialogue: 0,0:31:10.25,0:31:11.71,Default,,0,0,0,,事实上 你前三次写它的时候
Dialogue: 0,0:31:11.71,0:31:12.72,Default,,0,0,0,,都会遇到严重的BUG
Dialogue: 0,0:31:14.35,0:31:16.72,Default,,0,0,0,,也可能奇慢无比
Dialogue: 0,0:31:16.72,0:31:17.67,Default,,0,0,0,,因为这个算法太复杂了
Dialogue: 0,0:31:18.11,0:31:20.30,Default,,0,0,0,,它用了大概六倍的内存引用
Dialogue: 0,0:31:20.85,0:31:23.22,Default,,0,0,0,,来完成我们刚才讨论的任务
Dialogue: 0,0:31:24.58,0:31:27.07,Default,,0,0,0,,一旦我完成了标记阶段
Dialogue: 0,0:31:27.50,0:31:30.12,Default,,0,0,0,,我们就面临着这样的状况
Dialogue: 0,0:31:30.17,0:31:31.26,Default,,0,0,0,,请看
Dialogue: 0,0:31:31.51,0:31:34.03,Default,,0,0,0,,这里完成了标记工作
Dialogue: 0,0:31:34.08,0:31:35.00,Default,,0,0,0,,和我刚才描述的一样
Dialogue: 0,0:31:35.59,0:31:37.33,Default,,0,0,0,,现在我们要进行清除阶段
Dialogue: 0,0:31:37.60,0:31:39.32,Default,,0,0,0,,我刚才已经讲过如何清除了
Dialogue: 0,0:31:39.82,0:31:42.34,Default,,0,0,0,,我要从内存的一端开始
Dialogue: 0,0:31:42.34,0:31:43.34,Default,,0,0,0,,哪一端都可以
Dialogue: 0,0:31:43.62,0:31:46.17,Default,,0,0,0,,扫描内存中的每个格子
Dialogue: 0,0:31:47.17,0:31:48.67,Default,,0,0,0,,在扫描的同时
Dialogue: 0,0:31:49.20,0:31:50.97,Default,,0,0,0,,如果是空闲内存
Dialogue: 0,0:31:50.99,0:31:52.84,Default,,0,0,0,,就把它们连接到空闲表中
Dialogue: 0,0:31:53.15,0:31:54.05,Default,,0,0,0,,如果它们不是空闲内存
Dialogue: 0,0:31:54.05,0:31:56.07,Default,,0,0,0,,我就把它们的标记清除掉
Dialogue: 0,0:31:57.50,0:31:58.57,Default,,0,0,0,,事实上
Dialogue: 0,0:31:58.70,0:32:00.46,Default,,0,0,0,,最终的程序并不很复杂
Dialogue: 0,0:32:00.46,0:32:02.22,Default,,0,0,0,,它只是变长了一些
Dialogue: 0,0:32:02.78,0:32:04.17,Default,,0,0,0,,这是第一部分
Dialogue: 0,0:32:04.82,0:32:06.71,Default,,0,0,0,,它从内存的顶端向下遍历
Dialogue: 0,0:32:06.71,0:32:09.58,Default,,0,0,0,,我不期望你现在就搞懂它
Dialogue: 0,0:32:09.58,0:32:10.55,Default,,0,0,0,,它挺简单的
Dialogue: 0,0:32:11.03,0:32:12.52,Default,,0,0,0,,这是个非常简单的算法
Dialogue: 0,0:32:13.07,0:32:15.97,Default,,0,0,0,,其中的一段代码像是这样
Dialogue: 0,0:32:15.97,0:32:17.37,Default,,0,0,0,,非常显而易见
Dialogue: 0,0:32:18.60,0:32:20.08,Default,,0,0,0,,在清理结束后
Dialogue: 0,0:32:20.30,0:32:21.77,Default,,0,0,0,,我们就得到了像这样的结果
Dialogue: 0,0:32:25.33,0:32:26.54,Default,,0,0,0,,这种标记-清除算法
Dialogue: 0,0:32:26.56,0:32:28.20,Default,,0,0,0,,有一些缺点
Dialogue: 0,0:32:29.59,0:32:30.35,Default,,0,0,0,,最严重的一个是
Dialogue: 0,0:32:31.45,0:32:33.20,Default,,0,0,0,,最严重的缺点是
Dialogue: 0,0:32:33.20,0:32:34.97,Default,,0,0,0,,当你的内存越来越大
Dialogue: 0,0:32:36.82,0:32:38.87,Default,,0,0,0,,地址空间也就会越来越大
Dialogue: 0,0:32:38.87,0:32:40.80,Default,,0,0,0,,你想用它存更多东西
Dialogue: 0,0:32:41.37,0:32:44.52,Default,,0,0,0,,那么扫描整个内存就会非常耗时
Dialogue: 0,0:32:46.36,0:32:47.39,Default,,0,0,0,,你真正想做的是
Dialogue: 0,0:32:47.40,0:32:48.68,Default,,0,0,0,,只扫描有用的东西
Dialogue: 0,0:32:50.49,0:32:51.55,Default,,0,0,0,,这样就会好一点
Dialogue: 0,0:32:52.07,0:32:53.90,Default,,0,0,0,,如果你意识到
Dialogue: 0,0:32:54.48,0:32:57.72,Default,,0,0,0,,哪些东西已知是有用的
Dialogue: 0,0:32:58.28,0:33:00.37,Default,,0,0,0,,你就没必要去多次检查它
Dialogue: 0,0:33:00.37,0:33:01.20,Default,,0,0,0,,或者不用经常去检查它
Dialogue: 0,0:33:01.55,0:33:04.32,Default,,0,0,0,,对于那些你不太确定的
Dialogue: 0,0:33:05.00,0:33:06.22,Default,,0,0,0,,你可以在每次需要的时候
Dialogue: 0,0:33:07.10,0:33:08.75,Default,,0,0,0,,进行仔细检查
Dialogue: 0,0:33:09.93,0:33:10.85,Default,,0,0,0,,也就是垃圾收集的时候
Dialogue: 0,0:33:11.91,0:33:13.74,Default,,0,0,0,,这些算法
Dialogue: 0,0:33:13.76,0:33:15.10,Default,,0,0,0,,就是用了这样的方法
Dialogue: 0,0:33:15.66,0:33:18.16,Default,,0,0,0,,我要介绍一个著名的古老算法
Dialogue: 0,0:33:18.28,0:33:19.47,Default,,0,0,0,,这种算法允许你
Dialogue: 0,0:33:19.50,0:33:21.37,Default,,0,0,0,,只检查内存中已知是有用的部分
Dialogue: 0,0:33:23.12,0:33:23.85,Default,,0,0,0,,这让它成为了
Dialogue: 0,0:33:23.87,0:33:25.29,Default,,0,0,0,,目前已知最快的垃圾收集算法
Dialogue: 0,0:33:26.31,0:33:29.45,Default,,0,0,0,,它就是 Minsky-Fenichel-Yochelson 垃圾收集算法
Dialogue: 0,0:33:30.40,0:33:33.18,Default,,0,0,0,,它是由Minsky
Dialogue: 0,0:33:33.20,0:33:36.06,Default,,0,0,0,,在1960、61年左右发明的
Dialogue: 0,0:33:36.52,0:33:40.48,Default,,0,0,0,,当时是给RLE PDP-1 Lisp用的
Dialogue: 0,0:33:40.51,0:33:43.44,Default,,0,0,0,,这个机器只有4096个字的线性内存
Dialogue: 0,0:33:45.79,0:33:46.76,Default,,0,0,0,,还有个磁鼓
Dialogue: 0,0:33:48.48,0:33:49.39,Default,,0,0,0,,为了能够
Dialogue: 0,0:33:50.03,0:33:51.87,Default,,0,0,0,,在这种恶劣的条件下进行垃圾收集
Dialogue: 0,0:33:53.05,0:33:54.35,Default,,0,0,0,,Minsky意识到
Dialogue: 0,0:33:54.38,0:33:55.62,Default,,0,0,0,,达成目的最容易的方法是
Dialogue: 0,0:33:56.20,0:33:58.47,Default,,0,0,0,,在扫描内存的同时
Dialogue: 0,0:33:58.47,0:34:00.60,Default,,0,0,0,,遍历那些好的数据结构
Dialogue: 0,0:34:01.57,0:34:03.52,Default,,0,0,0,,把它复制到磁鼓中
Dialogue: 0,0:34:04.70,0:34:05.47,Default,,0,0,0,,压缩一下
Dialogue: 0,0:34:06.35,0:34:08.86,Default,,0,0,0,,之后把它们复制出来
Dialogue: 0,0:34:09.12,0:34:10.90,Default,,0,0,0,,并把它们交换回内存里
Dialogue: 0,0:34:12.30,0:34:13.68,Default,,0,0,0,,不管是使用的是磁鼓
Dialogue: 0,0:34:13.72,0:34:14.71,Default,,0,0,0,,或者其它的内存
Dialogue: 0,0:34:14.71,0:34:16.42,Default,,0,0,0,,这都不重要
Dialogue: 0,0:34:17.03,0:34:17.42,Default,,0,0,0,,事实上
Dialogue: 0,0:34:17.44,0:34:19.60,Default,,0,0,0,,我觉得现在应该没人用磁鼓了吧
Dialogue: 0,0:34:20.35,0:34:23.77,Default,,0,0,0,,但这个算法基本上
Dialogue: 0,0:34:24.03,0:34:25.42,Default,,0,0,0,,要依赖于
Dialogue: 0,0:34:25.42,0:34:27.42,Default,,0,0,0,,大约两倍于
Dialogue: 0,0:34:27.48,0:34:28.57,Default,,0,0,0,,你实际使用的内存
Dialogue: 0,0:34:30.27,0:34:32.96,Default,,0,0,0,,最开始的情况是
Dialogue: 0,0:34:33.12,0:34:36.60,Default,,0,0,0,,有用的数据和垃圾混在了一起
Dialogue: 0,0:34:37.11,0:34:38.97,Default,,0,0,0,,它被称为FROMSPACE
Dialogue: 0,0:34:45.17,0:34:47.05,Default,,0,0,0,,这是CRUD的混合
Dialogue: 0,0:34:47.87,0:34:49.79,Default,,0,0,0,,有些是有用的 有些没有用
Dialogue: 0,0:34:52.00,0:34:53.85,Default,,0,0,0,,现在还有另外一块空间
Dialogue: 0,0:34:54.17,0:34:55.61,Default,,0,0,0,,它需要足够大
Dialogue: 0,0:34:55.77,0:34:57.00,Default,,0,0,0,,这个地方叫TOSPACE
Dialogue: 0,0:34:57.12,0:34:58.24,Default,,0,0,0,,要把东西复制进去
Dialogue: 0,0:35:01.59,0:35:02.60,Default,,0,0,0,,接下来会发生的是
Dialogue: 0,0:35:02.60,0:35:04.06,Default,,0,0,0,,我不会深入细节
Dialogue: 0,0:35:04.16,0:35:07.07,Default,,0,0,0,,书上写得很清楚了
Dialogue: 0,0:35:07.59,0:35:10.40,Default,,0,0,0,,这里有一个根节点
Dialogue: 0,0:35:11.03,0:35:14.30,Default,,0,0,0,,你从根节点开始
Dialogue: 0,0:35:14.60,0:35:16.42,Default,,0,0,0,,复制你看到的第一个东西
Dialogue: 0,0:35:17.83,0:35:19.37,Default,,0,0,0,,根指针指向的第一个东西
Dialogue: 0,0:35:19.75,0:35:21.31,Default,,0,0,0,,复制到TOSPACE的头部
Dialogue: 0,0:35:22.81,0:35:24.12,Default,,0,0,0,,这些东西一般是一个序对
Dialogue: 0,0:35:24.16,0:35:25.60,Default,,0,0,0,,或者是类似的数据结构
Dialogue: 0,0:35:27.56,0:35:30.19,Default,,0,0,0,,然后在那里留下
Dialogue: 0,0:35:30.38,0:35:31.56,Default,,0,0,0,,一颗“破碎的心”
Dialogue: 0,0:35:31.77,0:35:35.74,Default,,0,0,0,,表示我把东西从这里移动到了这里
Dialogue: 0,0:35:35.74,0:35:37.05,Default,,0,0,0,,指示了移动的目的地
Dialogue: 0,0:35:37.80,0:35:39.65,Default,,0,0,0,,叫作破碎的心是因为
Dialogue: 0,0:35:39.65,0:35:40.78,Default,,0,0,0,,我的一个朋友
Dialogue: 0,0:35:40.78,0:35:43.39,Default,,0,0,0,,在1966年实现了这个算法
Dialogue: 0,0:35:43.82,0:35:45.26,Default,,0,0,0,,而他是个文艺青年
Dialogue: 0,0:35:45.26,0:35:46.76,Default,,0,0,0,,就取名叫“破碎的心”
Dialogue: 0,0:35:49.58,0:35:50.54,Default,,0,0,0,,不论如何
Dialogue: 0,0:35:51.15,0:35:52.72,Default,,0,0,0,,接下来要做的是
Dialogue: 0,0:35:52.94,0:35:55.00,Default,,0,0,0,,FREE指针现在指向这里
Dialogue: 0,0:35:55.17,0:35:56.38,Default,,0,0,0,,然后开始扫描
Dialogue: 0,0:35:56.88,0:35:59.68,Default,,0,0,0,,扫描这个刚复制过来的数据结构
Dialogue: 0,0:36:00.55,0:36:02.19,Default,,0,0,0,,每当你遇到其中的指针
Dialogue: 0,0:36:02.19,0:36:03.92,Default,,0,0,0,,你把它当作是这里的根指针
Dialogue: 0,0:36:04.00,0:36:04.59,Default,,0,0,0,,哦 不好意思
Dialogue: 0,0:36:04.60,0:36:05.69,Default,,0,0,0,,我们还需要做的是
Dialogue: 0,0:36:05.71,0:36:07.08,Default,,0,0,0,,你将根指针移动到这里
Dialogue: 0,0:36:09.22,0:36:10.17,Default,,0,0,0,,因此在扫描的过程中
Dialogue: 0,0:36:10.17,0:36:10.99,Default,,0,0,0,,把遇到的每个指针
Dialogue: 0,0:36:11.00,0:36:12.41,Default,,0,0,0,,都可以当作是ROOT指针
Dialogue: 0,0:36:14.11,0:36:15.45,Default,,0,0,0,,如果你遇到了某个指针
Dialogue: 0,0:36:15.45,0:36:17.40,Default,,0,0,0,,指向了这里的某个地方
Dialogue: 0,0:36:18.51,0:36:19.92,Default,,0,0,0,,它指向的东西
Dialogue: 0,0:36:19.93,0:36:20.99,Default,,0,0,0,,你复制过了吗？
Dialogue: 0,0:36:21.78,0:36:22.87,Default,,0,0,0,,这里是“破碎的心”吗
Dialogue: 0,0:36:23.88,0:36:24.84,Default,,0,0,0,,如果那里是破碎的心
Dialogue: 0,0:36:24.84,0:36:26.11,Default,,0,0,0,,就说明那里的东西复制过了
Dialogue: 0,0:36:26.20,0:36:27.34,Default,,0,0,0,,只需要用破碎的心所指向的地址
Dialogue: 0,0:36:27.36,0:36:28.75,Default,,0,0,0,,来替换它指针即可
Dialogue: 0,0:36:29.82,0:36:32.03,Default,,0,0,0,,如果它还没被复制
Dialogue: 0,0:36:32.12,0:36:34.08,Default,,0,0,0,,你把它复制到这里
Dialogue: 0,0:36:34.43,0:36:35.95,Default,,0,0,0,,把FREE指针移到这里
Dialogue: 0,0:36:37.05,0:36:40.60,Default,,0,0,0,,然后在那里放置一颗破碎的心
Dialogue: 0,0:36:41.05,0:36:41.80,Default,,0,0,0,,继续扫描
Dialogue: 0,0:36:43.67,0:36:46.40,Default,,0,0,0,,最终SCAN指针追上了FREE指针
Dialogue: 0,0:36:46.82,0:36:48.52,Default,,0,0,0,,内存里的所有东西都被复制了
Dialogue: 0,0:36:50.14,0:36:51.04,Default,,0,0,0,,这样这里就剩下了
Dialogue: 0,0:36:51.05,0:36:51.95,Default,,0,0,0,,大量的空闲空间
Dialogue: 0,0:36:51.96,0:36:53.28,Default,,0,0,0,,如果你需要的话
Dialogue: 0,0:36:53.31,0:36:54.47,Default,,0,0,0,,你可以把它组织为空闲表
Dialogue: 0,0:36:54.47,0:36:56.27,Default,,0,0,0,,但这种系统通常不这么来做
Dialogue: 0,0:36:56.27,0:36:59.15,Default,,0,0,0,,这类系统中 内存是顺序分配的
Dialogue: 0,0:37:00.91,0:37:02.48,Default,,0,0,0,,这是个非常 非常好的算法
Dialogue: 0,0:37:02.97,0:37:04.57,Default,,0,0,0,,你们现在使用的Scheme系统中
Dialogue: 0,0:37:04.67,0:37:05.97,Default,,0,0,0,,就使用了这种算法
Dialogue: 0,0:37:06.79,0:37:09.47,Default,,0,0,0,,它应该是--
Dialogue: 0,0:37:09.47,0:37:10.86,Default,,0,0,0,,我相信还没有人发现
Dialogue: 0,0:37:10.89,0:37:12.12,Default,,0,0,0,,比它跑得更快的算法
Dialogue: 0,0:37:12.40,0:37:14.85,Default,,0,0,0,,有一些对这个算法的简单修改
Dialogue: 0,0:37:14.85,0:37:16.77,Default,,0,0,0,,由Henry Baker发明
Dialogue: 0,0:37:17.17,0:37:20.31,Default,,0,0,0,,它让你能实时运行这个算法
Dialogue: 0,0:37:20.31,0:37:21.92,Default,,0,0,0,,也就是说进行回收时不需要暂停程序
Dialogue: 0,0:37:22.14,0:37:24.33,Default,,0,0,0,,你能够让机器运行时
Dialogue: 0,0:37:24.36,0:37:26.17,Default,,0,0,0,,进行的各种CONS操作
Dialogue: 0,0:37:26.32,0:37:28.40,Default,,0,0,0,,与垃圾回收过程交错进行
Dialogue: 0,0:37:28.85,0:37:31.20,Default,,0,0,0,,垃圾回收器是分散的
Dialogue: 0,0:37:31.20,0:37:32.19,Default,,0,0,0,,机器不需要停下来
Dialogue: 0,0:37:32.41,0:37:33.47,Default,,0,0,0,,再让垃圾回收开始运作
Dialogue: 0,0:37:34.64,0:37:37.87,Default,,0,0,0,,当然 在使用虚拟内存的机器中
Dialogue: 0,0:37:38.90,0:37:41.20,Default,,0,0,0,,有很多内存无法访问
Dialogue: 0,0:37:41.50,0:37:43.60,Default,,0,0,0,,这会让整个过程变得耗时
Dialogue: 0,0:37:44.28,0:37:46.43,Default,,0,0,0,,有很多人尝试
Dialogue: 0,0:37:47.16,0:37:48.65,Default,,0,0,0,,将它改进得更好
Dialogue: 0,0:37:49.19,0:37:51.15,Default,,0,0,0,,对于感兴趣的同学
Dialogue: 0,0:37:51.16,0:37:52.41,Default,,0,0,0,,这有一篇论文
Dialogue: 0,0:37:52.64,0:37:54.27,Default,,0,0,0,,作者是Moon等人
Dialogue: 0,0:37:54.65,0:37:56.89,Default,,0,0,0,,这篇论文描述了
Dialogue: 0,0:37:56.92,0:37:59.44,Default,,0,0,0,,增量式Minsky-Fenichel-Yochelson算法
Dialogue: 0,0:37:59.51,0:38:01.20,Default,,0,0,0,,和Baker算法的修改
Dialogue: 0,0:38:01.42,0:38:06.54,Default,,0,0,0,,让使用虚拟内存的系统更加高效
Dialogue: 0,0:38:08.27,0:38:12.32,Default,,0,0,0,,现在最后一个谜团也解开了
Dialogue: 0,0:38:12.84,0:38:14.09,Default,,0,0,0,,有什么疑惑吗？
Dialogue: 0,0:38:19.78,0:38:19.95,Default,,0,0,0,,请讲
Dialogue: 0,0:38:20.60,0:38:23.58,Default,,0,0,0,,学生：我在楼上的系统上
Dialogue: 0,0:38:23.64,0:38:25.05,Default,,0,0,0,,你们运行垃圾收集器的时候
Dialogue: 0,0:38:25.93,0:38:27.88,Default,,0,0,0,,它看起来跑得飞快
Dialogue: 0,0:38:27.96,0:38:28.40,Default,,0,0,0,,教授：是的
Dialogue: 0,0:38:28.49,0:38:29.52,Default,,0,0,0,,学生：整个过程花费了--
Dialogue: 0,0:38:30.11,0:38:31.88,Default,,0,0,0,,它真的扫描了整个内存吗？
Dialogue: 0,0:38:31.88,0:38:32.22,Default,,0,0,0,,教授：没有
Dialogue: 0,0:38:32.25,0:38:34.11,Default,,0,0,0,,它只扫描了那些需要的
Dialogue: 0,0:38:34.33,0:38:35.63,Default,,0,0,0,,去复制那些有用的数据结构
Dialogue: 0,0:38:37.32,0:38:38.36,Default,,0,0,0,,它是个复制收集器
Dialogue: 0,0:38:38.44,0:38:38.91,Default,,0,0,0,,学生：好吧
Dialogue: 0,0:38:39.30,0:38:40.88,Default,,0,0,0,,教授：但它确实很快
Dialogue: 0,0:38:41.85,0:38:45.88,Default,,0,0,0,,整体来说 我想如果要复制
Dialogue: 0,0:38:47.12,0:38:51.56,Default,,0,0,0,,一个大约3MB的东西
Dialogue: 0,0:38:52.43,0:38:53.24,Default,,0,0,0,,将在一秒内完成
Dialogue: 0,0:38:55.00,0:38:55.69,Default,,0,0,0,,而且是实时的
Dialogue: 0,0:38:56.54,0:38:58.46,Default,,0,0,0,,它们是非常小的程序
Dialogue: 0,0:38:58.62,0:39:01.50,Default,,0,0,0,,你需要注意到的一件事是
Dialogue: 0,0:39:02.91,0:39:04.40,Default,,0,0,0,,垃圾收集器必须要小
Dialogue: 0,0:39:05.40,0:39:07.10,Default,,0,0,0,,不是因为它们需要运行得快
Dialogue: 0,0:39:07.90,0:39:09.23,Default,,0,0,0,,因为没有人能够调试
Dialogue: 0,0:39:09.26,0:39:10.48,Default,,0,0,0,,复杂的垃圾收集器
Dialogue: 0,0:39:11.34,0:39:12.91,Default,,0,0,0,,如果一个垃圾收集器不能正常工作
Dialogue: 0,0:39:14.04,0:39:15.93,Default,,0,0,0,,它会把你的内存搞得一团糟
Dialogue: 0,0:39:15.93,0:39:17.39,Default,,0,0,0,,而你却束手无策
Dialogue: 0,0:39:18.35,0:39:19.67,Default,,0,0,0,,你需要跟踪审计
Dialogue: 0,0:39:20.66,0:39:22.01,Default,,0,0,0,,因为它把所有东西都换了位置
Dialogue: 0,0:39:22.04,0:39:23.24,Default,,0,0,0,,你需要知道那里发生了什么
Dialogue: 0,0:39:23.74,0:39:26.58,Default,,0,0,0,,所以这是唯一一种
Dialogue: 0,0:39:26.92,0:39:28.40,Default,,0,0,0,,真正非常重要的程序
Dialogue: 0,0:39:28.54,0:39:29.79,Default,,0,0,0,,如果你盯着它看足够久
Dialogue: 0,0:39:29.82,0:39:31.07,Default,,0,0,0,,那么你就相信它有效
Dialogue: 0,0:39:31.34,0:39:33.36,Default,,0,0,0,,这意味着某种“自我证明”
Dialogue: 0,0:39:33.92,0:39:36.11,Default,,0,0,0,,因此我们无法对它进行查错
Dialogue: 0,0:39:36.94,0:39:38.96,Default,,0,0,0,,这意味着它需要足够小
Dialogue: 0,0:39:38.96,0:39:39.97,Default,,0,0,0,,你的大脑能够思考它的工作情况
Dialogue: 0,0:39:41.45,0:39:43.90,Default,,0,0,0,,正因如此 垃圾收集器十分特殊
Dialogue: 0,0:39:45.02,0:39:47.12,Default,,0,0,0,,所以实用的垃圾收集器一定要短小
Dialogue: 0,0:39:47.13,0:39:48.45,Default,,0,0,0,,而通常短小的程序运行得就快
Dialogue: 0,0:39:52.05,0:39:52.43,Default,,0,0,0,,请讲
Dialogue: 0,0:39:52.43,0:39:54.51,Default,,0,0,0,,学生：您能再重复一遍这个技术的名字吗?
Dialogue: 0,0:39:54.68,0:39:56.92,Default,,0,0,0,,教授：Minsky-Fenichel-Yochelson垃圾回收器
Dialogue: 0,0:39:57.88,0:39:58.43,Default,,0,0,0,,学生：什么?
Dialogue: 0,0:39:59.00,0:40:00.78,Default,,0,0,0,,教授：Minsky在1961年
Dialogue: 0,0:40:00.81,0:40:02.21,Default,,0,0,0,,为RLE PDP-1设计了这个算法
Dialogue: 0,0:40:02.21,0:40:06.17,Default,,0,0,0,,Fenichel和Yochelson改进并精化了算法
Dialogue: 0,0:40:06.45,0:40:10.27,Default,,0,0,0,,将它用在了Multics平台的MacLisp中
Dialogue: 0,0:40:11.37,0:40:14.75,Default,,0,0,0,,那时大约是1968或者1969年
Dialogue: 0,0:40:19.57,0:40:21.36,Default,,0,0,0,,好吧 我们休息一下
Dialogue: 0,0:40:22.64,0:40:32.36,Default,,0,0,0,,[音乐]
Dialogue: 0,0:40:32.41,0:40:36.19,Declare,,0,0,0,,{\an2\fad(500,500)}《计算机程序的构造和解释》
Dialogue: 0,0:41:03.15,0:41:07.18,Declare,,0,0,0,,{\an2\fad(500,500)}讲师： 哈罗德·艾伯森教授 及 格兰德·杰·萨斯曼教授
Dialogue: 0,0:41:07.20,0:41:10.17,Declare,,0,0,0,,{\an2\fad(500,500)\pos(320,470)}《计算机程序的构造和解释》
Dialogue: 0,0:41:10.20,0:41:14.22,Declare,,0,0,0,,{\an2\fad(500,500)}计算的极限
Dialogue: 0,0:41:17.31,0:41:19.67,Default,,0,0,0,,教授：我们已经到课程的最后一部分了
Dialogue: 0,0:41:20.08,0:41:23.85,Default,,0,0,0,,我已经给你们展示了一台通用机器
Dialogue: 0,0:41:24.47,0:41:26.74,Default,,0,0,0,,它被简化为求值器
Dialogue: 0,0:41:27.02,0:41:28.38,Default,,0,0,0,,它被简化到
Dialogue: 0,0:41:28.38,0:41:29.67,Default,,0,0,0,,你自己也能构造出来
Dialogue: 0,0:41:30.19,0:41:33.32,Default,,0,0,0,,这是一个特定的Lisp实现
Dialogue: 0,0:41:33.90,0:41:36.01,Default,,0,0,0,,它是用
Dialogue: 0,0:41:36.16,0:41:38.05,Default,,0,0,0,,昨天讲过的Scheme芯片制作的
Dialogue: 0,0:41:38.20,0:41:38.91,Default,,0,0,0,,就是这个
Dialogue: 0,0:41:39.35,0:41:42.00,Default,,0,0,0,,这基本上就是暴露给他人内存的接口了
Dialogue: 0,0:41:42.60,0:41:44.75,Default,,0,0,0,,里面有节拍发生器等组件
Dialogue: 0,0:41:45.22,0:41:47.25,Default,,0,0,0,,尽管是解释执行
Dialogue: 0,0:41:47.77,0:41:50.17,Default,,0,0,0,,但它们运行Lisp的速度还算不错
Dialogue: 0,0:41:50.61,0:41:53.82,Default,,0,0,0,,它跑得像1979年的
Dialogue: 0,0:41:54.22,0:41:55.65,Default,,0,0,0,,DEC PDP-10一样快
Dialogue: 0,0:41:56.50,0:41:59.67,Default,,0,0,0,,作为一个十足的硬件
Dialogue: 0,0:42:00.02,0:42:00.89,Default,,0,0,0,,算是十分“实在”了
Dialogue: 0,0:42:02.47,0:42:04.70,Default,,0,0,0,,我们为你们讲解了一些
Dialogue: 0,0:42:04.72,0:42:06.07,Default,,0,0,0,,可以被计算的东西
Dialogue: 0,0:42:07.37,0:42:08.76,Default,,0,0,0,,但我们是否可能遇到
Dialogue: 0,0:42:09.32,0:42:10.55,Default,,0,0,0,,我们无法计算的情况？
Dialogue: 0,0:42:11.85,0:42:13.50,Default,,0,0,0,,课程的最后
Dialogue: 0,0:42:13.75,0:42:15.87,Default,,0,0,0,,我想展示一些你认为可以被计算
Dialogue: 0,0:42:16.60,0:42:17.22,Default,,0,0,0,,但实际上不能的东西
Dialogue: 0,0:42:18.19,0:42:19.45,Default,,0,0,0,,实际上
Dialogue: 0,0:42:19.45,0:42:20.82,Default,,0,0,0,,确实有我们无法计算的东西
Dialogue: 0,0:42:22.72,0:42:23.47,Default,,0,0,0,,例如
Dialogue: 0,0:42:24.45,0:42:25.82,Default,,0,0,0,,我们想要这样的一种东西
Dialogue: 0,0:42:27.80,0:42:29.36,Default,,0,0,0,,当我们在编写编译器时
Dialogue: 0,0:42:29.77,0:42:31.42,Default,,0,0,0,,你想用一个程序检查
Dialogue: 0,0:42:32.00,0:42:33.97,Default,,0,0,0,,你的代码能否正常运行
Dialogue: 0,0:42:34.63,0:42:35.40,Default,,0,0,0,,这不是很棒吗?
Dialogue: 0,0:42:36.08,0:42:37.87,Default,,0,0,0,,你希望能够捕获死循环
Dialogue: 0,0:42:37.87,0:42:38.54,Default,,0,0,0,,例如
Dialogue: 0,0:42:39.45,0:42:42.42,Default,,0,0,0,,用户编写的程序里的死循环
Dialogue: 0,0:42:43.19,0:42:45.12,Default,,0,0,0,,但通常来说 你写不出这样的程序
Dialogue: 0,0:42:45.35,0:42:46.49,Default,,0,0,0,,它读取某个程序
Dialogue: 0,0:42:46.51,0:42:47.45,Default,,0,0,0,,并检测它
Dialogue: 0,0:42:48.35,0:42:49.30,Default,,0,0,0,,是不是死循环
Dialogue: 0,0:42:50.99,0:42:51.71,Default,,0,0,0,,我来展示一下
Dialogue: 0,0:42:51.76,0:42:53.80,Default,,0,0,0,,这个需要涉及到数学知识
Dialogue: 0,0:42:58.78,0:42:59.65,Default,,0,0,0,,设想
Dialogue: 0,0:43:00.05,0:43:01.78,Default,,0,0,0,,在我们开始之前
Dialogue: 0,0:43:01.78,0:43:02.62,Default,,0,0,0,,有一个数学函数
Dialogue: 0,0:43:02.62,0:43:03.42,Default,,0,0,0,,这里就有一个
Dialogue: 0,0:43:03.84,0:43:04.67,Default,,0,0,0,,记作S
Dialogue: 0,0:43:05.47,0:43:07.54,Default,,0,0,0,,它接受一个过程
Dialogue: 0,0:43:12.64,0:43:14.23,Default,,0,0,0,,和它的参数A
Dialogue: 0,0:43:19.17,0:43:20.52,Default,,0,0,0,,S所做的是
Dialogue: 0,0:43:21.65,0:43:24.01,Default,,0,0,0,,检测以A为参数运行P时
Dialogue: 0,0:43:24.01,0:43:25.97,Default,,0,0,0,,是否安全
Dialogue: 0,0:43:26.90,0:43:28.17,Default,,0,0,0,,换句话说就是
Dialogue: 0,0:43:28.76,0:43:35.12,Default,,0,0,0,,如果(P A)
Dialogue: 0,0:43:35.62,0:43:36.74,Default,,0,0,0,,在没有出错的情况下
Dialogue: 0,0:43:41.40,0:43:42.45,Default,,0,0,0,,能够返回一个值
Dialogue: 0,0:43:44.35,0:43:45.33,Default,,0,0,0,,那么S就为TRUE
Dialogue: 0,0:43:52.70,0:43:53.68,Default,,0,0,0,,但如果(P A)
Dialogue: 0,0:43:56.10,0:43:57.04,Default,,0,0,0,,是死循环
Dialogue: 0,0:43:59.67,0:44:00.76,Default,,0,0,0,,或者抛出错误
Dialogue: 0,0:44:05.87,0:44:06.95,Default,,0,0,0,,那么S就为FALSE
Dialogue: 0,0:44:15.23,0:44:17.22,Default,,0,0,0,,这确实是个函数
Dialogue: 0,0:44:18.78,0:44:20.72,Default,,0,0,0,,对于你输入的任何过程
Dialogue: 0,0:44:21.20,0:44:22.85,Default,,0,0,0,,或者任何参数
Dialogue: 0,0:44:23.92,0:44:25.45,Default,,0,0,0,,它只能返回TRUE或FALSE
Dialogue: 0,0:44:25.92,0:44:27.85,Default,,0,0,0,,它会返回一个值而且不会报错
Dialogue: 0,0:44:28.44,0:44:30.15,Default,,0,0,0,,你可以为它们画一张巨大的表格
Dialogue: 0,0:44:32.22,0:44:32.92,Default,,0,0,0,,但问题是
Dialogue: 0,0:44:32.92,0:44:34.09,Default,,0,0,0,,你能写一个过程
Dialogue: 0,0:44:34.09,0:44:35.92,Default,,0,0,0,,来计算这个函数的值吗?
Dialogue: 0,0:44:37.43,0:44:38.92,Default,,0,0,0,,假设我们能做到
Dialogue: 0,0:44:39.72,0:44:40.55,Default,,0,0,0,,假设
Dialogue: 0,0:44:44.33,0:44:45.58,Default,,0,0,0,,我们有个过程
Dialogue: 0,0:44:48.55,0:44:52.73,Default,,0,0,0,,一个叫作SAFE?的过程
Dialogue: 0,0:44:56.54,0:44:59.90,Default,,0,0,0,,它能计算S的值
Dialogue: 0,0:45:12.65,0:45:14.89,Default,,0,0,0,,现在我要用几种方法
Dialogue: 0,0:45:15.90,0:45:18.51,Default,,0,0,0,,证明你做不到
Dialogue: 0,0:45:19.76,0:45:20.62,Default,,0,0,0,,最简单的一个
Dialogue: 0,0:45:20.62,0:45:21.28,Default,,0,0,0,,或者说第一个
Dialogue: 0,0:45:21.31,0:45:23.45,Default,,0,0,0,,我们定义一个叫DIAG1的过程
Dialogue: 0,0:45:23.76,0:45:24.86,Default,,0,0,0,,给定了SAFE?过程
Dialogue: 0,0:45:25.20,0:45:26.99,Default,,0,0,0,,我们可以把DIAG1定义为
Dialogue: 0,0:45:34.42,0:45:35.55,Default,,0,0,0,,把DIAG1定义为
Dialogue: 0,0:45:37.82,0:45:41.60,Default,,0,0,0,,只含有参数P的过程
Dialogue: 0,0:45:42.45,0:45:44.05,Default,,0,0,0,,它有着这样的属性
Dialogue: 0,0:45:44.78,0:45:50.67,Default,,0,0,0,,如果(SAFE? P P)为真
Dialogue: 0,0:45:53.32,0:45:55.32,Default,,0,0,0,,那么我就主动陷入死循环
Dialogue: 0,0:45:59.22,0:46:00.92,Default,,0,0,0,,否则我会返回3
Dialogue: 0,0:46:03.68,0:46:04.47,Default,,0,0,0,,它也可能是42
Dialogue: 0,0:46:04.47,0:46:06.42,Default,,0,0,0,,宇宙的终极答案是什么?
Dialogue: 0,0:46:07.06,0:46:08.87,Default,,0,0,0,,我们当然知道死循环是什么
Dialogue: 0,0:46:12.05,0:46:12.96,Default,,0,0,0,,死循环INF是
Dialogue: 0,0:46:13.82,0:46:16.02,Default,,0,0,0,,一个无参过程
Dialogue: 0,0:46:16.02,0:46:18.07,Default,,0,0,0,,这是一个极好的LAMBADA演算循环
Dialogue: 0,0:46:18.35,0:46:20.44,Default,,0,0,0,,(LAMBDA (X) (X X))
Dialogue: 0,0:46:21.30,0:46:24.68,Default,,0,0,0,,应用到(LAMBDA (X) (X X))
Dialogue: 0,0:46:24.68,0:46:26.55,Default,,0,0,0,,没什么想象的余地了
Dialogue: 0,0:46:29.83,0:46:31.17,Default,,0,0,0,,我们来看下会发生什么
Dialogue: 0,0:46:32.50,0:46:33.90,Default,,0,0,0,,我假设
Dialogue: 0,0:46:35.45,0:46:38.77,Default,,0,0,0,,我们考虑
Dialogue: 0,0:46:39.00,0:46:43.45,Default,,0,0,0,,把DIAG1应用到DIAG1上
Dialogue: 0,0:46:46.27,0:46:47.77,Default,,0,0,0,,那会发生什么呢?
Dialogue: 0,0:46:49.97,0:46:51.39,Default,,0,0,0,,我不知道
Dialogue: 0,0:46:51.39,0:46:53.21,Default,,0,0,0,,将DIAG1代换为
Dialogue: 0,0:46:53.55,0:46:55.50,Default,,0,0,0,,P的过程体
Dialogue: 0,0:46:57.31,0:47:00.22,Default,,0,0,0,,(SAFE? DIAG1 DIAG1)会返回什么呢？
Dialogue: 0,0:47:00.22,0:47:00.78,Default,,0,0,0,,我不知道
Dialogue: 0,0:47:00.78,0:47:01.82,Default,,0,0,0,,有两种可能
Dialogue: 0,0:47:03.40,0:47:05.50,Default,,0,0,0,,如果计算(DIAG1 DIAG1)是安全的
Dialogue: 0,0:47:05.92,0:47:06.89,Default,,0,0,0,,这意味着没有死循环
Dialogue: 0,0:47:08.49,0:47:09.22,Default,,0,0,0,,那么我就要来到这里
Dialogue: 0,0:47:09.22,0:47:10.35,Default,,0,0,0,,但是随即我就陷入了死循环
Dialogue: 0,0:47:10.56,0:47:11.57,Default,,0,0,0,,所以它不是安全的
Dialogue: 0,0:47:12.21,0:47:14.78,Default,,0,0,0,,但如果计算(DIAG1 DIAG1)不安全
Dialogue: 0,0:47:14.90,0:47:16.02,Default,,0,0,0,,那么它的结果是3
Dialogue: 0,0:47:16.02,0:47:17.26,Default,,0,0,0,,但是调用(DIAG1 DIAG1)又必须能够返回
Dialogue: 0,0:47:17.26,0:47:17.93,Default,,0,0,0,,所以它必须安全才行
Dialogue: 0,0:47:20.53,0:47:23.60,Default,,0,0,0,,因此 通过归纳出这个矛盾
Dialogue: 0,0:47:24.32,0:47:26.30,Default,,0,0,0,,我们无法写出这个SAFE?过程
Dialogue: 0,0:47:27.40,0:47:29.80,Default,,0,0,0,,如果大家没有听明白这种表述
Dialogue: 0,0:47:30.25,0:47:32.15,Default,,0,0,0,,我换个方式再讲一遍
Dialogue: 0,0:47:32.82,0:47:34.00,Default,,0,0,0,,请听另一个版本
Dialogue: 0,0:47:35.53,0:47:36.95,Default,,0,0,0,,我们定义DIAG2
Dialogue: 0,0:47:39.84,0:47:41.60,Default,,0,0,0,,取名叫DIAG是因为
Dialogue: 0,0:47:42.65,0:47:44.72,Default,,0,0,0,,它来源于康托尔的对角论证法
Dialogue: 0,0:47:45.00,0:47:47.05,Default,,0,0,0,,这些事例最初都来自于
Dialogue: 0,0:47:47.05,0:47:49.05,Default,,0,0,0,,一个著名的论证
Dialogue: 0,0:47:49.45,0:47:52.65,Default,,0,0,0,,也就是康托尔在19世纪末
Dialogue: 0,0:47:52.77,0:47:56.10,Default,,0,0,0,,证明了实数是不可数的
Dialogue: 0,0:47:56.67,0:47:58.00,Default,,0,0,0,,整数与实数
Dialogue: 0,0:47:58.06,0:47:59.42,Default,,0,0,0,,无法形成一一映射
Dialogue: 0,0:48:00.19,0:48:01.74,Default,,0,0,0,,数轴上的点
Dialogue: 0,0:48:01.74,0:48:02.50,Default,,0,0,0,,举例来说
Dialogue: 0,0:48:02.50,0:48:04.42,Default,,0,0,0,,比数轴上的刻度还要多
Dialogue: 0,0:48:05.26,0:48:06.85,Default,,0,0,0,,这或许不是个显而易见的结论
Dialogue: 0,0:48:06.85,0:48:08.17,Default,,0,0,0,,但我不想深入讨论这个
Dialogue: 0,0:48:10.90,0:48:12.45,Default,,0,0,0,,但是DIAG2
Dialogue: 0,0:48:13.30,0:48:15.82,Default,,0,0,0,,也是一个参数为P的单参过程
Dialogue: 0,0:48:15.82,0:48:17.47,Default,,0,0,0,,这几乎与之前的例子相同
Dialogue: 0,0:48:17.72,0:48:24.32,Default,,0,0,0,,如果计算(P P)是安全的
Dialogue: 0,0:48:25.17,0:48:26.67,Default,,0,0,0,,那么我就要
Dialogue: 0,0:48:27.26,0:48:28.14,Default,,0,0,0,,哦 漏了一个IF
Dialogue: 0,0:48:29.31,0:48:31.02,Default,,0,0,0,,那么我就去计算
Dialogue: 0,0:48:31.57,0:48:37.58,Default,,0,0,0,,一些(P P)之外的东西
Dialogue: 0,0:48:38.96,0:48:40.21,Default,,0,0,0,,否则我就返回FALSE
Dialogue: 0,0:48:43.60,0:48:45.30,Default,,0,0,0,,这里的OTHER-THAN意思是
Dialogue: 0,0:48:45.47,0:48:46.35,Default,,0,0,0,,不管这个(P P)是什么
Dialogue: 0,0:48:46.35,0:48:47.47,Default,,0,0,0,,我都返回一些别的东西
Dialogue: 0,0:48:48.88,0:48:50.03,Default,,0,0,0,,我来给出一个
Dialogue: 0,0:48:50.07,0:48:51.52,Default,,0,0,0,,OTHER-THAN的一个定义
Dialogue: 0,0:48:51.60,0:48:52.57,Default,,0,0,0,,我觉得它是可用的
Dialogue: 0,0:48:53.89,0:48:54.51,Default,,0,0,0,,来看看
Dialogue: 0,0:48:55.64,0:48:56.08,Default,,0,0,0,,好
Dialogue: 0,0:48:56.33,0:48:57.26,Default,,0,0,0,,定义OTHER-THAN
Dialogue: 0,0:49:04.03,0:49:06.11,Default,,0,0,0,,参数为X的单参过程
Dialogue: 0,0:49:06.57,0:49:07.26,Default,,0,0,0,,过程体是
Dialogue: 0,0:49:08.05,0:49:12.96,Default,,0,0,0,,如果(EQ? X 'A)
Dialogue: 0,0:49:13.47,0:49:15.07,Default,,0,0,0,,那么结果是'B
Dialogue: 0,0:49:15.72,0:49:16.80,Default,,0,0,0,,否则结果是'A
Dialogue: 0,0:49:20.27,0:49:21.90,Default,,0,0,0,,这样无论参数是什么
Dialogue: 0,0:49:22.07,0:49:23.45,Default,,0,0,0,,返回值跟参数总是不相同的
Dialogue: 0,0:49:25.20,0:49:26.12,Default,,0,0,0,,就是这样了
Dialogue: 0,0:49:26.54,0:49:27.37,Default,,0,0,0,,这就是我要的
Dialogue: 0,0:49:28.25,0:49:29.58,Default,,0,0,0,,我们考虑一下这个
Dialogue: 0,0:49:29.58,0:49:31.15,Default,,0,0,0,,(DIAG2 DIAG2)
Dialogue: 0,0:49:38.28,0:49:38.94,Default,,0,0,0,,看
Dialogue: 0,0:49:39.95,0:49:41.72,Default,,0,0,0,,这个东西会做些危险的事情
Dialogue: 0,0:49:42.00,0:49:43.45,Default,,0,0,0,,比如求值(P P)
Dialogue: 0,0:49:44.75,0:49:45.95,Default,,0,0,0,,如果它是安全的
Dialogue: 0,0:49:47.47,0:49:49.16,Default,,0,0,0,,如果SAFE?能够被定义的话
Dialogue: 0,0:49:50.30,0:49:52.49,Default,,0,0,0,,如果你能定义SAFE?过程
Dialogue: 0,0:49:52.97,0:49:54.32,Default,,0,0,0,,那么这个过程
Dialogue: 0,0:49:54.60,0:49:56.40,Default,,0,0,0,,也就顺理成章地是安全的
Dialogue: 0,0:49:56.52,0:49:57.22,Default,,0,0,0,,对于任意输入来说都是
Dialogue: 0,0:50:01.54,0:50:03.50,Default,,0,0,0,,那么(DIAG2 DIAG2)
Dialogue: 0,0:50:03.87,0:50:12.20,Default,,0,0,0,,就会返回(OTHER-THAN (DIAG2 DIAG2))
Dialogue: 0,0:50:15.82,0:50:16.97,Default,,0,0,0,,这说不通
Dialogue: 0,0:50:17.80,0:50:19.02,Default,,0,0,0,,又产生了悖论
Dialogue: 0,0:50:19.85,0:50:21.57,Default,,0,0,0,,因此我们不能定义SAFE?
Dialogue: 0,0:50:22.95,0:50:24.23,Default,,0,0,0,,我只想这样证明两次
Dialogue: 0,0:50:24.78,0:50:25.82,Default,,0,0,0,,有些许不同
Dialogue: 0,0:50:26.84,0:50:27.90,Default,,0,0,0,,你不会感到
Dialogue: 0,0:50:29.07,0:50:30.86,Default,,0,0,0,,第一个证明是个把戏
Dialogue: 0,0:50:32.54,0:50:33.45,Default,,0,0,0,,它们可能都是把戏
Dialogue: 0,0:50:33.80,0:50:35.15,Default,,0,0,0,,但它们稍微有些不同
Dialogue: 0,0:50:37.30,0:50:39.20,Default,,0,0,0,,因此 我想这就基本上讲清楚了
Dialogue: 0,0:50:40.03,0:50:41.97,Default,,0,0,0,,我们刚刚证明了所谓的“停机问题”
Dialogue: 0,0:50:43.00,0:50:44.70,Default,,0,0,0,,我想 本课程也即将画上句号
Dialogue: 0,0:50:46.72,0:50:47.63,Default,,0,0,0,,希望你们有所收获
Dialogue: 0,0:50:50.90,0:50:51.76,Default,,0,0,0,,有什么问题吗?
Dialogue: 0,0:50:53.30,0:50:53.56,Default,,0,0,0,,请讲
Dialogue: 0,0:50:53.81,0:50:56.27,Default,,0,0,0,,学生: (S DIAG1)的值是什么?
Dialogue: 0,0:50:56.75,0:50:57.23,Default,,0,0,0,,教授: 什么的值?
Dialogue: 0,0:50:57.50,0:50:58.80,Default,,0,0,0,,学生: (S DIAG1)的值
Dialogue: 0,0:51:00.12,0:51:02.20,Default,,0,0,0,,如果你说S是个函数 我们就可以--
Dialogue: 0,0:51:02.30,0:51:03.63,Default,,0,0,0,,教授: 噢 我不知道啊
Dialogue: 0,0:51:03.87,0:51:04.35,Default,,0,0,0,,我不知道
Dialogue: 0,0:51:04.35,0:51:04.88,Default,,0,0,0,,它是一个函数
Dialogue: 0,0:51:04.88,0:51:05.85,Default,,0,0,0,,但我不知道如何计算它
Dialogue: 0,0:51:06.80,0:51:08.00,Default,,0,0,0,,我做不到
Dialogue: 0,0:51:08.61,0:51:09.64,Default,,0,0,0,,我也只是个机器
Dialogue: 0,0:51:11.53,0:51:11.88,Default,,0,0,0,,对吧?
Dialogue: 0,0:51:11.90,0:51:13.37,Default,,0,0,0,,原则上来说
Dialogue: 0,0:51:13.37,0:51:14.05,Default,,0,0,0,,没有机器
Dialogue: 0,0:51:14.47,0:51:16.87,Default,,0,0,0,,当然 也有可能会处在你刚才问的那个情况中
Dialogue: 0,0:51:16.87,0:51:18.32,Default,,0,0,0,,花点时间还是可以计算出来
Dialogue: 0,0:51:18.58,0:51:19.37,Default,,0,0,0,,但通常情况下
Dialogue: 0,0:51:19.60,0:51:21.05,Default,,0,0,0,,我无法计算S的值
Dialogue: 0,0:51:21.05,0:51:22.52,Default,,0,0,0,,别的机器也做不到
Dialogue: 0,0:51:23.78,0:51:24.92,Default,,0,0,0,,存在这样一个函数
Dialogue: 0,0:51:25.92,0:51:28.00,Default,,0,0,0,,没有任何机器能够计算它
Dialogue: 0,0:51:29.58,0:51:30.05,Default,,0,0,0,,现在
Dialogue: 0,0:51:30.67,0:51:33.67,Default,,0,0,0,,我这么来说也不会让你们吃惊
Dialogue: 0,0:51:35.22,0:51:36.25,Default,,0,0,0,,来想一想
Dialogue: 0,0:51:36.25,0:51:38.36,Default,,0,0,0,,现在我没有时间给你们展示
Dialogue: 0,0:51:38.45,0:51:43.00,Default,,0,0,0,,但这样的函数非常多
Dialogue: 0,0:51:44.40,0:51:47.58,Default,,0,0,0,,如果有一定量的可能输入
Dialogue: 0,0:51:47.75,0:51:49.62,Default,,0,0,0,,和一定量可能的结果
Dialogue: 0,0:51:49.87,0:51:51.80,Default,,0,0,0,,那么结果数量的输入数量次幂
Dialogue: 0,0:51:51.80,0:51:53.20,Default,,0,0,0,,就是可能的函数的数量
Dialogue: 0,0:51:54.50,0:51:55.48,Default,,0,0,0,,这还是单参的函数
Dialogue: 0,0:51:56.51,0:51:59.24,Default,,0,0,0,,而多参函数的个数
Dialogue: 0,0:52:00.09,0:52:03.21,Default,,0,0,0,,又比这个幂次方
Dialogue: 0,0:52:03.58,0:52:04.32,Default,,0,0,0,,这个指数还要大
Dialogue: 0,0:52:05.48,0:52:09.80,Default,,0,0,0,,函数的数量
Dialogue: 0,0:52:09.95,0:52:12.72,Default,,0,0,0,,比一个人能写出的
Dialogue: 0,0:52:13.30,0:52:14.10,Default,,0,0,0,,程序的数量更多
Dialogue: 0,0:52:14.82,0:52:16.45,Default,,0,0,0,,因为有无穷多的参数
Dialogue: 0,0:52:17.57,0:52:19.00,Default,,0,0,0,,可能会更多
Dialogue: 0,0:52:19.47,0:52:22.12,Default,,0,0,0,,所以不可计算的函数数量
Dialogue: 0,0:52:22.12,0:52:23.48,Default,,0,0,0,,一定会非常多
Dialogue: 0,0:52:25.92,0:52:26.59,Default,,0,0,0,,学生：不久前
Dialogue: 0,0:52:26.64,0:52:28.25,Default,,0,0,0,,你讲了规范
Dialogue: 0,0:52:28.30,0:52:30.04,Default,,0,0,0,,和自动生成解决方案
Dialogue: 0,0:52:30.64,0:52:31.61,Default,,0,0,0,,您觉得通过规范
Dialogue: 0,0:52:31.82,0:52:33.36,Default,,0,0,0,,能够生成解决方案么？
Dialogue: 0,0:52:37.25,0:52:38.22,Default,,0,0,0,,教授：“生成”
Dialogue: 0,0:52:38.72,0:52:39.37,Default,,0,0,0,,你是说
Dialogue: 0,0:52:39.37,0:52:42.60,Default,,0,0,0,,如何按照规范
Dialogue: 0,0:52:42.60,0:52:44.78,Default,,0,0,0,,构建相应的装置吗?
Dialogue: 0,0:52:45.05,0:52:48.36,Default,,0,0,0,,学生：软件工程中有很多
Dialogue: 0,0:52:48.36,0:52:49.90,Default,,0,0,0,,层次化的设计
Dialogue: 0,0:52:49.90,0:52:51.90,Default,,0,0,0,,并进行实现的规范
Dialogue: 0,0:52:52.43,0:52:52.85,Default,,0,0,0,,教授：是的
Dialogue: 0,0:52:52.85,0:52:53.70,Default,,0,0,0,,学生：我很好奇
Dialogue: 0,0:52:53.70,0:52:54.62,Default,,0,0,0,,您觉得这现实吗?
Dialogue: 0,0:52:55.60,0:52:57.17,Default,,0,0,0,,教授：我觉得其中一些是现实的
Dialogue: 0,0:52:57.17,0:52:58.10,Default,,0,0,0,,另一些不现实
Dialogue: 0,0:52:58.10,0:53:00.32,Default,,0,0,0,,如果你想制造一个滤波器
Dialogue: 0,0:53:01.17,0:53:07.16,Default,,0,0,0,,我这有个挺有趣的例子
Dialogue: 0,0:53:07.16,0:53:09.42,Default,,0,0,0,,假设我想制造一个东西
Dialogue: 0,0:53:09.64,0:53:14.07,Default,,0,0,0,,把无线电发射器的输出
Dialogue: 0,0:53:14.47,0:53:18.75,Default,,0,0,0,,连接到某条天线上
Dialogue: 0,0:53:19.90,0:53:21.47,Default,,0,0,0,,我先把它引出来
Dialogue: 0,0:53:21.48,0:53:23.04,Default,,0,0,0,,这里是输出管线
Dialogue: 0,0:53:23.23,0:53:25.26,Default,,0,0,0,,问题是它们的阻抗不同
Dialogue: 0,0:53:25.92,0:53:27.55,Default,,0,0,0,,我希望能够匹配阻抗
Dialogue: 0,0:53:27.55,0:53:28.97,Default,,0,0,0,,我也想在其中加入一个滤波器
Dialogue: 0,0:53:29.15,0:53:31.71,Default,,0,0,0,,用来过滤一些谐波辐射
Dialogue: 0,0:53:32.78,0:53:36.63,Default,,0,0,0,,一种老派的技术叫作
Dialogue: 0,0:53:36.82,0:53:38.67,Default,,0,0,0,,“影像阻抗”之类的东西
Dialogue: 0,0:53:38.86,0:53:39.50,Default,,0,0,0,,你要做的是
Dialogue: 0,0:53:39.50,0:53:40.85,Default,,0,0,0,,你有个基础的模块
Dialogue: 0,0:53:40.85,0:53:42.75,Default,,0,0,0,,称为L型滤波器
Dialogue: 0,0:53:43.30,0:53:43.98,Default,,0,0,0,,就像这样
Dialogue: 0,0:53:47.08,0:53:49.80,Default,,0,0,0,,如果把它连接到某些电阻R上
Dialogue: 0,0:53:50.05,0:53:52.60,Default,,0,0,0,,如果我把它的阻抗记作X_L
Dialogue: 0,0:53:52.72,0:53:55.20,Default,,0,0,0,,而它的值刚好又等于Q*R
Dialogue: 0,0:53:55.26,0:53:58.52,Default,,0,0,0,,这就成了一个低通滤波器
Dialogue: 0,0:53:58.52,0:54:00.72,Default,,0,0,0,,有Q^2+1的等效阻抗
Dialogue: 0,0:54:02.11,0:54:02.86,Default,,0,0,0,,这就是我想要的
Dialogue: 0,0:54:03.12,0:54:04.28,Default,,0,0,0,,因为这样我就可以
Dialogue: 0,0:54:04.30,0:54:05.08,Default,,0,0,0,,把它们匹配到一起了
Dialogue: 0,0:54:05.82,0:54:06.38,Default,,0,0,0,,就像这样
Dialogue: 0,0:54:11.66,0:54:13.15,Default,,0,0,0,,我拿来另一个
Dialogue: 0,0:54:16.00,0:54:17.45,Default,,0,0,0,,想这样把它们连到一起
Dialogue: 0,0:54:18.29,0:54:19.95,Default,,0,0,0,,有两个L型滤波器连接起来
Dialogue: 0,0:54:20.32,0:54:23.07,Default,,0,0,0,,这能让它的阻抗降到我知道的值
Dialogue: 0,0:54:23.37,0:54:25.22,Default,,0,0,0,,让它的阻抗升到我知道的值
Dialogue: 0,0:54:25.53,0:54:26.64,Default,,0,0,0,,这两个低通滤波器
Dialogue: 0,0:54:26.67,0:54:27.82,Default,,0,0,0,,都过滤掉了一些谐波
Dialogue: 0,0:54:28.09,0:54:29.07,Default,,0,0,0,,这是个不错的滤波器
Dialogue: 0,0:54:29.07,0:54:30.27,Default,,0,0,0,,这就是π型滤波器
Dialogue: 0,0:54:30.27,0:54:30.62,Default,,0,0,0,,很好
Dialogue: 0,0:54:31.70,0:54:34.09,Default,,0,0,0,,除了实际上
Dialogue: 0,0:54:34.12,0:54:37.85,Default,,0,0,0,,我在系统里放了些无用的东西
Dialogue: 0,0:54:38.62,0:54:39.60,Default,,0,0,0,,我在本该只用一个的地方
Dialogue: 0,0:54:39.61,0:54:40.59,Default,,0,0,0,,用了两个线圈
Dialogue: 0,0:54:41.62,0:54:44.60,Default,,0,0,0,,在大多数软件工程技艺中
Dialogue: 0,0:54:44.89,0:54:46.88,Default,,0,0,0,,在人工优化和编译之外
Dialogue: 0,0:54:46.92,0:54:48.65,Default,,0,0,0,,不存在一种机制
Dialogue: 0,0:54:48.80,0:54:51.34,Default,,0,0,0,,能在自顶向下的设计中
Dialogue: 0,0:54:51.34,0:54:53.55,Default,,0,0,0,,去掉冗余的部分
Dialogue: 0,0:54:55.35,0:54:56.07,Default,,0,0,0,,或许会更糟
Dialogue: 0,0:54:56.07,0:54:57.58,Default,,0,0,0,,有很多重要的结构
Dialogue: 0,0:54:57.60,0:54:59.02,Default,,0,0,0,,你无法采用这种方式构建
Dialogue: 0,0:55:01.11,0:55:03.53,Default,,0,0,0,,我觉得标准的自上而下的设计方式
Dialogue: 0,0:55:03.53,0:55:04.87,Default,,0,0,0,,是一种很短视的手段
Dialogue: 0,0:55:05.71,0:55:06.60,Default,,0,0,0,,它不会真的抓到
Dialogue: 0,0:55:06.60,0:55:08.10,Default,,0,0,0,,设计者真正想要的结果
Dialogue: 0,0:55:08.31,0:55:10.10,Default,,0,0,0,,我再举一个电子学的例子
Dialogue: 0,0:55:10.10,0:55:11.75,Default,,0,0,0,,电子学的例子
Dialogue: 0,0:55:11.90,0:55:13.13,Default,,0,0,0,,要比计算的例子直观得多
Dialogue: 0,0:55:13.16,0:55:14.78,Default,,0,0,0,,因为计算的例子
Dialogue: 0,0:55:14.80,0:55:16.52,Default,,0,0,0,,解释起来比较复杂
Dialogue: 0,0:55:17.22,0:55:19.16,Default,,0,0,0,,在电子学世界中
Dialogue: 0,0:55:19.16,0:55:20.04,Default,,0,0,0,,我最喜欢的例子之一是
Dialogue: 0,0:55:20.60,0:55:22.80,Default,,0,0,0,,是如何设计中频放大器中
Dialogue: 0,0:55:23.28,0:55:26.55,Default,,0,0,0,,输入级和输出级的连接方式
Dialogue: 0,0:55:27.53,0:55:29.44,Default,,0,0,0,,这是一个三极管
Dialogue: 0,0:55:29.52,0:55:31.50,Default,,0,0,0,,我们来看看
Dialogue: 0,0:55:32.41,0:55:33.40,Default,,0,0,0,,这有个LC震荡电路
Dialogue: 0,0:55:36.45,0:55:39.17,Default,,0,0,0,,我要把它
Dialogue: 0,0:55:41.37,0:55:43.97,Default,,0,0,0,,把它与下一级的输入线圈耦合在一起
Dialogue: 0,0:55:44.36,0:55:47.47,Default,,0,0,0,,这是个完美的可行方案
Dialogue: 0,0:55:48.22,0:55:50.87,Default,,0,0,0,,除了我这个电流方向画错了
Dialogue: 0,0:55:50.87,0:55:52.92,Default,,0,0,0,,电流应该是这个方向
Dialogue: 0,0:55:53.17,0:55:55.45,Default,,0,0,0,,这是个完美的可行方案
Dialogue: 0,0:55:55.98,0:55:56.57,Default,,0,0,0,,不对
Dialogue: 0,0:55:57.12,0:55:57.79,Default,,0,0,0,,我犯蠢了
Dialogue: 0,0:55:58.40,0:55:59.07,Default,,0,0,0,,对不起
Dialogue: 0,0:55:59.69,0:56:00.42,Default,,0,0,0,,这不重要
Dialogue: 0,0:56:00.73,0:56:01.54,Default,,0,0,0,,关键在于这是一个
Dialogue: 0,0:56:01.54,0:56:03.42,Default,,0,0,0,,把两级耦合起来的完美方案
Dialogue: 0,0:56:04.54,0:56:06.92,Default,,0,0,0,,分层来看时会产生什么问题?
Dialogue: 0,0:56:07.62,0:56:08.80,Default,,0,0,0,,它就不是同一个东西了
Dialogue: 0,0:56:09.48,0:56:11.99,Default,,0,0,0,,当分层来看时它就没有任何意义了
Dialogue: 0,0:56:11.99,0:56:14.32,Default,,0,0,0,,这是一个调谐电路的电感
Dialogue: 0,0:56:15.55,0:56:18.02,Default,,0,0,0,,这是变压器的初级线圈
Dialogue: 0,0:56:19.10,0:56:21.82,Default,,0,0,0,,这是直流的通路
Dialogue: 0,0:56:21.82,0:56:23.57,Default,,0,0,0,,它是三极管的集电极
Dialogue: 0,0:56:23.57,0:56:25.10,Default,,0,0,0,,的偏置条件
Dialogue: 0,0:56:26.46,0:56:28.35,Default,,0,0,0,,没有任何简单的自顶向下设计
Dialogue: 0,0:56:28.38,0:56:30.17,Default,,0,0,0,,能够得到这样的结构
Dialogue: 0,0:56:30.22,0:56:34.02,Default,,0,0,0,,对于同一个东西有大量的复用
Dialogue: 0,0:56:34.53,0:56:36.72,Default,,0,0,0,,玩拼字游戏
Dialogue: 0,0:56:36.96,0:56:39.88,Default,,0,0,0,,当你要完成三倍分数的词时
Dialogue: 0,0:56:40.49,0:56:43.60,Default,,0,0,0,,自顶向下的设计策略并不容易
Dialogue: 0,0:56:44.95,0:56:47.08,Default,,0,0,0,,然而 大多数实际的工程学都是
Dialogue: 0,0:56:47.36,0:56:50.70,Default,,0,0,0,,秉承着“尽其力而为之”
Dialogue: 0,0:56:52.14,0:56:53.52,Default,,0,0,0,,那就是你所看到的东西
Dialogue: 0,0:56:54.86,0:56:55.55,Default,,0,0,0,,嗯？
Dialogue: 0,0:56:55.55,0:56:56.81,Default,,0,0,0,,学生：这是最后一个问题吗?
Dialogue: 0,0:57:00.28,0:57:02.03,Default,,0,0,0,,[笑声]
Dialogue: 0,0:57:18.64,0:57:19.63,Default,,0,0,0,,教授：看起来是
Dialogue: 0,0:57:23.57,0:57:24.12,Default,,0,0,0,,谢谢大家
Dialogue: 0,0:57:25.90,0:57:36.50,Default,,0,0,0,,[掌声]
Dialogue: 0,0:58:47.29,0:58:51.13,Declare,,0,0,0,,{\fad(500,500)}MIT OpenCourseWare\Nhttp://ocw.mit.edu
Dialogue: 0,0:58:47.29,0:58:51.13,Declare,,0,0,0,,{\an2\fad(500,500)}本项目主页\Nhttps://github.com/DeathKing/Learning-SICP
Dialogue: 0,0:58:51.87,0:58:53.71,Default,,0,0,0,,{\an4\pos(33,231)}　　你所知道的有关计算的东西，其他人也都能学到。绝不要认为\N\N\N似乎成功计算的钥匙就掌握在你的手里。你所掌握的，也是我认为\N\N\N并希望的，也就是智慧：那种看到这一机器比你第一次站在它面前\N\N\N时能做得更多的能力，这样你才能将它向前推进。\N\N\N\N\N　　　　　　　　　　　　　  　Alan J. Perlis (1922.4.1 - 1990.1.7)
