[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 640
PlayResY: 480

[Aegisub Project Garbage]
Scroll Position: 707
Active Line: 1394
Video Position: 126316

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: EN,Calisto MT,21,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,1,0,2,10,10,30,1
Style: Declare,微软雅黑,30,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,2,0,8,10,10,10,1
Style: staff,微软雅黑,30,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,0,2,5,10,10,10,1
Style: title,微软雅黑,35,&H001D64D9,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,0,1,5,10,10,10,1
Style: Default,雅黑宋体,20,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,1,0,2,10,10,30,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.03,0:00:00.97,Declare,,0,0,0,,{\an2\fad(500,500)}Learning-SICP 学习小组\N倾情制作
Dialogue: 0,0:00:01.05,0:00:09.09,title,,0,0,0,,{\fad(600,800)\pos(324,32)}《计算机程序的构造和解释》
Dialogue: 0,0:00:01.05,0:00:09.09,staff,,0,0,0,,{\fad(600,800)\pos(110.666,403.334)}翻译&&时间轴\N邓雄飞\N刘殊君
Dialogue: 0,0:00:01.05,0:00:09.09,staff,,0,0,0,,{\fad(600,800)\pos(534.666,404)}压制&&特效\N邓雄飞\N（Dysprosium）
Dialogue: 0,0:00:01.05,0:00:09.09,staff,,0,0,0,,{\fad(600,800)\pos(574.667,277.333)}校对\N邓雄飞
Dialogue: 0,0:00:01.05,0:00:09.09,staff,,0,0,0,,{\fad(600,800)\pos(89.334,273.333)}特别感谢\N裘宗燕教授
Dialogue: 0,0:00:09.21,0:00:13.12,Declare,,0,0,0,,{\an2\fad(500,500)}显示控制求值器
Dialogue: 0,0:00:16.30,0:00:18.08,Default,,0,0,0,,教授：我想大家已经意识到
Dialogue: 0,0:00:20.01,0:00:22.73,Default,,0,0,0,,我们介绍了一些真正的魔法
Dialogue: 0,0:00:24.20,0:00:27.24,Default,,0,0,0,,创造新语言的魔法
Dialogue: 0,0:00:27.42,0:00:28.72,Default,,0,0,0,,用来创造全新的语言
Dialogue: 0,0:00:29.69,0:00:30.40,Default,,0,0,0,,我们学了些什么？
Dialogue: 0,0:00:30.43,0:00:32.78,Default,,0,0,0,,我们学习了一门用来操作图片的Escher的语言
Dialogue: 0,0:00:38.92,0:00:41.15,Default,,0,0,0,,这门语言由Peter Henderson发明
Dialogue: 0,0:00:42.01,0:00:46.49,Default,,0,0,0,,我们还学习了数字逻辑语言
Dialogue: 0,0:00:53.16,0:00:55.55,Default,,0,0,0,,以及 我们还学习了查询语言
Dialogue: 0,0:00:59.70,0:01:00.78,Default,,0,0,0,,然而你需要明白的是
Dialogue: 0,0:01:00.81,0:01:03.10,Default,,0,0,0,,尽管它们都是“玩具级”的语言示例
Dialogue: 0,0:01:04.70,0:01:07.61,Default,,0,0,0,,但也确实是实用工具的核心
Dialogue: 0,0:01:08.25,0:01:09.48,Default,,0,0,0,,比如说
Dialogue: 0,0:01:10.12,0:01:11.18,Default,,0,0,0,,Escher图片语言
Dialogue: 0,0:01:11.20,0:01:14.33,Default,,0,0,0,,就被MIT的学生Henry Wu拿去
Dialogue: 0,0:01:14.88,0:01:16.43,Default,,0,0,0,,开发成了一门用于
Dialogue: 0,0:01:16.97,0:01:19.45,Default,,0,0,0,,为电路板布局的语言
Dialogue: 0,0:01:20.35,0:01:22.56,Default,,0,0,0,,它就是在这些结构上扩展而来
Dialogue: 0,0:01:23.24,0:01:24.65,Default,,0,0,0,,至于数字逻辑语言
Dialogue: 0,0:01:24.68,0:01:26.08,Default,,0,0,0,,Gerry教授在上课的时候也提到过
Dialogue: 0,0:01:26.43,0:01:29.92,Default,,0,0,0,,它被扩展为了一个仿真器的基础
Dialogue: 0,0:01:30.85,0:01:32.96,Default,,0,0,0,,用来设计真实的计算机
Dialogue: 0,0:01:33.46,0:01:34.32,Default,,0,0,0,,至于查询语言
Dialogue: 0,0:01:34.35,0:01:36.44,Default,,0,0,0,,当然就是Prolog语言的一种核心
Dialogue: 0,0:01:37.51,0:01:39.07,Default,,0,0,0,,我们构造的这些语言
Dialogue: 0,0:01:39.55,0:01:40.65,Default,,0,0,0,,全都是用Lisp编写
Dialogue: 0,0:01:43.63,0:01:44.59,Default,,0,0,0,,很多人问
Dialogue: 0,0:01:45.27,0:01:48.73,Default,,0,0,0,,Lisp适合用来解决哪一类问题？
Dialogue: 0,0:01:48.75,0:01:49.93,Default,,0,0,0,,答案就是
Dialogue: 0,0:01:50.33,0:01:52.65,Default,,0,0,0,,Lisp不适合解决任何一类问题
Dialogue: 0,0:01:53.53,0:01:54.60,Default,,0,0,0,,Lisp擅长的是
Dialogue: 0,0:01:54.73,0:01:57.15,Default,,0,0,0,,用它来构造一门合适的语言
Dialogue: 0,0:01:57.18,0:01:58.57,Default,,0,0,0,,来解决你的问题
Dialogue: 0,0:01:59.17,0:02:00.44,Default,,0,0,0,,你应该像这样看待Lisp
Dialogue: 0,0:02:01.47,0:02:03.39,Default,,0,0,0,,那么既然这些语言都基于Lisp
Dialogue: 0,0:02:04.57,0:02:05.72,Default,,0,0,0,,那Lisp又基于什么？
Dialogue: 0,0:02:06.97,0:02:07.88,Default,,0,0,0,,它又从何而来？
Dialogue: 0,0:02:07.90,0:02:09.40,Default,,0,0,0,,这个我们也学过
Dialogue: 0,0:02:09.58,0:02:16.09,Default,,0,0,0,,我们学过元循环求值器
Dialogue: 0,0:02:21.53,0:02:23.40,Default,,0,0,0,,学习了元循环求值器后 我们说
Dialogue: 0,0:02:23.42,0:02:25.76,Default,,0,0,0,,Lisp就是基于Lisp的
Dialogue: 0,0:02:25.80,0:02:27.48,Default,,0,0,0,,而当我们研究它的时候
Dialogue: 0,0:02:28.27,0:02:29.95,Default,,0,0,0,,我们必须得施展一些真正的魔法 对吧？
Dialogue: 0,0:02:29.95,0:02:31.74,Default,,0,0,0,,这又是什么意思呢？
Dialogue: 0,0:02:31.74,0:02:34.96,Default,,0,0,0,,Y算子、不动点
Dialogue: 0,0:02:35.76,0:02:38.33,Default,,0,0,0,,以及这样的一个观念--
Dialogue: 0,0:02:38.36,0:02:41.44,Default,,0,0,0,,Lisp实际上是一个方程的不动点
Dialogue: 0,0:02:42.20,0:02:45.42,Default,,0,0,0,,一个通过自身来定义的有趣方程
Dialogue: 0,0:02:47.40,0:02:48.56,Default,,0,0,0,,这确实是神奇的魔法
Dialogue: 0,0:02:49.07,0:02:52.35,Default,,0,0,0,,那么今天 作为魔法的最后一步
Dialogue: 0,0:02:52.62,0:02:54.03,Default,,0,0,0,,我们要把它们通通消除掉
Dialogue: 0,0:03:06.80,0:03:07.98,Default,,0,0,0,,我们已经知道怎么做了
Dialogue: 0,0:03:09.77,0:03:10.76,Default,,0,0,0,,核心要思想是
Dialogue: 0,0:03:11.13,0:03:12.73,Default,,0,0,0,,将Lisp语言
Dialogue: 0,0:03:13.36,0:03:15.50,Default,,0,0,0,,实现在使用寄存器架构的机器上
Dialogue: 0,0:03:15.50,0:03:17.93,Default,,0,0,0,,回想一下 寄存器机器的关键之处在于
Dialogue: 0,0:03:19.60,0:03:24.68,Default,,0,0,0,,机器的一部分是确定且有穷的
Dialogue: 0,0:03:24.72,0:03:26.12,Default,,0,0,0,,它有一个有穷状态控制器
Dialogue: 0,0:03:26.12,0:03:27.87,Default,,0,0,0,,它用特定的硬件
Dialogue: 0,0:03:27.88,0:03:29.31,Default,,0,0,0,,去完成特定的事情
Dialogue: 0,0:03:30.51,0:03:31.74,Default,,0,0,0,,其中还有一些运算所需的
Dialogue: 0,0:03:31.76,0:03:33.24,Default,,0,0,0,,特殊数据通路
Dialogue: 0,0:03:33.55,0:03:35.29,Default,,0,0,0,,然后 为了实现递归
Dialogue: 0,0:03:35.53,0:03:37.60,Default,,0,0,0,,并且维持无穷的假象
Dialogue: 0,0:03:37.82,0:03:39.77,Default,,0,0,0,,还使用了一种称作“栈”的大内存
Dialogue: 0,0:03:42.06,0:03:43.72,Default,,0,0,0,,所以如果我们在
Dialogue: 0,0:03:43.92,0:03:45.50,Default,,0,0,0,,寄存器机器上实现了Lisp
Dialogue: 0,0:03:47.02,0:03:48.35,Default,,0,0,0,,那么这个时候
Dialogue: 0,0:03:48.40,0:03:49.85,Default,,0,0,0,,所有的东西都会完全具体化
Dialogue: 0,0:03:49.85,0:03:51.23,Default,,0,0,0,,所有的魔法都会消除
Dialogue: 0,0:03:51.65,0:03:53.52,Default,,0,0,0,,这堂课结束时
Dialogue: 0,0:03:53.53,0:03:54.78,Default,,0,0,0,,我想让你感觉到
Dialogue: 0,0:03:55.14,0:03:59.05,Default,,0,0,0,,相对于神秘的元循环求值器
Dialogue: 0,0:03:59.67,0:04:02.60,Default,,0,0,0,,Lisp求值器是非常具体的东西
Dialogue: 0,0:04:02.85,0:04:04.57,Default,,0,0,0,,你甚至可以把它放在手心中
Dialogue: 0,0:04:04.76,0:04:06.24,Default,,0,0,0,,你可以想象一下
Dialogue: 0,0:04:06.57,0:04:07.90,Default,,0,0,0,,手里拿着一个Lisp解释器的情景
Dialogue: 0,0:04:09.63,0:04:10.94,Default,,0,0,0,,好 那我们怎么做呢？
Dialogue: 0,0:04:10.95,0:04:12.76,Default,,0,0,0,,所有的原料都已经齐全
Dialogue: 0,0:04:13.96,0:04:17.45,Default,,0,0,0,,上节课Gerry教了你们
Dialogue: 0,0:04:17.60,0:04:21.47,Default,,0,0,0,,对一个任意的Lisp过程
Dialogue: 0,0:04:22.60,0:04:24.28,Default,,0,0,0,,如何手动地把它们
Dialogue: 0,0:04:24.75,0:04:26.67,Default,,0,0,0,,翻译成在寄存器机器上运行的代码
Dialogue: 0,0:04:28.20,0:04:30.52,Default,,0,0,0,,那么 要在寄存器机器上实现Lisp本身
Dialogue: 0,0:04:30.57,0:04:31.44,Default,,0,0,0,,我们只需要
Dialogue: 0,0:04:31.69,0:04:33.45,Default,,0,0,0,,把最关键的过程
Dialogue: 0,0:04:33.68,0:04:35.42,Default,,0,0,0,,也就是元循环求值器
Dialogue: 0,0:04:36.17,0:04:38.11,Default,,0,0,0,,手工翻译成寄存器机器的代码
Dialogue: 0,0:04:39.04,0:04:40.25,Default,,0,0,0,,这就实现了整个Lisp
Dialogue: 0,0:04:42.14,0:04:43.00,Default,,0,0,0,,因此 我们已经知道了
Dialogue: 0,0:04:43.02,0:04:44.43,Default,,0,0,0,,实现的原理
Dialogue: 0,0:04:45.38,0:04:46.54,Default,,0,0,0,,而且实际上
Dialogue: 0,0:04:46.68,0:04:48.86,Default,,0,0,0,,这跟翻译
Dialogue: 0,0:04:50.00,0:04:53.40,Default,,0,0,0,,递归版的阶乘或斐波那契数列
Dialogue: 0,0:04:53.42,0:04:54.67,Default,,0,0,0,,没什么区别
Dialogue: 0,0:04:54.67,0:04:56.00,Default,,0,0,0,,只是它规模更大 代码更多
Dialogue: 0,0:04:56.84,0:04:58.03,Default,,0,0,0,,只是包含了更多细节
Dialogue: 0,0:04:58.04,0:04:59.66,Default,,0,0,0,,但是没有任何新的概念
Dialogue: 0,0:05:01.48,0:05:03.02,Default,,0,0,0,,当我们完成这个以后
Dialogue: 0,0:05:03.08,0:05:04.76,Default,,0,0,0,,所有的东西都变得明确了
Dialogue: 0,0:05:04.87,0:05:06.91,Default,,0,0,0,,当我们看到如何用一系列的
Dialogue: 0,0:05:06.94,0:05:10.08,Default,,0,0,0,,寄存器操作来实现Lisp之后
Dialogue: 0,0:05:10.16,0:05:11.63,Default,,0,0,0,,它就成为了我们整个课程中
Dialogue: 0,0:05:11.95,0:05:14.16,Default,,0,0,0,,最明确的Lisp模型
Dialogue: 0,0:05:14.81,0:05:16.95,Default,,0,0,0,,回忆一下 这个过程贯穿了整个课程
Dialogue: 0,0:05:16.95,0:05:18.25,Default,,0,0,0,,我们先从代换模型开始
Dialogue: 0,0:05:18.28,0:05:19.58,Default,,0,0,0,,它和代数有点相似
Dialogue: 0,0:05:20.24,0:05:21.87,Default,,0,0,0,,然后学习了环境模型
Dialogue: 0,0:05:21.88,0:05:24.00,Default,,0,0,0,,它引入了“框架”的概念
Dialogue: 0,0:05:24.03,0:05:25.31,Default,,0,0,0,,以及框架之间的关联
Dialogue: 0,0:05:26.32,0:05:27.88,Default,,0,0,0,,然后我们在元循环求值器中
Dialogue: 0,0:05:27.90,0:05:29.36,Default,,0,0,0,,把它变得更具体了
Dialogue: 0,0:05:31.05,0:05:31.64,Default,,0,0,0,,但是有的事情
Dialogue: 0,0:05:31.87,0:05:33.98,Default,,0,0,0,,元循环求值器没有告诉我们
Dialogue: 0,0:05:34.36,0:05:35.34,Default,,0,0,0,,你应该认识到这点
Dialogue: 0,0:05:36.09,0:05:38.64,Default,,0,0,0,,比如说 我们还不知道
Dialogue: 0,0:05:38.73,0:05:42.67,Default,,0,0,0,,像这里的递归阶乘过程
Dialogue: 0,0:05:45.17,0:05:47.13,Default,,0,0,0,,为何不断地申请新的空间
Dialogue: 0,0:05:47.21,0:05:47.98,Default,,0,0,0,,另一方面
Dialogue: 0,0:05:48.16,0:05:51.94,Default,,0,0,0,,一个语法上看起来像是递归的过程
Dialogue: 0,0:05:52.11,0:05:55.07,Default,,0,0,0,,比如FACT-ITER 并不占用栈空间
Dialogue: 0,0:05:55.10,0:05:59.16,Default,,0,0,0,,我们通过代换模型来证明
Dialogue: 0,0:06:00.50,0:06:01.96,Default,,0,0,0,,它不占用空间
Dialogue: 0,0:06:01.96,0:06:02.94,Default,,0,0,0,,但我们并没有说清楚
Dialogue: 0,0:06:03.42,0:06:06.76,Default,,0,0,0,,机器是如何做到这一点的
Dialogue: 0,0:06:07.31,0:06:08.91,Default,,0,0,0,,这涉及到一些细节
Dialogue: 0,0:06:09.02,0:06:11.12,Default,,0,0,0,,比如参数是如何传递给过程的
Dialogue: 0,0:06:12.48,0:06:13.69,Default,,0,0,0,,这是我们在元循环求值器中
Dialogue: 0,0:06:13.71,0:06:15.34,Default,,0,0,0,,没有看到的
Dialogue: 0,0:06:15.36,0:06:17.40,Default,,0,0,0,,完全是因为在所实现的Lisp中
Dialogue: 0,0:06:17.42,0:06:19.20,Default,,0,0,0,,把参数传递给过程的方式
Dialogue: 0,0:06:19.70,0:06:20.59,Default,,0,0,0,,取决于
Dialogue: 0,0:06:21.02,0:06:23.50,Default,,0,0,0,,外部Lisp的传参方式
Dialogue: 0,0:06:25.87,0:06:29.02,Default,,0,0,0,,但现在 这一点将变得非常明确
Dialogue: 0,0:06:30.74,0:06:31.12,Default,,0,0,0,,好
Dialogue: 0,0:06:31.23,0:06:34.30,Default,,0,0,0,,在开始研究求值器之前
Dialogue: 0,0:06:34.36,0:06:35.53,Default,,0,0,0,,我先让你们感受一下
Dialogue: 0,0:06:35.55,0:06:37.00,Default,,0,0,0,,一个完整Lisp系统是怎么样的
Dialogue: 0,0:06:37.60,0:06:39.36,Default,,0,0,0,,这样你就可以知道 我们要讨论哪部分
Dialogue: 0,0:06:39.40,0:06:40.81,Default,,0,0,0,,不讨论哪些部分
Dialogue: 0,0:06:43.18,0:06:47.42,Default,,0,0,0,,首先 这里有一个快乐的Lisp用户
Dialogue: 0,0:06:48.67,0:06:52.65,Default,,0,0,0,,他正在和一个叫做读取器的东西交流
Dialogue: 0,0:07:00.36,0:07:01.53,Default,,0,0,0,,读取器的工作是
Dialogue: 0,0:07:01.95,0:07:13.23,Default,,0,0,0,,读取用户输入的字符串
Dialogue: 0,0:07:14.17,0:07:16.62,Default,,0,0,0,,把它们转化成一种称作
Dialogue: 0,0:07:17.20,0:07:19.37,Default,,0,0,0,,表结构内存的数据结构
Dialogue: 0,0:07:30.00,0:07:31.72,Default,,0,0,0,,读取器会读取--
Dialogue: 0,0:07:32.65,0:07:33.95,Default,,0,0,0,,你敲出来的符号、括号
Dialogue: 0,0:07:34.48,0:07:37.12,Default,,0,0,0,,A和B、1和3这些东西
Dialogue: 0,0:07:37.18,0:07:39.04,Default,,0,0,0,,并把它们变成表结构
Dialogue: 0,0:07:39.15,0:07:40.54,Default,,0,0,0,,变成序对、指针等等
Dialogue: 0,0:07:42.35,0:07:43.92,Default,,0,0,0,,所以当求值器运行的时候
Dialogue: 0,0:07:43.93,0:07:45.10,Default,,0,0,0,,环境里已经不存在原始字符了
Dialogue: 0,0:07:45.85,0:07:48.16,Default,,0,0,0,,当然 在更现代的Lisp系统中
Dialogue: 0,0:07:49.00,0:07:50.44,Default,,0,0,0,,可能还有一大团东西
Dialogue: 0,0:07:50.44,0:07:52.17,Default,,0,0,0,,存在于在读取器和用户之间
Dialogue: 0,0:07:52.41,0:07:54.52,Default,,0,0,0,,最顶层首先是视窗系统
Dialogue: 0,0:07:54.77,0:07:56.03,Default,,0,0,0,,以及鼠标之类的东西
Dialogue: 0,0:07:56.28,0:07:58.20,Default,,0,0,0,,但从概念上来说 都是在输入字符
Dialogue: 0,0:07:59.93,0:08:04.32,Default,,0,0,0,,总之 读取器把它们都变成指针
Dialogue: 0,0:08:05.56,0:08:07.28,Default,,0,0,0,,指向内存中的对象
Dialogue: 0,0:08:08.27,0:08:10.94,Default,,0,0,0,,这是求值器的所能看到的东西
Dialogue: 0,0:08:15.55,0:08:16.04,Default,,0,0,0,,明白吗？
Dialogue: 0,0:08:17.02,0:08:18.88,Default,,0,0,0,,求值器有一些辅助函数
Dialogue: 0,0:08:19.78,0:08:23.16,Default,,0,0,0,,包括你需要的所有基本运算
Dialogue: 0,0:08:23.16,0:08:24.91,Default,,0,0,0,,也就是说这里另有一盒子东西
Dialogue: 0,0:08:28.40,0:08:30.25,Default,,0,0,0,,比如浮点单元
Dialogue: 0,0:08:32.22,0:08:34.40,Default,,0,0,0,,或者其它类似的东西来执行这些运算
Dialogue: 0,0:08:35.39,0:08:37.68,Default,,0,0,0,,如果你需要支持更多的基本运算
Dialogue: 0,0:08:37.71,0:08:39.02,Default,,0,0,0,,你就实现更多的运算符执行器
Dialogue: 0,0:08:39.05,0:08:40.48,Default,,0,0,0,,但它们和求值器都是分离的
Dialogue: 0,0:08:42.08,0:08:43.77,Default,,0,0,0,,求值器最终算出结果
Dialogue: 0,0:08:45.16,0:08:46.76,Default,,0,0,0,,并且把它们告诉打印程序
Dialogue: 0,0:08:50.62,0:08:52.01,Default,,0,0,0,,现在 打印程序的任务就是
Dialogue: 0,0:08:52.01,0:08:54.54,Default,,0,0,0,,从求值器取得这个表结构
Dialogue: 0,0:08:55.39,0:08:56.99,Default,,0,0,0,,再把它们变回字符
Dialogue: 0,0:09:01.85,0:09:04.07,Default,,0,0,0,,然后通过某种界面
Dialogue: 0,0:09:04.28,0:09:05.66,Default,,0,0,0,,展示给用户
Dialogue: 0,0:09:08.05,0:09:11.23,Default,,0,0,0,,那么 今天我们要讨论的是这个求值器
Dialogue: 0,0:09:12.67,0:09:15.20,Default,,0,0,0,,基本运算和Lisp没有什么特别的关系
Dialogue: 0,0:09:15.20,0:09:18.14,Default,,0,0,0,,它们只取决于你怎么实现基本运算
Dialogue: 0,0:09:19.36,0:09:22.18,Default,,0,0,0,,读取器和打印程序实际上很复杂
Dialogue: 0,0:09:22.18,0:09:23.55,Default,,0,0,0,,但是我们不去讨论它们
Dialogue: 0,0:09:24.68,0:09:27.10,Default,,0,0,0,,从字符构建表的过程中
Dialogue: 0,0:09:27.10,0:09:28.92,Default,,0,0,0,,它们需要处理很多细节
Dialogue: 0,0:09:29.90,0:09:31.18,Default,,0,0,0,,说来话长
Dialogue: 0,0:09:31.18,0:09:32.32,Default,,0,0,0,,我们就不讨论它了
Dialogue: 0,0:09:32.49,0:09:33.69,Default,,0,0,0,,关于表结构内存
Dialogue: 0,0:09:34.36,0:09:35.63,Default,,0,0,0,,我们下次再来讨论
Dialogue: 0,0:09:36.93,0:09:39.72,Default,,0,0,0,,那么去除了读取和打印的细节
Dialogue: 0,0:09:40.12,0:09:41.71,Default,,0,0,0,,关于这个求值器
Dialogue: 0,0:09:41.72,0:09:43.05,Default,,0,0,0,,所剩下的唯一谜团
Dialogue: 0,0:09:43.25,0:09:45.85,Default,,0,0,0,,几乎就只有怎么在传统内存上构建表结构了
Dialogue: 0,0:09:46.65,0:09:48.20,Default,,0,0,0,,不过我们把那也放到下次来讨论
Dialogue: 0,0:09:50.58,0:09:51.04,Default,,0,0,0,,好
Dialogue: 0,0:09:53.34,0:09:56.11,Default,,0,0,0,,那么 我们先来看看这个求值器
Dialogue: 0,0:09:56.20,0:09:58.32,Default,,0,0,0,,我将要展示的这个求值器
Dialogue: 0,0:09:58.49,0:10:01.12,Default,,0,0,0,,我想 它并没有什么特别的
Dialogue: 0,0:10:01.15,0:10:04.56,Default,,0,0,0,,它只是一台专门运行Lisp的寄存器机器
Dialogue: 0,0:10:04.81,0:10:06.09,Default,,0,0,0,,它有七个寄存器
Dialogue: 0,0:10:07.88,0:10:09.26,Default,,0,0,0,,这是它的七个寄存器
Dialogue: 0,0:10:09.89,0:10:12.38,Default,,0,0,0,,这个寄存器叫EXP
Dialogue: 0,0:10:14.12,0:10:15.53,Default,,0,0,0,,它的任务是存放
Dialogue: 0,0:10:16.36,0:10:18.03,Default,,0,0,0,,将要被求值的表达式
Dialogue: 0,0:10:18.37,0:10:19.80,Default,,0,0,0,,具体来说
Dialogue: 0,0:10:20.38,0:10:21.64,Default,,0,0,0,,它存放的是一个指针
Dialogue: 0,0:10:22.03,0:10:23.55,Default,,0,0,0,,指针指向存放着求值的表达式
Dialogue: 0,0:10:23.56,0:10:25.32,Default,,0,0,0,,的一处表结构内存
Dialogue: 0,0:10:26.55,0:10:27.82,Default,,0,0,0,,还有一个叫做ENV的寄存器
Dialogue: 0,0:10:28.88,0:10:30.28,Default,,0,0,0,,它存放着环境
Dialogue: 0,0:10:31.00,0:10:33.05,Default,,0,0,0,,也就是表达式的求值环境
Dialogue: 0,0:10:34.07,0:10:35.02,Default,,0,0,0,,同样的 这也是一个指针
Dialogue: 0,0:10:35.02,0:10:36.75,Default,,0,0,0,,环境是一种数据结构
Dialogue: 0,0:10:38.24,0:10:40.14,Default,,0,0,0,,这个叫做FUN的寄存器--
Dialogue: 0,0:10:40.75,0:10:42.54,Default,,0,0,0,,当你在应用一个过程时
Dialogue: 0,0:10:42.57,0:10:43.96,Default,,0,0,0,,它会存放这个过程
Dialogue: 0,0:10:44.56,0:10:46.24,Default,,0,0,0,,还有寄存器ARGL
Dialogue: 0,0:10:47.36,0:10:49.34,Default,,0,0,0,,它存放的是已求值的参数
Dialogue: 0,0:10:50.54,0:10:51.60,Default,,0,0,0,,从这里开始你能看到
Dialogue: 0,0:10:51.63,0:10:53.14,Default,,0,0,0,,求值器的基本构造
Dialogue: 0,0:10:53.14,0:10:54.49,Default,,0,0,0,,回忆一下它是怎么工作的
Dialogue: 0,0:10:54.49,0:10:56.62,Default,,0,0,0,,对这一块输入表达式和环境
Dialogue: 0,0:10:57.67,0:10:59.71,Default,,0,0,0,,而这一块接收函数
Dialogue: 0,0:10:59.74,0:11:02.14,Default,,0,0,0,,或者说 过程以及参数
Dialogue: 0,0:11:03.48,0:11:06.30,Default,,0,0,0,,EVAL-APPLY循环使用这些寄存器工作
Dialogue: 0,0:11:07.40,0:11:09.69,Default,,0,0,0,,所以这些是EVAL-APPLY的基本组成部分
Dialogue: 0,0:11:10.20,0:11:10.99,Default,,0,0,0,,还有一些别的东西
Dialogue: 0,0:11:11.00,0:11:11.61,Default,,0,0,0,,比如CONTINUE寄存器
Dialogue: 0,0:11:11.61,0:11:15.34,Default,,0,0,0,,你之前已经见过CONTINUE寄存器
Dialogue: 0,0:11:15.34,0:11:18.04,Default,,0,0,0,,是如何实现递归以及栈操作的
Dialogue: 0,0:11:18.94,0:11:20.68,Default,,0,0,0,,还有个寄存器用来存放
Dialogue: 0,0:11:20.94,0:11:22.52,Default,,0,0,0,,某个求值的结果
Dialogue: 0,0:11:24.14,0:11:24.89,Default,,0,0,0,,然后 除了这些以外
Dialogue: 0,0:11:24.89,0:11:26.43,Default,,0,0,0,,还有一个临时寄存器
Dialogue: 0,0:11:26.70,0:11:27.29,Default,,0,0,0,,它就是UNEV
Dialogue: 0,0:11:27.29,0:11:29.04,Default,,0,0,0,,一般来讲 在求值器中
Dialogue: 0,0:11:29.28,0:11:32.72,Default,,0,0,0,,它是用来存放正在求值的表达式
Dialogue: 0,0:11:32.89,0:11:33.95,Default,,0,0,0,,的临时部分
Dialogue: 0,0:11:33.95,0:11:35.72,Default,,0,0,0,,就是那些尚未求值的部分
Dialogue: 0,0:11:36.97,0:11:39.82,Default,,0,0,0,,那么 这就是我的七寄存器机器
Dialogue: 0,0:11:40.96,0:11:42.98,Default,,0,0,0,,当然 你可能想造一台
Dialogue: 0,0:11:42.98,0:11:44.96,Default,,0,0,0,,有更多寄存器的机器 来取得更好性能
Dialogue: 0,0:11:44.97,0:11:47.05,Default,,0,0,0,,但我们这个只是一台小型机器
Dialogue: 0,0:11:48.48,0:11:49.58,Default,,0,0,0,,那么数据通路呢？
Dialogue: 0,0:11:49.78,0:11:53.66,Default,,0,0,0,,这台机器有很多专为Lisp设计的运算
Dialogue: 0,0:11:55.10,0:11:58.08,Default,,0,0,0,,这里有几条典型的数据通路
Dialogue: 0,0:12:00.12,0:12:01.04,Default,,0,0,0,,其中一条可能是
Dialogue: 0,0:12:01.37,0:12:03.40,Default,,0,0,0,,将EXP寄存器的值
Dialogue: 0,0:12:03.40,0:12:04.80,Default,,0,0,0,,赋给VAL寄存器
Dialogue: 0,0:12:05.71,0:12:08.01,Default,,0,0,0,,用我们之前的数据通路图来说
Dialogue: 0,0:12:08.03,0:12:10.81,Default,,0,0,0,,就是一条箭头上的小按钮
Dialogue: 0,0:12:11.90,0:12:13.13,Default,,0,0,0,,这还有一个更复杂的
Dialogue: 0,0:12:13.69,0:12:14.80,Default,,0,0,0,,它判断
Dialogue: 0,0:12:15.23,0:12:19.58,Default,,0,0,0,,如果EXP寄存器的内容是COND语句
Dialogue: 0,0:12:20.49,0:12:22.72,Default,,0,0,0,,那么这里就会跳转到EV-COND标号处
Dialogue: 0,0:12:23.80,0:12:26.23,Default,,0,0,0,,你可以想象出很多种实现它的方法
Dialogue: 0,0:12:26.23,0:12:28.36,Default,,0,0,0,,你可以把这个判断看作是
Dialogue: 0,0:12:28.36,0:12:29.98,Default,,0,0,0,,一个特殊意图的子过程
Dialogue: 0,0:12:30.60,0:12:33.95,Default,,0,0,0,,而条件被表示成某种数据抽象
Dialogue: 0,0:12:33.96,0:12:36.00,Default,,0,0,0,,你在这个层面上不用考虑它
Dialogue: 0,0:12:36.61,0:12:37.98,Default,,0,0,0,,那么它可以用子过程实现
Dialogue: 0,0:12:37.98,0:12:40.67,Default,,0,0,0,,如果机器通过硬件来判断表达式类型
Dialogue: 0,0:12:40.90,0:12:44.04,Default,,0,0,0,,那么某些特定比特就代表了COND语句
Dialogue: 0,0:12:45.35,0:12:46.41,Default,,0,0,0,,有很多种实现办法
Dialogue: 0,0:12:46.41,0:12:48.48,Default,,0,0,0,,它们都低于我们关注的这一层抽象
Dialogue: 0,0:12:50.19,0:12:51.71,Default,,0,0,0,,然后还有另一种操作
Dialogue: 0,0:12:51.71,0:12:53.24,Default,,0,0,0,,以及其它很多操作
Dialogue: 0,0:12:53.24,0:12:56.65,Default,,0,0,0,,把EXP的第一个子句赋值给EXP
Dialogue: 0,0:12:56.84,0:12:58.89,Default,,0,0,0,,这可能是处理COND语句的一部分
Dialogue: 0,0:12:59.26,0:13:01.80,Default,,0,0,0,,同样 FIRST-SELECTOR这个选择子
Dialogue: 0,0:13:03.07,0:13:04.48,Default,,0,0,0,,我们也不需要关心它的细节
Dialogue: 0,0:13:04.49,0:13:06.46,Default,,0,0,0,,同样可以把那也看成一个子过程
Dialogue: 0,0:13:06.46,0:13:07.90,Default,,0,0,0,,用来进行一些表操作
Dialogue: 0,0:13:08.22,0:13:09.18,Default,,0,0,0,,或者你也可以想象成
Dialogue: 0,0:13:09.18,0:13:10.73,Default,,0,0,0,,一个直接构建在硬件中的东西
Dialogue: 0,0:13:12.17,0:13:13.71,Default,,0,0,0,,我之所以强调
Dialogue: 0,0:13:14.03,0:13:15.22,Default,,0,0,0,,你可以把它想象成硬件直接实现
Dialogue: 0,0:13:15.22,0:13:17.80,Default,,0,0,0,,是因为尽管有很多的运算
Dialogue: 0,0:13:18.36,0:13:19.74,Default,,0,0,0,,但也它们的数量也是固定的
Dialogue: 0,0:13:20.12,0:13:21.80,Default,,0,0,0,,我记不清有多少 大概有150个
Dialogue: 0,0:13:22.37,0:13:25.39,Default,,0,0,0,,所以假设用硬件实现它们是合理的
Dialogue: 0,0:13:26.41,0:13:27.68,Default,,0,0,0,,而这一条更加复杂
Dialogue: 0,0:13:28.27,0:13:29.47,Default,,0,0,0,,你会发现 这条涉及到
Dialogue: 0,0:13:29.47,0:13:31.10,Default,,0,0,0,,查找变量的值
Dialogue: 0,0:13:31.50,0:13:33.28,Default,,0,0,0,,它会查找某条表达式中
Dialogue: 0,0:13:33.45,0:13:36.91,Default,,0,0,0,,某个变量的值
Dialogue: 0,0:13:36.99,0:13:38.52,Default,,0,0,0,,并赋值给VAL寄存器
Dialogue: 0,0:13:39.18,0:13:40.30,Default,,0,0,0,,在本例中 也就是
Dialogue: 0,0:13:40.33,0:13:42.00,Default,,0,0,0,,在某个环境中查找变量
Dialogue: 0,0:13:42.80,0:13:44.68,Default,,0,0,0,,然后这个操作
Dialogue: 0,0:13:45.21,0:13:47.50,Default,,0,0,0,,会搜索整个环境结构
Dialogue: 0,0:13:47.52,0:13:48.97,Default,,0,0,0,,无论环境是如何表示的
Dialogue: 0,0:13:49.37,0:13:50.91,Default,,0,0,0,,并查找该变量
Dialogue: 0,0:13:52.17,0:13:53.95,Default,,0,0,0,,同样 它也不在我们思考的
Dialogue: 0,0:13:53.96,0:13:54.86,Default,,0,0,0,,的抽象层面上
Dialogue: 0,0:13:54.89,0:13:57.30,Default,,0,0,0,,它需要处理的细节是
Dialogue: 0,0:13:57.55,0:13:59.44,Default,,0,0,0,,用来表示环境的数据结构
Dialogue: 0,0:14:00.07,0:14:01.21,Default,,0,0,0,,但是不管怎么说
Dialogue: 0,0:14:01.31,0:14:03.47,Default,,0,0,0,,这就是这台寄存器机器的
Dialogue: 0,0:14:04.11,0:14:06.08,Default,,0,0,0,,有穷数量的固定操作
Dialogue: 0,0:14:08.50,0:14:11.60,Default,,0,0,0,,那么 它的整体结构是什么样子的？
Dialogue: 0,0:14:11.72,0:14:13.23,Default,,0,0,0,,这有几个典型的运算
Dialogue: 0,0:14:14.76,0:14:16.33,Default,,0,0,0,,想一想 我们要做什么
Dialogue: 0,0:14:16.44,0:14:18.40,Default,,0,0,0,,我们需要把元循环求值器
Dialogue: 0,0:14:20.43,0:14:22.76,Default,,0,0,0,,这就是元循环求值器的一部分
Dialogue: 0,0:14:22.76,0:14:26.89,Default,,0,0,0,,这是书中使用抽象代码的版本
Dialogue: 0,0:14:28.22,0:14:31.53,Default,,0,0,0,,它和Gerry教授给你们展示的有些不同
Dialogue: 0,0:14:33.50,0:14:35.10,Default,,0,0,0,,关于求值器
Dialogue: 0,0:14:35.13,0:14:37.87,Default,,0,0,0,,主要需要记住的是
Dialogue: 0,0:14:37.87,0:14:40.96,Default,,0,0,0,,它是某种针对表达式类型的分情况分析
Dialogue: 0,0:14:43.76,0:14:45.90,Default,,0,0,0,,看它是否为自求值的 或被引用的
Dialogue: 0,0:14:45.92,0:14:46.86,Default,,0,0,0,,或是别的什么
Dialogue: 0,0:14:48.56,0:14:50.57,Default,,0,0,0,,而在大部分情况下
Dialogue: 0,0:14:50.86,0:14:52.96,Default,,0,0,0,,它处理的是一个过程应用
Dialogue: 0,0:14:53.55,0:14:55.36,Default,,0,0,0,,那么里面有一些技巧性的递归过程
Dialogue: 0,0:14:55.75,0:14:59.36,Default,,0,0,0,,首先 EVAL要调用它自己
Dialogue: 0,0:14:59.79,0:15:01.45,Default,,0,0,0,,来求值运算符以及
Dialogue: 0,0:15:02.14,0:15:04.04,Default,,0,0,0,,所有的运算对象
Dialogue: 0,0:15:05.88,0:15:07.40,Default,,0,0,0,,因此这些标红线的地方
Dialogue: 0,0:15:07.63,0:15:09.28,Default,,0,0,0,,就是某种在语法树上的递归
Dialogue: 0,0:15:10.94,0:15:12.27,Default,,0,0,0,,这是很简单的递归
Dialogue: 0,0:15:12.27,0:15:14.44,Default,,0,0,0,,只是EVAL在递归地遍历语法树
Dialogue: 0,0:15:14.75,0:15:15.53,Default,,0,0,0,,然后在求值器中
Dialogue: 0,0:15:15.53,0:15:16.46,Default,,0,0,0,,有一个复杂的递归
Dialogue: 0,0:15:16.49,0:15:17.92,Default,,0,0,0,,由绿线到红线的递归
Dialogue: 0,0:15:18.00,0:15:19.66,Default,,0,0,0,,由EVAL调用APPLY
Dialogue: 0,0:15:22.47,0:15:26.45,Default,,0,0,0,,也就是把过程调用
Dialogue: 0,0:15:26.45,0:15:28.72,Default,,0,0,0,,归约为了 将过程应用在
Dialogue: 0,0:15:28.94,0:15:29.93,Default,,0,0,0,,实参表上
Dialogue: 0,0:15:30.37,0:15:31.76,Default,,0,0,0,,然后请看APPLY
Dialogue: 0,0:15:34.77,0:15:36.67,Default,,0,0,0,,APPLY需要过程PROC和参数ARGS
Dialogue: 0,0:15:37.65,0:15:39.45,Default,,0,0,0,,一般情况下
Dialogue: 0,0:15:39.48,0:15:40.81,Default,,0,0,0,,PROC都是一个复合过程
Dialogue: 0,0:15:41.05,0:15:42.19,Default,,0,0,0,,随着APPLY不断被调用
Dialogue: 0,0:15:42.25,0:15:43.15,Default,,0,0,0,,绿线处会调用红线处
Dialogue: 0,0:15:43.34,0:15:46.44,Default,,0,0,0,,APPLY被调用并再次调用EVAL
Dialogue: 0,0:15:48.17,0:15:49.79,Default,,0,0,0,,EVAL会求值过程体
Dialogue: 0,0:15:50.24,0:15:52.59,Default,,0,0,0,,基于一个扩展了的环境
Dialogue: 0,0:15:53.69,0:15:55.28,Default,,0,0,0,,这个环境通过将过程的形式参数
Dialogue: 0,0:15:55.48,0:15:56.92,Default,,0,0,0,,与实际参数绑定起来而得
Dialogue: 0,0:15:59.62,0:16:00.62,Default,,0,0,0,,而对于最基本的情况
Dialogue: 0,0:16:00.64,0:16:02.52,Default,,0,0,0,,它会调用PRIMITIVE-APPLY过程
Dialogue: 0,0:16:02.73,0:16:04.70,Default,,0,0,0,,而那又不是求值器的工作了
Dialogue: 0,0:16:05.98,0:16:07.47,Default,,0,0,0,,那么像这样从红到绿
Dialogue: 0,0:16:07.47,0:16:08.40,Default,,0,0,0,,又到红又到绿
Dialogue: 0,0:16:09.79,0:16:12.72,Default,,0,0,0,,这就是EVAL-APPLY循环
Dialogue: 0,0:16:14.06,0:16:15.74,Default,,0,0,0,,这就是我们在求值器中
Dialogue: 0,0:16:16.19,0:16:17.72,Default,,0,0,0,,想要看到的东西
Dialogue: 0,0:16:19.69,0:16:21.07,Default,,0,0,0,,这样 你不会惊异于
Dialogue: 0,0:16:21.07,0:16:23.52,Default,,0,0,0,,这个求值器的两大部分
Dialogue: 0,0:16:25.34,0:16:27.04,Default,,0,0,0,,对应于EVAL-APPLY
Dialogue: 0,0:16:27.47,0:16:29.44,Default,,0,0,0,,一个部分叫EVAL-DISPATCH
Dialogue: 0,0:16:29.60,0:16:31.20,Default,,0,0,0,,另一部分叫做APPLY-DISPATCH
Dialogue: 0,0:16:32.00,0:16:34.09,Default,,0,0,0,,在我们关注代码细节之前
Dialogue: 0,0:16:34.20,0:16:35.76,Default,,0,0,0,,理解它们的方法就是
Dialogue: 0,0:16:36.09,0:16:39.02,Default,,0,0,0,,假设这些求值器的各个部分
Dialogue: 0,0:16:39.02,0:16:40.97,Default,,0,0,0,,和这个世界中其它的部分有一些约定
Dialogue: 0,0:16:41.87,0:16:43.18,Default,,0,0,0,,在进入这些肮脏的细节前
Dialogue: 0,0:16:43.20,0:16:45.50,Default,,0,0,0,,它们在外部做了什么？
Dialogue: 0,0:16:45.78,0:16:49.32,Default,,0,0,0,,针对EVAL-DISPATCH的约定
Dialogue: 0,0:16:50.01,0:16:51.40,Default,,0,0,0,,还记得吗 它对应的是EVAL
Dialogue: 0,0:16:51.55,0:16:54.10,Default,,0,0,0,,它要在环境中求值一个表达式
Dialogue: 0,0:16:54.10,0:16:55.88,Default,,0,0,0,,那么 这部分要做的就是
Dialogue: 0,0:16:56.52,0:16:58.68,Default,,0,0,0,,EVAL-DISPATCH会假设当你调用它的时候
Dialogue: 0,0:16:59.68,0:17:01.48,Default,,0,0,0,,你想要求值的表达式
Dialogue: 0,0:17:01.48,0:17:02.52,Default,,0,0,0,,就存放在EXP寄存器中
Dialogue: 0,0:17:03.64,0:17:07.39,Default,,0,0,0,,而求值所基于的环境
Dialogue: 0,0:17:07.45,0:17:09.05,Default,,0,0,0,,则存放在ENV环境中
Dialogue: 0,0:17:09.56,0:17:10.67,Default,,0,0,0,,而CONTINUE寄存器用来指示
Dialogue: 0,0:17:10.84,0:17:12.46,Default,,0,0,0,,当求值完成后
Dialogue: 0,0:17:12.52,0:17:13.92,Default,,0,0,0,,机器需要去向何方
Dialogue: 0,0:17:17.28,0:17:19.18,Default,,0,0,0,,EVAL-DISPATCH的约定实际上就是
Dialogue: 0,0:17:19.28,0:17:21.26,Default,,0,0,0,,它会执行实际的求值
Dialogue: 0,0:17:21.40,0:17:22.46,Default,,0,0,0,,并且在求值结束后
Dialogue: 0,0:17:23.28,0:17:25.63,Default,,0,0,0,,它会转到由CONTINUE寄存器指定的位置
Dialogue: 0,0:17:26.61,0:17:29.16,Default,,0,0,0,,求值的结果会存放在VAL寄存器中
Dialogue: 0,0:17:29.82,0:17:30.96,Default,,0,0,0,,需要提醒的是
Dialogue: 0,0:17:30.99,0:17:32.91,Default,,0,0,0,,它对其余的寄存器
Dialogue: 0,0:17:32.96,0:17:34.60,Default,,0,0,0,,不做任何承诺
Dialogue: 0,0:17:35.23,0:17:36.81,Default,,0,0,0,,其它所有的寄存器都可能被修改
Dialogue: 0,0:17:37.49,0:17:40.14,Default,,0,0,0,,那么这是一部分
Dialogue: 0,0:17:41.55,0:17:43.48,Default,,0,0,0,,这些部分一块构成了APPLY-DISPATCH
Dialogue: 0,0:17:43.52,0:17:44.92,Default,,0,0,0,,它们对应了APPLY
Dialogue: 0,0:17:46.09,0:17:48.43,Default,,0,0,0,,用来把一个过程应用在一些参数上
Dialogue: 0,0:17:48.73,0:17:51.43,Default,,0,0,0,,因此它假设ARGL寄存器
Dialogue: 0,0:17:51.68,0:17:53.77,Default,,0,0,0,,存放着求值后的参数列表
Dialogue: 0,0:17:54.54,0:17:55.96,Default,,0,0,0,,FUN寄存器存放着那个过程
Dialogue: 0,0:17:57.22,0:17:58.83,Default,,0,0,0,,它们对应于元循环求值器中的
Dialogue: 0,0:17:58.94,0:18:01.36,Default,,0,0,0,,参数应用部分
Dialogue: 0,0:18:03.97,0:18:06.04,Default,,0,0,0,,在我们的这个求值器中
Dialogue: 0,0:18:06.06,0:18:07.58,Default,,0,0,0,,我们APPLY时采用的约定是
Dialogue: 0,0:18:07.72,0:18:08.97,Default,,0,0,0,,当APPLY完成后--
Dialogue: 0,0:18:09.47,0:18:11.20,Default,,0,0,0,,机器应该跳转到
Dialogue: 0,0:18:11.79,0:18:13.45,Default,,0,0,0,,的下一个地方应该是
Dialogue: 0,0:18:13.55,0:18:15.92,Default,,0,0,0,,APPLY-DISPATCH被调用时的栈顶元素
Dialogue: 0,0:18:17.07,0:18:21.24,Default,,0,0,0,,这只是针对这台机器的约定
Dialogue: 0,0:18:21.84,0:18:23.70,Default,,0,0,0,,现在已经给出了APPLY的所有约定
Dialogue: 0,0:18:23.93,0:18:25.37,Default,,0,0,0,,它会去执行应用
Dialogue: 0,0:18:25.54,0:18:27.85,Default,,0,0,0,,这个应用的结果将会保存在VAL寄存器中
Dialogue: 0,0:18:28.89,0:18:29.95,Default,,0,0,0,,栈会被弹出
Dialogue: 0,0:18:31.12,0:18:31.66,Default,,0,0,0,,同样的
Dialogue: 0,0:18:31.71,0:18:34.03,Default,,0,0,0,,其它所有寄存器的内容都可能被修改
Dialogue: 0,0:18:34.84,0:18:37.82,Default,,0,0,0,,那么 这就是这台机器的基本结构
Dialogue: 0,0:18:38.99,0:18:41.50,Default,,0,0,0,,我们先课间休息一下
Dialogue: 0,0:18:41.52,0:18:42.70,Default,,0,0,0,,然后再来研究一个真实的例子
Dialogue: 0,0:18:43.53,0:19:08.11,Default,,0,0,0,,[音乐]
Dialogue: 0,0:19:08.14,0:19:13.47,Declare,,0,0,0,,{\an2\fad(500,500)}《计算机程序的构造和解释》
Dialogue: 0,0:19:33.10,0:19:35.87,Declare,,0,0,0,,{\an2\fad(500,500)}讲师： 哈罗德·艾伯森教授 及 格兰德·杰·萨斯曼教授
Dialogue: 0,0:19:35.87,0:19:40.38,Declare,,0,0,0,,{\an2\fad(500,500)}《计算机程序的构造和解释》
Dialogue: 0,0:19:40.38,0:19:45.29,Declare,,0,0,0,,{\an2\fad(500,500)}显式控制求值器
Dialogue: 0,0:19:47.85,0:19:49.95,Default,,0,0,0,,现在 我们来研究一下这台寄存器机器
Dialogue: 0,0:19:50.41,0:19:51.77,Default,,0,0,0,,我们一步一步地跟进
Dialogue: 0,0:19:52.27,0:19:56.94,Default,,0,0,0,,具体到每一处细节
Dialogue: 0,0:19:57.07,0:19:58.52,Default,,0,0,0,,这样你就能完全具体地看到
Dialogue: 0,0:19:58.86,0:20:01.24,Default,,0,0,0,,表达式是如何求值的
Dialogue: 0,0:20:03.15,0:20:06.86,Default,,0,0,0,,那么我们从一个非常简单的表达式开始
Dialogue: 0,0:20:07.45,0:20:13.52,Default,,0,0,0,,我们要求值的表达式只有一个1
Dialogue: 0,0:20:18.77,0:20:20.40,Default,,0,0,0,,我们需要一个环境
Dialogue: 0,0:20:20.43,0:20:22.35,Default,,0,0,0,,因此我们假设某处有一个环境
Dialogue: 0,0:20:22.38,0:20:23.39,Default,,0,0,0,,我们把它记作E0
Dialogue: 0,0:20:30.06,0:20:34.56,Default,,0,0,0,,由于我们之后也要用到它
Dialogue: 0,0:20:35.62,0:20:37.04,Default,,0,0,0,,而且显然不需要任何东西
Dialogue: 0,0:20:37.07,0:20:37.93,Default,,0,0,0,,就可以求值1
Dialogue: 0,0:20:38.36,0:20:39.45,Default,,0,0,0,,但是为了方便以后引用
Dialogue: 0,0:20:39.45,0:20:40.94,Default,,0,0,0,,我们假设环境E0中有
Dialogue: 0,0:20:41.44,0:20:43.15,Default,,0,0,0,,X=3
Dialogue: 0,0:20:43.72,0:20:45.37,Default,,0,0,0,,Y=4
Dialogue: 0,0:20:48.27,0:20:48.78,Default,,0,0,0,,好吗？
Dialogue: 0,0:20:49.14,0:20:50.12,Default,,0,0,0,,现在 我们要做的就是
Dialogue: 0,0:20:50.51,0:20:54.59,Default,,0,0,0,,在这个环境中求值表达式1
Dialogue: 0,0:20:55.74,0:20:58.54,Default,,0,0,0,,这样 ENV寄存器就存放了一个指针
Dialogue: 0,0:20:59.65,0:21:01.04,Default,,0,0,0,,指向这个环境E0
Dialogue: 0,0:21:03.31,0:21:05.65,Default,,0,0,0,,那么我们来看它是怎么进行的
Dialogue: 0,0:21:05.65,0:21:07.26,Default,,0,0,0,,我要步步跟进代码
Dialogue: 0,0:21:08.26,0:21:10.00,Default,,0,0,0,,这样的话 我会充当控制器
Dialogue: 0,0:21:10.04,0:21:10.80,Default,,0,0,0,,现在我需要的是--
Dialogue: 0,0:21:11.02,0:21:12.49,Default,,0,0,0,,由于这台机器已经变得相当复杂
Dialogue: 0,0:21:12.98,0:21:16.83,Default,,0,0,0,,我需要一个小小的执行单元
Dialogue: 0,0:21:16.83,0:21:18.16,Default,,0,0,0,,那么请上我们的执行单元
Dialogue: 0,0:21:22.62,0:21:23.12,Default,,0,0,0,,好的
Dialogue: 0,0:21:28.59,0:21:29.96,Default,,0,0,0,,好 现在我们要开始了
Dialogue: 0,0:21:30.53,0:21:32.48,Default,,0,0,0,,我们要从EVAL-DISPATCH启动机器
Dialogue: 0,0:21:33.26,0:21:34.62,Default,,0,0,0,,这是整个过程的开始
Dialogue: 0,0:21:35.87,0:21:38.75,Default,,0,0,0,,EVAL-DISPATCH会查看表达式并进行分派
Dialogue: 0,0:21:39.32,0:21:40.06,Default,,0,0,0,,就像EVAL
Dialogue: 0,0:21:40.87,0:21:42.00,Default,,0,0,0,,先从第一句看起
Dialogue: 0,0:21:42.04,0:21:47.95,Default,,0,0,0,,先判断表达式是不是自求值的
Dialogue: 0,0:21:47.95,0:21:49.96,Default,,0,0,0,,SELF-EVALUATING?是我们放入机器的
Dialogue: 0,0:21:49.96,0:21:51.10,Default,,0,0,0,,一个抽象过程
Dialogue: 0,0:21:52.22,0:21:53.51,Default,,0,0,0,,它对于数字1来说为真
Dialogue: 0,0:21:53.64,0:21:55.52,Default,,0,0,0,,因此跳转的目的是EV-SELF-EVAL
Dialogue: 0,0:21:56.77,0:21:58.20,Default,,0,0,0,,那么我作为控制器
Dialogue: 0,0:21:58.22,0:21:59.55,Default,,0,0,0,,会去查看EV-SELF-EVAL
Dialogue: 0,0:22:00.06,0:22:01.07,Default,,0,0,0,,所以我们要跳到那里
Dialogue: 0,0:22:02.60,0:22:04.76,Default,,0,0,0,,EV-SELF-EAVL的代码是--
Dialogue: 0,0:22:06.54,0:22:09.90,Default,,0,0,0,,把EXP寄存器的值赋值给VAL寄存器
Dialogue: 0,0:22:15.24,0:22:16.51,Default,,0,0,0,,我遇到一个BUG
Dialogue: 0,0:22:17.93,0:22:20.59,Default,,0,0,0,,因为我初始化机器的时候没有做一件事情
Dialogue: 0,0:22:21.62,0:22:22.89,Default,,0,0,0,,也就是指定当它执行完毕后
Dialogue: 0,0:22:22.91,0:22:24.19,Default,,0,0,0,,应该做什么
Dialogue: 0,0:22:24.65,0:22:26.83,Default,,0,0,0,,所以在启动机器的时候
Dialogue: 0,0:22:27.37,0:22:29.85,Default,,0,0,0,,应该将CONTINUE寄存器设置为DONE
Dialogue: 0,0:22:31.18,0:22:33.26,Default,,0,0,0,,所以我们给VAL赋值
Dialogue: 0,0:22:33.37,0:22:35.56,Default,,0,0,0,,然后执行(GOTO (FETCH CONTINUE))
Dialogue: 0,0:22:35.63,0:22:36.56,Default,,0,0,0,,并且修改--
Dialogue: 0,0:22:38.09,0:22:38.60,Default,,0,0,0,,好
Dialogue: 0,0:22:40.00,0:22:41.16,Default,,0,0,0,,好 我们来看一个更复杂的
Dialogue: 0,0:22:42.16,0:22:43.45,Default,,0,0,0,,我们先重置机器
Dialogue: 0,0:22:44.86,0:22:50.88,Default,,0,0,0,,然后把X放入EXP寄存器中
Dialogue: 0,0:22:56.71,0:22:58.20,Default,,0,0,0,,重新从EVAL-DISPATCH开始
Dialogue: 0,0:22:59.61,0:23:01.69,Default,,0,0,0,,先检查它是自求值的么？
Dialogue: 0,0:23:01.69,0:23:02.03,Default,,0,0,0,,不是
Dialogue: 0,0:23:02.65,0:23:03.61,Default,,0,0,0,,它是变量吗
Dialogue: 0,0:23:04.63,0:23:05.02,Default,,0,0,0,,是的
Dialogue: 0,0:23:05.56,0:23:07.07,Default,,0,0,0,,我们跳转到EV-VARIABLE
Dialogue: 0,0:23:08.38,0:23:10.97,Default,,0,0,0,,它说：查找EXP寄存器中变量的值
Dialogue: 0,0:23:12.13,0:23:15.69,Default,,0,0,0,,并把它赋值给VAL寄存器
Dialogue: 0,0:23:21.23,0:23:22.91,Default,,0,0,0,,(GOTO (FETCH CONTINUE))
Dialogue: 0,0:23:23.96,0:23:24.48,Default,,0,0,0,,Sussman教授：DONE
Dialogue: 0,0:23:27.61,0:23:28.09,Default,,0,0,0,,Abelson教授：好
Dialogue: 0,0:23:29.31,0:23:30.76,Default,,0,0,0,,这些都是最基本的理念
Dialogue: 0,0:23:31.33,0:23:32.65,Default,,0,0,0,,这是这台机器上的简单运算
Dialogue: 0,0:23:32.68,0:23:35.07,Default,,0,0,0,,现在 我们来做些有意义的事情
Dialogue: 0,0:23:36.07,0:23:38.64,Default,,0,0,0,,我们看这条表达式
Dialogue: 0,0:23:43.58,0:23:47.93,Default,,0,0,0,,(+ X Y)
Dialogue: 0,0:23:49.69,0:23:51.28,Default,,0,0,0,,现在我们会看到
Dialogue: 0,0:23:52.41,0:23:54.01,Default,,0,0,0,,如何展开这些表达式树
Dialogue: 0,0:23:57.13,0:23:58.68,Default,,0,0,0,,我们再次从EVAL-DISPATCH开始
Dialogue: 0,0:24:04.61,0:24:05.80,Default,,0,0,0,,是自求值的吗？
Dialogue: 0,0:24:05.95,0:24:06.52,Default,,0,0,0,,不是
Dialogue: 0,0:24:06.70,0:24:07.71,Default,,0,0,0,,是变量吗？不是
Dialogue: 0,0:24:07.82,0:24:08.99,Default,,0,0,0,,它也不是我在这里
Dialogue: 0,0:24:08.99,0:24:10.12,Default,,0,0,0,,没有列出的特殊形式
Dialogue: 0,0:24:10.27,0:24:12.48,Default,,0,0,0,,比如引用、LAMBDA、SET! 等等
Dialogue: 0,0:24:12.48,0:24:13.08,Default,,0,0,0,,它都不是
Dialogue: 0,0:24:13.26,0:24:14.73,Default,,0,0,0,,它是一个过程应用
Dialogue: 0,0:24:15.88,0:24:17.42,Default,,0,0,0,,所以我们要跳转到EV-APPLICATION
Dialogue: 0,0:24:19.97,0:24:24.94,Default,,0,0,0,,回忆一下EV-APPLICATION要做什么
Dialogue: 0,0:24:25.58,0:24:28.19,Default,,0,0,0,,它先要求值运算符
Dialogue: 0,0:24:28.27,0:24:31.40,Default,,0,0,0,,然后求值运算对象
Dialogue: 0,0:24:32.36,0:24:34.30,Default,,0,0,0,,然后再进行应用
Dialogue: 0,0:24:35.06,0:24:36.09,Default,,0,0,0,,所以在我们开始之前
Dialogue: 0,0:24:36.94,0:24:37.88,Default,,0,0,0,,由于我们是严格按照代码来执行的
Dialogue: 0,0:24:37.88,0:24:38.88,Default,,0,0,0,,我们最好记住
Dialogue: 0,0:24:39.07,0:24:40.54,Default,,0,0,0,,在这个环境中的某处
Dialogue: 0,0:24:40.57,0:24:42.36,Default,,0,0,0,,连接到了另一个环境
Dialogue: 0,0:24:43.98,0:24:44.94,Default,,0,0,0,,其中符号'+
Dialogue: 0,0:24:45.72,0:24:49.16,Default,,0,0,0,,跟基本的加法过程绑定在了一起
Dialogue: 0,0:24:51.63,0:24:54.03,Default,,0,0,0,,这样 求值+时就不会导致“变量未定义”
Dialogue: 0,0:24:55.34,0:24:56.84,Default,,0,0,0,,现在我们来到了EV-APPLICATION
Dialogue: 0,0:24:59.85,0:25:04.32,Default,,0,0,0,,把EXP寄存器对应的运算对象
Dialogue: 0,0:25:04.92,0:25:06.89,Default,,0,0,0,,赋值给UNEV寄存器
Dialogue: 0,0:25:07.61,0:25:08.83,Default,,0,0,0,,这些是运算对象
Dialogue: 0,0:25:09.23,0:25:11.66,Default,,0,0,0,,UNEV这个临时寄存器
Dialogue: 0,0:25:11.68,0:25:12.59,Default,,0,0,0,,就是用来暂存它们的
Dialogue: 0,0:25:13.22,0:25:13.86,Default,,0,0,0,,Sussman教授：我正在赋值
Dialogue: 0,0:25:14.28,0:25:16.62,Default,,0,0,0,,Abelson教授：把运算符赋值给EXP寄存器
Dialogue: 0,0:25:18.07,0:25:20.09,Default,,0,0,0,,注意 现在我们已经修改了EXP中的表达式
Dialogue: 0,0:25:21.84,0:25:23.61,Default,,0,0,0,,但是我们需要的部分在UNEV中
Dialogue: 0,0:25:25.82,0:25:26.81,Default,,0,0,0,,现在 我们要准备好
Dialogue: 0,0:25:26.81,0:25:28.59,Default,,0,0,0,,去递归地求值运算符
Dialogue: 0,0:25:28.75,0:25:31.69,Default,,0,0,0,,把CONTINUE寄存器保存在栈上
Dialogue: 0,0:25:34.86,0:25:36.09,Default,,0,0,0,,保存ENV
Dialogue: 0,0:25:40.48,0:25:41.69,Default,,0,0,0,,保存UNEV
Dialogue: 0,0:25:49.53,0:25:54.64,Default,,0,0,0,,把标号EVAL-ARGS赋值给CONTINUE寄存器
Dialogue: 0,0:26:01.40,0:26:01.95,Default,,0,0,0,,我们做了什么
Dialogue: 0,0:26:01.95,0:26:04.38,Default,,0,0,0,,我们为递归调用做了必要的准备
Dialogue: 0,0:26:04.38,0:26:05.88,Default,,0,0,0,,我们要开始执行EVAL-DISPATCH
Dialogue: 0,0:26:06.28,0:26:08.83,Default,,0,0,0,,我们为递归调用EVAL-DISPATCH做好了准备
Dialogue: 0,0:26:10.23,0:26:10.86,Default,,0,0,0,,我们做了哪些事情
Dialogue: 0,0:26:11.02,0:26:13.64,Default,,0,0,0,,我们把之后要用到的东西
Dialogue: 0,0:26:14.48,0:26:15.98,Default,,0,0,0,,也就是UNEV中的运算对象
Dialogue: 0,0:26:16.36,0:26:18.99,Default,,0,0,0,,以及我们最终求值运算对象时
Dialogue: 0,0:26:19.16,0:26:20.72,Default,,0,0,0,,会用到的环境
Dialogue: 0,0:26:22.28,0:26:23.93,Default,,0,0,0,,以及我们最终想要去的位置
Dialogue: 0,0:26:23.95,0:26:25.07,Default,,0,0,0,,本例中 也就是DONE
Dialogue: 0,0:26:25.34,0:26:26.70,Default,,0,0,0,,我们把它们保存在栈上
Dialogue: 0,0:26:27.10,0:26:28.41,Default,,0,0,0,,我们之所以把它们保存在栈上
Dialogue: 0,0:26:28.43,0:26:30.67,Default,,0,0,0,,是因为EVAL-DISPATCH并不会保证
Dialogue: 0,0:26:30.94,0:26:32.54,Default,,0,0,0,,不会去修改这些寄存器
Dialogue: 0,0:26:33.55,0:26:35.02,Default,,0,0,0,,那么所有这些东西都存在了栈上
Dialogue: 0,0:26:35.02,0:26:36.91,Default,,0,0,0,,现在我们满足了EVAL-DISPATCH的约定
Dialogue: 0,0:26:37.38,0:26:38.75,Default,,0,0,0,,这是一条新的表达式
Dialogue: 0,0:26:38.78,0:26:40.04,Default,,0,0,0,,也就是+运算符
Dialogue: 0,0:26:41.07,0:26:41.95,Default,,0,0,0,,以及一个新的环境
Dialogue: 0,0:26:41.98,0:26:43.60,Default,,0,0,0,,尽管在本例中是同一个环境
Dialogue: 0,0:26:44.25,0:26:45.87,Default,,0,0,0,,以及在完成后要返回的位置
Dialogue: 0,0:26:45.87,0:26:46.91,Default,,0,0,0,,也就是EVAL-ARGS
Dialogue: 0,0:26:47.60,0:26:48.13,Default,,0,0,0,,这样就满足了
Dialogue: 0,0:26:48.13,0:26:49.68,Default,,0,0,0,,现在我们来执行EVAL-DISPATCH
Dialogue: 0,0:26:50.89,0:26:52.36,Default,,0,0,0,,我们回到了EVAL-DISPATCH
Dialogue: 0,0:26:53.05,0:26:54.40,Default,,0,0,0,,它不是自求值的
Dialogue: 0,0:26:54.44,0:26:55.47,Default,,0,0,0,,但它是一个变量
Dialogue: 0,0:26:56.32,0:26:58.06,Default,,0,0,0,,因此我们最好跳转到EV-VARIABLE
Dialogue: 0,0:26:59.79,0:27:02.65,Default,,0,0,0,,EV-VARIABLE首先要给VAL赋值
Dialogue: 0,0:27:02.70,0:27:06.33,Default,,0,0,0,,查找表达式中变量的值
Dialogue: 0,0:27:08.49,0:27:10.75,Default,,0,0,0,,那么VAL寄存器中应该是基本的加法运算
Dialogue: 0,0:27:13.37,0:27:15.16,Default,,0,0,0,,然后(GOTO (FETCH CONTINUE))
Dialogue: 0,0:27:15.23,0:27:16.11,Default,,0,0,0,,Sussman教授：它是EVAL-ARGS
Dialogue: 0,0:27:16.20,0:27:18.73,Default,,0,0,0,,Abelson教授：现在它是EVAL-ARGS而不是DONE了
Dialogue: 0,0:27:19.42,0:27:21.26,Default,,0,0,0,,然后我们来到EVAL-ARGS
Dialogue: 0,0:27:22.16,0:27:23.02,Default,,0,0,0,,看看它要做什么
Dialogue: 0,0:27:23.07,0:27:24.84,Default,,0,0,0,,我们要恢复之前保存的东西
Dialogue: 0,0:27:25.20,0:27:26.57,Default,,0,0,0,,因此调用(RESTORE UNEV)
Dialogue: 0,0:27:29.21,0:27:31.69,Default,,0,0,0,,注意 这里并不是必要的
Dialogue: 0,0:27:31.74,0:27:32.90,Default,,0,0,0,,但通常来说都会有这么一步
Dialogue: 0,0:27:32.90,0:27:35.16,Default,,0,0,0,,它可以是任意的求值过程
Dialogue: 0,0:27:35.43,0:27:36.70,Default,,0,0,0,,恢复ENV寄存器
Dialogue: 0,0:27:47.87,0:27:52.04,Default,,0,0,0,,然后把(FETCH VAL)赋值给FUN
Dialogue: 0,0:27:59.95,0:28:02.81,Default,,0,0,0,,现在我们要开始求值参数了
Dialogue: 0,0:28:04.34,0:28:06.48,Default,,0,0,0,,首先 我们最好把FUN寄存器保存起来
Dialogue: 0,0:28:07.42,0:28:10.62,Default,,0,0,0,,因为求值过程中可能发生任何事情
Dialogue: 0,0:28:15.33,0:28:16.88,Default,,0,0,0,,我们初始化参数列表
Dialogue: 0,0:28:16.91,0:28:19.29,Default,,0,0,0,,给ARGL赋值一个空的参数列表
Dialogue: 0,0:28:20.88,0:28:22.17,Default,,0,0,0,,然后跳转到EVAL-ARG-LOOP
Dialogue: 0,0:28:24.86,0:28:26.27,Default,,0,0,0,,在EVAL-ARG-LOOP中
Dialogue: 0,0:28:27.77,0:28:31.53,Default,,0,0,0,,我们想要去一条一条的求值
Dialogue: 0,0:28:31.61,0:28:33.37,Default,,0,0,0,,UNEV中的表达式
Dialogue: 0,0:28:33.54,0:28:35.68,Default,,0,0,0,,然后把它们从UNEV中的待求值表
Dialogue: 0,0:28:35.90,0:28:37.26,Default,,0,0,0,,移动到ARGL中的已求值表中
Dialogue: 0,0:28:37.84,0:28:39.18,Default,,0,0,0,,然后我们保存ARGL
Dialogue: 0,0:28:43.95,0:28:47.26,Default,,0,0,0,,然后我们把UNEV中的第一个运算对象
Dialogue: 0,0:28:47.37,0:28:48.38,Default,,0,0,0,,赋值给EXP
Dialogue: 0,0:28:53.77,0:28:55.89,Default,,0,0,0,,然后我们检查它是否为最后一个运算对象
Dialogue: 0,0:28:55.89,0:28:56.91,Default,,0,0,0,,在这里 它还不是
Dialogue: 0,0:28:58.99,0:29:01.55,Default,,0,0,0,,然后我们保存环境
Dialogue: 0,0:29:08.00,0:29:10.06,Default,,0,0,0,,我们之所以保存UNEV
Dialogue: 0,0:29:11.61,0:29:13.50,Default,,0,0,0,,是因为稍后我们可能会需要它们
Dialogue: 0,0:29:13.50,0:29:14.40,Default,,0,0,0,,我们需要环境
Dialogue: 0,0:29:14.44,0:29:15.64,Default,,0,0,0,,来进行一些求值
Dialogue: 0,0:29:15.80,0:29:16.60,Default,,0,0,0,,我们需要UNEV寄存器来指示
Dialogue: 0,0:29:16.62,0:29:19.20,Default,,0,0,0,,其余的待求值参数
Dialogue: 0,0:29:20.34,0:29:21.55,Default,,0,0,0,,我们要把CONTINUE寄存器赋值为
Dialogue: 0,0:29:21.56,0:29:24.44,Default,,0,0,0,,ACCUMULATE-ARG这个标号
Dialogue: 0,0:29:31.13,0:29:34.01,Default,,0,0,0,,现在 我们已经准备好再次调用EVAL-DISPATCH了
Dialogue: 0,0:29:37.07,0:29:38.54,Default,,0,0,0,,现在让我把这个短路掉
Dialogue: 0,0:29:39.12,0:29:41.09,Default,,0,0,0,,这里我们不跟进EVAL-DISPATCH的细节
Dialogue: 0,0:29:41.09,0:29:42.64,Default,,0,0,0,,EVAL-DISPATCH的约定说：
Dialogue: 0,0:29:42.97,0:29:45.00,Default,,0,0,0,,我的调用完成后
Dialogue: 0,0:29:45.13,0:29:45.96,Default,,0,0,0,,整个机器的状态会变为
Dialogue: 0,0:29:46.03,0:29:48.20,Default,,0,0,0,,也就是在ENV环境中求值EXP表达式
Dialogue: 0,0:29:48.24,0:29:50.27,Default,,0,0,0,,求值结果会保存在VAL寄存器中
Dialogue: 0,0:29:50.27,0:29:51.07,Default,,0,0,0,,结束状态就是这样
Dialogue: 0,0:29:51.32,0:29:52.62,Default,,0,0,0,,那么我们把这些全都省略掉
Dialogue: 0,0:29:54.43,0:29:56.36,Default,,0,0,0,,最后VAL的内容是3
Dialogue: 0,0:29:58.01,0:29:59.76,Default,,0,0,0,,并且当我们从EVAL-DISPATCH返回的时候
Dialogue: 0,0:29:59.76,0:30:01.76,Default,,0,0,0,,我们会返回到ACCUMULAT-ARG这里
Dialogue: 0,0:30:02.30,0:30:03.23,Default,,0,0,0,,Sussman教授：跳转到ACCUMULATE-ARG
Dialogue: 0,0:30:06.22,0:30:08.20,Default,,0,0,0,,Abelson教授：VAL寄存器里是3 对吧？
Dialogue: 0,0:30:08.72,0:30:10.59,Default,,0,0,0,,我们跳过了求值的细节
Dialogue: 0,0:30:10.65,0:30:11.32,Default,,0,0,0,,现在我们要做什么？
Dialogue: 0,0:30:11.32,0:30:13.68,Default,,0,0,0,,我们返回继续看剩下的参数
Dialogue: 0,0:30:13.68,0:30:14.83,Default,,0,0,0,,我们恢复UNEV
Dialogue: 0,0:30:17.51,0:30:19.00,Default,,0,0,0,,恢复ENV
Dialogue: 0,0:30:25.79,0:30:27.05,Default,,0,0,0,,然后恢复ARGL
Dialogue: 0,0:30:28.65,0:30:29.17,Default,,0,0,0,,这件事
Dialogue: 0,0:30:30.06,0:30:31.45,Default,,0,0,0,,Sussman教授：糟糕 奇偶错误
Dialogue: 0,0:30:33.76,0:30:34.83,Default,,0,0,0,,Abelson教授：恢复ARGL
Dialogue: 0,0:30:45.57,0:30:49.76,Default,,0,0,0,,然后 我们把VAL寄存器和ARGL给CONS起来
Dialogue: 0,0:30:50.65,0:30:52.64,Default,,0,0,0,,然后赋值给ARGL寄存器
Dialogue: 0,0:30:59.36,0:31:02.96,Default,,0,0,0,,我们把UNEV中剩余的运算对象
Dialogue: 0,0:31:03.34,0:31:04.52,Default,,0,0,0,,赋值给UNEV
Dialogue: 0,0:31:08.91,0:31:10.76,Default,,0,0,0,,然后我们返回到EVAL-ARG-LOOP
Dialogue: 0,0:31:11.51,0:31:12.28,Default,,0,0,0,,Sussman教授：EVAL-ARG-LOOP
Dialogue: 0,0:31:12.28,0:31:12.86,Default,,0,0,0,,Abelson教授：好
Dialogue: 0,0:31:15.88,0:31:17.08,Default,,0,0,0,,现在我们处理下一个参数
Dialogue: 0,0:31:17.58,0:31:19.31,Default,,0,0,0,,所以首先我们要保存ARGL
Dialogue: 0,0:31:25.40,0:31:28.27,Default,,0,0,0,,然后我们把UNEV中的第一个运算对象
Dialogue: 0,0:31:29.15,0:31:30.81,Default,,0,0,0,,赋给EXP
Dialogue: 0,0:31:34.72,0:31:37.02,Default,,0,0,0,,然后我们检查它是否为最后一个运算对象
Dialogue: 0,0:31:37.02,0:31:38.00,Default,,0,0,0,,这里它是最后一个
Dialogue: 0,0:31:39.08,0:31:40.27,Default,,0,0,0,,所以我们跳到一个特殊的地方
Dialogue: 0,0:31:40.28,0:31:42.06,Default,,0,0,0,,来求值最后一个参数
Dialogue: 0,0:31:43.37,0:31:45.07,Default,,0,0,0,,因为请注意 在求值这个参数之后
Dialogue: 0,0:31:45.10,0:31:46.62,Default,,0,0,0,,我们就不再需要这个环境了
Dialogue: 0,0:31:47.64,0:31:48.78,Default,,0,0,0,,这就是区别
Dialogue: 0,0:31:50.25,0:31:51.85,Default,,0,0,0,,在这里 在EVAL-LAST-ARG这里
Dialogue: 0,0:31:52.24,0:31:54.92,Default,,0,0,0,,CONTINUE被赋值为了ACCUMULATE-LAST-ARG
Dialogue: 0,0:32:04.27,0:32:06.90,Default,,0,0,0,,现在我们再次为EVAL-DISPATCH做准备
Dialogue: 0,0:32:06.90,0:32:08.51,Default,,0,0,0,,我们有一个完成时要跳转的目的地
Dialogue: 0,0:32:08.62,0:32:09.84,Default,,0,0,0,,我们有一条表达式
Dialogue: 0,0:32:09.84,0:32:10.80,Default,,0,0,0,,还有一个环境
Dialogue: 0,0:32:11.33,0:32:13.64,Default,,0,0,0,,好 那么我们略过对EVAL-DISPATCH的调用
Dialogue: 0,0:32:14.37,0:32:16.41,Default,,0,0,0,,现在情况是这里有一个Y
Dialogue: 0,0:32:16.70,0:32:18.56,Default,,0,0,0,,在这个环境中 它的值是4
Dialogue: 0,0:32:18.60,0:32:20.09,Default,,0,0,0,,所以最终VAL寄存器将会是4
Dialogue: 0,0:32:21.06,0:32:22.86,Default,,0,0,0,,然后我们就要以ACCUMULATE-LAST-ARG结束了
Dialogue: 0,0:32:25.45,0:32:26.91,Default,,0,0,0,,因此 在ACCUMULATE-LAST-ARG中
Dialogue: 0,0:32:29.28,0:32:30.52,Default,,0,0,0,,我们恢复ARGL寄存器
Dialogue: 0,0:32:37.69,0:32:42.76,Default,,0,0,0,,我们把ARGL赋值为
Dialogue: 0,0:32:43.60,0:32:45.83,Default,,0,0,0,,将一个新值CONS在它上面的结果
Dialogue: 0,0:32:45.93,0:32:47.39,Default,,0,0,0,,所以我们在它的旧值前CONS一个4
Dialogue: 0,0:32:49.85,0:32:52.52,Default,,0,0,0,,我们恢复FUN寄存器中的内容
Dialogue: 0,0:32:53.77,0:32:54.99,Default,,0,0,0,,需要注意的是 在则个例子中
Dialogue: 0,0:32:55.00,0:32:56.27,Default,,0,0,0,,FUN寄存器还没有被修改过
Dialogue: 0,0:32:56.38,0:32:57.72,Default,,0,0,0,,但是通常来说 它会的
Dialogue: 0,0:32:59.13,0:33:01.50,Default,,0,0,0,,现在 我们将要调用APPLY-DISPATCH
Dialogue: 0,0:33:02.65,0:33:04.40,Default,,0,0,0,,所以我们刚刚步步跟进了EVAL过程
Dialogue: 0,0:33:04.51,0:33:05.85,Default,,0,0,0,,我们求值了运算符
Dialogue: 0,0:33:06.46,0:33:07.98,Default,,0,0,0,,以及实际参数
Dialogue: 0,0:33:07.98,0:33:09.24,Default,,0,0,0,,现在我们要应用它们了
Dialogue: 0,0:33:09.58,0:33:11.37,Default,,0,0,0,,因此 我们来到APPLY-DISPATCH这里
Dialogue: 0,0:33:18.03,0:33:19.29,Default,,0,0,0,,这是APPLY-DISPATCH的代码
Dialogue: 0,0:33:21.05,0:33:22.41,Default,,0,0,0,,我们要检查它是一个基本过程
Dialogue: 0,0:33:22.41,0:33:23.45,Default,,0,0,0,,还是一个复合过程
Dialogue: 0,0:33:23.64,0:33:24.20,Default,,0,0,0,,Sussman教授：基本过程
Dialogue: 0,0:33:24.54,0:33:24.83,Default,,0,0,0,,Abelson教授：好的
Dialogue: 0,0:33:24.89,0:33:26.52,Default,,0,0,0,,这里 它是一个基本过程
Dialogue: 0,0:33:27.45,0:33:28.91,Default,,0,0,0,,因此 我们跳转到PRIMITIVE-APPLY
Dialogue: 0,0:33:29.79,0:33:31.36,Default,,0,0,0,,我们来到PRIMITIVE-APPLY
Dialogue: 0,0:33:33.71,0:33:35.37,Default,,0,0,0,,它说：把VAL赋值为
Dialogue: 0,0:33:35.69,0:33:38.25,Default,,0,0,0,,把基本过程
Dialogue: 0,0:33:38.36,0:33:40.30,Default,,0,0,0,,应用在参数表的结果
Dialogue: 0,0:33:41.31,0:33:42.43,Default,,0,0,0,,Sussman教授：我不知道怎么做加法
Dialogue: 0,0:33:42.54,0:33:43.80,Default,,0,0,0,,我只是一个执行单元
Dialogue: 0,0:33:44.14,0:33:45.35,Default,,0,0,0,,Abelson教授：我也不知道
Dialogue: 0,0:33:45.35,0:33:46.51,Default,,0,0,0,,我只是一个求值器
Dialogue: 0,0:33:47.08,0:33:48.36,Default,,0,0,0,,因此 我们需要一个基本运算执行器
Dialogue: 0,0:33:48.36,0:33:49.72,Default,,0,0,0,,那么 请问基本运算执行器
Dialogue: 0,0:33:49.76,0:33:52.36,Default,,0,0,0,,3+4等于多少？
Dialogue: 0,0:33:52.86,0:33:53.32,Default,,0,0,0,,学生：7
Dialogue: 0,0:33:53.71,0:33:54.65,Default,,0,0,0,,Abelson教授：好 是7
Dialogue: 0,0:33:55.32,0:33:55.99,Default,,0,0,0,,Sussman教授：谢谢
Dialogue: 0,0:33:59.20,0:34:00.60,Default,,0,0,0,,Abelson教授：现在 我们恢复CONTINUE
Dialogue: 0,0:34:11.58,0:34:12.90,Default,,0,0,0,,执行(GOTO (FETCH CONTINUE))
Dialogue: 0,0:34:13.07,0:34:13.47,Default,,0,0,0,,Sussman教授：'DONE
Dialogue: 0,0:34:14.20,0:34:14.67,Default,,0,0,0,,Abelson教授：好
Dialogue: 0,0:34:14.92,0:34:18.41,Default,,0,0,0,,这些是你能看到的最细致的过程了
Dialogue: 0,0:34:18.41,0:34:20.19,Default,,0,0,0,,我们再也不会讲得这么细了
Dialogue: 0,0:34:21.59,0:34:23.92,Default,,0,0,0,,有一件重要的事需要注意
Dialogue: 0,0:34:24.91,0:34:27.55,Default,,0,0,0,,我们刚刚执行了一个递归过程
Dialogue: 0,0:34:29.56,0:34:31.17,Default,,0,0,0,,我们在整个过程中使用了栈
Dialogue: 0,0:34:31.17,0:34:32.75,Default,,0,0,0,,而且求值器是递归的
Dialogue: 0,0:34:33.07,0:34:35.88,Default,,0,0,0,,有很多人以为在求值器中
Dialogue: 0,0:34:36.48,0:34:37.85,Default,,0,0,0,,会用到栈和递归
Dialogue: 0,0:34:37.87,0:34:38.97,Default,,0,0,0,,或许是因为
Dialogue: 0,0:34:39.09,0:34:42.15,Default,,0,0,0,,回去求值像阶乘或者FIB那样的递归过程
Dialogue: 0,0:34:42.15,0:34:42.92,Default,,0,0,0,,这并不正确
Dialogue: 0,0:34:43.67,0:34:44.99,Default,,0,0,0,,注意 我们在这里进行了递归
Dialogue: 0,0:34:45.00,0:34:46.86,Default,,0,0,0,,而仅仅是去求值(+ X Y)
Dialogue: 0,0:34:47.77,0:34:50.65,Default,,0,0,0,,在求值器中需要递归 实际上是因为
Dialogue: 0,0:34:50.96,0:34:52.97,Default,,0,0,0,,是因为求值过程本身
Dialogue: 0,0:34:52.99,0:34:54.06,Default,,0,0,0,,就是递归的
Dialogue: 0,0:34:54.45,0:34:56.17,Default,,0,0,0,,并不是因为你在Lisp中
Dialogue: 0,0:34:56.32,0:34:58.09,Default,,0,0,0,,要求值的那个过程
Dialogue: 0,0:34:58.12,0:34:59.27,Default,,0,0,0,,是一个递归过程
Dialogue: 0,0:34:59.27,0:35:00.52,Default,,0,0,0,,这一点很重要
Dialogue: 0,0:35:00.52,0:35:02.14,Default,,0,0,0,,人们经常在这里被弄糊涂
Dialogue: 0,0:35:03.01,0:35:04.27,Default,,0,0,0,,另一点要注意的是
Dialogue: 0,0:35:04.27,0:35:05.64,Default,,0,0,0,,我们在这里完成之后
Dialogue: 0,0:35:06.28,0:35:07.12,Default,,0,0,0,,真正完成以后
Dialogue: 0,0:35:07.12,0:35:08.49,Default,,0,0,0,,不仅仅是指我们在'DONE这个标号
Dialogue: 0,0:35:09.45,0:35:13.23,Default,,0,0,0,,栈上也没有累积的东西了
Dialogue: 0,0:35:13.60,0:35:15.71,Default,,0,0,0,,对吧？机器又回到了它的初始状态
Dialogue: 0,0:35:17.00,0:35:18.75,Default,,0,0,0,,那就是“完成”的其中一部分意义
Dialogue: 0,0:35:19.71,0:35:21.04,Default,,0,0,0,,换句话说就是
Dialogue: 0,0:35:22.72,0:35:26.04,Default,,0,0,0,,整个求值过程是把
Dialogue: 0,0:35:26.41,0:35:28.32,Default,,0,0,0,,(+ X Y)这条表达式
Dialogue: 0,0:35:30.54,0:35:32.78,Default,,0,0,0,,归约为这里的7
Dialogue: 0,0:35:33.24,0:35:35.45,Default,,0,0,0,,我所指的“归约”有特殊的意义
Dialogue: 0,0:35:36.01,0:35:38.18,Default,,0,0,0,,也就是栈上没剩下任何东西了
Dialogue: 0,0:35:38.18,0:35:40.36,Default,,0,0,0,,机器现在与初始状态相同
Dialogue: 0,0:35:40.92,0:35:42.65,Default,,0,0,0,,只是VAL寄存器里有一些东西
Dialogue: 0,0:35:42.72,0:35:44.52,Default,,0,0,0,,它不是任何问题的子问题
Dialogue: 0,0:35:44.52,0:35:45.63,Default,,0,0,0,,不需要返回到其它地方
Dialogue: 0,0:35:46.12,0:35:46.96,Default,,0,0,0,,好 这节课就讲到这里
Dialogue: 0,0:35:50.16,0:35:50.76,Default,,0,0,0,,有问题吗
Dialogue: 0,0:35:51.08,0:35:54.02,Default,,0,0,0,,学生：关于栈有一个问题
Dialogue: 0,0:35:54.02,0:35:55.82,Default,,0,0,0,,由于数据有可能是递归的
Dialogue: 0,0:35:56.20,0:35:58.75,Default,,0,0,0,,例如 嵌套的表达式
Dialogue: 0,0:35:59.31,0:36:02.08,Default,,0,0,0,,教授：是的 因为你可能遇到嵌套的表达式
Dialogue: 0,0:36:02.08,0:36:04.77,Default,,0,0,0,,但是再说一遍 不要搞混
Dialogue: 0,0:36:04.77,0:36:07.98,Default,,0,0,0,,有时候人们说数据是递归的
Dialogue: 0,0:36:08.00,0:36:10.35,Default,,0,0,0,,他们说的是对于这些表结构的
Dialogue: 0,0:36:11.04,0:36:12.93,Default,,0,0,0,,一些递归运算
Dialogue: 0,0:36:12.93,0:36:13.96,Default,,0,0,0,,那和这没有关系
Dialogue: 0,0:36:13.98,0:36:16.16,Default,,0,0,0,,这只是包含子表达式的表达式而已
Dialogue: 0,0:36:20.04,0:36:23.52,Default,,0,0,0,,学生：为什么ARGL中参数的顺序是反过来的
Dialogue: 0,0:36:23.55,0:36:25.29,Default,,0,0,0,,教授：对 我应该提一嘴这个
Dialogue: 0,0:36:27.26,0:36:29.07,Default,,0,0,0,,之所以在这里把顺序反过来
Dialogue: 0,0:36:32.78,0:36:35.37,Default,,0,0,0,,你首先定义怎么算“逆序”
Dialogue: 0,0:36:36.05,0:36:39.90,Default,,0,0,0,,我记得应该是牛顿
Dialogue: 0,0:36:40.91,0:36:42.41,Default,,0,0,0,,在光学发展的很早期
Dialogue: 0,0:36:42.43,0:36:43.26,Default,,0,0,0,,人们意识到
Dialogue: 0,0:36:43.61,0:36:45.36,Default,,0,0,0,,当你用眼睛通过透镜看东西的时候
Dialogue: 0,0:36:45.50,0:36:46.73,Default,,0,0,0,,图像是上下颠倒的
Dialogue: 0,0:36:46.73,0:36:48.04,Default,,0,0,0,,当时有很多的争论说
Dialogue: 0,0:36:48.04,0:36:50.48,Default,,0,0,0,,为什么不能是你眼睛平时看见的都是上下颠倒的
Dialogue: 0,0:36:51.28,0:36:52.65,Default,,0,0,0,,这实际上是一样的道理
Dialogue: 0,0:36:52.86,0:36:53.90,Default,,0,0,0,,和什么相比反过来了
Dialogue: 0,0:36:54.81,0:36:56.24,Default,,0,0,0,,我们只是需要一个约定
Dialogue: 0,0:36:56.59,0:37:00.35,Default,,0,0,0,,它们作为(4 3)出现的原因是
Dialogue: 0,0:37:00.80,0:37:02.49,Default,,0,0,0,,是因为我们从UNEV中取出东西
Dialogue: 0,0:37:02.52,0:37:04.03,Default,,0,0,0,,并且把它CONS到了ARGL上面
Dialogue: 0,0:37:04.52,0:37:06.68,Default,,0,0,0,,那么你要意识到你已经做了这个约定
Dialogue: 0,0:37:06.86,0:37:09.37,Default,,0,0,0,,你需要意识到这点的地方有
Dialogue: 0,0:37:09.98,0:37:11.23,Default,,0,0,0,,实际上有两个地方
Dialogue: 0,0:37:11.23,0:37:12.91,Default,,0,0,0,,首先是在APPLY-PRIMITIVE-OPERATOR
Dialogue: 0,0:37:12.91,0:37:14.06,Default,,0,0,0,,你要意识到
Dialogue: 0,0:37:15.12,0:37:16.75,Default,,0,0,0,,参数传入基本运算的顺序
Dialogue: 0,0:37:16.78,0:37:18.72,Default,,0,0,0,,是和你的书写顺序相反的
Dialogue: 0,0:37:19.49,0:37:21.00,Default,,0,0,0,,我们之后会在另外一处看到
Dialogue: 0,0:37:21.07,0:37:23.80,Default,,0,0,0,,当你实际绑定绑定函数的形式参数时
Dialogue: 0,0:37:24.01,0:37:25.74,Default,,0,0,0,,你要意识到参数进入的顺序
Dialogue: 0,0:37:25.74,0:37:28.54,Default,,0,0,0,,和你要绑定这些变量时的顺序相反
Dialogue: 0,0:37:28.87,0:37:30.17,Default,,0,0,0,,所以如果你注意这些
Dialogue: 0,0:37:31.08,0:37:31.83,Default,,0,0,0,,就没有问题了
Dialogue: 0,0:37:31.83,0:37:33.69,Default,,0,0,0,,同样 这完全是随意的
Dialogue: 0,0:37:33.90,0:37:34.96,Default,,0,0,0,,因为如果我们做了一个
Dialogue: 0,0:37:35.10,0:37:37.15,Default,,0,0,0,,比如 给向量的各个维度赋值的迭代
Dialogue: 0,0:37:37.42,0:37:38.73,Default,,0,0,0,,它们可能会以其它顺序输出
Dialogue: 0,0:37:40.41,0:37:42.04,Default,,0,0,0,,那么这只是这个求值器
Dialogue: 0,0:37:42.06,0:37:43.53,Default,,0,0,0,,工作时的一个约定
Dialogue: 0,0:37:45.39,0:37:46.24,Default,,0,0,0,,好 我们休息一下
Dialogue: 0,0:37:46.33,0:38:02.44,Default,,0,0,0,,[音乐]
Dialogue: 0,0:38:02.44,0:38:07.64,Declare,,0,0,0,,{\an2\fad(500,500)}《计算机程序的构造和解释》
Dialogue: 0,0:38:28.62,0:38:32.51,Declare,,0,0,0,,{\an2\fad(500,500)}讲师： 哈罗德·艾伯森教授 及 格兰德·杰·萨斯曼教授
Dialogue: 0,0:38:32.51,0:38:35.68,Declare,,0,0,0,,{\an2\fad(500,500)}《计算机程序的构造和解释》
Dialogue: 0,0:38:35.68,0:38:39.61,Declare,,0,0,0,,{\an2\fad(500,500)}显式控制求值器
Dialogue: 0,0:38:41.84,0:38:45.31,Default,,0,0,0,,教授：我们已经学习了表达式的求值
Dialogue: 0,0:38:45.60,0:38:47.08,Default,,0,0,0,,虽然这只是一个非常简单的例子
Dialogue: 0,0:38:48.81,0:38:50.24,Default,,0,0,0,,但从本质上来说
Dialogue: 0,0:38:50.24,0:38:52.03,Default,,0,0,0,,它跟那些大型嵌套表达式没什么不同
Dialogue: 0,0:38:52.03,0:38:54.57,Default,,0,0,0,,后者只是在栈上递归得更深而已
Dialogue: 0,0:38:55.13,0:38:56.03,Default,,0,0,0,,我现在要为你们
Dialogue: 0,0:38:56.04,0:38:56.91,Default,,0,0,0,,讲解最后一部分
Dialogue: 0,0:38:56.92,0:38:59.82,Default,,0,0,0,,我要带着你们观察EVAL-APPLY循环
Dialogue: 0,0:39:01.01,0:39:02.81,Default,,0,0,0,,我们还没有仔细研究过它
Dialogue: 0,0:39:03.00,0:39:04.75,Default,,0,0,0,,我们还没有见过一个复合程序
Dialogue: 0,0:39:05.20,0:39:07.79,Default,,0,0,0,,对它的求值会归约为
Dialogue: 0,0:39:07.92,0:39:10.11,Default,,0,0,0,,对一个过程的应用
Dialogue: 0,0:39:10.12,0:39:11.64,Default,,0,0,0,,进而是对过程体的求值
Dialogue: 0,0:39:12.44,0:39:15.88,Default,,0,0,0,,因此 假设我们有这个
Dialogue: 0,0:39:15.93,0:39:17.44,Default,,0,0,0,,假设我们正在考察
Dialogue: 0,0:39:18.07,0:39:31.60,Default,,0,0,0,,(DEFINE (F A B) (+ A B)
Dialogue: 0,0:39:33.99,0:39:37.32,Default,,0,0,0,,假设我们预先定义好了这个过程
Dialogue: 0,0:39:37.69,0:39:41.64,Default,,0,0,0,,现在 我们将要求值(F X Y)
Dialogue: 0,0:39:42.27,0:39:44.20,Default,,0,0,0,,基于的环境是E0
Dialogue: 0,0:39:44.35,0:39:47.02,Default,,0,0,0,,其中X=3 Y=4
Dialogue: 0,0:39:50.78,0:39:52.11,Default,,0,0,0,,当执行DEFINE的时候
Dialogue: 0,0:39:52.12,0:39:53.69,Default,,0,0,0,,还记得么 这里是一个LAMBDA
Dialogue: 0,0:39:53.82,0:39:55.53,Default,,0,0,0,,LAMBDA会创建一个过程
Dialogue: 0,0:39:55.95,0:39:58.49,Default,,0,0,0,,基本上 会发生的事情是
Dialogue: 0,0:39:59.63,0:40:00.68,Default,,0,0,0,,在环境E0中
Dialogue: 0,0:40:01.00,0:40:02.65,Default,,0,0,0,,我们会得到F的绑定
Dialogue: 0,0:40:03.56,0:40:05.61,Default,,0,0,0,,它指出F是一个过程
Dialogue: 0,0:40:07.15,0:40:11.28,Default,,0,0,0,,这个过程的参数是A和B
Dialogue: 0,0:40:12.57,0:40:16.19,Default,,0,0,0,,而过程体是(+ A B)
Dialogue: 0,0:40:18.11,0:40:20.99,Default,,0,0,0,,这就是环境大概的样子
Dialogue: 0,0:40:21.21,0:40:22.52,Default,,0,0,0,,我们之前就定义过了
Dialogue: 0,0:40:24.22,0:40:27.28,Default,,0,0,0,,然后 我们去求值(F X Y)
Dialogue: 0,0:40:28.80,0:40:30.89,Default,,0,0,0,,我们会仔细地解释每一步
Dialogue: 0,0:40:31.02,0:40:31.85,Default,,0,0,0,,就像之前那样
Dialogue: 0,0:40:31.88,0:40:33.09,Default,,0,0,0,,不会跳过重复的表达式
Dialogue: 0,0:40:33.28,0:40:34.38,Default,,0,0,0,,唯一的不同是
Dialogue: 0,0:40:34.40,0:40:36.64,Default,,0,0,0,,它的内部不再是基本的“+”过程
Dialogue: 0,0:40:37.24,0:40:38.99,Default,,0,0,0,,它还有这个东西
Dialogue: 0,0:40:41.04,0:40:43.60,Default,,0,0,0,,因此我们要进行相同的过程
Dialogue: 0,0:40:43.60,0:40:44.92,Default,,0,0,0,,只不过这次
Dialogue: 0,0:40:45.26,0:40:47.42,Default,,0,0,0,,当我们停在APPLY-DISPATCH时
Dialogue: 0,0:40:47.86,0:40:50.28,Default,,0,0,0,,FUN寄存器中不再是基本的“+”过程
Dialogue: 0,0:40:50.44,0:40:53.58,Default,,0,0,0,,而是一个代表过程的东西
Dialogue: 0,0:40:54.30,0:40:59.00,Default,,0,0,0,,其中参数为A和B
Dialogue: 0,0:41:00.64,0:41:06.27,Default,,0,0,0,,过程体是(+ A B)
Dialogue: 0,0:41:07.87,0:41:09.92,Default,,0,0,0,,再强调一下 我所谓的ENV
Dialogue: 0,0:41:09.96,0:41:11.12,Default,,0,0,0,,是一个指向环境的指针
Dialogue: 0,0:41:11.24,0:41:13.07,Default,,0,0,0,,所以不用担心我在这里写了很多东西
Dialogue: 0,0:41:13.28,0:41:15.63,Default,,0,0,0,,这是一个指向代表过程的数据结构的指针
Dialogue: 0,0:41:17.17,0:41:19.77,Default,,0,0,0,,因此 我们现在面临着相同的情况
Dialogue: 0,0:41:20.27,0:41:22.43,Default,,0,0,0,,我们来到了APPLY-DISPATCH
Dialogue: 0,0:41:23.98,0:41:26.48,Default,,0,0,0,,这是APPLY-DISPATCH的代码
Dialogue: 0,0:41:26.48,0:41:28.73,Default,,0,0,0,,上一次 我们分支跳转到了一个基本过程
Dialogue: 0,0:41:30.01,0:41:30.70,Default,,0,0,0,,然而这一次
Dialogue: 0,0:41:30.84,0:41:32.80,Default,,0,0,0,,我们遇到的是一个复合过程
Dialogue: 0,0:41:34.55,0:41:36.60,Default,,0,0,0,,因此我们要跳转到COMPOUND-APPLY
Dialogue: 0,0:41:38.47,0:41:39.92,Default,,0,0,0,,COMPOUND-APPLY又是怎样定义的呢？
Dialogue: 0,0:41:41.92,0:41:44.54,Default,,0,0,0,,还记得元循环求值器是怎么做的么？
Dialogue: 0,0:41:45.09,0:41:47.40,Default,,0,0,0,,COMPOUND-APPLY的执行步骤则是
Dialogue: 0,0:41:49.90,0:41:51.60,Default,,0,0,0,,在一个新的环境中
Dialogue: 0,0:41:52.94,0:41:54.12,Default,,0,0,0,,求值一个过程的体
Dialogue: 0,0:41:54.12,0:41:55.87,Default,,0,0,0,,这个新的环境来自于哪里呢？
Dialogue: 0,0:41:56.73,0:42:01.36,Default,,0,0,0,,我们把跟过程一同打包的环境
Dialogue: 0,0:42:03.02,0:42:05.79,Default,,0,0,0,,我们把过程的形式参数
Dialogue: 0,0:42:06.00,0:42:07.63,Default,,0,0,0,,同传递进来的实际参数给绑定起来
Dialogue: 0,0:42:09.75,0:42:11.95,Default,,0,0,0,,把这个作为新的框架
Dialogue: 0,0:42:12.59,0:42:13.79,Default,,0,0,0,,来扩展过程附带的环境
Dialogue: 0,0:42:14.99,0:42:16.08,Default,,0,0,0,,我们就是在这个环境中
Dialogue: 0,0:42:16.30,0:42:18.88,Default,,0,0,0,,求值过程的体
Dialogue: 0,0:42:20.12,0:42:24.47,Default,,0,0,0,,对吧？这就是APPLY-EVAL循环做的事
Dialogue: 0,0:42:24.47,0:42:26.25,Default,,0,0,0,,这就是APPLY回过头来调用EVAL
Dialogue: 0,0:42:32.86,0:42:34.92,Default,,0,0,0,,因此 这就是我们要在COMPOUND-APPLY中要做的所有事
Dialogue: 0,0:42:36.78,0:42:37.72,Default,,0,0,0,,要怎么来实现呢？
Dialogue: 0,0:42:37.72,0:42:40.97,Default,,0,0,0,,我们要构造一个新的环境
Dialogue: 0,0:42:43.55,0:42:45.64,Default,,0,0,0,,而我们构造的这个新环境呢
Dialogue: 0,0:42:46.76,0:42:48.11,Default,,0,0,0,,我们把它记作E1
Dialogue: 0,0:42:52.90,0:42:55.63,Default,,0,0,0,,E1这个环境呢
Dialogue: 0,0:42:57.31,0:42:59.15,Default,,0,0,0,,存储了过程的参数绑定
Dialogue: 0,0:42:59.21,0:43:03.26,Default,,0,0,0,,其中A=3 B=4
Dialogue: 0,0:43:04.27,0:43:05.76,Default,,0,0,0,,并且它跟E0相连
Dialogue: 0,0:43:05.76,0:43:08.08,Default,,0,0,0,,这是因为 F就是在E0中定义的
Dialogue: 0,0:43:09.27,0:43:10.27,Default,,0,0,0,,因此 在这个环境中
Dialogue: 0,0:43:10.27,0:43:11.96,Default,,0,0,0,,我们要来求值过程的体
Dialogue: 0,0:43:12.05,0:43:14.48,Default,,0,0,0,,让我们来看一看
Dialogue: 0,0:43:16.52,0:43:18.32,Default,,0,0,0,,我们来看COMPOUND-APPLY的代码
Dialogue: 0,0:43:20.30,0:43:23.47,Default,,0,0,0,,首先是给EXP寄存器赋值
Dialogue: 0,0:43:24.50,0:43:25.98,Default,,0,0,0,,所赋的值是FUN寄存器
Dialogue: 0,0:43:25.98,0:43:27.26,Default,,0,0,0,,所指向过程的体
Dialogue: 0,0:43:28.38,0:43:30.64,Default,,0,0,0,,这样 我就将过程的体
Dialogue: 0,0:43:31.29,0:43:32.33,Default,,0,0,0,,赋值给了EXP寄存器
Dialogue: 0,0:43:40.75,0:43:41.10,Default,,0,0,0,,对吧？
Dialogue: 0,0:43:42.64,0:43:44.97,Default,,0,0,0,,而这将在某个环境中求值
Dialogue: 0,0:43:45.82,0:43:48.32,Default,,0,0,0,,这个环境是通过将FUN寄存器
Dialogue: 0,0:43:51.30,0:43:53.67,Default,,0,0,0,,所指向的过程中的形式参数
Dialogue: 0,0:43:53.67,0:43:56.25,Default,,0,0,0,,与实际参数绑定起来 得到的
Dialogue: 0,0:43:57.80,0:44:00.00,Default,,0,0,0,,我们先不要关系它的具体细节
Dialogue: 0,0:44:00.08,0:44:01.63,Default,,0,0,0,,你可以知道它的最后结果
Dialogue: 0,0:44:01.93,0:44:03.32,Default,,0,0,0,,因此MAKE-BINDINGS会说
Dialogue: 0,0:44:04.04,0:44:07.90,Default,,0,0,0,,过程本身就附带有一个环境
Dialogue: 0,0:44:07.96,0:44:09.32,Default,,0,0,0,,在这里 我没有写出来
Dialogue: 0,0:44:09.36,0:44:10.56,Default,,0,0,0,,但我应该说过它有一个环境
Dialogue: 0,0:44:11.30,0:44:12.73,Default,,0,0,0,,因为每个过程在构造时
Dialogue: 0,0:44:12.76,0:44:13.44,Default,,0,0,0,,都有一个环境
Dialogue: 0,0:44:13.66,0:44:14.83,Default,,0,0,0,,因此 通过这个环境
Dialogue: 0,0:44:15.68,0:44:16.35,Default,,0,0,0,,它能够知道
Dialogue: 0,0:44:16.60,0:44:18.65,Default,,0,0,0,,定义该过程时的环境是怎样的
Dialogue: 0,0:44:19.29,0:44:20.75,Default,,0,0,0,,它知道实际参数是什么
Dialogue: 0,0:44:21.83,0:44:22.49,Default,,0,0,0,,它查看ARGL
Dialogue: 0,0:44:22.49,0:44:24.28,Default,,0,0,0,,然后你会在这里看到逆序的约定
Dialogue: 0,0:44:24.28,0:44:26.62,Default,,0,0,0,,它需要知道ARGL是逆序的
Dialogue: 0,0:44:27.06,0:44:28.81,Default,,0,0,0,,然后它构造了这个框架 E1
Dialogue: 0,0:44:29.99,0:44:31.08,Default,,0,0,0,,因此我们假设
Dialogue: 0,0:44:31.10,0:44:32.92,Default,,0,0,0,,MAKE-BINDINGS返回的就是这些东西
Dialogue: 0,0:44:33.36,0:44:36.22,Default,,0,0,0,,然后 它把E1赋值给ENV
Dialogue: 0,0:44:41.34,0:44:42.54,Default,,0,0,0,,下一步就是
Dialogue: 0,0:44:43.95,0:44:45.84,Default,,0,0,0,,恢复CONTINUE
Dialogue: 0,0:44:46.89,0:44:48.19,Default,,0,0,0,,还记得CONTINUE之前是什么吗？
Dialogue: 0,0:44:48.76,0:44:50.43,Default,,0,0,0,,在最后一段中
Dialogue: 0,0:44:52.24,0:44:54.02,Default,,0,0,0,,CONTINUE被保存了
Dialogue: 0,0:44:54.02,0:44:55.18,Default,,0,0,0,,它的值是最初的'DONE
Dialogue: 0,0:44:55.32,0:44:56.56,Default,,0,0,0,,这代表了
Dialogue: 0,0:44:56.73,0:44:59.44,Default,,0,0,0,,在完成这项特定应用后要做的事
Dialogue: 0,0:45:00.14,0:45:01.72,Default,,0,0,0,,这是在求值整个应用时
Dialogue: 0,0:45:01.76,0:45:03.18,Default,,0,0,0,,最先发生的事儿
Dialogue: 0,0:45:03.88,0:45:05.87,Default,,0,0,0,,现在 我们要恢复CONTINUE了
Dialogue: 0,0:45:06.86,0:45:09.55,Default,,0,0,0,,还记得APPLY-DISPATCH的约定么？
Dialogue: 0,0:45:09.58,0:45:11.20,Default,,0,0,0,,它假设下一步的跳转目标
Dialogue: 0,0:45:11.23,0:45:11.98,Default,,0,0,0,,已经存放在栈上了
Dialogue: 0,0:45:12.03,0:45:13.12,Default,,0,0,0,,并且 这里确实存放在栈上了
Dialogue: 0,0:45:13.59,0:45:14.76,Default,,0,0,0,,CONTINUE被赋值成了DONE
Dialogue: 0,0:45:17.82,0:45:19.90,Default,,0,0,0,,现在我们要回到EVAL-DISPATCH了
Dialogue: 0,0:45:19.94,0:45:20.84,Default,,0,0,0,,我们要再次进行寄存器设置
Dialogue: 0,0:45:20.97,0:45:24.41,Default,,0,0,0,,我们有表达式、环境、下一步
Dialogue: 0,0:45:25.80,0:45:26.89,Default,,0,0,0,,我不会再细讲了
Dialogue: 0,0:45:27.88,0:45:29.55,Default,,0,0,0,,因为它基本上就是相同的表达式
Dialogue: 0,0:45:35.40,0:45:37.79,Default,,0,0,0,,但是需要注意的是
Dialogue: 0,0:45:37.82,0:45:38.73,Default,,0,0,0,,在这个时候
Dialogue: 0,0:45:39.34,0:45:43.72,Default,,0,0,0,,我们已经归约了原始表达式(F X Y)
Dialogue: 0,0:45:44.64,0:45:47.92,Default,,0,0,0,,通过在E0中求值(F X Y)
Dialogue: 0,0:45:48.89,0:45:52.67,Default,,0,0,0,,将其归约为在E1中求值(+ A B)
Dialogue: 0,0:45:52.78,0:45:55.92,Default,,0,0,0,,要注意 栈上并没有什么东西 对吧？
Dialogue: 0,0:45:56.11,0:45:56.83,Default,,0,0,0,,这是一个归约
Dialogue: 0,0:45:56.84,0:45:59.80,Default,,0,0,0,,这个时候 机器的状态中
Dialogue: 0,0:45:59.84,0:46:01.20,Default,,0,0,0,,并没有包含
Dialogue: 0,0:46:01.76,0:46:03.71,Default,,0,0,0,,它是求值过程F的
Dialogue: 0,0:46:03.72,0:46:04.88,Default,,0,0,0,,中间状态的事实
Dialogue: 0,0:46:05.49,0:46:06.28,Default,,0,0,0,,它消失了
Dialogue: 0,0:46:07.66,0:46:09.55,Default,,0,0,0,,这里面没有积累的状态
Dialogue: 0,0:46:13.07,0:46:14.37,Default,,0,0,0,,注意 这个思想非常重要
Dialogue: 0,0:46:14.37,0:46:16.33,Default,,0,0,0,,这意味着
Dialogue: 0,0:46:16.76,0:46:18.39,Default,,0,0,0,,当我们使用代换模型时
Dialogue: 0,0:46:18.39,0:46:20.86,Default,,0,0,0,,一条表达式会归约到另一条表达式
Dialogue: 0,0:46:21.35,0:46:22.66,Default,,0,0,0,,而你不需要记住任何东西
Dialogue: 0,0:46:22.66,0:46:24.50,Default,,0,0,0,,这里 你就见到了归约的真谛
Dialogue: 0,0:46:24.56,0:46:26.16,Default,,0,0,0,,这个时候 栈上没有任何东西
Dialogue: 0,0:46:31.59,0:46:33.63,Default,,0,0,0,,这样就有一个非常重要的结果
Dialogue: 0,0:46:35.24,0:46:37.90,Default,,0,0,0,,让我们回过头来看看迭代式阶乘
Dialogue: 0,0:46:40.42,0:46:42.76,Default,,0,0,0,,还记得吗？这是某种循环
Dialogue: 0,0:46:44.01,0:46:44.88,Default,,0,0,0,,用来进行迭代
Dialogue: 0,0:46:45.13,0:46:47.36,Default,,0,0,0,,我们不断强调 它是一个迭代过程
Dialogue: 0,0:46:49.26,0:46:53.84,Default,,0,0,0,,还记得吗
Dialogue: 0,0:46:58.44,0:47:03.13,Default,,0,0,0,,我们使用它的时候
Dialogue: 0,0:47:04.35,0:47:11.07,Default,,0,0,0,,是像(FACT-ITER 5)这样调用它的
Dialogue: 0,0:47:12.36,0:47:18.67,Default,,0,0,0,,然后我们把它归约成(ITER 1 1 5)
Dialogue: 0,0:47:19.03,0:47:25.15,Default,,0,0,0,,然后它归约成(ITER 1 2 5)
Dialogue: 0,0:47:25.32,0:47:27.07,Default,,0,0,0,,等等等等
Dialogue: 0,0:47:27.07,0:47:28.17,Default,,0,0,0,,然后我们又说 看
Dialogue: 0,0:47:28.17,0:47:30.35,Default,,0,0,0,,为了实现这个效果 不需要存储任何东西
Dialogue: 0,0:47:31.72,0:47:32.73,Default,,0,0,0,,我们摆了摆手 说
Dialogue: 0,0:47:32.75,0:47:34.59,Default,,0,0,0,,“原则上 这不需要任何存储”
Dialogue: 0,0:47:35.04,0:47:36.17,Default,,0,0,0,,现在你们发现 确实不需要
Dialogue: 0,0:47:36.17,0:47:39.09,Default,,0,0,0,,这里的每一步都是真正的归约 对吧？
Dialogue: 0,0:47:39.09,0:47:42.60,Default,,0,0,0,,随着你求值这些表达式
Dialogue: 0,0:47:47.30,0:47:50.51,Default,,0,0,0,,在求值这些表达式的过程中
Dialogue: 0,0:47:50.83,0:47:51.37,Default,,0,0,0,,你会发现
Dialogue: 0,0:47:51.37,0:47:52.81,Default,,0,0,0,,栈上的这些表达式
Dialogue: 0,0:47:53.75,0:47:55.64,Default,,0,0,0,,都在一个特定的环境中
Dialogue: 0,0:47:56.42,0:48:00.02,Default,,0,0,0,,抱歉 是EXP寄存器中的表达式
Dialogue: 0,0:48:00.02,0:48:01.50,Default,,0,0,0,,是在某个特定的环境中
Dialogue: 0,0:48:01.57,0:48:02.19,Default,,0,0,0,,并且 在每一步
Dialogue: 0,0:48:02.19,0:48:04.00,Default,,0,0,0,,栈上不会积累任何东西
Dialogue: 0,0:48:04.36,0:48:05.68,Default,,0,0,0,,因为每一步都是真正的归约
Dialogue: 0,0:48:09.28,0:48:10.51,Default,,0,0,0,,因此 举例来说
Dialogue: 0,0:48:10.58,0:48:12.51,Default,,0,0,0,,说得更仔细一点
Dialogue: 0,0:48:13.46,0:48:16.88,Default,,0,0,0,,如果我从这样的一条表达式开始
Dialogue: 0,0:48:22.44,0:48:34.25,Default,,0,0,0,,比如说 在某个环境中计算(FACT-ITER 5)
Dialogue: 0,0:48:42.11,0:48:46.30,Default,,0,0,0,,它将在某个时刻创建一个环境
Dialogue: 0,0:48:46.81,0:48:48.38,Default,,0,0,0,,其中N=5
Dialogue: 0,0:48:51.47,0:48:52.01,Default,,0,0,0,,我们把它写下来
Dialogue: 0,0:48:55.68,0:48:56.59,Default,,0,0,0,,然后 在某个时候
Dialogue: 0,0:48:56.89,0:49:02.56,Default,,0,0,0,,机器会归约这整个东西
Dialogue: 0,0:49:02.91,0:49:04.35,Default,,0,0,0,,将它归约为
Dialogue: 0,0:49:04.76,0:49:09.85,Default,,0,0,0,,(ITER 1 1 N)
Dialogue: 0,0:49:10.68,0:49:13.72,Default,,0,0,0,,然后在环境E1中求值这条表达式
Dialogue: 0,0:49:15.87,0:49:17.16,Default,,0,0,0,,而不在栈上存放任何东西
Dialogue: 0,0:49:17.16,0:49:19.55,Default,,0,0,0,,看到了么 这时机器并不会记住
Dialogue: 0,0:49:20.71,0:49:22.50,Default,,0,0,0,,求值这条ITER表达式--
Dialogue: 0,0:49:25.00,0:49:25.63,Default,,0,0,0,,也就是某种循环--
Dialogue: 0,0:49:25.79,0:49:28.57,Default,,0,0,0,,并不是FACT-ITER的一部分
Dialogue: 0,0:49:29.68,0:49:30.59,Default,,0,0,0,,它不会记住这个事实
Dialogue: 0,0:49:30.59,0:49:33.17,Default,,0,0,0,,它只是归约了该表达式
Dialogue: 0,0:49:33.17,0:49:36.56,Default,,0,0,0,,如果我们再来看迭代式阶乘的体
Dialogue: 0,0:49:38.05,0:49:41.08,Default,,0,0,0,,这条表达式归约为了这条表达式
Dialogue: 0,0:49:42.81,0:49:43.87,Default,,0,0,0,,哦 这里漏了一个N
Dialogue: 0,0:49:46.59,0:49:47.74,Default,,0,0,0,,幻灯片中的约定
Dialogue: 0,0:49:47.74,0:49:49.13,Default,,0,0,0,,和实际程序中稍有不同
Dialogue: 0,0:49:53.34,0:49:56.25,Default,,0,0,0,,那么 ITER的体又是什么？
Dialogue: 0,0:49:56.28,0:49:57.40,Default,,0,0,0,,ITER的体首先是一个IF--
Dialogue: 0,0:49:58.75,0:50:00.19,Default,,0,0,0,,我不会再深入IF语句的细节了
Dialogue: 0,0:50:00.24,0:50:01.63,Default,,0,0,0,,它会对谓词求值
Dialogue: 0,0:50:02.40,0:50:03.71,Default,,0,0,0,,本例中 会返回FALSE
Dialogue: 0,0:50:03.81,0:50:08.64,Default,,0,0,0,,然后这里的ITER会归约为表达式--
Dialogue: 0,0:50:09.85,0:50:20.20,Default,,0,0,0,,(ITER (* COUNTER PRODUCT)
Dialogue: 0,0:50:21.62,0:50:22.24,Default,,0,0,0,,按照它代码写的--
Dialogue: 0,0:50:22.68,0:50:24.56,Default,,0,0,0,,(+ COUNTER 1))
Dialogue: 0,0:50:28.72,0:50:31.42,Default,,0,0,0,,在另外的一个环境E2中求值
Dialogue: 0,0:50:32.97,0:50:35.98,Default,,0,0,0,,其中 E2会记录着
Dialogue: 0,0:50:36.49,0:50:39.39,Default,,0,0,0,,PRODUCT和COUNTER的值
Dialogue: 0,0:50:42.92,0:50:44.33,Default,,0,0,0,,它会被归约为这条语句
Dialogue: 0,0:50:44.94,0:50:46.04,Default,,0,0,0,,它不会记得
Dialogue: 0,0:50:46.06,0:50:48.75,Default,,0,0,0,,它是一个需要返回到某处的一部分
Dialogue: 0,0:50:49.34,0:50:50.43,Default,,0,0,0,,当ITER再次调用ITER时
Dialogue: 0,0:50:50.44,0:50:52.56,Default,,0,0,0,,它会归约为另一个像这样的东西
Dialogue: 0,0:50:53.05,0:50:54.68,Default,,0,0,0,,只是会在新环境E3中
Dialogue: 0,0:50:54.83,0:50:56.67,Default,,0,0,0,,里面有关于PRODUCT和COUNTER新的绑定
Dialogue: 0,0:50:58.80,0:51:05.29,Default,,0,0,0,,因此 如果你想知道
Dialogue: 0,0:51:06.09,0:51:07.53,Default,,0,0,0,,如果你一直感到不安
Dialogue: 0,0:51:08.25,0:51:10.67,Default,,0,0,0,,不知道为什么我们说这些过程
Dialogue: 0,0:51:10.67,0:51:12.45,Default,,0,0,0,,虽然从语法上看起来是递归的
Dialogue: 0,0:51:13.20,0:51:15.69,Default,,0,0,0,,但实际上是迭代的
Dialogue: 0,0:51:15.87,0:51:17.24,Default,,0,0,0,,可以在常量空间中运行
Dialogue: 0,0:51:18.40,0:51:19.75,Default,,0,0,0,,我不知道这么说是否打消了你们的疑虑
Dialogue: 0,0:51:19.75,0:51:21.23,Default,,0,0,0,,但至少让你们知道发生了什么
Dialogue: 0,0:51:21.23,0:51:22.81,Default,,0,0,0,,这其中没有任何构造
Dialogue: 0,0:51:25.91,0:51:27.58,Default,,0,0,0,,但你也会说 这里面还是有一些构造
Dialogue: 0,0:51:27.98,0:51:30.08,Default,,0,0,0,,从原则上来说 我们也构造了环境框架
Dialogue: 0,0:51:31.71,0:51:32.37,Default,,0,0,0,,答案则是
Dialogue: 0,0:51:32.40,0:51:33.84,Default,,0,0,0,,你确实需要构建这些环境框架
Dialogue: 0,0:51:33.84,0:51:35.26,Default,,0,0,0,,但是 等你求值完毕后
Dialogue: 0,0:51:35.42,0:51:36.19,Default,,0,0,0,,不必保留它们
Dialogue: 0,0:51:36.44,0:51:37.61,Default,,0,0,0,,它们可以被废料收集
Dialogue: 0,0:51:37.92,0:51:39.47,Default,,0,0,0,,这些空间也可以被自动地重用
Dialogue: 0,0:51:40.72,0:51:42.99,Default,,0,0,0,,但你们可以看到求值器控制流
Dialogue: 0,0:51:43.25,0:51:46.12,Default,,0,0,0,,的中心思想就是进行归约
Dialogue: 0,0:51:47.02,0:51:49.29,Default,,0,0,0,,因此这些过程实际上是迭代过程
Dialogue: 0,0:51:50.13,0:51:51.38,Default,,0,0,0,,好吧 有什么问题么？
Dialogue: 0,0:52:02.68,0:52:03.23,Default,,0,0,0,,好吧 课件休息吧
Dialogue: 0,0:52:04.12,0:52:24.56,Default,,0,0,0,,[音乐]
Dialogue: 0,0:52:24.60,0:52:29.69,Declare,,0,0,0,,{\an2\fad(500,500)}《计算机程序的构造和解释》
Dialogue: 0,0:52:35.20,0:52:38.36,Declare,,0,0,0,,{\an2\fad(500,500)}讲师： 哈罗德·艾伯森教授 及 格兰德·杰·萨斯曼教授
Dialogue: 0,0:52:38.36,0:52:42.14,Declare,,0,0,0,,{\an2\fad(500,500)}《计算机程序的构造和解释》
Dialogue: 0,0:52:42.14,0:52:46.44,Declare,,0,0,0,,{\an2\fad(500,500)}显示控制求值器
Dialogue: 0,0:52:48.77,0:52:51.55,Default,,0,0,0,,教授：跟迭代过程形成对比的是
Dialogue: 0,0:52:52.77,0:52:54.89,Default,,0,0,0,,确实会占用空间的
Dialogue: 0,0:52:55.12,0:52:56.14,Default,,0,0,0,,递归过程
Dialogue: 0,0:52:56.17,0:52:57.29,Default,,0,0,0,,你们可以看到其中的区别
Dialogue: 0,0:52:58.03,0:53:01.20,Default,,0,0,0,,让我们来看看递归式阶乘的求值
Dialogue: 0,0:53:02.65,0:53:05.53,Default,,0,0,0,,这里的FACT-REC
Dialogue: 0,0:53:05.55,0:53:07.22,Default,,0,0,0,,就是阶乘的标准定义
Dialogue: 0,0:53:07.22,0:53:10.01,Default,,0,0,0,,这个当然是一个递归过程
Dialogue: 0,0:53:10.01,0:53:12.57,Default,,0,0,0,,它的计算过程也是递归的
Dialogue: 0,0:53:13.75,0:53:16.56,Default,,0,0,0,,然后 只要把它和我们开始的方式联系起来
Dialogue: 0,0:53:16.83,0:53:20.53,Default,,0,0,0,,我们会通过代换模型发现
Dialogue: 0,0:53:20.53,0:53:21.82,Default,,0,0,0,,这是一个递归过程
Dialogue: 0,0:53:22.36,0:53:28.00,Default,,0,0,0,,因为 如果我调用(REC-FACT 5)
Dialogue: 0,0:53:30.45,0:53:34.94,Default,,0,0,0,,会变成(* 5
Dialogue: 0,0:53:36.28,0:53:37.82,Default,,0,0,0,,哦 这里是FACT-REC
Dialogue: 0,0:53:42.62,0:53:47.93,Default,,0,0,0,,(* 5 (FACT-REC 4))
Dialogue: 0,0:53:49.66,0:53:58.22,Default,,0,0,0,,又会变成(* 5 (* 4 (FACT-REC 3)))
Dialogue: 0,0:54:00.22,0:54:08.60,Default,,0,0,0,,又会变成(* 5 (* 4 (* 3 (* ...
Dialogue: 0,0:54:13.45,0:54:15.31,Default,,0,0,0,,以此类推
Dialogue: 0,0:54:15.39,0:54:17.39,Default,,0,0,0,,关键点就是 有一条链条被不断构造出来
Dialogue: 0,0:54:18.10,0:54:20.06,Default,,0,0,0,,这就在代换模型中证明了
Dialogue: 0,0:54:20.08,0:54:21.28,Default,,0,0,0,,FACT-REC是递归的
Dialogue: 0,0:54:21.52,0:54:24.18,Default,,0,0,0,,现在 让我们来看看这条构造起来的链条
Dialogue: 0,0:54:24.18,0:54:25.29,Default,,0,0,0,,它又是在机器中的什么地方？
Dialogue: 0,0:54:27.68,0:54:29.95,Default,,0,0,0,,好吧 让我们想象一下要从哪里开始
Dialogue: 0,0:54:30.44,0:54:40.01,Default,,0,0,0,,我们告诉机器 求值(FACT-REC 5)
Dialogue: 0,0:54:41.45,0:54:43.39,Default,,0,0,0,,基于的环境是E0
Dialogue: 0,0:54:45.08,0:54:48.97,Default,,0,0,0,,也就是定义FACT-REC时的环境
Dialogue: 0,0:54:49.55,0:54:51.23,Default,,0,0,0,,现在 我们知道最终要发生什么
Dialogue: 0,0:54:52.25,0:54:53.64,Default,,0,0,0,,首先
Dialogue: 0,0:54:53.92,0:54:55.64,Default,,0,0,0,,它会对这些东西求值
Dialogue: 0,0:54:55.68,0:54:56.99,Default,,0,0,0,,发现它是一个过程
Dialogue: 0,0:54:57.18,0:55:00.16,Default,,0,0,0,,在这里创建一个新环境E1
Dialogue: 0,0:55:00.88,0:55:03.69,Default,,0,0,0,,其中N=5
Dialogue: 0,0:55:04.33,0:55:06.54,Default,,0,0,0,,并且与E0相连
Dialogue: 0,0:55:07.80,0:55:08.97,Default,,0,0,0,,这个E0也就是
Dialogue: 0,0:55:08.99,0:55:12.30,Default,,0,0,0,,定义FACT-REC的那个环境
Dialogue: 0,0:55:14.11,0:55:15.74,Default,,0,0,0,,然后 在E1这个环境中
Dialogue: 0,0:55:15.76,0:55:17.48,Default,,0,0,0,,求值过程的体
Dialogue: 0,0:55:19.67,0:55:25.92,Default,,0,0,0,,因此 在这里求值会归约为
Dialogue: 0,0:55:27.00,0:55:28.92,Default,,0,0,0,,在E1中求值过程的体
Dialogue: 0,0:55:30.16,0:55:31.34,Default,,0,0,0,,这就需要求值IF语句
Dialogue: 0,0:55:32.17,0:55:33.53,Default,,0,0,0,,而我不会讲解IF语句的细节
Dialogue: 0,0:55:33.53,0:55:34.88,Default,,0,0,0,,IF语句会求值谓词
Dialogue: 0,0:55:34.88,0:55:37.53,Default,,0,0,0,,最后发现需要求值ELSE子句
Dialogue: 0,0:55:37.84,0:55:40.41,Default,,0,0,0,,因此 这里的整个部分 会归约为
Dialogue: 0,0:55:41.30,0:55:45.53,Default,,0,0,0,,FACT-REC的ELSE子句
Dialogue: 0,0:55:45.82,0:55:46.97,Default,,0,0,0,,也就是谓词为假的部分
Dialogue: 0,0:55:47.23,0:55:51.16,Default,,0,0,0,,整个表达式就归约为了(* N
Dialogue: 0,0:55:53.07,0:55:59.96,Default,,0,0,0,,(FACT-REC (- N 1))
Dialogue: 0,0:56:03.48,0:56:05.55,Default,,0,0,0,,求值的环境是E1
Dialogue: 0,0:56:08.38,0:56:10.91,Default,,0,0,0,,因此 最初的表达式现在就会归约为
Dialogue: 0,0:56:11.04,0:56:12.52,Default,,0,0,0,,求值这样的一个表达式
Dialogue: 0,0:56:13.75,0:56:16.28,Default,,0,0,0,,而现在 我们面对的是一个应用
Dialogue: 0,0:56:16.28,0:56:17.63,Default,,0,0,0,,我们之前求值过应用
Dialogue: 0,0:56:18.22,0:56:20.25,Default,,0,0,0,,还记得要怎么求值应用么？
Dialogue: 0,0:56:20.36,0:56:21.69,Default,,0,0,0,,正式求值一个应用之前
Dialogue: 0,0:56:21.74,0:56:24.81,Default,,0,0,0,,你需要把CONTINUE寄存器的值保存在栈上
Dialogue: 0,0:56:25.35,0:56:27.18,Default,,0,0,0,,此时 栈上会有一个值'DONE
Dialogue: 0,0:56:29.98,0:56:32.88,Default,,0,0,0,,接下来 你要为求值子部分做准备
Dialogue: 0,0:56:35.00,0:56:37.20,Default,,0,0,0,,因此 我们在这里开始求值子部分
Dialogue: 0,0:56:39.47,0:56:41.45,Default,,0,0,0,,首先要做的是求值运算符
Dialogue: 0,0:56:44.60,0:56:46.32,Default,,0,0,0,,运算符是怎样求值的呢？
Dialogue: 0,0:56:47.25,0:56:48.99,Default,,0,0,0,,我们通过一些手段
Dialogue: 0,0:56:49.00,0:56:51.04,Default,,0,0,0,,将EXP寄存器指向运算符对应的过程
Dialogue: 0,0:56:51.48,0:56:53.15,Default,,0,0,0,,并且让ENV寄存器指向求值的环境
Dialogue: 0,0:56:53.66,0:56:54.60,Default,,0,0,0,,而把CONTINUE寄存器赋值为
Dialogue: 0,0:56:54.62,0:56:56.22,Default,,0,0,0,,用于求值参数的EVAL-ARGS
Dialogue: 0,0:56:56.59,0:56:57.37,Default,,0,0,0,,并且 我们把
Dialogue: 0,0:56:57.40,0:56:59.29,Default,,0,0,0,,CONTINUE的原始值保存在栈上
Dialogue: 0,0:56:59.52,0:57:01.02,Default,,0,0,0,,我们完成所有工作后 就会跳转到这个地方
Dialogue: 0,0:57:01.72,0:57:02.86,Default,,0,0,0,,在我们求值完运算符后
Dialogue: 0,0:57:03.58,0:57:05.80,Default,,0,0,0,,需要做的则是
Dialogue: 0,0:57:05.90,0:57:07.66,Default,,0,0,0,,求值对实际参数进行求值
Dialogue: 0,0:57:07.69,0:57:12.01,Default,,0,0,0,,也就是这个环境和这些参数
Dialogue: 0,0:57:12.14,0:57:13.44,Default,,0,0,0,,这些尚未求值的实际参数
Dialogue: 0,0:57:14.20,0:57:15.62,Default,,0,0,0,,它们现在都还在栈上
Dialogue: 0,0:57:15.62,0:57:18.59,Default,,0,0,0,,我们现在就要先来求值运算符
Dialogue: 0,0:57:23.26,0:57:26.73,Default,,0,0,0,,当我们从这个调用返回时
Dialogue: 0,0:57:26.92,0:57:28.64,Default,,0,0,0,,在这里 我们将要去调用EVAL-DISPATCH
Dialogue: 0,0:57:29.38,0:57:30.83,Default,,0,0,0,,当我们从这个调用返回时
Dialogue: 0,0:57:31.45,0:57:32.70,Default,,0,0,0,,这个运算符所对应的值
Dialogue: 0,0:57:32.73,0:57:33.52,Default,,0,0,0,,在本例中
Dialogue: 0,0:57:33.55,0:57:35.44,Default,,0,0,0,,也就是基本的乘法过程
Dialogue: 0,0:57:36.44,0:57:37.93,Default,,0,0,0,,会存放在FUN寄存器中
Dialogue: 0,0:57:43.02,0:57:44.53,Default,,0,0,0,,我们要去求值实际参数
Dialogue: 0,0:57:44.53,0:57:45.85,Default,,0,0,0,,现在这里求值N
Dialogue: 0,0:57:47.73,0:57:49.87,Default,,0,0,0,,本例中 会返回5
Dialogue: 0,0:57:50.25,0:57:52.04,Default,,0,0,0,,然后我们会把它放入ARGL寄存器
Dialogue: 0,0:57:53.00,0:57:55.88,Default,,0,0,0,,然后我们会去求值第二个运算对象
Dialogue: 0,0:57:57.46,0:58:00.48,Default,,0,0,0,,就在我们准备求值第二个运算对象之时
Dialogue: 0,0:58:00.52,0:58:02.19,Default,,0,0,0,,我会省略计算
Dialogue: 0,0:58:02.20,0:58:03.58,Default,,0,0,0,,(- N 1)之类的细节
Dialogue: 0,0:58:03.71,0:58:05.88,Default,,0,0,0,,但是 当我们去求值第二个运算对象时
Dialogue: 0,0:58:06.62,0:58:10.44,Default,,0,0,0,,会最终归约为对FACT-REC的另一个调用
Dialogue: 0,0:58:12.00,0:58:14.20,Default,,0,0,0,,现在 我们在栈上有
Dialogue: 0,0:58:16.52,0:58:19.94,Default,,0,0,0,,来自于这个组合式的运算符
Dialogue: 0,0:58:20.12,0:58:21.07,Default,,0,0,0,,以及其它的参数
Dialogue: 0,0:58:23.40,0:58:27.61,Default,,0,0,0,,现在 我们已经准备好
Dialogue: 0,0:58:28.49,0:58:29.69,Default,,0,0,0,,去调用另外的FACT-REC了
Dialogue: 0,0:58:30.20,0:58:31.43,Default,,0,0,0,,而让我们完成了这个调用以后
Dialogue: 0,0:58:31.56,0:58:33.64,Default,,0,0,0,,我们就要跳转到ACCUMULATE-LAST-ARG
Dialogue: 0,0:58:34.12,0:58:35.20,Default,,0,0,0,,还记得这是做什么的么？
Dialogue: 0,0:58:35.20,0:58:35.93,Default,,0,0,0,,它会说
Dialogue: 0,0:58:36.45,0:58:39.28,Default,,0,0,0,,我们会把这个调用的结果
Dialogue: 0,0:58:39.28,0:58:40.40,Default,,0,0,0,,和这个5相乘
Dialogue: 0,0:58:41.69,0:58:42.38,Default,,0,0,0,,但是请注意
Dialogue: 0,0:58:42.73,0:58:44.81,Default,,0,0,0,,我们现在处于另一个递归阶乘中
Dialogue: 0,0:58:45.72,0:58:48.92,Default,,0,0,0,,我们又要再次调用EVAL-DISPATCH
Dialogue: 0,0:58:49.32,0:58:50.60,Default,,0,0,0,,然而我们并没有真正地“归约”它
Dialogue: 0,0:58:50.64,0:58:52.08,Default,,0,0,0,,因为现在栈上还有东西
Dialogue: 0,0:58:53.70,0:58:55.39,Default,,0,0,0,,栈上的这些东西说：“当你返回时”
Dialogue: 0,0:58:55.40,0:58:57.52,Default,,0,0,0,,你最好把结果和放在这里的5相乘
Dialogue: 0,0:58:58.43,0:59:05.77,Default,,0,0,0,,所以当我们进行另外的调用
Dialogue: 0,0:59:07.12,0:59:08.84,Default,,0,0,0,,求值(- N 1)
Dialogue: 0,0:59:09.30,0:59:11.05,Default,,0,0,0,,这会返回给我们另一个环境
Dialogue: 0,0:59:11.25,0:59:13.84,Default,,0,0,0,,其中N的新值为4
Dialogue: 0,0:59:14.60,0:59:16.22,Default,,0,0,0,,然后又将调用EVAL-DISPATCH
Dialogue: 0,0:59:19.20,0:59:20.22,Default,,0,0,0,,我们又创建了另一个调用
Dialogue: 0,0:59:21.35,0:59:24.44,Default,,0,0,0,,这个4又会遇到相同的情况
Dialogue: 0,0:59:26.04,0:59:28.62,Default,,0,0,0,,我们最后会遇到对(FACT-REC N)的又一次调用
Dialogue: 0,0:59:30.02,0:59:32.68,Default,,0,0,0,,而这时候 栈上会有从最初的调用
Dialogue: 0,0:59:32.88,0:59:34.51,Default,,0,0,0,,到最近一次调用的东西
Dialogue: 0,0:59:35.36,0:59:36.91,Default,,0,0,0,,它们都在等待同一个东西
Dialogue: 0,0:59:36.91,0:59:39.16,Default,,0,0,0,,它们都要跳转到ACCUMULATE-LAST-ARG
Dialogue: 0,0:59:40.51,0:59:42.94,Default,,0,0,0,,当然 当我们进行第四次调用时
Dialogue: 0,0:59:43.25,0:59:44.38,Default,,0,0,0,,会发生同样的事
Dialogue: 0,0:59:45.64,0:59:47.07,Default,,0,0,0,,如此往复
Dialogue: 0,0:59:47.30,0:59:48.60,Default,,0,0,0,,在这里 你在栈上看到的
Dialogue: 0,0:59:50.30,0:59:52.22,Default,,0,0,0,,栈上面实际存放的是
Dialogue: 0,0:59:52.22,0:59:54.59,Default,,0,0,0,,基本过程*以及5
Dialogue: 0,0:59:54.96,0:59:56.40,Default,,0,0,0,,而你要把它用来
Dialogue: 0,0:59:56.59,0:59:58.54,Default,,0,0,0,,调用ACCUMULATE-LAST-ARG
Dialogue: 0,1:00:00.47,1:00:02.01,Default,,0,0,0,,就是这样 对吧？
Dialogue: 0,1:00:02.01,1:00:04.75,Default,,0,0,0,,这跟它们在表达式中的顺序是一致的
Dialogue: 0,1:00:05.65,1:00:10.65,Default,,0,0,0,,实际上 你将要应用的运算符
Dialogue: 0,1:00:11.72,1:00:14.30,Default,,0,0,0,,以及当你返回时
Dialogue: 0,1:00:14.32,1:00:15.79,Default,,0,0,0,,需要去求积的参数
Dialogue: 0,1:00:15.80,1:00:16.91,Default,,0,0,0,,以及这里的括号
Dialogue: 0,1:00:16.94,1:00:18.96,Default,,0,0,0,,都在告诉你 在对它们进行积累
Dialogue: 0,1:00:19.62,1:00:21.88,Default,,0,0,0,,因此 你可以看到代换模型并不是这样的谎言
Dialogue: 0,1:00:22.56,1:00:23.63,Default,,0,0,0,,从某种意义上来说 它实际上是
Dialogue: 0,1:00:23.64,1:00:25.31,Default,,0,0,0,,存在于栈上的那些东西
Dialogue: 0,1:00:29.37,1:00:30.40,Default,,0,0,0,,好吧 从某种意义上来说
Dialogue: 0,1:00:30.81,1:00:32.48,Default,,0,0,0,,应该给你们解释了
Dialogue: 0,1:00:33.26,1:00:34.52,Default,,0,0,0,,或者 至少让你们相信
Dialogue: 0,1:00:35.93,1:00:38.72,Default,,0,0,0,,求值器会通过某些方式
Dialogue: 0,1:00:40.06,1:00:42.86,Default,,0,0,0,,迭代地去求值某些过程
Dialogue: 0,1:00:42.95,1:00:44.25,Default,,0,0,0,,而递归地去求值另外的过程
Dialogue: 0,1:00:45.26,1:00:47.45,Default,,0,0,0,,尽管从语法上看
Dialogue: 0,1:00:47.45,1:00:49.05,Default,,0,0,0,,它们都是递归过程
Dialogue: 0,1:00:49.40,1:00:50.64,Default,,0,0,0,,它又是如何做到的呢？
Dialogue: 0,1:00:50.66,1:00:53.72,Default,,0,0,0,,其中的基本原因就是
Dialogue: 0,1:00:53.80,1:00:55.68,Default,,0,0,0,,求值器被设置为
Dialogue: 0,1:00:56.04,1:00:59.26,Default,,0,0,0,,只保存那些稍后会用到的东西
Dialogue: 0,1:01:01.09,1:01:04.25,Default,,0,0,0,,比如说 当你在把
Dialogue: 0,1:01:04.67,1:01:07.39,Default,,0,0,0,,在一个环境中求值表达式归约为
Dialogue: 0,1:01:07.87,1:01:09.87,Default,,0,0,0,,将某个过程应用在参数上时
Dialogue: 0,1:01:10.52,1:01:12.49,Default,,0,0,0,,它就不再需要最初的环境了
Dialogue: 0,1:01:13.37,1:01:16.65,Default,,0,0,0,,因为所需要的环境信息都被打包到
Dialogue: 0,1:01:17.88,1:01:19.36,Default,,0,0,0,,需要应用的那个过程中了
Dialogue: 0,1:01:20.75,1:01:21.61,Default,,0,0,0,,同样 类似地
Dialogue: 0,1:01:21.63,1:01:23.65,Default,,0,0,0,,当你求值一个参数表时
Dialogue: 0,1:01:23.65,1:01:25.20,Default,,0,0,0,,当你完成对表的求值时
Dialogue: 0,1:01:25.91,1:01:28.03,Default,,0,0,0,,当你求值完最后一个参数时
Dialogue: 0,1:01:28.20,1:01:31.61,Default,,0,0,0,,你就不再需要这个参数表了 对吧？
Dialogue: 0,1:01:31.63,1:01:32.94,Default,,0,0,0,,你也就不再需要
Dialogue: 0,1:01:33.04,1:01:34.64,Default,,0,0,0,,求值这些参数所需的环境了
Dialogue: 0,1:01:36.69,1:01:40.89,Default,,0,0,0,,所以这个解释器如此“智能”的根本原因
Dialogue: 0,1:01:40.89,1:01:42.88,Default,,0,0,0,,根本不是因为它“智能” 只是因为它老实
Dialogue: 0,1:01:43.05,1:01:45.74,Default,,0,0,0,,它的原则就是：“只保存那些需要的”
Dialogue: 0,1:01:48.70,1:01:51.00,Default,,0,0,0,,这里 让我来给你们展示
Dialogue: 0,1:01:53.07,1:01:57.20,Default,,0,0,0,,这是致使尾递归的根本原因
Dialogue: 0,1:01:58.31,1:02:00.20,Default,,0,0,0,,要记住 (RESOTRE CONTINUE)这条代码
Dialogue: 0,1:02:00.22,1:02:06.94,Default,,0,0,0,,它指的是 当我去求值过程体的时候
Dialogue: 0,1:02:08.96,1:02:11.00,Default,,0,0,0,,我应该告诉EVAL返回到
Dialogue: 0,1:02:11.25,1:02:12.54,Default,,0,0,0,,最初的求值
Dialogue: 0,1:02:12.54,1:02:14.25,Default,,0,0,0,,应该返回的地方
Dialogue: 0,1:02:15.17,1:02:15.95,Default,,0,0,0,,因此 从某种角度来说
Dialogue: 0,1:02:16.17,1:02:18.84,Default,,0,0,0,,你想知道是哪一行代码致使了尾递归
Dialogue: 0,1:02:18.89,1:02:19.44,Default,,0,0,0,,那么就是这一行
Dialogue: 0,1:02:19.92,1:02:21.53,Default,,0,0,0,,出于某些奇怪的原因
Dialogue: 0,1:02:21.77,1:02:24.80,Default,,0,0,0,,如果我想构建一个没有尾递归的求值器
Dialogue: 0,1:02:25.69,1:02:26.86,Default,,0,0,0,,我需要做的就是
Dialogue: 0,1:02:27.12,1:02:29.29,Default,,0,0,0,,在这里先不要去恢复CONTINUE
Dialogue: 0,1:02:30.06,1:02:31.66,Default,,0,0,0,,而是在这里建立一个标号
Dialogue: 0,1:02:32.75,1:02:36.25,Default,,0,0,0,,用来标识完成过程应用后的返回位置
Dialogue: 0,1:02:37.64,1:02:39.71,Default,,0,0,0,,而我会把CONTINUE设置为这个标号
Dialogue: 0,1:02:39.92,1:02:41.21,Default,,0,0,0,,然后跳转到EVAL-DISPATCH
Dialogue: 0,1:02:41.40,1:02:43.21,Default,,0,0,0,,然后EVAL-DISPATCH会回到这里
Dialogue: 0,1:02:43.79,1:02:44.30,Default,,0,0,0,,而这时
Dialogue: 0,1:02:44.32,1:02:45.28,Default,,0,0,0,,我会恢复CONTINUE
Dialogue: 0,1:02:45.29,1:02:46.52,Default,,0,0,0,,并回到最初的返回位置
Dialogue: 0,1:02:47.92,1:02:51.00,Default,,0,0,0,,因此 这里唯一的后果就是
Dialogue: 0,1:02:51.15,1:02:52.68,Default,,0,0,0,,解释器不再是尾递归的了
Dialogue: 0,1:02:52.84,1:02:54.62,Default,,0,0,0,,它会给你完全相同的答案
Dialogue: 0,1:02:54.72,1:02:57.02,Default,,0,0,0,,只是当你执行迭代式阶乘
Dialogue: 0,1:02:57.05,1:02:58.36,Default,,0,0,0,,或者其它迭代过程时
Dialogue: 0,1:02:58.60,1:02:59.80,Default,,0,0,0,,它都会递归地去执行
Dialogue: 0,1:03:03.04,1:03:05.40,Default,,0,0,0,,然而 我对你们撒了一个小谎
Dialogue: 0,1:03:05.76,1:03:06.99,Default,,0,0,0,,因为我演示的
Dialogue: 0,1:03:07.02,1:03:08.33,Default,,0,0,0,,一个有些过于简化的解释器
Dialogue: 0,1:03:08.72,1:03:10.38,Default,,0,0,0,,这个解释器假设每个过程
Dialogue: 0,1:03:11.36,1:03:13.66,Default,,0,0,0,,只含有一条表达式
Dialogue: 0,1:03:13.89,1:03:14.54,Default,,0,0,0,,还记得吗 通常来说
Dialogue: 0,1:03:14.56,1:03:16.57,Default,,0,0,0,,过程的体是多条表达式组成的序列
Dialogue: 0,1:03:17.87,1:03:20.49,Default,,0,0,0,,所以没有什么新概念
Dialogue: 0,1:03:20.49,1:03:22.28,Default,,0,0,0,,让我来展示一下实际的求值器
Dialogue: 0,1:03:22.89,1:03:24.73,Default,,0,0,0,,是怎么来处理表达式序列的
Dialogue: 0,1:03:28.47,1:03:29.74,Default,,0,0,0,,这是现在的COMPOUND-APPLY
Dialogue: 0,1:03:29.74,1:03:31.31,Default,,0,0,0,,和之前的唯一不同是
Dialogue: 0,1:03:32.07,1:03:34.33,Default,,0,0,0,,它不再直接地跳转到EVAL
Dialogue: 0,1:03:35.98,1:03:38.03,Default,,0,0,0,,它先获取整个过程的体
Dialogue: 0,1:03:38.03,1:03:40.15,Default,,0,0,0,,在本例中 也就是表达式序列
Dialogue: 0,1:03:40.28,1:03:41.71,Default,,0,0,0,,然后跳转到EVAL-SEQUENCE
Dialogue: 0,1:03:42.60,1:03:45.32,Default,,0,0,0,,EVAL-SEQUENCE是一个小型的循环
Dialogue: 0,1:03:46.83,1:03:49.98,Default,,0,0,0,,然后每次求值一条表达式
Dialogue: 0,1:03:52.63,1:03:53.85,Default,,0,0,0,,就是这样来求值的--
Dialogue: 0,1:03:53.90,1:03:54.94,Default,,0,0,0,,当它求值完一条表达式后
Dialogue: 0,1:03:54.97,1:03:56.86,Default,,0,0,0,,会跳转到这里 去求值下一条
Dialogue: 0,1:03:58.44,1:03:59.29,Default,,0,0,0,,当我完成了所有的求值后
Dialogue: 0,1:03:59.29,1:04:01.02,Default,,0,0,0,,我想要跳转到LAST-EXP
Dialogue: 0,1:04:01.31,1:04:03.28,Default,,0,0,0,,我就只需要恢复CONTINUE寄存器
Dialogue: 0,1:04:03.92,1:04:05.28,Default,,0,0,0,,然后跳转到EVAL-DISPATCH
Dialogue: 0,1:04:06.41,1:04:08.20,Default,,0,0,0,,同样的 如果你想要在这种求值器中
Dialogue: 0,1:04:08.20,1:04:10.35,Default,,0,0,0,,破坏尾递归机制
Dialogue: 0,1:04:10.64,1:04:13.71,Default,,0,0,0,,你只需要在LAST-EXP中不做特殊处理即可
Dialogue: 0,1:04:14.90,1:04:17.34,Default,,0,0,0,,也就是说 当你处理完最后一条表达式
Dialogue: 0,1:04:17.36,1:04:18.65,Default,,0,0,0,,你跳转到另外一个地方
Dialogue: 0,1:04:19.15,1:04:20.68,Default,,0,0,0,,在那个地方去恢复CONTINUE
Dialogue: 0,1:04:21.90,1:04:23.26,Default,,0,0,0,,出于某些原因
Dialogue: 0,1:04:23.26,1:04:25.74,Default,,0,0,0,,很多Lisp求值器倾向于这么做
Dialogue: 0,1:04:26.55,1:04:28.44,Default,,0,0,0,,这样做的后果就是
Dialogue: 0,1:04:28.86,1:04:30.72,Default,,0,0,0,,迭代式过程也会使栈增长
Dialogue: 0,1:04:31.88,1:04:33.61,Default,,0,0,0,,还不清楚为什么会这样
Dialogue: 0,1:04:35.92,1:04:37.98,Default,,0,0,0,,好吧 我稍微来总结一下
Dialogue: 0,1:04:38.09,1:04:39.60,Default,,0,0,0,,毕竟这是一个大程序
Dialogue: 0,1:04:39.98,1:04:41.04,Default,,0,0,0,,又有很多细节
Dialogue: 0,1:04:41.12,1:04:42.25,Default,,0,0,0,,但关键点就是
Dialogue: 0,1:04:43.04,1:04:43.87,Default,,0,0,0,,从概念上来说
Dialogue: 0,1:04:44.04,1:04:46.08,Default,,0,0,0,,这跟翻译其它程序没什么不同
Dialogue: 0,1:04:47.06,1:04:48.06,Default,,0,0,0,,核心思想就是
Dialogue: 0,1:04:48.06,1:04:50.28,Default,,0,0,0,,我们已经有了通用求值器程序
Dialogue: 0,1:04:50.33,1:04:51.71,Default,,0,0,0,,一个元循环求值器
Dialogue: 0,1:04:51.87,1:04:53.07,Default,,0,0,0,,如果我们把它翻译为了Lisp
Dialogue: 0,1:04:53.10,1:04:53.95,Default,,0,0,0,,那么我们就有了Lisp的所有东西
Dialogue: 0,1:04:54.33,1:04:55.15,Default,,0,0,0,,我们就是这么来做的
Dialogue: 0,1:04:57.98,1:04:59.68,Default,,0,0,0,,第二点则是 魔法消失了
Dialogue: 0,1:04:59.68,1:05:01.97,Default,,0,0,0,,这整个系统不再神秘了 对吧？
Dialogue: 0,1:05:01.97,1:05:07.79,Default,,0,0,0,,原则上来说 这应该相当清楚了
Dialogue: 0,1:05:07.82,1:05:10.08,Default,,0,0,0,,只是还不太了解表结构的内存管理
Dialogue: 0,1:05:10.80,1:05:11.80,Default,,0,0,0,,我们后面会讲
Dialogue: 0,1:05:12.64,1:05:14.20,Default,,0,0,0,,这也并不困难
Dialogue: 0,1:05:15.45,1:05:16.35,Default,,0,0,0,,第三点就是
Dialogue: 0,1:05:16.35,1:05:17.52,Default,,0,0,0,,所有的这些尾递归
Dialogue: 0,1:05:18.24,1:05:21.96,Default,,0,0,0,,来自于严格的求值纪律
Dialogue: 0,1:05:22.55,1:05:24.51,Default,,0,0,0,,也就是只保存那些后面会用到的东西
Dialogue: 0,1:05:25.87,1:05:27.72,Default,,0,0,0,,而不是一些比较随意的原则
Dialogue: 0,1:05:27.76,1:05:29.86,Default,,0,0,0,,比如 无论什么时候我们调用一个子过程
Dialogue: 0,1:05:29.86,1:05:32.16,Default,,0,0,0,,我们会保存所有的寄存器并且返回
Dialogue: 0,1:05:33.94,1:05:36.49,Default,,0,0,0,,有些时候为了提效 这样做很值得
Dialogue: 0,1:05:37.15,1:05:39.96,Default,,0,0,0,,当你研究求值机器的内部原理时
Dialogue: 0,1:05:40.45,1:05:42.56,Default,,0,0,0,,这类东西就很值得去研究
Dialogue: 0,1:05:42.56,1:05:43.96,Default,,0,0,0,,因为它会带来显著的不同
Dialogue: 0,1:05:45.23,1:05:47.69,Default,,0,0,0,,我想现在基本上已经
Dialogue: 0,1:05:47.90,1:05:52.30,Default,,0,0,0,,把这个求值器讲得很清楚了
Dialogue: 0,1:05:52.56,1:05:53.90,Default,,0,0,0,,我希望你们能相信
Dialogue: 0,1:05:54.32,1:05:56.27,Default,,0,0,0,,真的有人能够
Dialogue: 0,1:05:56.84,1:05:58.56,Default,,0,0,0,,将一个Lisp求值器放在掌心之中
Dialogue: 0,1:05:59.07,1:06:00.49,Default,,0,0,0,,为了让你们死心塌地
Dialogue: 0,1:06:00.80,1:06:01.96,Default,,0,0,0,,我给你们看一个Lisp求值器
Dialogue: 0,1:06:02.54,1:06:04.06,Default,,0,0,0,,它就在我的手掌中
Dialogue: 0,1:06:06.16,1:06:10.56,Default,,0,0,0,,这块求值器芯片实际上
Dialogue: 0,1:06:10.89,1:06:13.70,Default,,0,0,0,,比我给你们展示的求值器还要复杂
Dialogue: 0,1:06:16.86,1:06:19.20,Default,,0,0,0,,这张图片效果更好
Dialogue: 0,1:06:22.07,1:06:22.57,Default,,0,0,0,,在这上面
Dialogue: 0,1:06:22.60,1:06:24.38,Default,,0,0,0,,你可以看到相同的宏观结构
Dialogue: 0,1:06:24.73,1:06:25.93,Default,,0,0,0,,这是寄存器阵列
Dialogue: 0,1:06:26.80,1:06:27.71,Default,,0,0,0,,这些是数据通路
Dialogue: 0,1:06:27.72,1:06:29.07,Default,,0,0,0,,这里有是有穷状态控制器
Dialogue: 0,1:06:29.80,1:06:31.04,Default,,0,0,0,,再强调一下 是有穷状态
Dialogue: 0,1:06:31.96,1:06:32.80,Default,,0,0,0,,全都在这里了
Dialogue: 0,1:06:32.81,1:06:34.16,Default,,0,0,0,,在另外的地方还有外部存储
Dialogue: 0,1:06:34.16,1:06:35.23,Default,,0,0,0,,用来存储数据
Dialogue: 0,1:06:35.75,1:06:37.63,Default,,0,0,0,,而这块芯片非常复杂
Dialogue: 0,1:06:37.64,1:06:39.16,Default,,0,0,0,,是因为它尝试更快地运行Lisp
Dialogue: 0,1:06:39.66,1:06:42.97,Default,,0,0,0,,它具有非常非常之快的并行运算
Dialogue: 0,1:06:43.07,1:06:46.32,Default,,0,0,0,,比如说 如果你想要索引一个数组
Dialogue: 0,1:06:46.70,1:06:50.40,Default,,0,0,0,,同时又要检查该索引是否为一个整数
Dialogue: 0,1:06:50.43,1:06:52.86,Default,,0,0,0,,以及该索引没有越界
Dialogue: 0,1:06:53.04,1:06:55.02,Default,,0,0,0,,同时还要进行内存存取
Dialogue: 0,1:06:55.05,1:06:56.70,Default,,0,0,0,,它会同时进行这些事
Dialogue: 0,1:06:57.12,1:06:58.40,Default,,0,0,0,,如果这些操作都没有问题的话
Dialogue: 0,1:06:58.44,1:06:59.96,Default,,0,0,0,,最终就会在这里得到结果
Dialogue: 0,1:07:00.42,1:07:02.46,Default,,0,0,0,,因此 数据通路中大量的
Dialogue: 0,1:07:02.48,1:07:04.65,Default,,0,0,0,,复杂运算使得Lisp能够并行运行
Dialogue: 0,1:07:05.26,1:07:08.41,Default,,0,0,0,,这完全是求值Lisp的
Dialogue: 0,1:07:08.76,1:07:10.36,Default,,0,0,0,,一种无冒险的哲学
Dialogue: 0,1:07:10.64,1:07:13.20,Default,,0,0,0,,并且 这个的微指令也相当复杂
Dialogue: 0,1:07:13.45,1:07:17.56,Default,,0,0,0,,让我先看一看
Dialogue: 0,1:07:17.60,1:07:21.10,Default,,0,0,0,,这其中有大概389条
Dialogue: 0,1:07:21.68,1:07:23.85,Default,,0,0,0,,220比特的微指令
Dialogue: 0,1:07:24.07,1:07:27.94,Default,,0,0,0,,只因为这些数据通路非常复杂
Dialogue: 0,1:07:27.94,1:07:32.25,Default,,0,0,0,,整个芯片大概有89,000支晶体管
Dialogue: 0,1:07:33.56,1:07:36.86,Default,,0,0,0,,好吧 我希望通过这节课解答了大部分疑惑
Dialogue: 0,1:07:37.97,1:07:39.24,Default,,0,0,0,,也许你们想看一看这块芯片
Dialogue: 0,1:07:46.14,1:07:46.89,Default,,0,0,0,,好吧 先讲到这里
Dialogue: 0,1:07:56.46,1:07:56.75,Default,,0,0,0,,有问题吗？
Dialogue: 0,1:07:59.00,1:08:00.42,Default,,0,0,0,,学生：您所讲的 听起来像是
Dialogue: 0,1:08:00.42,1:08:03.48,Default,,0,0,0,,如果把(RESTORE CONTINUE)放在合适的地方
Dialogue: 0,1:08:03.58,1:08:09.42,Default,,0,0,0,,这样之前递归求值的过程
Dialogue: 0,1:08:09.42,1:08:11.95,Default,,0,0,0,,现在就会变成迭代求值的
Dialogue: 0,1:08:12.67,1:08:15.36,Default,,0,0,0,,（意义不明）
Dialogue: 0,1:08:15.60,1:08:17.54,Default,,0,0,0,,教授：我想我应该这么来说
Dialogue: 0,1:08:17.54,1:08:19.82,Default,,0,0,0,,如果把(RESTORE CONTINUE)放在了错误的位置
Dialogue: 0,1:08:20.55,1:08:25.48,Default,,0,0,0,,你就会让那些语法上看起来像递归的过程
Dialogue: 0,1:08:25.52,1:08:27.28,Default,,0,0,0,,在运行的时候不断地扩张栈
Dialogue: 0,1:08:28.64,1:08:30.52,Default,,0,0,0,,但这样是没有原因的
Dialogue: 0,1:08:33.15,1:08:35.12,Default,,0,0,0,,你可以自己去试一试
Dialogue: 0,1:08:35.15,1:08:38.09,Default,,0,0,0,,你可以在COMPOND-APPLY返回后
Dialogue: 0,1:08:38.18,1:08:40.78,Default,,0,0,0,,交换两、三条语句的顺序
Dialogue: 0,1:08:41.31,1:08:43.26,Default,,0,0,0,,那么你得到的就不再是尾递归了
Dialogue: 0,1:08:45.06,1:08:46.14,Default,,0,0,0,,我只是想强调
Dialogue: 0,1:08:46.16,1:08:47.40,Default,,0,0,0,,这其中没有什么魔法
Dialogue: 0,1:08:47.67,1:08:48.57,Default,,0,0,0,,这并不是
Dialogue: 0,1:08:49.31,1:08:52.17,Default,,0,0,0,,有什么智能的预处理程序
Dialogue: 0,1:08:52.65,1:08:55.45,Default,,0,0,0,,它会分析FACT-ITER这个程序
Dialogue: 0,1:08:55.47,1:08:56.73,Default,,0,0,0,,然后说
Dialogue: 0,1:08:57.42,1:08:58.86,Default,,0,0,0,,我注意到
Dialogue: 0,1:08:58.88,1:09:01.13,Default,,0,0,0,,完成这个调用 不需要我进行压栈
Dialogue: 0,1:09:01.13,1:09:02.88,Default,,0,0,0,,但是有些人是这么认为的
Dialogue: 0,1:09:03.76,1:09:05.38,Default,,0,0,0,,而是一种比这个还要蠢的机制
Dialogue: 0,1:09:05.38,1:09:07.50,Default,,0,0,0,,就是在合适的地方插入RESTORE指令
Dialogue: 0,1:09:08.56,1:09:09.79,Default,,0,0,0,,就可以自动地实现
Dialogue: 0,1:09:14.72,1:09:17.55,Default,,0,0,0,,学生：但这不会影响到时间复杂度 对吧？
Dialogue: 0,1:09:17.58,1:09:17.87,Default,,0,0,0,,教授：不会
Dialogue: 0,1:09:18.60,1:09:21.77,Default,,0,0,0,,学生：它不会迭代地处理
Dialogue: 0,1:09:21.80,1:09:23.02,Default,,0,0,0,,而是会递归地处理
Dialogue: 0,1:09:23.02,1:09:27.34,Default,,0,0,0,,但就从完成这两个运算的时间来说
Dialogue: 0,1:09:27.37,1:09:29.22,Default,,0,0,0,,它们都是相同的 对吧？
Dialogue: 0,1:09:29.47,1:09:29.76,Default,,0,0,0,,教授 ：是的
Dialogue: 0,1:09:29.79,1:09:32.68,Default,,0,0,0,,尾递归不会改变任何东西的时间复杂度
Dialogue: 0,1:09:32.72,1:09:33.29,Default,,0,0,0,,因为 从某种意义上来说
Dialogue: 0,1:09:33.34,1:09:35.15,Default,,0,0,0,,两者都是相同的算法
Dialogue: 0,1:09:36.02,1:09:39.37,Default,,0,0,0,,它只是让这个过程迭代地运行
Dialogue: 0,1:09:41.00,1:09:42.64,Default,,0,0,0,,这样 当参数很大时
Dialogue: 0,1:09:42.68,1:09:44.22,Default,,0,0,0,,它不会耗尽所有的内存
Dialogue: 0,1:09:44.75,1:09:46.40,Default,,0,0,0,,因为这其中没有压栈
Dialogue: 0,1:09:48.35,1:09:50.24,Default,,0,0,0,,事实上 你们需要相信
Dialogue: 0,1:09:50.56,1:09:51.13,Default,,0,0,0,,当我们编写--
Dialogue: 0,1:09:51.64,1:09:53.78,Default,,0,0,0,,我们一直把这些代码称作“迭代”
Dialogue: 0,1:09:53.93,1:09:57.99,Default,,0,0,0,,把(DEFINE (LOOP) (LOOP))称作无穷循环
Dialogue: 0,1:10:00.32,1:10:03.36,Default,,0,0,0,,这就是一个迭代
Dialogue: 0,1:10:03.65,1:10:05.66,Default,,0,0,0,,跟我们用DO语句来写无穷循环是一样的
Dialogue: 0,1:10:07.63,1:10:09.28,Default,,0,0,0,,它们只是语法上不同而已
Dialogue: 0,1:10:09.28,1:10:11.32,Default,,0,0,0,,它们实际上都是迭代
Dialogue: 0,1:10:14.73,1:10:16.08,Default,,0,0,0,,它们并不改变时间复杂度
Dialogue: 0,1:10:16.11,1:10:18.53,Default,,0,0,0,,但是它会把它们变成真正的迭代
Dialogue: 0,1:10:21.68,1:10:23.80,Default,,0,0,0,,好吧 下课
Dialogue: 0,1:10:24.25,1:10:40.73,Declare,,0,0,0,,{\fad(500,500)}MIT OpenCourseWare\Nhttp://ocw.mit.edu
Dialogue: 0,1:10:24.25,1:10:40.73,Declare,,0,0,0,,{\an2\fad(500,500)}本项目主页\Nhttps://github.com/DeathKing/Learning-SICP
