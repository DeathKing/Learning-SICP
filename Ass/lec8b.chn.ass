[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 640
PlayResY: 480

[Aegisub Project Garbage]
Audio File: ../../../../Movies/lec8b_480_muxed.mp4
Video File: ../../../../Movies/lec8b_480_muxed.mp4
Video AR Mode: 4
Video AR Value: 1.333333
Video Zoom Percent: 2.000000

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: EN,Calisto MT,21,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,1,0,2,10,10,30,1
Style: Declare,微软雅黑,30,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,2,0,8,10,10,10,1
Style: staff,微软雅黑,30,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,0,2,5,10,10,10,1
Style: title,微软雅黑,35,&H001D64D9,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,0,1,5,10,10,10,1
Style: Default,雅黑宋体,20,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,1,0,2,10,10,30,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.00,0:00:02.14,Declare,,0,0,0,,{\an2\fad(500,500)}Learning-SICP 学习小组\N倾情制作
Dialogue: 0,0:00:02.40,0:00:09.84,title,,0,0,0,,{\fad(600,800)\pos(324,32)}《计算机程序的构造和解释》
Dialogue: 0,0:00:02.40,0:00:09.84,staff,,0,0,0,,{\fad(600,800)\pos(110.666,403.334)}翻译&&时间轴\N邓雄飞\N（Dysprosium）
Dialogue: 0,0:00:02.40,0:00:09.84,staff,,0,0,0,,{\fad(600,800)\pos(534.666,404)}压制&&特效\N邓雄飞\N（Dysprosium）
Dialogue: 0,0:00:02.40,0:00:09.84,staff,,0,0,0,,{\fad(600,800)\pos(574.667,277.333)}校对\N邓雄飞
Dialogue: 0,0:00:02.40,0:00:09.84,staff,,0,0,0,,{\fad(600,800)\pos(89.334,273.333)}特别感谢\N裘宗燕教授
Dialogue: 0,0:00:09.90,0:00:16.04,Declare,,0,0,0,,{\an2\fad(500,500)}逻辑式程序设计 II
Dialogue: 0,0:00:18.91,0:00:21.79,Default,,0,0,0,,我们已经了解了查询语言的使用方式
Dialogue: 0,0:00:22.64,0:00:25.07,Default,,0,0,0,,现在该来讨论如何实现了
Dialogue: 0,0:00:26.28,0:00:27.98,Default,,0,0,0,,你们也应该能够猜到
Dialogue: 0,0:00:28.59,0:00:29.47,Default,,0,0,0,,它其中的原理了
Dialogue: 0,0:00:29.47,0:00:31.64,Default,,0,0,0,,它的最底层是一个模式匹配器
Dialogue: 0,0:00:32.81,0:00:34.25,Default,,0,0,0,,我们在《基于规则的控制语言》一课中
Dialogue: 0,0:00:34.67,0:00:36.94,Default,,0,0,0,,已经介绍过模式匹配器了
Dialogue: 0,0:00:38.11,0:00:40.59,Default,,0,0,0,,我举个例子来让你们温习一下
Dialogue: 0,0:00:41.52,0:00:43.68,Default,,0,0,0,,这个模式会匹配
Dialogue: 0,0:00:43.80,0:00:44.92,Default,,0,0,0,,一个含有三个元素的表
Dialogue: 0,0:00:44.96,0:00:47.10,Default,,0,0,0,,其中 首元素为A
Dialogue: 0,0:00:47.16,0:00:48.33,Default,,0,0,0,,其次是C
Dialogue: 0,0:00:48.48,0:00:50.19,Default,,0,0,0,,而中间可以为任意元素
Dialogue: 0,0:00:50.65,0:00:52.27,Default,,0,0,0,,所以在这个小型的模式匹配语言中
Dialogue: 0,0:00:52.30,0:00:54.05,Default,,0,0,0,,你只能区分一种类型
Dialogue: 0,0:00:54.05,0:00:57.20,Default,,0,0,0,,也就是区分字面量或者变量
Dialogue: 0,0:00:57.23,0:00:58.86,Default,,0,0,0,,以问号开头的就是变量
Dialogue: 0,0:01:01.37,0:01:03.64,Default,,0,0,0,,因此这个模式会匹配任意的三元表
Dialogue: 0,0:01:04.44,0:01:06.50,Default,,0,0,0,,只要它的首元素为A 而第三个元素为C
Dialogue: 0,0:01:06.50,0:01:09.00,Default,,0,0,0,,而这个模式匹配的三元表
Dialogue: 0,0:01:10.43,0:01:12.53,Default,,0,0,0,,它的首元素必须是符号'JOB
Dialogue: 0,0:01:12.53,0:01:13.90,Default,,0,0,0,,第二个元素为任意值
Dialogue: 0,0:01:14.21,0:01:15.90,Default,,0,0,0,,第三个元素必须是一个二元表
Dialogue: 0,0:01:15.95,0:01:17.72,Default,,0,0,0,,二元表的首元素为符号'COMPUTER
Dialogue: 0,0:01:17.88,0:01:19.42,Default,,0,0,0,,第二个元素可以为任意值
Dialogue: 0,0:01:20.48,0:01:25.55,Default,,0,0,0,,而下一条模式所匹配的三元表
Dialogue: 0,0:01:25.87,0:01:26.99,Default,,0,0,0,,区别就在于
Dialogue: 0,0:01:28.40,0:01:31.32,Default,,0,0,0,,在于第三个元素的首元素必须为符号'COMPUTER
Dialogue: 0,0:01:31.76,0:01:33.29,Default,,0,0,0,,表剩余部分可以是任意值
Dialogue: 0,0:01:35.04,0:01:37.53,Default,,0,0,0,,也就是说 上面是二元表 而下面没有限定数目
Dialogue: 0,0:01:37.86,0:01:39.74,Default,,0,0,0,,然而我们的语言实现
Dialogue: 0,0:01:39.85,0:01:42.06,Default,,0,0,0,,根本不用操心如何去实现这个点号
Dialogue: 0,0:01:42.11,0:01:44.17,Default,,0,0,0,,因为这个由Lisp读取器自动地完成
Dialogue: 0,0:01:48.34,0:01:50.31,Default,,0,0,0,,要注意 匹配器还要保持一致性
Dialogue: 0,0:01:50.31,0:01:52.32,Default,,0,0,0,,这个模式匹配一个三元表
Dialogue: 0,0:01:52.59,0:01:53.98,Default,,0,0,0,,表的首元素是A
Dialogue: 0,0:01:54.43,0:01:55.79,Default,,0,0,0,,而第二个元素和第三个元素可以是任意值
Dialogue: 0,0:01:55.80,0:01:57.08,Default,,0,0,0,,但它们必须是相同的
Dialogue: 0,0:01:57.94,0:01:58.84,Default,,0,0,0,,它们都是?X
Dialogue: 0,0:01:59.60,0:02:01.55,Default,,0,0,0,,而这个模式匹配一个四元表
Dialogue: 0,0:02:01.96,0:02:03.26,Default,,0,0,0,,其中第一个元素与第四个元素相同
Dialogue: 0,0:02:03.66,0:02:05.15,Default,,0,0,0,,而第二个元素与第三个元素相同
Dialogue: 0,0:02:05.59,0:02:08.60,Default,,0,0,0,,最后一个模式匹配以A开头的任意表
Dialogue: 0,0:02:09.68,0:02:11.05,Default,,0,0,0,,以A开头
Dialogue: 0,0:02:11.23,0:02:12.56,Default,,0,0,0,,余下的可以是任意值
Dialogue: 0,0:02:14.04,0:02:16.60,Default,,0,0,0,,这是对我们已经学习过的模式匹配语言
Dialogue: 0,0:02:16.62,0:02:17.87,Default,,0,0,0,,的一个回顾
Dialogue: 0,0:02:18.78,0:02:19.64,Default,,0,0,0,,还记得吗
Dialogue: 0,0:02:19.79,0:02:22.28,Default,,0,0,0,,这是由一个叫做MATCH的过程实现的
Dialogue: 0,0:02:24.87,0:02:36.06,Default,,0,0,0,,MATCH有三个参数：PAT、DATA以及DICTIONARY
Dialogue: 0,0:02:43.20,0:02:47.12,Default,,0,0,0,,MATCH考虑的是
Dialogue: 0,0:02:47.79,0:02:52.64,Default,,0,0,0,,利用给定DICTIONAY中的绑定
Dialogue: 0,0:02:53.55,0:02:56.73,Default,,0,0,0,,能够找到一种方法把模式与数据对象匹配起来吗？
Dialogue: 0,0:02:58.16,0:02:59.21,Default,,0,0,0,,比如说
Dialogue: 0,0:02:59.56,0:03:06.43,Default,,0,0,0,,如果我们想要把模式(?X ?Y ?Y ?X)
Dialogue: 0,0:03:07.71,0:03:13.84,Default,,0,0,0,,与数据对象(A B B A)相匹配
Dialogue: 0,0:03:15.12,0:03:20.52,Default,,0,0,0,,又给定了一个字典 X=A
Dialogue: 0,0:03:22.01,0:03:25.23,Default,,0,0,0,,MATCH就会说：“它们是一致的”
Dialogue: 0,0:03:25.26,0:03:27.16,Default,,0,0,0,,再给定的字典说 X=A 的情况下
Dialogue: 0,0:03:27.80,0:03:30.20,Default,,0,0,0,,模式与数据相匹配
Dialogue: 0,0:03:30.32,0:03:31.60,Default,,0,0,0,,而匹配的结果则是
Dialogue: 0,0:03:32.25,0:03:34.30,Default,,0,0,0,,一个扩展了的词典
Dialogue: 0,0:03:34.46,0:03:37.60,Default,,0,0,0,,其中包含 X=A Y=B
Dialogue: 0,0:03:39.49,0:03:42.24,Default,,0,0,0,,MATCH接收模式、数据以及字典
Dialogue: 0,0:03:42.38,0:03:44.54,Default,,0,0,0,,如果成功匹配就输出一个扩展后的词典
Dialogue: 0,0:03:44.97,0:03:46.84,Default,,0,0,0,,否则就报错
Dialogue: 0,0:03:46.84,0:03:47.71,Default,,0,0,0,,因此 比如说
Dialogue: 0,0:03:47.88,0:03:50.38,Default,,0,0,0,,如果我在这里使用同样的模式
Dialogue: 0,0:03:50.97,0:03:55.12,Default,,0,0,0,,如果我用模式(?X ?Y ?Y ?X)
Dialogue: 0,0:03:55.66,0:03:58.49,Default,,0,0,0,,去匹配(A B B A)
Dialogue: 0,0:03:59.47,0:04:02.84,Default,,0,0,0,,并给定词典 Y=A
Dialogue: 0,0:04:05.15,0:04:06.81,Default,,0,0,0,,那么MATCH就会输出FAIL
Dialogue: 0,0:04:12.52,0:04:14.65,Default,,0,0,0,,你们已经见过模式匹配器的代码了
Dialogue: 0,0:04:15.00,0:04:16.17,Default,,0,0,0,,我就不会再去细讲
Dialogue: 0,0:04:16.64,0:04:19.77,Default,,0,0,0,,这跟我们以前做的类似
Dialogue: 0,0:04:21.19,0:04:23.22,Default,,0,0,0,,我们在《基于规则的系统》中已经见过了
Dialogue: 0,0:04:23.22,0:04:24.56,Default,,0,0,0,,基本上是同样的匹配器
Dialogue: 0,0:04:24.95,0:04:27.66,Default,,0,0,0,,实际上 我认为这里的语法还更简单一点
Dialogue: 0,0:04:28.16,0:04:29.31,Default,,0,0,0,,因为我们不用去关心
Dialogue: 0,0:04:29.40,0:04:31.40,Default,,0,0,0,,任意变量、任意表达式之类的东西
Dialogue: 0,0:04:31.40,0:04:32.88,Default,,0,0,0,,这里面只区分变量和常量
Dialogue: 0,0:04:35.79,0:04:37.32,Default,,0,0,0,,那么 有了模式匹配器以后
Dialogue: 0,0:04:38.46,0:04:39.61,Default,,0,0,0,,基本查询又是怎么样的呢？
Dialogue: 0,0:04:42.97,0:04:45.34,Default,,0,0,0,,基本查询将会是一个相当复杂的东西
Dialogue: 0,0:04:46.67,0:05:03.58,Default,,0,0,0,,就拿查询(JOB ?X (?D . ?Y))来说
Dialogue: 0,0:05:07.04,0:05:08.73,Default,,0,0,0,,我们可能会输入这样的查询
Dialogue: 0,0:05:09.40,0:05:11.39,Default,,0,0,0,,这又将如何在系统内实现呢？
Dialogue: 0,0:05:14.14,0:05:15.66,Default,,0,0,0,,我们可以把它想做这个小盒子
Dialogue: 0,0:05:15.70,0:05:16.80,Default,,0,0,0,,这是一条基本查询
Dialogue: 0,0:05:18.88,0:05:20.30,Default,,0,0,0,,这个小盒子将会
Dialogue: 0,0:05:22.24,0:05:27.28,Default,,0,0,0,,以两条流作为输入
Dialogue: 0,0:05:31.96,0:05:33.20,Default,,0,0,0,,并输出一条流
Dialogue: 0,0:05:34.03,0:05:36.19,Default,,0,0,0,,因此一条基本查询的形状
Dialogue: 0,0:05:36.51,0:05:38.46,Default,,0,0,0,,就将是有两条输入流
Dialogue: 0,0:05:38.67,0:05:39.96,Default,,0,0,0,,和一条输出流
Dialogue: 0,0:05:41.12,0:05:46.20,Default,,0,0,0,,而这些流 来自于这里的数据库
Dialogue: 0,0:05:51.95,0:05:53.93,Default,,0,0,0,,因此我们把数据库中的所有数据
Dialogue: 0,0:05:55.93,0:05:57.20,Default,,0,0,0,,想象成一条流
Dialogue: 0,0:05:57.31,0:05:58.40,Default,,0,0,0,,而这个盒子不断地吸取
Dialogue: 0,0:06:00.36,0:06:02.43,Default,,0,0,0,,那么 数据库中有什么呢？
Dialogue: 0,0:06:08.43,0:06:20.32,Default,,0,0,0,,首先是(JOB (ALYSSA ...))
Dialogue: 0,0:06:21.96,0:06:23.71,Default,,0,0,0,,以及还有其它的JOB数据
Dialogue: 0,0:06:25.77,0:06:30.41,Default,,0,0,0,,想象一下 数据库中的所有事实都在这条流中
Dialogue: 0,0:06:32.04,0:06:33.10,Default,,0,0,0,,都到了这里
Dialogue: 0,0:06:33.36,0:06:34.52,Default,,0,0,0,,而这条流送来的
Dialogue: 0,0:06:34.89,0:06:36.52,Default,,0,0,0,,是一些字典
Dialogue: 0,0:06:38.51,0:06:41.40,Default,,0,0,0,,其中一个就可能是
Dialogue: 0,0:06:46.70,0:06:49.31,Default,,0,0,0,,Y=PROG
Dialogue: 0,0:06:55.47,0:06:56.64,Default,,0,0,0,,现在 查询工作就是要
Dialogue: 0,0:06:57.07,0:06:59.80,Default,,0,0,0,,当它从这条流中取得一个字典后
Dialogue: 0,0:07:02.01,0:07:06.67,Default,,0,0,0,,它会搜寻数据库中的东西
Dialogue: 0,0:07:07.45,0:07:10.24,Default,,0,0,0,,来尽可能产生所有匹配结果
Dialogue: 0,0:07:11.39,0:07:12.89,Default,,0,0,0,,它把查询视作一种模式
Dialogue: 0,0:07:13.15,0:07:16.72,Default,,0,0,0,,并将它们与数据库中的事实匹配起来
Dialogue: 0,0:07:16.96,0:07:21.98,Default,,0,0,0,,结合着相应的字典中的数据
Dialogue: 0,0:07:22.94,0:07:25.68,Default,,0,0,0,,找到数据库中所有匹配的结果
Dialogue: 0,0:07:27.55,0:07:29.69,Default,,0,0,0,,所以针对数据库中的每条事实
Dialogue: 0,0:07:29.72,0:07:34.35,Default,,0,0,0,,它都会调用(MATCH PAT FACT DICTIONAY)来检查
Dialogue: 0,0:07:35.11,0:07:37.68,Default,,0,0,0,,如果成功匹配
Dialogue: 0,0:07:38.19,0:07:39.93,Default,,0,0,0,,它就输出一个扩展了的字典
Dialogue: 0,0:07:40.67,0:07:42.32,Default,,0,0,0,,比如说 这里进来了一本字典
Dialogue: 0,0:07:43.00,0:07:44.09,Default,,0,0,0,,并且成功匹配
Dialogue: 0,0:07:44.51,0:07:45.87,Default,,0,0,0,,那么就会输出一本字典
Dialogue: 0,0:07:46.81,0:07:49.79,Default,,0,0,0,,本例中就是Y=PROG
Dialogue: 0,0:07:51.52,0:07:52.97,Default,,0,0,0,,X=...
Dialogue: 0,0:07:56.54,0:07:58.75,Default,,0,0,0,,Y=PROG X=...
Dialogue: 0,0:07:58.96,0:08:00.54,Default,,0,0,0,,D又是一个新的项
Dialogue: 0,0:08:01.72,0:08:02.27,Default,,0,0,0,,像这样扩展
Dialogue: 0,0:08:03.52,0:08:07.82,Default,,0,0,0,,当然 它会针对数据库中的所有事实做同样的尝试
Dialogue: 0,0:08:07.98,0:08:09.25,Default,,0,0,0,,所以就可能有很多的结果
Dialogue: 0,0:08:09.56,0:08:10.59,Default,,0,0,0,,可能会产生另一本字典
Dialogue: 0,0:08:11.28,0:08:17.12,Default,,0,0,0,,其中 Y=PROG X=... D=...
Dialogue: 0,0:08:19.18,0:08:21.55,Default,,0,0,0,,因此 对于每个输入的框架
Dialogue: 0,0:08:21.76,0:08:23.69,Default,,0,0,0,,对于每输入一本字典
Dialogue: 0,0:08:23.72,0:08:25.24,Default,,0,0,0,,它可能输出很多本字典
Dialogue: 0,0:08:26.54,0:08:28.67,Default,,0,0,0,,或者什么也不输出
Dialogue: 0,0:08:30.47,0:08:38.48,Default,,0,0,0,,可能会有一些不匹配的情况 比如X=FOO
Dialogue: 0,0:08:39.02,0:08:40.89,Default,,0,0,0,,这个条目不会匹配任何东西
Dialogue: 0,0:08:41.52,0:08:45.12,Default,,0,0,0,,就这个框架来说 不会向输出流中输出东西
Dialogue: 0,0:08:47.51,0:08:51.28,Default,,0,0,0,,或者你也可以输入一个空框架
Dialogue: 0,0:08:52.91,0:08:56.24,Default,,0,0,0,,空框架是用来
Dialogue: 0,0:08:59.87,0:09:02.33,Default,,0,0,0,,在没有任何约束的情况下
Dialogue: 0,0:09:02.57,0:09:06.14,Default,,0,0,0,,匹配数据库中所有可能的结果
Dialogue: 0,0:09:07.57,0:09:09.16,Default,,0,0,0,,这仅仅代表着
Dialogue: 0,0:09:10.32,0:09:13.87,Default,,0,0,0,,处理你输入的查询 最初所进行的计算
Dialogue: 0,0:09:14.20,0:09:15.56,Default,,0,0,0,,它试图找出所有的匹配
Dialogue: 0,0:09:16.65,0:09:18.83,Default,,0,0,0,,基本查询建立了这种机制
Dialogue: 0,0:09:19.37,0:09:20.57,Default,,0,0,0,,而语言要做的是
Dialogue: 0,0:09:22.75,0:09:24.67,Default,,0,0,0,,当你在顶层输入这条查询时
Dialogue: 0,0:09:24.84,0:09:26.14,Default,,0,0,0,,它基于这种机制
Dialogue: 0,0:09:26.16,0:09:28.35,Default,,0,0,0,,它会输入一本空的字典
Dialogue: 0,0:09:30.86,0:09:32.56,Default,,0,0,0,,而对于输出的每个东西
Dialogue: 0,0:09:33.08,0:09:35.88,Default,,0,0,0,,然后把最初的查询
Dialogue: 0,0:09:36.56,0:09:40.44,Default,,0,0,0,,用不同的字典来实例化
Dialogue: 0,0:09:40.81,0:09:44.36,Default,,0,0,0,,于是实例化后的模式就形成了一条新的流
Dialogue: 0,0:09:44.99,0:09:46.51,Default,,0,0,0,,这就是在终端上打印出来的内容
Dialogue: 0,0:09:48.17,0:09:51.24,Default,,0,0,0,,这也就是其中的基本原理
Dialogue: 0,0:09:53.51,0:09:55.48,Default,,0,0,0,,那么 这又为什么复杂呢？
Dialogue: 0,0:09:57.71,0:10:01.00,Default,,0,0,0,,除了使用这种基于流的方法
Dialogue: 0,0:10:01.37,0:10:04.25,Default,,0,0,0,,你们可以想出很多更简单的方法来组织基本查询
Dialogue: 0,0:10:05.18,0:10:06.09,Default,,0,0,0,,而答案就在于
Dialogue: 0,0:10:07.15,0:10:08.51,Default,,0,0,0,,你们可能已经在想了
Dialogue: 0,0:10:10.86,0:10:14.09,Default,,0,0,0,,答案就是 这种方法能够优雅地
Dialogue: 0,0:10:14.56,0:10:16.76,Default,,0,0,0,,实现组合手段
Dialogue: 0,0:10:17.79,0:10:18.80,Default,,0,0,0,,比如说
Dialogue: 0,0:10:20.65,0:10:22.47,Default,,0,0,0,,假设我还想实现其它的效果
Dialogue: 0,0:10:22.47,0:10:26.96,Default,,0,0,0,,我不只是想查询所有人的工作信息
Dialogue: 0,0:10:27.23,0:10:28.35,Default,,0,0,0,,假设我还想查询
Dialogue: 0,0:10:29.47,0:10:35.92,Default,,0,0,0,,(AND (JOB ?X (?D . ?Y))
Dialogue: 0,0:10:36.80,0:10:47.04,Default,,0,0,0,,(SUPERVIOSR ?X ?Z))
Dialogue: 0,0:10:48.80,0:10:50.67,Default,,0,0,0,,(SUPERVISOR ?X ?Z)这条查询
Dialogue: 0,0:10:51.39,0:10:52.96,Default,,0,0,0,,是另外的一条基本查询
Dialogue: 0,0:10:53.71,0:10:58.43,Default,,0,0,0,,它也有类似的形状——接收一条数据对象流
Dialogue: 0,0:10:59.18,0:11:01.64,Default,,0,0,0,,一条初始字典流
Dialogue: 0,0:11:01.68,0:11:05.52,Default,,0,0,0,,字典是你在进行匹配时 需要遵循的约束
Dialogue: 0,0:11:05.53,0:11:07.44,Default,,0,0,0,,然后它会输出一条字典流
Dialogue: 0,0:11:08.70,0:11:10.80,Default,,0,0,0,,这就是这条基本查询的形状
Dialogue: 0,0:11:11.50,0:11:12.91,Default,,0,0,0,,我又该如何实现AND呢？
Dialogue: 0,0:11:12.91,0:11:13.45,Default,,0,0,0,,其实很简单
Dialogue: 0,0:11:13.45,0:11:14.44,Default,,0,0,0,,把它们连接起来就好了
Dialogue: 0,0:11:14.88,0:11:16.28,Default,,0,0,0,,我把这条查询的输出
Dialogue: 0,0:11:16.96,0:11:18.81,Default,,0,0,0,,连接在这条查询的输入上
Dialogue: 0,0:11:19.83,0:11:21.84,Default,,0,0,0,,然后把这里的字典扇出开来
Dialogue: 0,0:11:26.57,0:11:27.96,Default,,0,0,0,,你们就能发现它是如何工作的了
Dialogue: 0,0:11:29.05,0:11:32.44,Default,,0,0,0,,这里会输出一个框架
Dialogue: 0,0:11:32.51,0:11:36.84,Default,,0,0,0,,其中有X、Y和D的绑定
Dialogue: 0,0:11:37.92,0:11:39.28,Default,,0,0,0,,当后面的查询接收到结果后
Dialogue: 0,0:11:39.29,0:11:41.60,Default,,0,0,0,,当它了解了这些约束后
Dialogue: 0,0:11:42.17,0:11:49.24,Default,,0,0,0,,字典中的是Y、X和D的值
Dialogue: 0,0:11:51.80,0:11:53.08,Default,,0,0,0,,它会搜寻数据库
Dialogue: 0,0:11:53.12,0:11:54.92,Default,,0,0,0,,试图找到有关SUPERVISOR关系的事实
Dialogue: 0,0:11:56.04,0:11:58.51,Default,,0,0,0,,如果找到了的话 它就会输出一些词典
Dialogue: 0,0:11:59.58,0:12:09.34,Default,,0,0,0,,其中有Y、X、D以及Z的绑定
Dialogue: 0,0:12:12.07,0:12:14.09,Default,,0,0,0,,不过要注意
Dialogue: 0,0:12:14.19,0:12:17.24,Default,,0,0,0,,因为这里输入的框架建立了约束
Dialogue: 0,0:12:17.61,0:12:20.28,Default,,0,0,0,,它保证了当你执行AND运算时
Dialogue: 0,0:12:20.49,0:12:24.62,Default,,0,0,0,,这两个X是相同的
Dialogue: 0,0:12:26.47,0:12:28.96,Default,,0,0,0,,这是因为通过这条流输出时
Dialogue: 0,0:12:29.96,0:12:32.65,Default,,0,0,0,,X已经有值了 你要确保匹配的一致性
Dialogue: 0,0:12:34.46,0:12:36.17,Default,,0,0,0,,然后我们想起在MATCH的代码中
Dialogue: 0,0:12:36.19,0:12:38.17,Default,,0,0,0,,有一种操作字典的特殊组织方法
Dialogue: 0,0:12:38.20,0:12:39.82,Default,,0,0,0,,确保了匹配的一致性
Dialogue: 0,0:12:40.92,0:12:41.77,Default,,0,0,0,,这就是AND的实现
Dialogue: 0,0:12:44.08,0:12:46.94,Default,,0,0,0,,关键是要注意它的一般性形状
Dialogue: 0,0:12:48.49,0:12:51.55,Default,,0,0,0,,我们来看看(AND P Q)
Dialogue: 0,0:12:52.88,0:12:55.61,Default,,0,0,0,,这里是P和Q
Dialogue: 0,0:12:57.29,0:12:58.60,Default,,0,0,0,,两条查询的AND
Dialogue: 0,0:13:00.27,0:13:01.19,Default,,0,0,0,,看起来像是这样
Dialogue: 0,0:13:01.19,0:13:04.44,Default,,0,0,0,,每一条查询都通过一条流连接数据库
Dialogue: 0,0:13:04.54,0:13:05.71,Default,,0,0,0,,一条输入流
Dialogue: 0,0:13:06.33,0:13:08.17,Default,,0,0,0,,并输出一条输出流
Dialogue: 0,0:13:10.23,0:13:11.72,Default,,0,0,0,,关键是要注意
Dialogue: 0,0:13:12.20,0:13:15.02,Default,,0,0,0,,如果我在它们周围画一个盒子
Dialogue: 0,0:13:19.26,0:13:23.64,Default,,0,0,0,,这就是(AND P Q)
Dialogue: 0,0:13:25.66,0:13:30.38,Default,,0,0,0,,那么这个盒子也有同样的形状
Dialogue: 0,0:13:32.04,0:13:34.20,Default,,0,0,0,,它也有一条连接数据库的流
Dialogue: 0,0:13:34.20,0:13:35.74,Default,,0,0,0,,但是在内部会扇出开来
Dialogue: 0,0:13:36.60,0:13:37.93,Default,,0,0,0,,但是在外部你看不到
Dialogue: 0,0:13:38.16,0:13:40.64,Default,,0,0,0,,它接收一个流 并输出一个流
Dialogue: 0,0:13:42.06,0:13:43.16,Default,,0,0,0,,这就是AND
Dialogue: 0,0:13:43.57,0:13:45.72,Default,,0,0,0,,类似地 OR可能看起像这样
Dialogue: 0,0:13:46.02,0:13:49.58,Default,,0,0,0,,虽然我没给你们演示过OR的用法
Dialogue: 0,0:13:49.84,0:13:54.70,Default,,0,0,0,,OR会尝试找出P或Q所有匹配的事实
Dialogue: 0,0:13:55.80,0:13:58.07,Default,,0,0,0,,P、Q两条查询都有各自的形状
Dialogue: 0,0:14:04.46,0:14:06.68,Default,,0,0,0,,OR的实现则是
Dialogue: 0,0:14:08.54,0:14:10.91,Default,,0,0,0,,我把来自于数据库的流
Dialogue: 0,0:14:12.50,0:14:13.49,Default,,0,0,0,,扇出开来
Dialogue: 0,0:14:13.49,0:14:16.04,Default,,0,0,0,,把它们分别送给P和Q
Dialogue: 0,0:14:17.44,0:14:21.98,Default,,0,0,0,,我把最初的查询流也给扇出开来
Dialogue: 0,0:14:26.75,0:14:29.16,Default,,0,0,0,,这样我不但能够得到P的所有结果
Dialogue: 0,0:14:29.29,0:14:31.08,Default,,0,0,0,,也能得到Q的所有结果
Dialogue: 0,0:14:31.61,0:14:34.56,Default,,0,0,0,,把这些输出送入某种“附加器”中
Dialogue: 0,0:14:34.62,0:14:37.48,Default,,0,0,0,,或者把它们“合并”到一条流中
Dialogue: 0,0:14:39.64,0:14:40.88,Default,,0,0,0,,然后得到输出
Dialogue: 0,0:14:41.08,0:14:48.24,Default,,0,0,0,,而从外部来看 这整个东西就是OR
Dialogue: 0,0:14:52.35,0:14:54.89,Default,,0,0,0,,同样的 当你们从外部观察它时
Dialogue: 0,0:14:55.07,0:14:56.54,Default,,0,0,0,,你会发现它具有相同的形状
Dialogue: 0,0:15:01.00,0:15:01.61,Default,,0,0,0,,NOT又如何实现呢？
Dialogue: 0,0:15:02.02,0:15:03.45,Default,,0,0,0,,NOT的原理有些类似
Dialogue: 0,0:15:04.31,0:15:05.95,Default,,0,0,0,,如果我有一条查询P
Dialogue: 0,0:15:06.86,0:15:13.50,Default,,0,0,0,,这是一条基本查询P
Dialogue: 0,0:15:14.69,0:15:16.32,Default,,0,0,0,,现在我要实现(NOT P)
Dialogue: 0,0:15:18.68,0:15:20.54,Default,,0,0,0,,NOT的作用像是一个过滤器
Dialogue: 0,0:15:20.72,0:15:21.95,Default,,0,0,0,,这里连接数据库
Dialogue: 0,0:15:23.84,0:15:28.28,Default,,0,0,0,,这里是输入的字典流
Dialogue: 0,0:15:28.78,0:15:31.53,Default,,0,0,0,,(NOT P)要做的就是
Dialogue: 0,0:15:31.88,0:15:37.40,Default,,0,0,0,,对这些东西做过滤
Dialogue: 0,0:15:39.02,0:15:40.09,Default,,0,0,0,,过滤的方法则是
Dialogue: 0,0:15:40.19,0:15:42.70,Default,,0,0,0,,如果我在这里获得了一本字典
Dialogue: 0,0:15:43.42,0:15:44.65,Default,,0,0,0,,那么我就去找所有的匹配
Dialogue: 0,0:15:44.83,0:15:46.48,Default,,0,0,0,,然后丢弃找到的结果
Dialogue: 0,0:15:47.46,0:15:49.93,Default,,0,0,0,,如果我没有在这里找到匹配
Dialogue: 0,0:15:50.12,0:15:51.37,Default,,0,0,0,,我就把它传递过去
Dialogue: 0,0:15:52.40,0:15:53.55,Default,,0,0,0,,NOT就是一个纯粹的过滤器
Dialogue: 0,0:15:55.34,0:15:59.98,Default,,0,0,0,,因此AND就类似于一个电阻
Dialogue: 0,0:15:59.98,0:16:01.85,Default,,0,0,0,,AND是串行的组合
Dialogue: 0,0:16:02.49,0:16:04.14,Default,,0,0,0,,OR是并行组合
Dialogue: 0,0:16:04.96,0:16:07.46,Default,,0,0,0,,然而NOT并不会对字典做任何扩展
Dialogue: 0,0:16:07.46,0:16:08.40,Default,,0,0,0,,它只会做过滤
Dialogue: 0,0:16:08.75,0:16:11.79,Default,,0,0,0,,它会丢弃那些能够匹配的结果
Dialogue: 0,0:16:12.64,0:16:14.19,Default,,0,0,0,,LISP-VALUE的原理类似
Dialogue: 0,0:16:14.84,0:16:16.60,Default,,0,0,0,,它的过滤器会复杂点
Dialogue: 0,0:16:16.60,0:16:17.37,Default,,0,0,0,,因为要应用到谓词上
Dialogue: 0,0:16:19.93,0:16:21.64,Default,,0,0,0,,这里需要注意的关键点是
Dialogue: 0,0:16:21.92,0:16:23.55,Default,,0,0,0,,我们之前也强调过了
Dialogue: 0,0:16:23.64,0:16:25.29,Default,,0,0,0,,就是关于“闭包性质”的思想
Dialogue: 0,0:16:28.22,0:16:31.80,Default,,0,0,0,,我们通过组合手段构建的东西
Dialogue: 0,0:16:31.95,0:16:34.51,Default,,0,0,0,,跟所使用的基本物件
Dialogue: 0,0:16:35.69,0:16:37.58,Default,,0,0,0,,有同样的结构
Dialogue: 0,0:16:39.75,0:16:41.68,Default,,0,0,0,,所以从外面看
Dialogue: 0,0:16:41.71,0:16:43.72,Default,,0,0,0,,查询的AND与基本查询结构相同
Dialogue: 0,0:16:44.63,0:16:46.14,Default,,0,0,0,,这就意味着
Dialogue: 0,0:16:46.94,0:16:50.28,Default,,0,0,0,,这里的盒子可以是AND、OR、NOT或者其它的
Dialogue: 0,0:16:50.30,0:16:54.22,Default,,0,0,0,,因为它具有相同的形状来连接更大的东西
Dialogue: 0,0:16:54.95,0:16:56.68,Default,,0,0,0,,这种思想能够让我们获得
Dialogue: 0,0:16:56.92,0:16:58.96,Default,,0,0,0,,Escher绘图语言中的那种复杂度
Dialogue: 0,0:16:59.55,0:17:01.31,Default,,0,0,0,,让你能够仅仅使用序对
Dialogue: 0,0:17:01.34,0:17:03.26,Default,,0,0,0,,构建出这些复杂结构
Dialogue: 0,0:17:03.93,0:17:04.78,Default,,0,0,0,,这就是“闭包性质”
Dialogue: 0,0:17:06.28,0:17:08.06,Default,,0,0,0,,这种性质
Dialogue: 0,0:17:09.64,0:17:11.72,Default,,0,0,0,,能够让我完成你们现在觉得理所当然的事儿
Dialogue: 0,0:17:11.76,0:17:14.91,Default,,0,0,0,,比如我可以查询(AND JOB SALARY)
Dialogue: 0,0:17:14.91,0:17:18.80,Default,,0,0,0,,当然我也可以查询(AND JOB (NOT ...))等等
Dialogue: 0,0:17:19.26,0:17:20.92,Default,,0,0,0,,这种便利是由
Dialogue: 0,0:17:20.94,0:17:22.91,Default,,0,0,0,,这种“闭包原则”直接带给我们的
Dialogue: 0,0:17:25.18,0:17:27.08,Default,,0,0,0,,好吧 提问时间
Dialogue: 0,0:17:29.32,0:17:30.89,Default,,0,0,0,,学生：字典是从哪里来的？
Dialogue: 0,0:17:30.99,0:17:36.03,Default,,0,0,0,,教授：字典最初来自于你的输入
Dialogue: 0,0:17:36.09,0:17:37.32,Default,,0,0,0,,因此当你最初进行查询时
Dialogue: 0,0:17:39.16,0:17:41.09,Default,,0,0,0,,它首先会建立起这整个结构
Dialogue: 0,0:17:41.09,0:17:42.64,Default,,0,0,0,,它先输入一个空字典
Dialogue: 0,0:17:45.00,0:17:47.24,Default,,0,0,0,,如果你只有一条基本查询的话
Dialogue: 0,0:17:48.24,0:17:51.10,Default,,0,0,0,,那么它就会输出一系列具有内容的字典
Dialogue: 0,0:17:52.31,0:17:54.33,Default,,0,0,0,,这里演示的一般性情况是
Dialogue: 0,0:17:54.51,0:17:59.71,Default,,0,0,0,,某个嵌套组合查询的中间过程
Dialogue: 0,0:18:01.55,0:18:02.30,Default,,0,0,0,,所以在那时
Dialogue: 0,0:18:02.38,0:18:03.79,Default,,0,0,0,,让我们来看看这里
Dialogue: 0,0:18:04.38,0:18:06.73,Default,,0,0,0,,这条SUPERVISOR查询得到了某本字典
Dialogue: 0,0:18:06.73,0:18:08.03,Default,,0,0,0,,这本字典来自于哪里呢？
Dialogue: 0,0:18:08.73,0:18:11.15,Default,,0,0,0,,它来自于
Dialogue: 0,0:18:12.84,0:18:14.89,Default,,0,0,0,,这条基本查询的输出
Dialogue: 0,0:18:16.26,0:18:17.88,Default,,0,0,0,,说得更具体一点
Dialogue: 0,0:18:18.35,0:18:21.72,Default,,0,0,0,,如果我最初在顶层只输入了这条查询
Dialogue: 0,0:18:22.27,0:18:22.92,Default,,0,0,0,,这整条AND查询
Dialogue: 0,0:18:23.07,0:18:25.28,Default,,0,0,0,,它实际上会构建这种结构
Dialogue: 0,0:18:25.50,0:18:30.24,Default,,0,0,0,,并使用一本空字典来启动整个过程
Dialogue: 0,0:18:31.77,0:18:34.33,Default,,0,0,0,,处理过程开始后 会产生一系列的字典
Dialogue: 0,0:18:34.36,0:18:37.36,Default,,0,0,0,,其中就有X、Y以及D
Dialogue: 0,0:18:38.64,0:18:39.58,Default,,0,0,0,,向这边传递
Dialogue: 0,0:18:40.19,0:18:42.16,Default,,0,0,0,,这就是这条查询的输入
Dialogue: 0,0:18:42.16,0:18:43.72,Default,,0,0,0,,这条查询也会生成其它的东西
Dialogue: 0,0:18:45.04,0:18:48.22,Default,,0,0,0,,如果这整个查询是构建在一个更大的查询中的话
Dialogue: 0,0:18:49.31,0:18:51.00,Default,,0,0,0,,比如说一条OR查询
Dialogue: 0,0:18:53.42,0:18:55.71,Default,,0,0,0,,那么它将输出到下一个查询中
Dialogue: 0,0:18:58.56,0:19:01.28,Default,,0,0,0,,因此最初开始处理时 只有一本空字典
Dialogue: 0,0:19:01.68,0:19:04.08,Default,,0,0,0,,但是在处理这些复合查询的过程中
Dialogue: 0,0:19:04.11,0:19:06.65,Default,,0,0,0,,会生成各种不同的字典
Dialogue: 0,0:19:07.66,0:19:12.28,Default,,0,0,0,,学生：字典都是查询的结果吗？
Dialogue: 0,0:19:15.12,0:19:17.69,Default,,0,0,0,,它们会变成
Dialogue: 0,0:19:18.84,0:19:22.81,Default,,0,0,0,,它们存储在数据库中吗？
Dialogue: 0,0:19:23.68,0:19:24.98,Default,,0,0,0,,它们是临时数据吗？
Dialogue: 0,0:19:24.98,0:19:27.18,Default,,0,0,0,,教授：它们是在MATCH过程中临时创建的
Dialogue: 0,0:19:28.03,0:19:29.88,Default,,0,0,0,,但它们实际存放在内存中
Dialogue: 0,0:19:29.88,0:19:33.02,Default,,0,0,0,,最初 某人创建了一本THE-EMPTY-DICT字典
Dialogue: 0,0:19:34.22,0:19:36.80,Default,,0,0,0,,送入这个匹配过程
Dialogue: 0,0:19:36.81,0:19:39.05,Default,,0,0,0,,MATCH过程据此构建新字典
Dialogue: 0,0:19:39.07,0:19:40.27,Default,,0,0,0,,并把它们传递下去
Dialogue: 0,0:19:40.76,0:19:42.48,Default,,0,0,0,,学生：因此匹配完成后它们就被丢弃了？
Dialogue: 0,0:19:43.64,0:19:46.25,Default,,0,0,0,,教授：实际上 当没人需要它们后（就被废料回收了）
Dialogue: 0,0:19:51.90,0:19:53.60,Default,,0,0,0,,学生：似乎AND查询对数据库
Dialogue: 0,0:19:53.63,0:19:55.37,Default,,0,0,0,,进行了一些冗余操作
Dialogue: 0,0:19:55.96,0:19:57.48,Default,,0,0,0,,如果第一条子句扫描过了
Dialogue: 0,0:19:57.50,0:19:59.90,Default,,0,0,0,,比如说前两个元素没有匹配 而第三个元素匹配了
Dialogue: 0,0:20:00.25,0:20:03.64,Default,,0,0,0,,然而第二条子句又会检查这两个元素
Dialogue: 0,0:20:04.32,0:20:06.59,Default,,0,0,0,,然后又一次丢弃这些不匹配的元素
Dialogue: 0,0:20:06.64,0:20:08.72,Default,,0,0,0,,而字典中已经有匹配的项了
Dialogue: 0,0:20:10.00,0:20:12.56,Default,,0,0,0,,如果我们把数据库中的数据
Dialogue: 0,0:20:12.57,0:20:14.43,Default,,0,0,0,,跟字典同时传递 这样可行么？
Dialogue: 0,0:20:15.69,0:20:17.60,Default,,0,0,0,,教授：实际上 通常来说
Dialogue: 0,0:20:17.63,0:20:19.48,Default,,0,0,0,,我们能够以其它方式来安排这些搜索
Dialogue: 0,0:20:20.12,0:20:21.74,Default,,0,0,0,,你也可以做一些分析
Dialogue: 0,0:20:21.74,0:20:23.16,Default,,0,0,0,,我记得书里面就有这样的习题
Dialogue: 0,0:20:23.87,0:20:26.65,Default,,0,0,0,,是考察通过安排AND子句的顺序
Dialogue: 0,0:20:27.00,0:20:29.20,Default,,0,0,0,,来消除不同类型的冗余
Dialogue: 0,0:20:29.85,0:20:30.72,Default,,0,0,0,,而这里只是为了
Dialogue: 0,0:20:31.32,0:20:34.54,Default,,0,0,0,,用非常简单的情况来向你们展示它们是如何配合的
Dialogue: 0,0:20:34.70,0:20:35.38,Default,,0,0,0,,但是你说得非常对
Dialogue: 0,0:20:35.38,0:20:37.32,Default,,0,0,0,,这些冗余是可以避免的
Dialogue: 0,0:20:38.37,0:20:40.80,Default,,0,0,0,,这也是这门语言缓慢的原因之一
Dialogue: 0,0:20:41.19,0:20:42.70,Default,,0,0,0,,你们可以让它变得更聪明
Dialogue: 0,0:20:42.93,0:20:46.22,Default,,0,0,0,,我只是为了向你们演示非常简单的、原理性的实现
Dialogue: 0,0:20:51.22,0:20:53.23,Default,,0,0,0,,学生：您是根据Prolog来建模这门语言的
Dialogue: 0,0:20:53.24,0:20:55.13,Default,,0,0,0,,还是说它只是偶然地像Prolog？
Dialogue: 0,0:21:04.96,0:21:07.08,Default,,0,0,0,,教授：Gerry教授昨天羞辱了一大堆人
Dialogue: 0,0:21:07.24,0:21:09.92,Default,,0,0,0,,我想说真实的情况是
Dialogue: 0,0:21:10.19,0:21:12.60,Default,,0,0,0,,MIT的研究人员在1971年做了类似的事
Dialogue: 0,0:21:12.64,0:21:15.60,Default,,0,0,0,,但是发现这个方向并不正确 并停止了研究
Dialogue: 0,0:21:16.12,0:21:22.80,Default,,0,0,0,,因此我们是根据查询处理的基本原理建模的
Dialogue: 0,0:21:22.84,0:21:24.73,Default,,0,0,0,,大概在1971年左右
Dialogue: 0,0:21:25.13,0:21:27.24,Default,,0,0,0,,只是说 那时候我们还没有用流来实现
Dialogue: 0,0:21:28.27,0:21:33.04,Default,,0,0,0,,然后我们 -- 但我们使用了它差不多六个月后
Dialogue: 0,0:21:33.08,0:21:34.91,Default,,0,0,0,,发现它存在各种各样的问题
Dialogue: 0,0:21:34.94,0:21:36.30,Default,,0,0,0,,稍后我会解释
Dialogue: 0,0:21:37.33,0:21:38.19,Default,,0,0,0,,然后我们就想
Dialogue: 0,0:21:38.44,0:21:39.92,Default,,0,0,0,,Prolog一定解决了这些问题
Dialogue: 0,0:21:39.93,0:21:41.21,Default,,0,0,0,,但却发现它并没有
Dialogue: 0,0:21:41.25,0:21:43.02,Default,,0,0,0,,从这种意义上来说 它确实跟Prolog一样
Dialogue: 0,0:21:43.60,0:21:44.95,Default,,0,0,0,,学生：Prolog基于流么？
Dialogue: 0,0:21:44.95,0:21:46.20,Default,,0,0,0,,教授：不 Prolog基于的是
Dialogue: 0,0:21:46.78,0:21:51.04,Default,,0,0,0,,就行为上来说 我们的语言很像Prolog
Dialogue: 0,0:21:51.04,0:21:52.96,Default,,0,0,0,,Prolog使用回溯策略
Dialogue: 0,0:21:53.80,0:21:55.71,Default,,0,0,0,,但是Prolog有一个优点非常好
Dialogue: 0,0:21:55.72,0:21:57.98,Default,,0,0,0,,也使得它变得实用
Dialogue: 0,0:21:58.28,0:22:01.50,Default,,0,0,0,,你知道吗
Dialogue: 0,0:22:01.68,0:22:04.09,Default,,0,0,0,,它们精心设计了Prolog的编译器
Dialogue: 0,0:22:04.11,0:22:05.32,Default,,0,0,0,,使得它能够高速运行
Dialogue: 0,0:22:06.65,0:22:10.81,Default,,0,0,0,,因此 虽然我们这门语言非常缓慢地输出答案
Dialogue: 0,0:22:11.66,0:22:13.61,Default,,0,0,0,,真正的Prolog程序却运行得非常快
Dialogue: 0,0:22:14.70,0:22:16.48,Default,,0,0,0,,这是因为 尽管搜索过程十分低效
Dialogue: 0,0:22:16.67,0:22:20.81,Default,,0,0,0,,Prolog卓越的编译器也会高效地完成工作
Dialogue: 0,0:22:24.30,0:22:25.21,Default,,0,0,0,,休息一下吧
Dialogue: 0,0:22:25.42,0:22:36.17,Default,,0,0,0,,[音乐]
Dialogue: 0,0:22:36.35,0:22:39.87,Declare,,0,0,0,,{\an2\fad(500,500)}《计算机程序的构造和解释》
Dialogue: 0,0:23:01.48,0:23:05.12,Declare,,0,0,0,,{\an2\fad(500,500)}讲师：哈罗德·艾伯森教授 及 格兰德·杰·萨斯曼教授
Dialogue: 0,0:23:05.18,0:23:09.05,Declare,,0,0,0,,{\an2\fad(500,500)}《计算机程序的构造和解释》
Dialogue: 0,0:23:09.12,0:23:13.66,Declare,,0,0,0,,{\an2\fad(500,500)}逻辑式程序设计 II
Dialogue: 0,0:23:16.65,0:23:18.83,Default,,0,0,0,,我们已经考察过了基本查询
Dialogue: 0,0:23:19.21,0:23:23.52,Default,,0,0,0,,以及如何使用流来实现组合手段
Dialogue: 0,0:23:23.79,0:23:25.72,Default,,0,0,0,,AND、OR以及NOT
Dialogue: 0,0:23:26.95,0:23:28.43,Default,,0,0,0,,现在 该讨论抽象手段了
Dialogue: 0,0:23:29.58,0:23:32.80,Default,,0,0,0,,回想一下 我们这门语言的抽象手段是RULE
Dialogue: 0,0:23:35.15,0:23:37.79,Default,,0,0,0,,(BOSS ?Z ?D)描述的是
Dialogue: 0,0:23:39.18,0:23:43.77,Default,,0,0,0,,如果某人在D部门工作
Dialogue: 0,0:23:45.68,0:23:47.47,Default,,0,0,0,,并且Z是X的上司
Dialogue: 0,0:23:48.90,0:23:50.60,Default,,0,0,0,,这就是所谓的“BOSS”
Dialogue: 0,0:23:52.26,0:23:53.15,Default,,0,0,0,,并且 实际上
Dialogue: 0,0:23:53.34,0:23:55.61,Default,,0,0,0,,如果我们考察一下编写的规则与这边的关系
Dialogue: 0,0:23:56.80,0:23:57.90,Default,,0,0,0,,这是我们编写的查询
Dialogue: 0,0:23:57.93,0:24:01.90,Default,,0,0,0,,这个是(JOB ?X ?D) 而这个是(SUPERVISOR ?X ?Z)
Dialogue: 0,0:24:02.19,0:24:04.28,Default,,0,0,0,,我们实际想要把这一大堆东西
Dialogue: 0,0:24:05.07,0:24:06.57,Default,,0,0,0,,用一个盒子封装起来
Dialogue: 0,0:24:19.08,0:24:24.54,Default,,0,0,0,,然后把这个盒子里的所有东西
Dialogue: 0,0:24:25.15,0:24:32.48,Default,,0,0,0,,认为是(BOSS ?Z ?D)
Dialogue: 0,0:24:33.90,0:24:35.25,Default,,0,0,0,,这是我们想要达到的效果
Dialogue: 0,0:24:38.72,0:24:39.72,Default,,0,0,0,,因此 比如说
Dialogue: 0,0:24:43.18,0:24:44.08,Default,,0,0,0,,我们这样做了过后
Dialogue: 0,0:24:45.00,0:24:47.84,Default,,0,0,0,,我们想要检查
Dialogue: 0,0:24:47.95,0:24:50.51,Default,,0,0,0,,Ben Bitdiddle是否为计算机分部的BOSS
Dialogue: 0,0:24:51.10,0:25:02.86,Default,,0,0,0,,如果我想查询 (BOSS (BITDIDDLE BEN) COMPUTER)
Dialogue: 0,0:25:04.78,0:25:07.08,Default,,0,0,0,,想象一下把这条查询输入系统
Dialogue: 0,0:25:07.12,0:25:09.16,Default,,0,0,0,,实际上发生的是
Dialogue: 0,0:25:10.67,0:25:12.92,Default,,0,0,0,,在这里先构建一本字典
Dialogue: 0,0:25:15.82,0:25:23.63,Default,,0,0,0,,其中 ?Z=BITDIDDLE
Dialogue: 0,0:25:28.88,0:25:33.31,Default,,0,0,0,,?D=COMPUTER
Dialogue: 0,0:25:37.08,0:25:38.62,Default,,0,0,0,,这个字典又是来自于哪里呢？
Dialogue: 0,0:25:38.68,0:25:40.71,Default,,0,0,0,,我们来看下幻灯片
Dialogue: 0,0:25:40.71,0:25:43.71,Default,,0,0,0,,这本字典是通过把
Dialogue: 0,0:25:44.30,0:25:46.33,Default,,0,0,0,,查询(BOSS (BITDIDDLE BEN) COMPUTER)
Dialogue: 0,0:25:46.51,0:25:49.63,Default,,0,0,0,,与规则的结论(BOSS ?Z ?D)相匹配得到
Dialogue: 0,0:25:51.65,0:25:54.11,Default,,0,0,0,,所以我们把规则的结论和查询匹配了起来
Dialogue: 0,0:25:54.19,0:25:55.53,Default,,0,0,0,,这样我们就获得了一本字典
Dialogue: 0,0:25:58.99,0:26:02.54,Default,,0,0,0,,现在我们就要把这本字典输入到这整个结构中
Dialogue: 0,0:26:02.92,0:26:05.56,Default,,0,0,0,,进行处理 并观察是否有输出
Dialogue: 0,0:26:06.67,0:26:09.88,Default,,0,0,0,,如果输出了结果 那么查询就为真
Dialogue: 0,0:26:11.33,0:26:12.37,Default,,0,0,0,,这是基本的思想
Dialogue: 0,0:26:12.37,0:26:13.24,Default,,0,0,0,,因此 通常来说
Dialogue: 0,0:26:14.03,0:26:15.40,Default,,0,0,0,,我们实现规则的方法就是
Dialogue: 0,0:26:15.85,0:26:18.89,Default,,0,0,0,,用规则的结论去匹配
Dialogue: 0,0:26:20.86,0:26:22.96,Default,,0,0,0,,假设为真的查询
Dialogue: 0,0:26:23.58,0:26:25.12,Default,,0,0,0,,这个过程会产生一本字典
Dialogue: 0,0:26:25.29,0:26:28.22,Default,,0,0,0,,在有了相关字典后
Dialogue: 0,0:26:30.35,0:26:34.51,Default,,0,0,0,,我们来处理规则的体
Dialogue: 0,0:26:36.33,0:26:37.68,Default,,0,0,0,,基本上就是这样了
Dialogue: 0,0:26:38.64,0:26:41.44,Default,,0,0,0,,但还有两个技术点
Dialogue: 0,0:26:43.04,0:26:44.32,Default,,0,0,0,,首先就是
Dialogue: 0,0:26:45.74,0:26:47.26,Default,,0,0,0,,我也可能有其它的问法
Dialogue: 0,0:26:47.51,0:26:48.41,Default,,0,0,0,,比如说
Dialogue: 0,0:26:50.54,0:26:52.36,Default,,0,0,0,,查询计算机分部的BOSS
Dialogue: 0,0:26:52.54,0:26:56.32,Default,,0,0,0,,就可以查询 (BOSS ?WHO COMPUTER)
Dialogue: 0,0:27:00.78,0:27:01.63,Default,,0,0,0,,这样做了以后
Dialogue: 0,0:27:02.57,0:27:04.62,Default,,0,0,0,,我真正想要做的
Dialogue: 0,0:27:05.04,0:27:06.49,Default,,0,0,0,,就是先建立一本字典
Dialogue: 0,0:27:08.35,0:27:09.88,Default,,0,0,0,,其中有一些约束
Dialogue: 0,0:27:09.93,0:27:11.20,Default,,0,0,0,,比如 ?D=COMPUTER
Dialogue: 0,0:27:14.35,0:27:18.48,Default,,0,0,0,,而?Z等同于?WHO
Dialogue: 0,0:27:21.70,0:27:23.22,Default,,0,0,0,,我们的匹配器不会那么做
Dialogue: 0,0:27:23.22,0:27:27.00,Default,,0,0,0,,这不是模式和数据的匹配方式
Dialogue: 0,0:27:28.58,0:27:29.72,Default,,0,0,0,,这是在匹配两个模式
Dialogue: 0,0:27:29.74,0:27:31.58,Default,,0,0,0,,并判断它们是否一致
Dialogue: 0,0:27:31.90,0:27:33.48,Default,,0,0,0,,又是什么使它们不一致
Dialogue: 0,0:27:33.48,0:27:36.43,Default,,0,0,0,,换句话说 我们需要的不是一个模式匹配器
Dialogue: 0,0:27:36.96,0:27:38.91,Default,,0,0,0,,而是一种更一般性的东西
Dialogue: 0,0:27:39.13,0:27:40.11,Default,,0,0,0,,就是“合一”算法
Dialogue: 0,0:27:44.42,0:27:48.06,Default,,0,0,0,,“合一”是更为一般化的模式匹配算法
Dialogue: 0,0:27:49.53,0:27:52.17,Default,,0,0,0,,合一算法接收两条模式
Dialogue: 0,0:27:53.23,0:27:57.53,Default,,0,0,0,,它考虑的是：可以找到哪些一般性的元素
Dialogue: 0,0:27:58.20,0:28:00.01,Default,,0,0,0,,用来代换模式中的变量
Dialogue: 0,0:28:02.68,0:28:05.08,Default,,0,0,0,,使得它俩能够同时满足
Dialogue: 0,0:28:05.68,0:28:06.60,Default,,0,0,0,,让我来举个例子
Dialogue: 0,0:28:08.86,0:28:14.49,Default,,0,0,0,,我有一个含有两个元素的模式：(?X ?X)
Dialogue: 0,0:28:15.76,0:28:17.15,Default,,0,0,0,,它描述的是一个二元表
Dialogue: 0,0:28:17.32,0:28:18.64,Default,,0,0,0,,不管元素具体是什么
Dialogue: 0,0:28:18.67,0:28:20.04,Default,,0,0,0,,但两个元素是相同的
Dialogue: 0,0:28:20.40,0:28:22.83,Default,,0,0,0,,我把它与另一个模式进行“合一”
Dialogue: 0,0:28:22.92,0:28:24.62,Default,,0,0,0,,后者描述的是一个二元表
Dialogue: 0,0:28:24.65,0:28:27.61,Default,,0,0,0,,首元素一张由A、?Y、C构成的表
Dialogue: 0,0:28:28.00,0:28:30.14,Default,,0,0,0,,而第二个元素是由A、B、?Z构成的表
Dialogue: 0,0:28:33.07,0:28:34.88,Default,,0,0,0,,那么 合一算法能够告诉我
Dialogue: 0,0:28:34.89,0:28:36.17,Default,,0,0,0,,在生成的字典中
Dialogue: 0,0:28:36.35,0:28:37.96,Default,,0,0,0,,?X必须是(A B C)
Dialogue: 0,0:28:39.34,0:28:41.92,Default,,0,0,0,,?Y必须为B ?Z必须为C
Dialogue: 0,0:28:43.44,0:28:46.28,Default,,0,0,0,,这些是我必须对X、Y以及Z施加的约束
Dialogue: 0,0:28:46.33,0:28:47.58,Default,,0,0,0,,以便让两个模式合一
Dialogue: 0,0:28:48.12,0:28:50.84,Default,,0,0,0,,或者换句话来说 让它匹配这个?X
Dialogue: 0,0:28:51.15,0:28:53.37,Default,,0,0,0,,让它匹配这个?X
Dialogue: 0,0:28:55.28,0:28:57.76,Default,,0,0,0,,合一算法需要能够推断出这些
Dialogue: 0,0:28:58.54,0:29:01.08,Default,,0,0,0,,但是合一算法也会遇到复杂的情况
Dialogue: 0,0:29:01.08,0:29:03.07,Default,,0,0,0,,我可能会询问一些复杂的查询
Dialogue: 0,0:29:03.48,0:29:05.74,Default,,0,0,0,,比如这是一个二元表
Dialogue: 0,0:29:07.00,0:29:08.28,Default,,0,0,0,,其中的元素都是相同的
Dialogue: 0,0:29:08.86,0:29:11.15,Default,,0,0,0,,它要与这个模式进行合一
Dialogue: 0,0:29:12.65,0:29:15.36,Default,,0,0,0,,合一算法也要能够从中推断出
Dialogue: 0,0:29:16.89,0:29:19.57,Default,,0,0,0,,?Y必须为B
Dialogue: 0,0:29:19.57,0:29:22.12,Default,,0,0,0,,因为这两个是一样的
Dialogue: 0,0:29:22.22,0:29:23.52,Default,,0,0,0,,因此?Y就是B
Dialogue: 0,0:29:24.34,0:29:27.53,Default,,0,0,0,,这里 ?V应该为A
Dialogue: 0,0:29:28.94,0:29:30.99,Default,,0,0,0,,只要?Z和?W取值相同
Dialogue: 0,0:29:31.00,0:29:32.43,Default,,0,0,0,,它们就可以是任意值
Dialogue: 0,0:29:35.71,0:29:41.76,Default,,0,0,0,,?X就应该是(B A ?W) 其中?W为任意值
Dialogue: 0,0:29:42.83,0:29:44.68,Default,,0,0,0,,或者是?Z -- 因为?Z和?W是一致的
Dialogue: 0,0:29:44.70,0:29:49.42,Default,,0,0,0,,发现了么 合一算法需要从这些模式中推断出信息
Dialogue: 0,0:29:50.88,0:29:53.52,Default,,0,0,0,,所以你们可能认为 这其中有某种魔法般的推理
Dialogue: 0,0:29:54.27,0:29:55.23,Default,,0,0,0,,但其实并不是
Dialogue: 0,0:29:55.85,0:29:59.88,Default,,0,0,0,,合一算法基本上只是对模式匹配的小小修改
Dialogue: 0,0:30:00.15,0:30:01.85,Default,,0,0,0,,如果你们翻阅教材 就会发现
Dialogue: 0,0:30:02.25,0:30:06.16,Default,,0,0,0,,在模式匹配算法中加入了三到四行代码
Dialogue: 0,0:30:06.49,0:30:08.17,Default,,0,0,0,,来处理对称的情况
Dialogue: 0,0:30:08.28,0:30:10.81,Default,,0,0,0,,还记得吗 模式匹配中有一处代码判断
Dialogue: 0,0:30:11.66,0:30:14.28,Default,,0,0,0,,这个变量匹配一个常量吗？
Dialogue: 0,0:30:14.98,0:30:16.42,Default,,0,0,0,,如果是的话 就在字典中进行检查
Dialogue: 0,0:30:16.42,0:30:18.25,Default,,0,0,0,,在合一算法中只有另一条子句
Dialogue: 0,0:30:18.49,0:30:20.75,Default,,0,0,0,,它判断两个变量是否相匹配
Dialogue: 0,0:30:22.00,0:30:23.42,Default,,0,0,0,,这种情况下你去查询字典
Dialogue: 0,0:30:23.45,0:30:25.68,Default,,0,0,0,,看它们在字典的约束下是否一致
Dialogue: 0,0:30:27.03,0:30:31.13,Default,,0,0,0,,因此 这门语言中的所有“推断”
Dialogue: 0,0:30:31.28,0:30:34.59,Default,,0,0,0,,你会发现它蕴含在规则应用中
Dialogue: 0,0:30:34.99,0:30:37.88,Default,,0,0,0,,更进一步地考察 你会发现在合一算法中
Dialogue: 0,0:30:38.36,0:30:40.32,Default,,0,0,0,,如果更进一步地用“显微镜”观察
Dialogue: 0,0:30:40.56,0:30:43.96,Default,,0,0,0,,基本上就在模式匹配算法中
Dialogue: 0,0:30:44.94,0:30:47.07,Default,,0,0,0,,这其中并没有什么魔法
Dialogue: 0,0:30:47.41,0:30:50.25,Default,,0,0,0,,而你们所见到的“推断”
Dialogue: 0,0:30:50.94,0:30:52.89,Default,,0,0,0,,只是因为其中的递归
Dialogue: 0,0:30:52.92,0:30:55.69,Default,,0,0,0,,它一点一点地回绕MATCH过程
Dialogue: 0,0:30:56.03,0:30:58.03,Default,,0,0,0,,它让这个过程看起来很聪明
Dialogue: 0,0:30:58.44,0:31:00.36,Default,,0,0,0,,但它实际上并不是那么聪明
Dialogue: 0,0:31:02.14,0:31:04.41,Default,,0,0,0,,当然 合一算法需要聪明地识别出一些情况
Dialogue: 0,0:31:04.88,0:31:05.87,Default,,0,0,0,,我来举个例子吧
Dialogue: 0,0:31:11.07,0:31:13.36,Default,,0,0,0,,假设我想要用一个二元表进行合一
Dialogue: 0,0:31:13.48,0:31:14.81,Default,,0,0,0,,(?X ?X)
Dialogue: 0,0:31:17.24,0:31:22.14,Default,,0,0,0,,另一个模式则是 (?Y (a . ?Y))
Dialogue: 0,0:31:24.37,0:31:26.12,Default,,0,0,0,,现在 如果你想一想它所表达的意思
Dialogue: 0,0:31:26.86,0:31:29.71,Default,,0,0,0,,它表示了?X应该跟?Y一致
Dialogue: 0,0:31:30.92,0:31:31.66,Default,,0,0,0,,同时呢
Dialogue: 0,0:31:31.82,0:31:36.16,Default,,0,0,0,,?X又应该跟(A . ?Y)相同
Dialogue: 0,0:31:37.33,0:31:39.45,Default,,0,0,0,,如果你仔细思考它成立的条件
Dialogue: 0,0:31:42.27,0:31:44.71,Default,,0,0,0,,你会发现 ?Y必须是一个由A构成的无穷表
Dialogue: 0,0:31:47.50,0:31:48.35,Default,,0,0,0,,从某种角度来说
Dialogue: 0,0:31:49.21,0:31:52.40,Default,,0,0,0,,为了完成这样的合一
Dialogue: 0,0:31:52.60,0:31:54.84,Default,,0,0,0,,我需要求解一个不动点方程
Dialogue: 0,0:31:55.05,0:32:01.84,Default,,0,0,0,,(CONS 'A Y)=Y
Dialogue: 0,0:32:04.57,0:32:06.96,Default,,0,0,0,,通常来说 --- 我这个例子很简单
Dialogue: 0,0:32:07.29,0:32:08.67,Default,,0,0,0,,但实际进行合一时
Dialogue: 0,0:32:08.97,0:32:11.98,Default,,0,0,0,,我们可能要求解一个任意的不动点方程
Dialogue: 0,0:32:12.01,0:32:13.42,Default,,0,0,0,,(F Y)=Y
Dialogue: 0,0:32:15.53,0:32:17.08,Default,,0,0,0,,你基本上不能保证
Dialogue: 0,0:32:17.10,0:32:19.47,Default,,0,0,0,,在有穷时间内找到解
Dialogue: 0,0:32:20.57,0:32:23.60,Default,,0,0,0,,我们的逻辑语言又该如何处理这类情况呢？
Dialogue: 0,0:32:24.89,0:32:26.48,Default,,0,0,0,,答案就是：“不处理”
Dialogue: 0,0:32:27.16,0:32:28.04,Default,,0,0,0,,它会撒手不干
Dialogue: 0,0:32:28.73,0:32:31.07,Default,,0,0,0,,合一算法中有一处小检查
Dialogue: 0,0:32:31.31,0:32:33.82,Default,,0,0,0,,用来判断是否为困难的情况
Dialogue: 0,0:32:34.44,0:32:38.00,Default,,0,0,0,,也就是 匹配这些东西需要求解不动点方程
Dialogue: 0,0:32:38.65,0:32:40.81,Default,,0,0,0,,遇到这类情况 我就撒手不干
Dialogue: 0,0:32:42.84,0:32:44.65,Default,,0,0,0,,如果不进行这样的检查
Dialogue: 0,0:32:45.00,0:32:45.88,Default,,0,0,0,,会发生什么情况？
Dialogue: 0,0:32:47.99,0:32:49.10,Default,,0,0,0,,大多数情况就是
Dialogue: 0,0:32:49.13,0:32:51.31,Default,,0,0,0,,合一算法会陷入无穷循环
Dialogue: 0,0:32:53.74,0:32:56.54,Default,,0,0,0,,其它的逻辑语言有类似的工作原理
Dialogue: 0,0:32:56.80,0:32:58.14,Default,,0,0,0,,因此这其中没有什么魔法
Dialogue: 0,0:32:58.22,0:32:59.93,Default,,0,0,0,,简单的情况由匹配器完成
Dialogue: 0,0:33:00.10,0:33:01.58,Default,,0,0,0,,困难的情况根本不去处理
Dialogue: 0,0:33:02.96,0:33:05.47,Default,,0,0,0,,这就是这种技术的现状
Dialogue: 0,0:33:11.88,0:33:14.24,Default,,0,0,0,,现在 我来形式化地描述一下
Dialogue: 0,0:33:14.27,0:33:16.38,Default,,0,0,0,,规则系统的运行原理 -- 也就是合一算法
Dialogue: 0,0:33:17.39,0:33:18.75,Default,,0,0,0,,因此 正式的定义就是
Dialogue: 0,0:33:19.20,0:33:20.96,Default,,0,0,0,,应用一条规则
Dialogue: 0,0:33:24.17,0:33:27.13,Default,,0,0,0,,我们需要使用一些之前的术语
Dialogue: 0,0:33:28.27,0:33:32.01,Default,,0,0,0,,我们把向查询的盒子中
Dialogue: 0,0:33:32.88,0:33:34.78,Default,,0,0,0,,塞入字典称作是
Dialogue: 0,0:33:34.81,0:33:38.54,Default,,0,0,0,,相对一个环境或者框架
Dialogue: 0,0:33:39.95,0:33:43.85,Default,,0,0,0,,对这些大型查询求值
Dialogue: 0,0:33:43.85,0:33:45.04,Default,,0,0,0,,因此 当我们谈及“字典”的时候
Dialogue: 0,0:33:45.07,0:33:46.28,Default,,0,0,0,,“字典”究竟是什么？
Dialogue: 0,0:33:46.72,0:33:48.18,Default,,0,0,0,,它是符号的一系列语义
Dialogue: 0,0:33:48.18,0:33:50.22,Default,,0,0,0,,我们把它叫做“框架”或者“环境”
Dialogue: 0,0:33:51.80,0:33:55.97,Default,,0,0,0,,根据环境进行操作 又是什么？
Dialogue: 0,0:33:55.97,0:33:57.42,Default,,0,0,0,,我们把这个叫做“求值”
Dialogue: 0,0:33:58.33,0:34:01.56,Default,,0,0,0,,因此我们就说 应用一条规则的方法是
Dialogue: 0,0:34:01.92,0:34:06.16,Default,,0,0,0,,先通过将给定的查询与规则的结论合一 得到环境
Dialogue: 0,0:34:06.67,0:34:11.58,Default,,0,0,0,,再在该环境中求值相应规则的体
Dialogue: 0,0:34:13.23,0:34:14.51,Default,,0,0,0,,我想要让你们注意的是
Dialogue: 0,0:34:14.80,0:34:17.08,Default,,0,0,0,,这非常像是
Dialogue: 0,0:34:18.16,0:34:21.50,Default,,0,0,0,,元循环求值器以及代换模型
Dialogue: 0,0:34:21.63,0:34:22.73,Default,,0,0,0,,规则的应用就是
Dialogue: 0,0:34:22.86,0:34:28.36,Default,,0,0,0,,在一个环境中求值规则的体
Dialogue: 0,0:34:28.54,0:34:33.13,Default,,0,0,0,,环境是通过将实际参数与形式参数绑定起来得到的
Dialogue: 0,0:34:34.56,0:34:36.41,Default,,0,0,0,,规则、规则的应用、过程的应用
Dialogue: 0,0:34:36.44,0:34:40.41,Default,,0,0,0,,它们在形式上完全相似
Dialogue: 0,0:34:40.57,0:34:42.30,Default,,0,0,0,,尽管它们又非常不同
Dialogue: 0,0:34:43.65,0:34:45.61,Default,,0,0,0,,再一次地出现了EVAL-APPLY循环
Dialogue: 0,0:34:47.29,0:34:49.52,Default,,0,0,0,,EVAL-APPLY
Dialogue: 0,0:34:53.39,0:34:57.39,Default,,0,0,0,,因此通常来说 我们可能会处理一些复合表达式
Dialogue: 0,0:34:57.42,0:34:59.13,Default,,0,0,0,,它们会变成规则的应用
Dialogue: 0,0:35:00.70,0:35:03.28,Default,,0,0,0,,进一步又会产生字典、框架或者环境
Dialogue: 0,0:35:03.31,0:35:04.72,Default,,0,0,0,,不管你要怎么叫它
Dialogue: 0,0:35:05.02,0:35:08.43,Default,,0,0,0,,它们随后又会作为某个大的复合对象的输入
Dialogue: 0,0:35:08.66,0:35:11.77,Default,,0,0,0,,这有它的一部分 并可能有其它规则的应用
Dialogue: 0,0:35:13.58,0:35:15.68,Default,,0,0,0,,这基本上就是相同的循环
Dialogue: 0,0:35:15.72,0:35:18.68,Default,,0,0,0,,尽管这里没有什么东西看起来像过程
Dialogue: 0,0:35:19.68,0:35:21.87,Default,,0,0,0,,这是因为我们创建的语言
Dialogue: 0,0:35:22.08,0:35:25.49,Default,,0,0,0,,它们的组合手段和抽象手段以某种方式展开
Dialogue: 0,0:35:28.77,0:35:29.52,Default,,0,0,0,,通常来说
Dialogue: 0,0:35:29.77,0:35:31.39,Default,,0,0,0,,最顶层所发生的是
Dialogue: 0,0:35:33.79,0:35:35.96,Default,,0,0,0,,数据库中也有一些规则
Dialogue: 0,0:35:36.65,0:35:38.70,Default,,0,0,0,,数据库中的数据也可能是规则
Dialogue: 0,0:35:40.46,0:35:42.06,Default,,0,0,0,,它们用来检查对象是否为真
Dialogue: 0,0:35:42.92,0:35:44.89,Default,,0,0,0,,所以这里可能会有规则检查
Dialogue: 0,0:35:46.75,0:35:48.16,Default,,0,0,0,,然后就会有一些控制结构
Dialogue: 0,0:35:48.19,0:35:50.48,Default,,0,0,0,,用来判断你访问的是规则
Dialogue: 0,0:35:50.51,0:35:51.80,Default,,0,0,0,,还是数据元素
Dialogue: 0,0:35:51.84,0:35:53.12,Default,,0,0,0,,然后不断地把它们扇出来开
Dialogue: 0,0:35:53.35,0:35:55.48,Default,,0,0,0,,所以基本上不可能说清楚
Dialogue: 0,0:35:55.68,0:35:57.69,Default,,0,0,0,,是用什么样的顺序来查询这些东西的
Dialogue: 0,0:35:58.20,0:36:00.27,Default,,0,0,0,,是广度优先还是深度优先
Dialogue: 0,0:36:00.28,0:36:01.64,Default,,0,0,0,,另外一个原因是
Dialogue: 0,0:36:01.66,0:36:05.58,Default,,0,0,0,,我们通过惰性流隐藏了实际执行顺序
Dialogue: 0,0:36:07.69,0:36:11.16,Default,,0,0,0,,因此很难说清楚它的扫描顺序
Dialogue: 0,0:36:11.27,0:36:12.16,Default,,0,0,0,,但真实的是
Dialogue: 0,0:36:12.19,0:36:13.64,Default,,0,0,0,,由于你是在流视图观察它的
Dialogue: 0,0:36:13.90,0:36:15.82,Default,,0,0,0,,而它们最终都要被扫描到
Dialogue: 0,0:36:24.98,0:36:28.15,Default,,0,0,0,,这里还有一个小小的技术问题
Dialogue: 0,0:36:30.88,0:36:33.55,Default,,0,0,0,,假设我在这里输入
Dialogue: 0,0:36:37.53,0:36:41.00,Default,,0,0,0,,假设我输入(BOSS ?Y COMPUTER)
Dialogue: 0,0:36:44.22,0:36:45.78,Default,,0,0,0,,然后就会发生一件有意思的事儿
Dialogue: 0,0:36:45.78,0:36:50.25,Default,,0,0,0,,这里的字典就有一项?Y
Dialogue: 0,0:36:52.73,0:36:57.37,Default,,0,0,0,,而这两个?Y是不相同的
Dialogue: 0,0:36:57.42,0:37:00.62,Default,,0,0,0,,后者是其它人的工作描述
Dialogue: 0,0:37:01.58,0:37:03.80,Default,,0,0,0,,因此 按照输入“照本宣科”地执行的话
Dialogue: 0,0:37:04.22,0:37:06.44,Default,,0,0,0,,我们就会遇到变量冲突的问题
Dialogue: 0,0:37:09.28,0:37:10.48,Default,,0,0,0,,所以我骗了你们一下
Dialogue: 0,0:37:10.93,0:37:13.84,Default,,0,0,0,,注意 我们之前也遇到过同样的问题
Dialogue: 0,0:37:14.27,0:37:15.56,Default,,0,0,0,,具体来说就是
Dialogue: 0,0:37:15.96,0:37:18.36,Default,,0,0,0,,一门语言需要局部变量
Dialogue: 0,0:37:19.24,0:37:21.74,Default,,0,0,0,,当我计算SQUARE和SUM-SQUARES的时候
Dialogue: 0,0:37:21.79,0:37:23.39,Default,,0,0,0,,这两个X应该是不同的
Dialogue: 0,0:37:24.96,0:37:26.32,Default,,0,0,0,,同样的道理
Dialogue: 0,0:37:27.39,0:37:29.77,Default,,0,0,0,,这两个?Y应该也不相同
Dialogue: 0,0:37:31.80,0:37:32.75,Default,,0,0,0,,我们知道该如何解决
Dialogue: 0,0:37:32.78,0:37:34.49,Default,,0,0,0,,就是引入环境模型
Dialogue: 0,0:37:34.51,0:37:37.04,Default,,0,0,0,,我们构建类似于“框架链”一类的东西
Dialogue: 0,0:37:37.71,0:37:39.10,Default,,0,0,0,,还有更加“粗暴”的解决方法
Dialogue: 0,0:37:39.10,0:37:41.73,Default,,0,0,0,,在查询语言中 我们根本不这么做
Dialogue: 0,0:37:41.73,0:37:43.18,Default,,0,0,0,,我们的解决方法非常粗暴
Dialogue: 0,0:37:43.54,0:37:45.93,Default,,0,0,0,,我们规定 每次你在应用一条规则的时候
Dialogue: 0,0:37:47.26,0:37:49.63,Default,,0,0,0,,用一个不会引起冲突的唯一名字
Dialogue: 0,0:37:49.77,0:37:53.50,Default,,0,0,0,,统一地为规则中的所有变量更名
Dialogue: 0,0:37:54.04,0:37:57.10,Default,,0,0,0,,这个从概念上来说更简单
Dialogue: 0,0:37:57.12,0:37:59.24,Default,,0,0,0,,但既粗暴 又不是很有效
Dialogue: 0,0:37:59.97,0:38:01.15,Default,,0,0,0,,但是请注意
Dialogue: 0,0:38:01.39,0:38:04.68,Default,,0,0,0,,如果我们对Lisp中定义的过程也这么处理
Dialogue: 0,0:38:05.50,0:38:08.72,Default,,0,0,0,,那么就不需要环境模型了
Dialogue: 0,0:38:08.75,0:38:11.56,Default,,0,0,0,,如果我们每次在应用一个过程的时候
Dialogue: 0,0:38:11.87,0:38:13.90,Default,,0,0,0,,我们为过程中的所有变量更名
Dialogue: 0,0:38:14.19,0:38:16.28,Default,,0,0,0,,那么我们就不需要担心局部变量了
Dialogue: 0,0:38:16.33,0:38:17.39,Default,,0,0,0,,因为它们不会出现
Dialogue: 0,0:38:19.04,0:38:20.41,Default,,0,0,0,,但这种做法比较低效
Dialogue: 0,0:38:20.91,0:38:23.04,Default,,0,0,0,,在我们的查询语言中同样也比较低效
Dialogue: 0,0:38:23.29,0:38:24.59,Default,,0,0,0,,但我们还是这样做了 并让它保持简单
Dialogue: 0,0:38:25.61,0:38:26.67,Default,,0,0,0,,有问题吗？
Dialogue: 0,0:38:30.88,0:38:33.39,Default,,0,0,0,,学生：您这一小节开始的时候
Dialogue: 0,0:38:33.40,0:38:39.60,Default,,0,0,0,,就强调APPLY-EVAL模型是多么的强大
Dialogue: 0,0:38:39.63,0:38:41.17,Default,,0,0,0,,以至于任何语言都适用
Dialogue: 0,0:38:41.17,0:38:43.39,Default,,0,0,0,,但你又说这门语言将会非常不同
Dialogue: 0,0:38:43.95,0:38:45.13,Default,,0,0,0,,但最后却发现这门语言
Dialogue: 0,0:38:45.58,0:38:47.88,Default,,0,0,0,,就像你指出的那样--也是同样的
Dialogue: 0,0:38:47.88,0:38:49.85,Default,,0,0,0,,我在想 您是否是在论证
Dialogue: 0,0:38:50.48,0:38:54.57,Default,,0,0,0,,所有的语言都可以转化成 规则或过程的应用
Dialogue: 0,0:38:55.12,0:38:55.98,Default,,0,0,0,,或者类似的
Dialogue: 0,0:38:57.07,0:38:58.88,Default,,0,0,0,,教授：可以说 几乎所有语言
Dialogue: 0,0:38:58.92,0:39:00.30,Default,,0,0,0,,我们通过组合手段构建对象
Dialogue: 0,0:39:00.92,0:39:04.40,Default,,0,0,0,,用简单的名字给它们命名
Dialogue: 0,0:39:04.70,0:39:06.86,Default,,0,0,0,,你可以把任何类似的 比如
Dialogue: 0,0:39:07.79,0:39:09.90,Default,,0,0,0,,有一种一般性的表达式
Dialogue: 0,0:39:09.98,0:39:11.40,Default,,0,0,0,,比如说如何计算某数的平方
Dialogue: 0,0:39:12.03,0:39:14.20,Default,,0,0,0,,几乎所有的东西都可以称为“过程”
Dialogue: 0,0:39:14.88,0:39:15.88,Default,,0,0,0,,如果语言中有这么一部分的话
Dialogue: 0,0:39:15.90,0:39:17.24,Default,,0,0,0,,那么你就需要能够展开它们
Dialogue: 0,0:39:18.02,0:39:20.19,Default,,0,0,0,,你需要有某种组织 使得
Dialogue: 0,0:39:20.57,0:39:24.03,Default,,0,0,0,,当你查看这些抽象变量 或者说标签的时候
Dialogue: 0,0:39:24.06,0:39:27.10,Default,,0,0,0,,它们可能代表着某些特定的东西
Dialogue: 0,0:39:28.33,0:39:29.34,Default,,0,0,0,,你必须一直跟踪它们
Dialogue: 0,0:39:29.39,0:39:30.91,Default,,0,0,0,,这就会形成类似于环境的结构
Dialogue: 0,0:39:31.72,0:39:32.54,Default,,0,0,0,,让后当你要
Dialogue: 0,0:39:32.70,0:39:35.26,Default,,0,0,0,,展开复合对象其中的一个部分的时候
Dialogue: 0,0:39:35.80,0:39:37.44,Default,,0,0,0,,你就需要EVAL-APPLY循环了
Dialogue: 0,0:39:39.97,0:39:43.20,Default,,0,0,0,,有很多很多的语言有这样的特点
Dialogue: 0,0:39:43.36,0:39:45.40,Default,,0,0,0,,它们也是按这种方式组织的
Dialogue: 0,0:39:45.59,0:39:47.20,Default,,0,0,0,,而这门语言特殊之处在于
Dialogue: 0,0:39:47.21,0:39:49.50,Default,,0,0,0,,从外界看 并没有“过程”
Dialogue: 0,0:39:50.69,0:39:52.68,Default,,0,0,0,,而当你剖开表层 深入到实现中去
Dialogue: 0,0:39:52.70,0:39:54.24,Default,,0,0,0,,当然 你会发现本质是一样的
Dialogue: 0,0:39:54.87,0:39:56.95,Default,,0,0,0,,但是从外界来看 这是一种非常不同的世界观
Dialogue: 0,0:39:56.95,0:39:58.54,Default,,0,0,0,,你没有计算输入的函数
Dialogue: 0,0:40:03.97,0:40:05.71,Default,,0,0,0,,学生：您之前提到过
Dialogue: 0,0:40:06.60,0:40:09.55,Default,,0,0,0,,当用模式匹配来实现这些规则时
Dialogue: 0,0:40:10.01,0:40:11.42,Default,,0,0,0,,由于使用了流实现延迟求值
Dialogue: 0,0:40:11.45,0:40:12.72,Default,,0,0,0,,所以没有办法知道
Dialogue: 0,0:40:13.37,0:40:15.36,Default,,0,0,0,,对象的求值顺序
Dialogue: 0,0:40:15.58,0:40:15.94,Default,,0,0,0,,教授：是这样的
Dialogue: 0,0:40:15.94,0:40:18.28,Default,,0,0,0,,学生：但这就表明
Dialogue: 0,0:40:18.94,0:40:22.28,Default,,0,0,0,,我们只能表达总是为真的陈述性知识
Dialogue: 0,0:40:22.30,0:40:23.79,Default,,0,0,0,,语言并不支持时间序列
Dialogue: 0,0:40:23.95,0:40:25.47,Default,,0,0,0,,否则的话 后果就会--
Dialogue: 0,0:40:27.39,0:40:28.76,Default,,0,0,0,,教授：是的 非常正确
Dialogue: 0,0:40:28.82,0:40:29.48,Default,,0,0,0,,问题在于
Dialogue: 0,0:40:30.06,0:40:32.60,Default,,0,0,0,,这个本来就是用来处理陈述性知识的
Dialogue: 0,0:40:33.26,0:40:34.81,Default,,0,0,0,,而就我目前所演示的来说 不支持
Dialogue: 0,0:40:35.71,0:40:39.56,Default,,0,0,0,,休息之后我会向你们揭露这其中的丑陋之处
Dialogue: 0,0:40:40.83,0:40:42.60,Default,,0,0,0,,就如我目前所展示的 它只是进行逻辑运算
Dialogue: 0,0:40:43.07,0:40:44.52,Default,,0,0,0,,原理上来说 如果我们做的是逻辑运算
Dialogue: 0,0:40:44.54,0:40:46.81,Default,,0,0,0,,用什么顺序完成并不会造成影响
Dialogue: 0,0:40:48.84,0:40:51.55,Default,,0,0,0,,但是呢
Dialogue: 0,0:40:51.60,0:40:53.61,Default,,0,0,0,,当你在进行一些具有副作用的操作的时候
Dialogue: 0,0:40:53.68,0:40:55.20,Default,,0,0,0,,比如向数据库中添加项
Dialogue: 0,0:40:55.23,0:40:58.16,Default,,0,0,0,,从中取出项 等等操作
Dialogue: 0,0:40:58.75,0:41:00.83,Default,,0,0,0,,你就丧失了这类控制
Dialogue: 0,0:41:01.29,0:41:02.94,Default,,0,0,0,,因此 这就与Prolog完全不同
Dialogue: 0,0:41:02.94,0:41:05.15,Default,,0,0,0,,Prolog有各种功能
Dialogue: 0,0:41:05.16,0:41:07.79,Default,,0,0,0,,能够让你利用求值的顺序
Dialogue: 0,0:41:09.64,0:41:11.77,Default,,0,0,0,,人们也这么来写Prolog
Dialogue: 0,0:41:11.77,0:41:14.04,Default,,0,0,0,,结果发现这样变得非常困难
Dialogue: 0,0:41:14.32,0:41:17.55,Default,,0,0,0,,但如果你是Prolog程序专家 你就可以这么做
Dialogue: 0,0:41:18.59,0:41:20.21,Default,,0,0,0,,但是我认为你们现在并不可以
Dialogue: 0,0:41:20.21,0:41:21.24,Default,,0,0,0,,它相当复杂
Dialogue: 0,0:41:21.72,0:41:23.64,Default,,0,0,0,,因为你们放弃了对事先安排的
Dialogue: 0,0:41:23.77,0:41:25.72,Default,,0,0,0,,求值顺序的控制权
Dialogue: 0,0:41:27.15,0:41:30.16,Default,,0,0,0,,学生：这就表明 当你有一个函数式映射时
Dialogue: 0,0:41:30.67,0:41:32.51,Default,,0,0,0,,而你最初在讲这门课的时候
Dialogue: 0,0:41:32.99,0:41:34.08,Default,,0,0,0,,你说过
Dialogue: 0,0:41:34.67,0:41:36.70,Default,,0,0,0,,我们在表述作为关系的陈述性知识
Dialogue: 0,0:41:37.15,0:41:38.81,Default,,0,0,0,,因为我们讨论的不是输入和输出
Dialogue: 0,0:41:41.21,0:41:43.37,Default,,0,0,0,,教授：这是关于“函数式”的双关语
Dialogue: 0,0:41:43.37,0:41:45.79,Default,,0,0,0,,一种是没有副作用
Dialogue: 0,0:41:46.20,0:41:48.16,Default,,0,0,0,,因此并不依赖于求值的顺序
Dialogue: 0,0:41:48.70,0:41:51.04,Default,,0,0,0,,还有就是数学意义上的“函数”
Dialogue: 0,0:41:51.07,0:41:52.22,Default,,0,0,0,,有关于输入和输出
Dialogue: 0,0:41:52.59,0:41:54.36,Default,,0,0,0,,我想这就是你想表达的双关
Dialogue: 0,0:41:56.51,0:41:58.51,Default,,0,0,0,,学生：我对其中两条语句不太明白
Dialogue: 0,0:41:58.81,0:42:00.70,Default,,0,0,0,,也就是那两条有关BOSS的语句
Dialogue: 0,0:42:01.27,0:42:05.74,Default,,0,0,0,,是不是 第一条查询构建了一个数据库
Dialogue: 0,0:42:05.76,0:42:08.08,Default,,0,0,0,,然后第二条查询--
Dialogue: 0,0:42:09.07,0:42:10.12,Default,,0,0,0,,教授：抱歉
Dialogue: 0,0:42:12.44,0:42:15.16,Default,,0,0,0,,这里的意思是 如果我输入这样的查询
Dialogue: 0,0:42:16.12,0:42:18.44,Default,,0,0,0,,我应该最初就给你们举这个例子
Dialogue: 0,0:42:19.47,0:42:23.52,Default,,0,0,0,,如果我输入(JOB (BITDIDDLE BEN) (COMPUTER WIZARD))
Dialogue: 0,0:42:25.04,0:42:27.77,Default,,0,0,0,,系统会找到一处事实
Dialogue: 0,0:42:28.30,0:42:30.28,Default,,0,0,0,,来完全匹配这条查询
Dialogue: 0,0:42:30.86,0:42:33.28,Default,,0,0,0,,然后输出(JOB (BITDIDDLE BEN) (COMPUTER WIZARD))
Dialogue: 0,0:42:34.22,0:42:35.60,Default,,0,0,0,,如果没找到这样的匹配
Dialogue: 0,0:42:35.69,0:42:36.75,Default,,0,0,0,,它就什么也不输出
Dialogue: 0,0:42:37.40,0:42:39.55,Default,,0,0,0,,我应该这么来表述
Dialogue: 0,0:42:39.56,0:42:42.27,Default,,0,0,0,,这门语言是用来查询某个表述是否为真
Dialogue: 0,0:42:43.40,0:42:45.77,Default,,0,0,0,,这是逻辑式编程的目的之一
Dialogue: 0,0:42:46.41,0:42:49.34,Default,,0,0,0,,输入一条查询 要么得到结果 要么没有
Dialogue: 0,0:42:50.68,0:42:52.38,Default,,0,0,0,,因此 我这里想要演示的是
Dialogue: 0,0:42:52.41,0:42:54.80,Default,,0,0,0,,我想要在介绍合一算法前
Dialogue: 0,0:42:54.83,0:42:56.62,Default,,0,0,0,,举一个简单的例子
Dialogue: 0,0:42:57.48,0:42:58.11,Default,,0,0,0,,所以 我应该说
Dialogue: 0,0:42:58.14,0:43:00.96,Default,,0,0,0,,如果我想要检查 这个是否为真
Dialogue: 0,0:43:01.18,0:43:03.28,Default,,0,0,0,,我就可以将它输入 并看有没有任何输出
Dialogue: 0,0:43:05.16,0:43:06.27,Default,,0,0,0,,学生：然后第二条查询
Dialogue: 0,0:43:06.28,0:43:07.84,Default,,0,0,0,,教授：第二条就是真正意义上的“查询”
Dialogue: 0,0:43:07.88,0:43:09.12,Default,,0,0,0,,学生：好的 真正的查询
Dialogue: 0,0:43:10.77,0:43:13.10,Default,,0,0,0,,教授：在这里它就会输出与?WHO相关的信息
Dialogue: 0,0:43:13.90,0:43:15.74,Default,,0,0,0,,就会有一个框架 存储着
Dialogue: 0,0:43:16.62,0:43:18.81,Default,,0,0,0,,?Z=?WHO ?D=COMPUTER
Dialogue: 0,0:43:19.56,0:43:20.49,Default,,0,0,0,,这个会传递下去
Dialogue: 0,0:43:20.51,0:43:21.95,Default,,0,0,0,,传递到这里的时候
Dialogue: 0,0:43:22.01,0:43:23.25,Default,,0,0,0,,?WHO就会被绑定起来
Dialogue: 0,0:43:26.95,0:43:28.76,Default,,0,0,0,,学生：在合一那里
Dialogue: 0,0:43:29.18,0:43:35.96,Default,,0,0,0,,我还是不太清楚?WHO和?Z之间发生了什么
Dialogue: 0,0:43:36.46,0:43:39.58,Default,,0,0,0,,要进行合一的话 这里的规则说
Dialogue: 0,0:43:42.03,0:43:46.22,Default,,0,0,0,,你说过 两个模式变量之间不能互相绑定
Dialogue: 0,0:43:46.26,0:43:48.08,Default,,0,0,0,,教授：模式匹配器确实不能这样
Dialogue: 0,0:43:48.36,0:43:50.83,Default,,0,0,0,,但对合一算法来说
Dialogue: 0,0:43:51.92,0:43:54.01,Default,,0,0,0,,就是一个有存储三个变量的环境
Dialogue: 0,0:43:56.69,0:43:57.90,Default,,0,0,0,,其中?D=COMPUTER
Dialogue: 0,0:43:58.52,0:44:00.19,Default,,0,0,0,,?Z=?WHO
Dialogue: 0,0:44:01.83,0:44:05.26,Default,,0,0,0,,所以在稍后的匹配过程中
Dialogue: 0,0:44:07.20,0:44:10.38,Default,,0,0,0,,如果?WHO=3
Dialogue: 0,0:44:12.06,0:44:13.66,Default,,0,0,0,,那么当我再查找字典的时候
Dialogue: 0,0:44:14.00,0:44:16.40,Default,,0,0,0,,它会告诉我 因为?Z=?WHO 所以?Z=3
Dialogue: 0,0:44:18.36,0:44:20.44,Default,,0,0,0,,从某种意义上来说 你就只需要修改这一点
Dialogue: 0,0:44:20.46,0:44:21.98,Default,,0,0,0,,就可以把合一算法变成模式匹配器
Dialogue: 0,0:44:22.48,0:44:24.80,Default,,0,0,0,,学生：但是看起来你好像告诉了它 如何进行合一
Dialogue: 0,0:44:24.83,0:44:26.96,Default,,0,0,0,,就像你已经解好了方程 准备好了值
Dialogue: 0,0:44:26.99,0:44:29.23,Default,,0,0,0,,并把它们安排成这样
Dialogue: 0,0:44:29.77,0:44:31.24,Default,,0,0,0,,现在看起来就像是
Dialogue: 0,0:44:31.28,0:44:32.83,Default,,0,0,0,,你传递了一本字典
Dialogue: 0,0:44:32.88,0:44:34.86,Default,,0,0,0,,其中的两个变量是关联起来的
Dialogue: 0,0:44:34.88,0:44:37.23,Default,,0,0,0,,教授：实际上 我们在同时求解它们
Dialogue: 0,0:44:37.52,0:44:39.74,Default,,0,0,0,,这是因为我们想要一下得到整个答案
Dialogue: 0,0:44:40.54,0:44:42.81,Default,,0,0,0,,如果你观察它们是如何被递归地构建的
Dialogue: 0,0:44:42.81,0:44:43.74,Default,,0,0,0,,基本上就是这样了
Dialogue: 0,0:44:44.98,0:44:48.40,Default,,0,0,0,,学生：也就是确实要传递含有两个变量的字典？
Dialogue: 0,0:44:48.40,0:44:49.11,Default,,0,0,0,,教授：是的
Dialogue: 0,0:44:49.11,0:44:49.68,Default,,0,0,0,,学生：然后把它们关联起来？
Dialogue: 0,0:44:50.38,0:44:52.91,Default,,0,0,0,,教授：就像通常的字典那样
Dialogue: 0,0:44:54.35,0:44:56.06,Default,,0,0,0,,学生：你在讨论合一算法的时候
Dialogue: 0,0:44:56.09,0:45:00.19,Default,,0,0,0,,你说过在某些情况下
Dialogue: 0,0:45:00.75,0:45:03.98,Default,,0,0,0,,合一不能够完成
Dialogue: 0,0:45:04.03,0:45:04.30,Default,,0,0,0,,教授：是的
Dialogue: 0,0:45:04.97,0:45:08.46,Default,,0,0,0,,学生：那么 是否可以通过编写规则
Dialogue: 0,0:45:09.16,0:45:15.93,Default,,0,0,0,,或者 写入那些事先知道可解的形式
Dialogue: 0,0:45:16.48,0:45:18.54,Default,,0,0,0,,来使得合一算法能够完成
Dialogue: 0,0:45:18.76,0:45:22.94,Default,,0,0,0,,是否可以在规则中添加一些属性
Dialogue: 0,0:45:23.18,0:45:25.45,Default,,0,0,0,,或者向输入的形式中添加属性
Dialogue: 0,0:45:25.82,0:45:29.04,Default,,0,0,0,,来避免无法进行合一的窘境
Dialogue: 0,0:45:29.18,0:45:31.15,Default,,0,0,0,,PROFESSOR: 我想 你也同意
Dialogue: 0,0:45:31.47,0:45:35.26,Default,,0,0,0,,用非常受限的方式来编写查询
Dialogue: 0,0:45:35.60,0:45:36.67,Default,,0,0,0,,看 你遇到的是
Dialogue: 0,0:45:36.88,0:45:39.12,Default,,0,0,0,,仔细看 你遇到问题是在
Dialogue: 0,0:45:39.68,0:45:44.25,Default,,0,0,0,,用像这样的东西去匹配
Dialogue: 0,0:45:44.59,0:45:47.20,Default,,0,0,0,,具有这样结构的模式时
Dialogue: 0,0:45:47.55,0:45:55.30,Default,,0,0,0,,比如((A ?Y B) ?Y)
Dialogue: 0,0:45:58.98,0:46:01.48,Default,,0,0,0,,这是你可能遇到问题的一个地方
Dialogue: 0,0:46:03.07,0:46:05.80,Default,,0,0,0,,学生：所以你可以在语法层次上处理它么？
Dialogue: 0,0:46:06.14,0:46:08.76,Default,,0,0,0,,教授：你可以在写查询时
Dialogue: 0,0:46:08.76,0:46:10.49,Default,,0,0,0,,注意你的规则
Dialogue: 0,0:46:11.90,0:46:14.08,Default,,0,0,0,,学生：这个问题应该由
Dialogue: 0,0:46:14.11,0:46:16.27,Default,,0,0,0,,数据库的构建者考虑么？
Dialogue: 0,0:46:16.57,0:46:17.80,Default,,0,0,0,,教授：这个问题
Dialogue: 0,0:46:19.93,0:46:22.01,Default,,0,0,0,,不完全是数据库的构建者
Dialogue: 0,0:46:22.04,0:46:23.61,Default,,0,0,0,,或者是表述规则的人
Dialogue: 0,0:46:24.01,0:46:25.31,Default,,0,0,0,,所需要考虑的
Dialogue: 0,0:46:25.80,0:46:29.79,Default,,0,0,0,,当你们仔细审查合一算法的代码时
Dialogue: 0,0:46:29.92,0:46:31.87,Default,,0,0,0,,你们会发现
Dialogue: 0,0:46:32.41,0:46:34.76,Default,,0,0,0,,它实际上在查询一个字典
Dialogue: 0,0:46:34.94,0:46:36.83,Default,,0,0,0,,它会问 ?Y的取值应该是什么？
Dialogue: 0,0:46:37.26,0:46:41.42,Default,,0,0,0,,?Y应该是一个含有自包含的表达式么？
Dialogue: 0,0:46:41.96,0:46:43.26,Default,,0,0,0,,这时候 合一算法就会说
Dialogue: 0,0:46:43.28,0:46:46.24,Default,,0,0,0,,哦 我正在求解一个不动点方程
Dialogue: 0,0:46:46.24,0:46:46.99,Default,,0,0,0,,我还是放弃吧
Dialogue: 0,0:46:48.59,0:46:51.91,Default,,0,0,0,,学生：你区分过数据库中的规则
Dialogue: 0,0:46:51.91,0:46:56.48,Default,,0,0,0,,这些规则是加入数据库的么？
Dialogue: 0,0:46:56.95,0:46:57.36,Default,,0,0,0,,教授：是的
Dialogue: 0,0:46:57.87,0:46:58.87,Default,,0,0,0,,我应该这么来说
Dialogue: 0,0:46:58.87,0:47:00.33,Default,,0,0,0,,你们可以把规则看作
Dialogue: 0,0:47:00.60,0:47:02.65,Default,,0,0,0,,数据库中的其它东西
Dialogue: 0,0:47:03.71,0:47:06.81,Default,,0,0,0,,如果你想要检查数据库中需要检查的东西
Dialogue: 0,0:47:06.83,0:47:09.44,Default,,0,0,0,,它们就是存在于数据库中的虚拟事实
Dialogue: 0,0:47:09.44,0:47:12.32,Default,,0,0,0,,学生：但是在这个解释中
Dialogue: 0,0:47:12.43,0:47:17.26,Default,,0,0,0,,你就已经区分了数据库和规则本身
Dialogue: 0,0:47:18.23,0:47:19.90,Default,,0,0,0,,教授：是的 我应该不这么来说
Dialogue: 0,0:47:20.49,0:47:23.31,Default,,0,0,0,,这样做的唯一理由就是实现
Dialogue: 0,0:47:23.54,0:47:24.67,Default,,0,0,0,,当你们查看具体实现时
Dialogue: 0,0:47:24.68,0:47:27.50,Default,,0,0,0,,会发现其中有部分用来检查数据库中的
Dialogue: 0,0:47:27.55,0:47:29.85,Default,,0,0,0,,基本断言或者规则
Dialogue: 0,0:47:30.47,0:47:32.72,Default,,0,0,0,,这其中的真正原因就是
Dialogue: 0,0:47:32.78,0:47:34.56,Default,,0,0,0,,你不知道查询结果是以什么顺序输出的
Dialogue: 0,0:47:34.96,0:47:40.46,Default,,0,0,0,,而规则数据库和数据数据库
Dialogue: 0,0:47:40.48,0:47:43.68,Default,,0,0,0,,是通过某种延迟求值的方式合并的
Dialogue: 0,0:47:44.60,0:47:46.80,Default,,0,0,0,,这就使得顺序变得非常复杂
Dialogue: 0,0:47:55.44,0:47:56.09,Default,,0,0,0,,那好 我们休息一下
Dialogue: 0,0:47:56.30,0:48:09.90,Default,,0,0,0,,[音乐]
Dialogue: 0,0:48:10.04,0:48:14.41,Declare,,0,0,0,,{\an2\fad(500,500)}《计算机程序的构造和解释》
Dialogue: 0,0:48:18.68,0:48:22.09,Declare,,0,0,0,,{\an2\fad(500,500)}讲师：哈罗德·艾伯森教授 及 格兰德·杰·萨斯曼教授
Dialogue: 0,0:48:22.09,0:48:25.96,Declare,,0,0,0,,{\an2\fad(500,500)}《计算机程序的构造和解释》
Dialogue: 0,0:48:26.00,0:48:29.87,Declare,,0,0,0,,{\an2\fad(500,500)}逻辑式程序设计 II
Dialogue: 0,0:48:33.16,0:48:35.37,Default,,0,0,0,,我们已经学习了逻辑式语言与
Dialogue: 0,0:48:35.39,0:48:36.41,Default,,0,0,0,,规则系统的运行原理
Dialogue: 0,0:48:37.23,0:48:39.37,Default,,0,0,0,,现在 让我们来探讨一个更加深刻的问题
Dialogue: 0,0:48:40.12,0:48:41.28,Default,,0,0,0,,来看下它们意味着什么
Dialogue: 0,0:48:43.18,0:48:46.86,Default,,0,0,0,,这把我们带入到整个查询语言中
Dialogue: 0,0:48:46.99,0:48:48.67,Default,,0,0,0,,最微妙的部分
Dialogue: 0,0:48:49.21,0:48:53.07,Default,,0,0,0,,也就是它看起来与想象中不同的地方
Dialogue: 0,0:48:53.57,0:48:56.22,Default,,0,0,0,,AND、OR以及NOT
Dialogue: 0,0:48:57.02,0:48:58.88,Default,,0,0,0,,以及规则的逻辑蕴含
Dialogue: 0,0:48:59.69,0:49:06.64,Default,,0,0,0,,并不是逻辑学中的与、或、非以及蕴含
Dialogue: 0,0:49:07.69,0:49:09.71,Default,,0,0,0,,让我来举一个实例
Dialogue: 0,0:49:09.91,0:49:12.22,Default,,0,0,0,,当然 如果我们有两个逻辑命题
Dialogue: 0,0:49:12.40,0:49:19.44,Default,,0,0,0,,那么(AND P Q)就应该
Dialogue: 0,0:49:20.00,0:49:22.59,Default,,0,0,0,,等同于(AND Q P)
Dialogue: 0,0:49:23.10,0:49:24.51,Default,,0,0,0,,而(OR P Q)就应该
Dialogue: 0,0:49:24.78,0:49:26.51,Default,,0,0,0,,等同于(OR Q P)
Dialogue: 0,0:49:28.67,0:49:30.09,Default,,0,0,0,,但我们来看看这里
Dialogue: 0,0:49:30.10,0:49:32.01,Default,,0,0,0,,这里是一个例子
Dialogue: 0,0:49:32.18,0:49:36.16,Default,,0,0,0,,来看看 在我们的数据库中
Dialogue: 0,0:49:36.28,0:49:40.14,Default,,0,0,0,,如何表示某人的级别高于他人
Dialogue: 0,0:49:40.14,0:49:42.89,Default,,0,0,0,,我们定义(OUTRANKED-BY ?S ?B)为
Dialogue: 0,0:49:44.64,0:49:48.62,Default,,0,0,0,,或者S是B的上司
Dialogue: 0,0:49:49.63,0:49:51.07,Default,,0,0,0,,或者这其中有某个中间经理M
Dialogue: 0,0:49:51.10,0:49:55.82,Default,,0,0,0,,其中S是M的上司 M的级别又比B高
Dialogue: 0,0:49:59.64,0:50:02.31,Default,,0,0,0,,这是定义OUTRANKED-BY的一种方式
Dialogue: 0,0:50:02.31,0:50:04.16,Default,,0,0,0,,或者我们可以原封不动地写过来
Dialogue: 0,0:50:05.08,0:50:06.91,Default,,0,0,0,,除了在最底部的这里
Dialogue: 0,0:50:07.21,0:50:09.88,Default,,0,0,0,,我们颠倒一下这两个子句的顺序
Dialogue: 0,0:50:11.63,0:50:12.99,Default,,0,0,0,,当然 如果它们都是逻辑表达式的话
Dialogue: 0,0:50:13.00,0:50:14.88,Default,,0,0,0,,它们应该表示的是相同的东西
Dialogue: 0,0:50:16.69,0:50:17.31,Default,,0,0,0,,然而
Dialogue: 0,0:50:17.71,0:50:19.61,Default,,0,0,0,,在我们这个特定的实现中
Dialogue: 0,0:50:19.64,0:50:22.88,Default,,0,0,0,,如果你查询(OUTRANDKED-BY ?WHO (BITDIIDLE BEN))
Dialogue: 0,0:50:23.48,0:50:25.36,Default,,0,0,0,,你会发现 这条规则
Dialogue: 0,0:50:26.76,0:50:28.72,Default,,0,0,0,,会完美地生成答案
Dialogue: 0,0:50:30.04,0:50:31.98,Default,,0,0,0,,然而 这条规则会陷入无穷循环
Dialogue: 0,0:50:34.11,0:50:36.27,Default,,0,0,0,,其中的原因就是
Dialogue: 0,0:50:36.33,0:50:40.33,Default,,0,0,0,,这条规则会问谁比BEN BITDIDDLE级别高？
Dialogue: 0,0:50:41.92,0:50:43.53,Default,,0,0,0,,它试图寻找一个S
Dialogue: 0,0:50:43.88,0:50:46.22,Default,,0,0,0,,使得S比B的级别更高 其中B是BEN BITDIDDLE
Dialogue: 0,0:50:47.50,0:50:49.63,Default,,0,0,0,,这会在一个子问题中重复出现
Dialogue: 0,0:50:50.33,0:50:51.98,Default,,0,0,0,,找到一个M
Dialogue: 0,0:50:52.24,0:50:54.57,Default,,0,0,0,,使得M的级别高于BEN BITDIDDLE
Dialogue: 0,0:50:55.61,0:50:57.36,Default,,0,0,0,,而对M没有限制
Dialogue: 0,0:50:58.56,0:51:00.40,Default,,0,0,0,,这就相当于为了解决这个问题
Dialogue: 0,0:51:01.42,0:51:03.29,Default,,0,0,0,,我就还需要求解同样的问题
Dialogue: 0,0:51:04.57,0:51:07.23,Default,,0,0,0,,在把它解出来后 我才检查SUPERVISOR关系
Dialogue: 0,0:51:08.00,0:51:09.16,Default,,0,0,0,,然而这条规则没有这样的问题
Dialogue: 0,0:51:09.18,0:51:12.35,Default,,0,0,0,,因为在它尝试找出这条OUTRANKED-BY规则之前
Dialogue: 0,0:51:12.94,0:51:15.26,Default,,0,0,0,,在这里已经对M施加过约束了
Dialogue: 0,0:51:18.38,0:51:20.94,Default,,0,0,0,,随意 这两条规则理论上是相同的
Dialogue: 0,0:51:20.99,0:51:22.67,Default,,0,0,0,,但实际上 其中一条会陷入无穷循环
Dialogue: 0,0:51:22.86,0:51:25.04,Default,,0,0,0,,而另一条不会
Dialogue: 0,0:51:26.72,0:51:29.77,Default,,0,0,0,,通过这个非常极端的例子
Dialogue: 0,0:51:29.79,0:51:32.65,Default,,0,0,0,,你会发现在逻辑式程序设计中
Dialogue: 0,0:51:34.28,0:51:38.70,Default,,0,0,0,,如果你改变了AND或OR所连接子句的顺序
Dialogue: 0,0:51:39.34,0:51:41.58,Default,,0,0,0,,你会发现效率上的巨大差异
Dialogue: 0,0:51:42.24,0:51:43.21,Default,,0,0,0,,我们刚刚就看到了
Dialogue: 0,0:51:43.55,0:51:46.54,Default,,0,0,0,,在无穷循环方面的巨大差异
Dialogue: 0,0:51:49.19,0:51:51.74,Default,,0,0,0,,同样的 这也跟输入规则
Dialogue: 0,0:51:52.00,0:51:53.31,Default,,0,0,0,,的顺序有关
Dialogue: 0,0:51:54.07,0:51:56.48,Default,,0,0,0,,向数据库查询规则的顺序
Dialogue: 0,0:51:56.70,0:51:59.95,Default,,0,0,0,,会极大程度上影响效率：比如得到答案
Dialogue: 0,0:52:00.46,0:52:02.60,Default,,0,0,0,,或者在某些顺序下陷入无穷循环
Dialogue: 0,0:52:03.84,0:52:07.29,Default,,0,0,0,,这些都跟
Dialogue: 0,0:52:07.63,0:52:10.04,Default,,0,0,0,,你检查这些规则的顺序有关
Dialogue: 0,0:52:10.95,0:52:14.41,Default,,0,0,0,,有些规则的蕴含路径会相当的长
Dialogue: 0,0:52:14.44,0:52:16.06,Default,,0,0,0,,而另外一些不会
Dialogue: 0,0:52:16.44,0:52:17.68,Default,,0,0,0,,但你事先并不知道
Dialogue: 0,0:52:17.72,0:52:19.16,Default,,0,0,0,,哪一个长 哪一个短
Dialogue: 0,0:52:19.30,0:52:21.48,Default,,0,0,0,,有很多研究都与此有关
Dialogue: 0,0:52:22.16,0:52:23.76,Default,,0,0,0,,其中大多数都是想通过
Dialogue: 0,0:52:23.95,0:52:26.97,Default,,0,0,0,,用并行的方法来实现逻辑式程序设计语言
Dialogue: 0,0:52:27.32,0:52:29.90,Default,,0,0,0,,某种意义上来说 就是并行地检查所有规则
Dialogue: 0,0:52:30.36,0:52:32.80,Default,,0,0,0,,一旦有一条搜索得到答案 就返回结果
Dialogue: 0,0:52:33.04,0:52:34.99,Default,,0,0,0,,如果某条路径陷入了无穷的推导
Dialogue: 0,0:52:35.02,0:52:38.25,Default,,0,0,0,,那么 你只需知道 内存和处理器都非常廉价
Dialogue: 0,0:52:38.28,0:52:40.49,Default,,0,0,0,,让它们根据你的需要一直搜寻就好了
Dialogue: 0,0:52:43.47,0:52:44.83,Default,,0,0,0,,尽管如此 与真正的逻辑相比
Dialogue: 0,0:52:45.18,0:52:50.49,Default,,0,0,0,,这门逻辑式语言还有一个更深刻的问题
Dialogue: 0,0:52:50.68,0:52:52.52,Default,,0,0,0,,我给你们演示的例子
Dialogue: 0,0:52:52.97,0:52:54.80,Default,,0,0,0,,只是会陷入无穷循环
Dialogue: 0,0:52:55.37,0:52:56.99,Default,,0,0,0,,但至少不会给你错误的答案
Dialogue: 0,0:52:58.37,0:53:03.64,Default,,0,0,0,,当我们开始严肃地把这门逻辑式语言
Dialogue: 0,0:53:03.68,0:53:05.24,Default,,0,0,0,,与真正的经典逻辑作比较时
Dialogue: 0,0:53:05.71,0:53:08.46,Default,,0,0,0,,就会发现其中最深层次的问题
Dialogue: 0,0:53:09.49,0:53:12.43,Default,,0,0,0,,让我们来看看真正的经典逻辑
Dialogue: 0,0:53:13.71,0:53:21.04,Default,,0,0,0,,所有的人类都是凡人
Dialogue: 0,0:53:22.35,0:53:23.45,Default,,0,0,0,,相当经典的逻辑命题
Dialogue: 0,0:53:24.39,0:53:28.67,Default,,0,0,0,,然后我们就依照最经典的传统
Dialogue: 0,0:53:29.24,0:53:32.46,Default,,0,0,0,,我们按照最传统的方式来做
Dialogue: 0,0:53:32.67,0:53:37.16,Default,,0,0,0,,所有的希腊人都是人类
Dialogue: 0,0:53:40.49,0:53:46.06,Default,,0,0,0,,苏格拉底是希腊人
Dialogue: 0,0:53:48.17,0:53:49.21,Default,,0,0,0,,然后我们又该写什么呢？
Dialogue: 0,0:53:49.21,0:53:51.89,Default,,0,0,0,,经典逻辑中有一个三点符号
Dialogue: 0,0:53:51.89,0:53:54.33,Default,,0,0,0,,因此 我们得到了一个三段论
Dialogue: 0,0:53:54.64,0:53:59.55,Default,,0,0,0,,苏格拉底是凡人
Dialogue: 0,0:54:01.36,0:54:04.91,Default,,0,0,0,,这些都是真正的经典逻辑
Dialogue: 0,0:54:05.88,0:54:11.05,Default,,0,0,0,,把它跟我们经典逻辑数据库比较一下
Dialogue: 0,0:54:12.40,0:54:14.46,Default,,0,0,0,,这是一个经典逻辑数据库
Dialogue: 0,0:54:16.27,0:54:17.48,Default,,0,0,0,,(GREEK SOCRATES)
Dialogue: 0,0:54:18.03,0:54:18.84,Default,,0,0,0,,(GREEK PLATO)
Dialogue: 0,0:54:19.60,0:54:20.40,Default,,0,0,0,,(GREEK ZEUS)
Dialogue: 0,0:54:20.84,0:54:21.98,Default,,0,0,0,,(GOD ZEUS)
Dialogue: 0,0:54:24.12,0:54:29.96,Default,,0,0,0,,所有的人类都是凡人
Dialogue: 0,0:54:30.54,0:54:32.12,Default,,0,0,0,,为了证明某人是平凡的
Dialogue: 0,0:54:32.16,0:54:33.60,Default,,0,0,0,,只需要证明他是人类
Dialogue: 0,0:54:34.65,0:54:35.90,Default,,0,0,0,,所有的人类都是不可靠的
Dialogue: 0,0:54:38.90,0:54:40.98,Default,,0,0,0,,并且说所有的希腊人都是人类 并不正确
Dialogue: 0,0:54:40.98,0:54:44.41,Default,,0,0,0,,这条规则说 所有不是神的希腊人都是人类
Dialogue: 0,0:54:45.71,0:54:47.04,Default,,0,0,0,,因此为了证明某人是人类
Dialogue: 0,0:54:47.07,0:54:48.89,Default,,0,0,0,,只需要说明他是一个希腊人 并且不是神
Dialogue: 0,0:54:49.32,0:54:52.88,Default,,0,0,0,,任何一个希腊神的住址是奥林匹斯山
Dialogue: 0,0:54:54.32,0:54:57.16,Default,,0,0,0,,这就是一个小型经典逻辑数据库
Dialogue: 0,0:54:57.39,0:54:59.32,Default,,0,0,0,,确实 它运行得相当好
Dialogue: 0,0:54:59.49,0:55:02.09,Default,,0,0,0,,如果我们向其询问
Dialogue: 0,0:55:03.47,0:55:06.57,Default,,0,0,0,,苏格拉底是凡人么 不可靠么？
Dialogue: 0,0:55:06.91,0:55:07.69,Default,,0,0,0,,它会输出：是
Dialogue: 0,0:55:07.77,0:55:09.71,Default,,0,0,0,,柏拉图是凡人并且不可靠么？
Dialogue: 0,0:55:09.71,0:55:10.24,Default,,0,0,0,,它会回答：是
Dialogue: 0,0:55:10.68,0:55:12.21,Default,,0,0,0,,如果我们问宙斯是凡人么
Dialogue: 0,0:55:12.21,0:55:13.23,Default,,0,0,0,,它什么都不会找到
Dialogue: 0,0:55:14.90,0:55:15.96,Default,,0,0,0,,运行得非常完美
Dialogue: 0,0:55:16.54,0:55:20.12,Default,,0,0,0,,然而 如果我们想要把它扩展一下
Dialogue: 0,0:55:20.12,0:55:23.05,Default,,0,0,0,,让我们来定义一下什么是“完美生命体”
Dialogue: 0,0:55:23.82,0:55:27.21,Default,,0,0,0,,我们把规则PERFECT定义为
Dialogue: 0,0:55:34.05,0:55:35.48,Default,,0,0,0,,我想这样来定义是正确的
Dialogue: 0,0:55:35.48,0:55:38.14,Default,,0,0,0,,如果你熟悉中世纪经院哲学
Dialogue: 0,0:55:38.44,0:55:40.17,Default,,0,0,0,,我想所谓“完美生命体”一定
Dialogue: 0,0:55:40.68,0:55:42.65,Default,,0,0,0,,既不是凡人 又不会不可靠
Dialogue: 0,0:55:44.10,0:55:56.84,Default,,0,0,0,,(AND (NOT (MORTAL ?X)) (NOT (FALLIBLE ?X)))
Dialogue: 0,0:55:59.30,0:56:00.89,Default,,0,0,0,,这样 我们就定义了一个规则
Dialogue: 0,0:56:02.67,0:56:04.36,Default,,0,0,0,,来告诉系统 什么是“完美生命体”
Dialogue: 0,0:56:05.79,0:56:07.69,Default,,0,0,0,,现在 我们就要
Dialogue: 0,0:56:08.06,0:56:10.17,Default,,0,0,0,,询问所有“完美生命体”的地址
Dialogue: 0,0:56:11.48,0:56:22.30,Default,,0,0,0,,(AND (ADDRESS ?X ?Y) (PERFECT ?X))
Dialogue: 0,0:56:23.48,0:56:24.97,Default,,0,0,0,,在这里 我们生成了
Dialogue: 0,0:56:24.99,0:56:27.80,Default,,0,0,0,,世界上最独有的邮件列表
Dialogue: 0,0:56:30.16,0:56:32.20,Default,,0,0,0,,为了查询所有完美生命体的地址
Dialogue: 0,0:56:32.24,0:56:33.47,Default,,0,0,0,,我们会输入像这样的查询
Dialogue: 0,0:56:33.83,0:56:35.44,Default,,0,0,0,,或者像这样输入
Dialogue: 0,0:56:36.24,0:56:50.57,Default,,0,0,0,,(AND (PERFECT ?X) (ADDRESS ?X ?Y))
Dialogue: 0,0:56:52.06,0:56:54.96,Default,,0,0,0,,假设我们把它输入进去 并尝试查询
Dialogue: 0,0:56:55.19,0:56:56.76,Default,,0,0,0,,这条查询会给我们答案
Dialogue: 0,0:56:57.65,0:57:00.00,Default,,0,0,0,,这条查询会输出：奥林匹斯山
Dialogue: 0,0:57:04.23,0:57:06.57,Default,,0,0,0,,而这条查询 什么也不会输出
Dialogue: 0,0:57:06.74,0:57:09.58,Default,,0,0,0,,它找不到完美生命体的地址
Dialogue: 0,0:57:11.64,0:57:12.51,Default,,0,0,0,,为什么会这样？
Dialogue: 0,0:57:12.51,0:57:13.44,Default,,0,0,0,,这又为什么不同？
Dialogue: 0,0:57:14.23,0:57:15.69,Default,,0,0,0,,这个问题跟无穷循环没什么关系
Dialogue: 0,0:57:15.69,0:57:17.08,Default,,0,0,0,,这个的问题是答案不相同
Dialogue: 0,0:57:19.48,0:57:20.09,Default,,0,0,0,,原因就是
Dialogue: 0,0:57:20.38,0:57:22.32,Default,,0,0,0,,如果你们还记得NOT的实现的话
Dialogue: 0,0:57:23.50,0:57:24.84,Default,,0,0,0,,NOT是作为一个过滤器
Dialogue: 0,0:57:25.88,0:57:29.00,Default,,0,0,0,,NOT会接收一本字典
Dialogue: 0,0:57:29.05,0:57:31.56,Default,,0,0,0,,里面有可行解构成的框架
Dialogue: 0,0:57:31.79,0:57:33.16,Default,,0,0,0,,然后过滤出那些
Dialogue: 0,0:57:33.29,0:57:34.94,Default,,0,0,0,,满足某个条件的解
Dialogue: 0,0:57:34.97,0:57:36.11,Default,,0,0,0,,这就是我如何实现NOT的
Dialogue: 0,0:57:36.92,0:57:38.43,Default,,0,0,0,,如果你们仔细想想其中的原理
Dialogue: 0,0:57:40.11,0:57:42.65,Default,,0,0,0,,我创建了一个查询盒子
Dialogue: 0,0:57:43.32,0:57:47.39,Default,,0,0,0,,ADDRESS盒子的输出作为了PERFECT的输入
Dialogue: 0,0:57:50.29,0:57:51.00,Default,,0,0,0,,这就使得
Dialogue: 0,0:57:51.32,0:57:53.26,Default,,0,0,0,,ADDRESS盒子会创建出
Dialogue: 0,0:57:53.32,0:57:54.83,Default,,0,0,0,,我知道地址的人
Dialogue: 0,0:57:55.29,0:57:57.64,Default,,0,0,0,,这些都会被PERFECT中的NOT给过滤掉
Dialogue: 0,0:57:59.88,0:58:04.19,Default,,0,0,0,,所以它会丢弃掉那些满足平凡的或者不可靠的数据
Dialogue: 0,0:58:04.91,0:58:06.38,Default,,0,0,0,,而对于另外一种顺序来说
Dialogue: 0,0:58:06.73,0:58:09.12,Default,,0,0,0,,我以一个空框架开始的
Dialogue: 0,0:58:09.52,0:58:12.35,Default,,0,0,0,,但是这里PERFECT没有可以给NOT过滤的东西
Dialogue: 0,0:58:12.38,0:58:13.98,Default,,0,0,0,,所以这里不会有什么输出
Dialogue: 0,0:58:18.83,0:58:21.50,Default,,0,0,0,,这也就导致没有东西输入到ADDRESS中
Dialogue: 0,0:58:21.94,0:58:23.15,Default,,0,0,0,,因此 我得不到答案
Dialogue: 0,0:58:23.93,0:58:27.04,Default,,0,0,0,,在强调一下 这是因为NOT不会生成任何东西
Dialogue: 0,0:58:27.44,0:58:28.80,Default,,0,0,0,,NOT只会丢弃数据
Dialogue: 0,0:58:29.08,0:58:30.51,Default,,0,0,0,,如果我不向NOT传递东西的话
Dialogue: 0,0:58:30.52,0:58:31.74,Default,,0,0,0,,它也就不会输出
Dialogue: 0,0:58:32.02,0:58:33.77,Default,,0,0,0,,这样我就得到了错误的答案
Dialogue: 0,0:58:37.20,0:58:37.97,Default,,0,0,0,,我们又该如何修复它呢？
Dialogue: 0,0:58:37.97,0:58:39.07,Default,,0,0,0,,当然 有很多办法
Dialogue: 0,0:58:39.36,0:58:40.91,Default,,0,0,0,,你可能认为 现在这样有点愚蠢
Dialogue: 0,0:58:41.41,0:58:44.90,Default,,0,0,0,,为什么要一开始就执行NOT呢？
Dialogue: 0,0:58:44.96,0:58:47.48,Default,,0,0,0,,想要正确地实现NOT
Dialogue: 0,0:58:47.84,0:58:50.08,Default,,0,0,0,,就是要认识到当你遇到NOT时
Dialogue: 0,0:58:50.33,0:58:52.09,Default,,0,0,0,,你应该首先生成好答案
Dialogue: 0,0:58:52.80,0:58:54.97,Default,,0,0,0,,然后通过字典把它们传递过来
Dialogue: 0,0:58:55.52,0:58:57.85,Default,,0,0,0,,然后再最后再做过滤
Dialogue: 0,0:58:58.56,0:59:02.01,Default,,0,0,0,,有些按照这种方式实现的逻辑式语言
Dialogue: 0,0:59:02.41,0:59:04.05,Default,,0,0,0,,能够解决这个问题
Dialogue: 0,0:59:06.80,0:59:08.97,Default,,0,0,0,,然而 还有一个更深刻的问题
Dialogue: 0,0:59:09.60,0:59:11.53,Default,,0,0,0,,也就是 哪个才是正确答案呢？
Dialogue: 0,0:59:12.53,0:59:14.24,Default,,0,0,0,,是奥林匹斯山 还是没有呢？
Dialogue: 0,0:59:15.37,0:59:18.73,Default,,0,0,0,,你可能会认为是奥林匹斯山
Dialogue: 0,0:59:18.76,0:59:20.73,Default,,0,0,0,,毕竟 宙斯在数据库中
Dialogue: 0,0:59:22.52,0:59:25.10,Default,,0,0,0,,宙斯不是平凡的 也不是不可靠的
Dialogue: 0,0:59:29.55,0:59:32.44,Default,,0,0,0,,因此你可能会认为宙斯满足
Dialogue: 0,0:59:34.30,0:59:44.03,Default,,0,0,0,,(NOT (MORTAL ZEUS))或者(NOT (FALLIBLE ZEUS))
Dialogue: 0,0:59:44.12,0:59:45.85,Default,,0,0,0,,但我们实际来看一看数据库
Dialogue: 0,0:59:47.92,0:59:48.46,Default,,0,0,0,,来看一下
Dialogue: 0,0:59:49.36,0:59:53.24,Default,,0,0,0,,它要如何知道宙斯不是不可靠的？
Dialogue: 0,0:59:54.81,0:59:56.11,Default,,0,0,0,,这里面没有关于它的知识
Dialogue: 0,0:59:57.93,0:59:59.66,Default,,0,0,0,,里面只能得到人类是不可靠的
Dialogue: 0,1:00:02.16,1:00:04.12,Default,,0,0,0,,它又如何知道宙斯不是不可靠的呢？
Dialogue: 0,1:00:04.48,1:00:05.93,Default,,0,0,0,,这其中没有相关的规则
Dialogue: 0,1:00:07.98,1:00:11.00,Default,,0,0,0,,它只是说 我没有这样的规则
Dialogue: 0,1:00:11.68,1:00:14.06,Default,,0,0,0,,我只能通过某人是人类来推断出他是平凡的
Dialogue: 0,1:00:14.08,1:00:15.68,Default,,0,0,0,,这也是它所知道关于“平凡”的所有东西
Dialogue: 0,1:00:16.69,1:00:19.85,Default,,0,0,0,,然而 如果你还记得古典神话的话
Dialogue: 0,1:00:19.87,1:00:23.48,Default,,0,0,0,,你就知道 古希腊众神是不平凡的 但都不可靠
Dialogue: 0,1:00:25.05,1:00:28.65,Default,,0,0,0,,所以 不能通过这些规则得到答案
Dialogue: 0,1:00:30.85,1:00:32.10,Default,,0,0,0,,但它又为什么推导出这些呢？
Dialogue: 0,1:00:34.49,1:00:38.32,Default,,0,0,0,,显然 苏格拉底不会犯这类逻辑错误
Dialogue: 0,1:00:40.08,1:00:42.67,Default,,0,0,0,,在这门语言中 NOT并不是NOT
Dialogue: 0,1:00:43.37,1:00:44.32,Default,,0,0,0,,不是逻辑非运算
Dialogue: 0,1:00:44.93,1:00:46.40,Default,,0,0,0,,这门语言中 NOT表示的是
Dialogue: 0,1:00:47.16,1:00:49.96,Default,,0,0,0,,不可以从数据库中推断出结果
Dialogue: 0,1:00:50.75,1:00:53.34,Default,,0,0,0,,而不是“非真”
Dialogue: 0,1:00:55.02,1:00:56.30,Default,,0,0,0,,完全是天壤之别
Dialogue: 0,1:00:57.30,1:00:58.64,Default,,0,0,0,,很细微 但也很巨大
Dialogue: 0,1:00:59.25,1:01:00.27,Default,,0,0,0,,因此 实际上
Dialogue: 0,1:01:00.76,1:01:03.92,Default,,0,0,0,,如果什么都不知道 最好就说NOT
Dialogue: 0,1:01:04.68,1:01:06.14,Default,,0,0,0,,如果你问它
Dialogue: 0,1:01:06.16,1:01:07.83,Default,,0,0,0,,宙斯是否喜欢巧克力冰激凌
Dialogue: 0,1:01:07.85,1:01:09.12,Default,,0,0,0,,它会说 这个查询当然非真
Dialogue: 0,1:01:10.64,1:01:12.51,Default,,0,0,0,,这些事情它都不知道
Dialogue: 0,1:01:12.59,1:01:17.34,Default,,0,0,0,,NOT表示：不能从你告知它的事实中推断出来
Dialogue: 0,1:01:18.28,1:01:22.44,Default,,0,0,0,,换句话说 你要把“无法推断出”
Dialogue: 0,1:01:22.65,1:01:24.00,Default,,0,0,0,,与“命题非真”区别开来
Dialogue: 0,1:01:24.41,1:01:26.30,Default,,0,0,0,,这被称作是“封闭世界假说”
Dialogue: 0,1:01:37.37,1:01:38.17,Default,,0,0,0,,封闭世界假说
Dialogue: 0,1:01:38.20,1:01:42.38,Default,,0,0,0,,只要结论不能通过我所知道的知识推断出来
Dialogue: 0,1:01:43.50,1:01:44.36,Default,,0,0,0,,那么就不是真的
Dialogue: 0,1:01:46.24,1:01:48.01,Default,,0,0,0,,对吧 如果我对X一无所知
Dialogue: 0,1:01:48.22,1:01:49.21,Default,,0,0,0,,那么X就非真
Dialogue: 0,1:01:49.29,1:01:50.33,Default,,0,0,0,,这相当危险
Dialogue: 0,1:01:51.29,1:01:52.44,Default,,0,0,0,,首先 从逻辑学的角度来说
Dialogue: 0,1:01:52.46,1:01:53.76,Default,,0,0,0,,它一点也说不通
Dialogue: 0,1:01:54.48,1:01:56.33,Default,,0,0,0,,因为如果我对X一无所知的话
Dialogue: 0,1:01:58.38,1:01:59.69,Default,,0,0,0,,就说X非真
Dialogue: 0,1:02:00.24,1:02:03.32,Default,,0,0,0,,但为什么不说“X非真”非真
Dialogue: 0,1:02:03.85,1:02:05.66,Default,,0,0,0,,当然 我也许对后面那个命题也一无所知
Dialogue: 0,1:02:06.47,1:02:08.65,Default,,0,0,0,,因此(NOT (NOT X))就没有必要与X一致
Dialogue: 0,1:02:09.24,1:02:10.94,Default,,0,0,0,,等等等等
Dialogue: 0,1:02:11.71,1:02:13.93,Default,,0,0,0,,因此 这里面一定有某种“偏见”
Dialogue: 0,1:02:15.97,1:02:17.29,Default,,0,0,0,,这相当有趣
Dialogue: 0,1:02:17.29,1:02:18.09,Default,,0,0,0,,第二点就是
Dialogue: 0,1:02:20.14,1:02:24.12,Default,,0,0,0,,如果你基于此 构建一个真正的推理程序
Dialogue: 0,1:02:24.70,1:02:26.11,Default,,0,0,0,,想一想是多么地危险
Dialogue: 0,1:02:27.07,1:02:32.00,Default,,0,0,0,,你说我知道我可以推断出
Dialogue: 0,1:02:32.22,1:02:36.22,Default,,0,0,0,,与这个问题有关的所有事情
Dialogue: 0,1:02:37.44,1:02:40.78,Default,,0,0,0,,因为在我推理机制的内部
Dialogue: 0,1:02:41.23,1:02:44.20,Default,,0,0,0,,会认为所有与问题有关的知识
Dialogue: 0,1:02:44.24,1:02:46.27,Default,,0,0,0,,我都已经知道了
Dialogue: 0,1:02:48.44,1:02:53.04,Default,,0,0,0,,有相当多的大型组织都像这样运作 对吧？
Dialogue: 0,1:02:53.16,1:02:56.83,Default,,0,0,0,,大多数公司的市场部门都是这样工作的。
Dialogue: 0,1:02:56.83,1:02:59.12,Default,,0,0,0,,你们也知道这样做的后果
Dialogue: 0,1:03:00.33,1:03:03.45,Default,,0,0,0,,因此 向这个大型逻辑推理系统
Dialogue: 0,1:03:03.84,1:03:06.25,Default,,0,0,0,,输入各种查询 根据输出继续工作
Dialogue: 0,1:03:07.05,1:03:09.00,Default,,0,0,0,,的做法相当危险
Dialogue: 0,1:03:09.02,1:03:11.28,Default,,0,0,0,,因为它们内建的假说非常地有限
Dialogue: 0,1:03:12.60,1:03:14.36,Default,,0,0,0,,因此你对此需要非常非常地小心
Dialogue: 0,1:03:15.29,1:03:16.28,Default,,0,0,0,,就是这么一个深层次问题
Dialogue: 0,1:03:16.56,1:03:17.82,Default,,0,0,0,,这个问题并不是
Dialogue: 0,1:03:18.22,1:03:20.14,Default,,0,0,0,,通过构建更加聪明的实现
Dialogue: 0,1:03:20.16,1:03:21.85,Default,,0,0,0,,或者通过组织无穷循环
Dialogue: 0,1:03:22.16,1:03:23.84,Default,,0,0,0,,以及过滤器就可以消除的
Dialogue: 0,1:03:23.84,1:03:25.08,Default,,0,0,0,,这是完全不同的一类问题
Dialogue: 0,1:03:25.92,1:03:26.89,Default,,0,0,0,,完全不同的语义
Dialogue: 0,1:03:27.06,1:03:30.51,Default,,0,0,0,,我想该总结一下了 平心而论
Dialogue: 0,1:03:31.34,1:03:34.43,Default,,0,0,0,,逻辑式程序设计是一个振奋人心的想法
Dialogue: 0,1:03:34.60,1:03:37.00,Default,,0,0,0,,这个想法使你能够弥合
Dialogue: 0,1:03:37.04,1:03:38.78,Default,,0,0,0,,命令式与声明式语言的鸿沟
Dialogue: 0,1:03:39.90,1:03:42.94,Default,,0,0,0,,使得你可以谈论关系
Dialogue: 0,1:03:43.58,1:03:45.08,Default,,0,0,0,,从而获得惊人的力量
Dialogue: 0,1:03:46.09,1:03:49.48,Default,,0,0,0,,让你超越输入和输出的抽象
Dialogue: 0,1:03:50.56,1:03:51.53,Default,,0,0,0,,而关于逻辑
Dialogue: 0,1:03:52.46,1:03:56.46,Default,,0,0,0,,我认为这个问题还尚未解决
Dialogue: 0,1:03:58.03,1:04:01.80,Default,,0,0,0,,也许现在语言中最令人感兴趣的
Dialogue: 0,1:04:02.27,1:04:04.41,Default,,0,0,0,,研究问题之一就是
Dialogue: 0,1:04:04.67,1:04:08.28,Default,,0,0,0,,你该如何创建一门真正的逻辑语言？
Dialogue: 0,1:04:09.46,1:04:11.05,Default,,0,0,0,,其次 你如何从
Dialogue: 0,1:04:11.31,1:04:13.15,Default,,0,0,0,,这个逻辑和关系的世界
Dialogue: 0,1:04:13.52,1:04:16.43,Default,,0,0,0,,到更传统语言的世界之间
Dialogue: 0,1:04:16.46,1:04:17.98,Default,,0,0,0,,架起桥梁并结合两者的力量
Dialogue: 0,1:04:18.88,1:04:19.68,Default,,0,0,0,,有什么问题吗？
Dialogue: 0,1:04:23.29,1:04:25.29,Default,,0,0,0,,学生：你能够通过添加额外的规则
Dialogue: 0,1:04:25.29,1:04:27.74,Default,,0,0,0,,来解决最后一个问题么？
Dialogue: 0,1:04:27.96,1:04:29.85,Default,,0,0,0,,这里的困境是：你有某物的定义
Dialogue: 0,1:04:29.88,1:04:31.82,Default,,0,0,0,,但没有它对立面的定义
Dialogue: 0,1:04:32.08,1:04:33.92,Default,,0,0,0,,如果你在数据库中有
Dialogue: 0,1:04:34.14,1:04:36.89,Default,,0,0,0,,某些规则推导出(MORTAL X)
Dialogue: 0,1:04:36.99,1:04:38.70,Default,,0,0,0,,另外一些规则推导出(NOT (MORTAL X))
Dialogue: 0,1:04:38.75,1:04:40.37,Default,,0,0,0,,这不就基本上解决这个问题么？
Dialogue: 0,1:04:43.37,1:04:44.14,Default,,0,0,0,,教授：但问题就是
Dialogue: 0,1:04:44.75,1:04:46.38,Default,,0,0,0,,添加的这些规则是有穷个么？
Dialogue: 0,1:04:48.65,1:04:53.13,Default,,0,0,0,,学生：如果你同时定义正、反两面 --
Dialogue: 0,1:04:53.61,1:04:57.07,Default,,0,0,0,,教授：但问题就是 你该如何去做推断？
Dialogue: 0,1:05:00.20,1:05:02.11,Default,,0,0,0,,要知道 你不能直接定义命题的非
Dialogue: 0,1:05:03.40,1:05:04.76,Default,,0,0,0,,而问题就在于 在大型系统中
Dialogue: 0,1:05:04.78,1:05:07.96,Default,,0,0,0,,可能含有无穷个数的东西
Dialogue: 0,1:05:12.82,1:05:15.29,Default,,0,0,0,,这其中有两个问题
Dialogue: 0,1:05:15.29,1:05:16.56,Default,,0,0,0,,其一是可能有无穷项
Dialogue: 0,1:05:16.69,1:05:19.39,Default,,0,0,0,,另外是因为可能不向你想的那样
Dialogue: 0,1:05:21.51,1:05:24.52,Default,,0,0,0,,一个极好的例子 就是连通性
Dialogue: 0,1:05:25.12,1:05:26.54,Default,,0,0,0,,我想对连通性做推理
Dialogue: 0,1:05:28.05,1:05:30.38,Default,,0,0,0,,我会告诉你这有四个对象
Dialogue: 0,1:05:30.40,1:05:33.74,Default,,0,0,0,,A、B、C和D
Dialogue: 0,1:05:35.48,1:05:38.19,Default,,0,0,0,,我会告诉你A和B相连
Dialogue: 0,1:05:38.64,1:05:41.42,Default,,0,0,0,,C和D相连
Dialogue: 0,1:05:43.20,1:05:44.80,Default,,0,0,0,,然后我再告诉你A和D相连
Dialogue: 0,1:05:45.05,1:05:46.03,Default,,0,0,0,,就是这种情况
Dialogue: 0,1:05:46.78,1:05:48.52,Default,,0,0,0,,在这个例子中
Dialogue: 0,1:05:48.70,1:05:50.35,Default,,0,0,0,,我就希望有“封闭世界假说”这样的东西
Dialogue: 0,1:05:54.43,1:05:55.66,Default,,0,0,0,,这是个小玩具
Dialogue: 0,1:05:56.24,1:05:58.30,Default,,0,0,0,,但是很多时候 我都想说
Dialogue: 0,1:05:58.48,1:06:01.34,Default,,0,0,0,,我没告诉你的事 都假设非真
Dialogue: 0,1:06:04.26,1:06:06.27,Default,,0,0,0,,所以这并不是你显式地
Dialogue: 0,1:06:06.27,1:06:08.09,Default,,0,0,0,,为所有命题定义否命题就可以解决的
Dialogue: 0,1:06:09.47,1:06:12.70,Default,,0,0,0,,而是有些时候 你不清楚自己真正想要什么
Dialogue: 0,1:06:14.15,1:06:17.92,Default,,0,0,0,,同时定义原命题与否命题又太过于精细
Dialogue: 0,1:06:17.93,1:06:20.00,Default,,0,0,0,,这会使你陷入困境
Dialogue: 0,1:06:20.96,1:06:22.68,Default,,0,0,0,,但还是有很多方法
Dialogue: 0,1:06:23.32,1:06:25.93,Default,,0,0,0,,显式地定义否命题 并基于此进行推理
Dialogue: 0,1:06:26.51,1:06:27.66,Default,,0,0,0,,这个想法非常好
Dialogue: 0,1:06:28.07,1:06:31.45,Default,,0,0,0,,只是在一些复杂的大型问题中
Dialogue: 0,1:06:31.48,1:06:33.49,Default,,0,0,0,,这么做就变得有些笨重了
Dialogue: 0,1:06:43.46,1:06:45.96,Default,,0,0,0,,学生：有个论点 我不知道它和本节课的直接关系
Dialogue: 0,1:06:46.00,1:06:47.98,Default,,0,0,0,,但你想要表达的是
Dialogue: 0,1:06:48.49,1:06:50.16,Default,,0,0,0,,封闭世界假说的危害之一就是
Dialogue: 0,1:06:50.19,1:06:52.06,Default,,0,0,0,,你永远不会真正了解那里的所有事物
Dialogue: 0,1:06:53.44,1:06:55.32,Default,,0,0,0,,你永远不会知道它们的每个部分
Dialogue: 0,1:06:55.87,1:06:58.16,Default,,0,0,0,,这难道不是任何一门程序设计语言的主要问题吗？
Dialogue: 0,1:06:58.16,1:06:59.64,Default,,0,0,0,,写程序时 我总是
Dialogue: 0,1:06:59.90,1:07:01.56,Default,,0,0,0,,假设我考虑了所有的情况
Dialogue: 0,1:07:01.58,1:07:03.40,Default,,0,0,0,,然后我检查了每一种情况
Dialogue: 0,1:07:04.06,1:07:04.99,Default,,0,0,0,,然而在某处
Dialogue: 0,1:07:05.02,1:07:06.52,Default,,0,0,0,,我发现了我遗漏了其中的一个
Dialogue: 0,1:07:07.39,1:07:08.54,Default,,0,0,0,,教授：你说得很对
Dialogue: 0,1:07:08.54,1:07:09.76,Default,,0,0,0,,但这里的问题在于
Dialogue: 0,1:07:11.96,1:07:15.47,Default,,0,0,0,,对于你所做的事情
Dialogue: 0,1:07:15.48,1:07:17.34,Default,,0,0,0,,你是否认为它是逻辑问题
Dialogue: 0,1:07:19.60,1:07:20.51,Default,,0,0,0,,你说得非常正确
Dialogue: 0,1:07:20.51,1:07:22.22,Default,,0,0,0,,这是你永远不会遇到的情况
Dialogue: 0,1:07:22.22,1:07:24.14,Default,,0,0,0,,问题在于 如果你认为
Dialogue: 0,1:07:24.17,1:07:25.44,Default,,0,0,0,,你在进行逻辑式程序设计
Dialogue: 0,1:07:26.17,1:07:27.32,Default,,0,0,0,,然后审视你所编写的规则
Dialogue: 0,1:07:27.34,1:07:28.89,Default,,0,0,0,,并思考能从中推断出什么
Dialogue: 0,1:07:29.53,1:07:32.80,Default,,0,0,0,,你就需要清醒地认识到NOT具有另外的意义
Dialogue: 0,1:07:33.47,1:07:35.21,Default,,0,0,0,,它的意义基于某种假设
Dialogue: 0,1:07:35.24,1:07:36.70,Default,,0,0,0,,并且可能并不正确
Dialogue: 0,1:07:39.03,1:07:40.19,Default,,0,0,0,,学生：我不知道这样理解是否正确
Dialogue: 0,1:07:40.25,1:07:41.84,Default,,0,0,0,,也就是我们无法通过改变NOT
Dialogue: 0,1:07:42.25,1:07:46.08,Default,,0,0,0,,来消灭推断的所有可能性 从而解决这个问题？
Dialogue: 0,1:07:46.54,1:07:49.80,Default,,0,0,0,,教授：不 并不是这样
Dialogue: 0,1:07:52.96,1:07:55.08,Default,,0,0,0,,有很多种方法可以实现真正的逻辑非
Dialogue: 0,1:07:56.34,1:07:58.03,Default,,0,0,0,,实际上有很多种方法
Dialogue: 0,1:07:58.54,1:08:00.84,Default,,0,0,0,,但目前没有一个广为人知的高效算法
Dialogue: 0,1:08:01.61,1:08:02.56,Default,,0,0,0,,而且他们还--
Dialogue: 0,1:08:04.09,1:08:06.89,Default,,0,0,0,,这里所谓的“推论”
Dialogue: 0,1:08:07.39,1:08:08.83,Default,,0,0,0,,是建立在这个合一算法
Dialogue: 0,1:08:08.91,1:08:11.29,Default,,0,0,0,,以及模式匹配算法之中的
Dialogue: 0,1:08:11.98,1:08:16.19,Default,,0,0,0,,有多种方法可以实现真正的逻辑推理
Dialogue: 0,1:08:16.59,1:08:18.19,Default,,0,0,0,,但它们并不基于此
Dialogue: 0,1:08:18.51,1:08:20.73,Default,,0,0,0,,而逻辑式程序设计语言也不倾向于这么做
Dialogue: 0,1:08:20.75,1:08:23.85,Default,,0,0,0,,因为大家都知道 那样做非常低效
Dialogue: 0,1:08:29.39,1:08:30.03,Default,,0,0,0,,好吧 下课
Dialogue: 0,1:08:30.03,1:08:42.68,Declare,,0,0,0,,{\fad(500,500)}MIT OpenCourseWare\Nhttp://ocw.mit.edu
Dialogue: 0,1:08:30.03,1:08:42.68,Declare,,0,0,0,,{\an2\fad(500,500)}本项目主页\Nhttps://github.com/DeathKing/Learning-SICP
