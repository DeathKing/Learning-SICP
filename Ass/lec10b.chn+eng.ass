[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 640
PlayResY: 480

[Aegisub Project Garbage]
Active Line: 2622
Video Position: 105949

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: EN,Calisto MT,21,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,1,0,2,10,10,30,1
Style: Declare,微软雅黑,30,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,2,0,8,10,10,10,1
Style: staff,微软雅黑,30,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,0,2,5,10,10,10,1
Style: title,微软雅黑,35,&H001D64D9,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,0,1,5,10,10,10,1
Style: Default,雅黑宋体,20,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,1,0,2,10,10,30,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:18.91,0:00:20.61,EN,,0,0,0,,PROFESSOR: Well, there's one bit of mystery left,
Dialogue: 0,0:00:21.16,0:00:23.36,EN,,0,0,0,,which I'd like to get rid of right now.
Dialogue: 0,0:00:24.44,0:00:28.80,EN,,0,0,0,,And that's that we've been blithely doing things like cons
Dialogue: 0,0:00:30.00,0:00:31.62,EN,,0,0,0,,assuming there's always another one.
Dialogue: 0,0:00:32.80,0:00:36.32,EN,,0,0,0,,That we've been doing these things like
Dialogue: 0,0:00:36.51,0:00:37.44,EN,,0,0,0,,car-ing and cdr-ing
Dialogue: 0,0:00:37.47,0:00:38.72,EN,,0,0,0,,and assuming that we had some idea
Dialogue: 0,0:00:38.75,0:00:39.74,EN,,0,0,0,,how this can be done.
Dialogue: 0,0:00:40.02,0:00:40.67,EN,,0,0,0,,Now indeed
Dialogue: 0,0:00:41.07,0:00:44.40,EN,,0,0,0,,we said that that's equivalent to having procedures.
Dialogue: 0,0:00:45.37,0:00:47.57,EN,,0,0,0,,OK? But that doesn't really solve the problem,
Dialogue: 0,0:00:47.73,0:00:50.25,EN,,0,0,0,,because the procedure need all sorts of complicated mechanisms
Dialogue: 0,0:00:50.27,0:00:51.37,EN,,0,0,0,,like environment structures
Dialogue: 0,0:00:51.64,0:00:52.76,EN,,0,0,0,,and things like that to work.
Dialogue: 0,0:00:53.01,0:00:54.89,EN,,0,0,0,,And those were ultimately made out of conses
Dialogue: 0,0:00:54.89,0:00:56.42,EN,,0,0,0,,in the model that we had,
Dialogue: 0,0:00:56.70,0:00:58.47,EN,,0,0,0,,so that really doesn't solve the problem.
Dialogue: 0,0:00:59.38,0:01:01.13,EN,,0,0,0,,Now the problem here is
Dialogue: 0,0:01:01.31,0:01:03.97,EN,,0,0,0,,is the glue the data structure's made out of.
Dialogue: 0,0:01:04.76,0:01:06.40,EN,,0,0,0,,What kind of possible thing could it be?
Dialogue: 0,0:01:07.04,0:01:10.46,EN,,0,0,0,,OK? We've been showing you things like a machine,
Dialogue: 0,0:01:10.46,0:01:13.96,EN,,0,0,0,,a computer that has a controller,
Dialogue: 0,0:01:14.27,0:01:15.45,EN,,0,0,0,,and some registers,
Dialogue: 0,0:01:15.45,0:01:16.47,EN,,0,0,0,,and maybe a stack.
Dialogue: 0,0:01:16.98,0:01:18.12,EN,,0,0,0,,And we haven't said anything about,
Dialogue: 0,0:01:18.16,0:01:19.95,EN,,0,0,0,,for example, larger memory.
Dialogue: 0,0:01:20.57,0:01:22.38,EN,,0,0,0,,And I think that's what we have to worry about right now.
Dialogue: 0,0:01:23.74,0:01:26.56,EN,,0,0,0,,But just to make it perfectly clear
Dialogue: 0,0:01:26.59,0:01:27.88,EN,,0,0,0,,that this is an inessential,
Dialogue: 0,0:01:28.82,0:01:30.79,EN,,0,0,0,,purely implementational thing,
Dialogue: 0,0:01:31.10,0:01:32.60,EN,,0,0,0,,I'd like to show you, for example,
Dialogue: 0,0:01:32.60,0:01:34.20,EN,,0,0,0,,how you can do it all with the numbers.
Dialogue: 0,0:01:35.23,0:01:36.82,EN,,0,0,0,,That's an easy one.
Dialogue: 0,0:01:37.59,0:01:39.00,EN,,0,0,0,,Famous fellow by the name of Godel,
Dialogue: 0,0:01:44.09,0:01:46.01,EN,,0,0,0,,a logician at the end of the 1930s,
Dialogue: 0,0:01:46.38,0:01:48.70,EN,,0,0,0,,invented a very clever way
Dialogue: 0,0:01:48.70,0:01:52.27,EN,,0,0,0,,of encoding the complicated expressions
Dialogue: 0,0:01:52.81,0:01:53.52,EN,,0,0,0,,as numbers.
Dialogue: 0,0:01:54.32,0:01:55.05,EN,,0,0,0,,For example--
Dialogue: 0,0:01:55.05,0:01:58.00,EN,,0,0,0,,I'm not saying exactly what Godel's scheme is,
Dialogue: 0,0:01:58.00,0:01:59.48,EN,,0,0,0,,because he didn't use words like cons.
Dialogue: 0,0:01:59.66,0:02:00.60,EN,,0,0,0,,He had other kinds of
Dialogue: 0,0:02:00.91,0:02:02.60,EN,,0,0,0,,of ways of combining to make expressions.
Dialogue: 0,0:02:03.09,0:02:03.88,EN,,0,0,0,,But he said,
Dialogue: 0,0:02:03.92,0:02:06.81,EN,,0,0,0,,I'm going to assign a number to every algebraic expression.
Dialogue: 0,0:02:07.92,0:02:09.72,EN,,0,0,0,,And the way I'm going to manufacture these numbers
Dialogue: 0,0:02:09.72,0:02:11.65,EN,,0,0,0,,is by combining the numbers of the parts.
Dialogue: 0,0:02:12.47,0:02:13.45,EN,,0,0,0,,So for example,
Dialogue: 0,0:02:13.62,0:02:15.35,EN,,0,0,0,,what we were doing our world,
Dialogue: 0,0:02:15.35,0:02:18.01,EN,,0,0,0,,we could say that if objects
Dialogue: 0,0:02:20.78,0:02:22.22,EN,,0,0,0,,are represented by numbers,
Dialogue: 0,0:02:30.67,0:02:37.93,EN,,0,0,0,,then cons of x and y
Dialogue: 0,0:02:38.04,0:02:41.07,EN,,0,0,0,,could be represented by,
Dialogue: 0,0:02:41.55,0:02:43.77,EN,,0,0,0,,2 to the x times 3 to the y.
Dialogue: 0,0:02:46.13,0:02:48.03,EN,,0,0,0,,Because then we could extract the parts.
Dialogue: 0,0:02:49.56,0:02:50.97,EN,,0,0,0,,We could say, for example,
Dialogue: 0,0:02:51.18,0:02:55.88,EN,,0,0,0,,that then car of, say, x
Dialogue: 0,0:02:56.55,0:03:05.18,EN,,0,0,0,,is the number of factors of 2 in x.
Dialogue: 0,0:03:06.69,0:03:08.78,EN,,0,0,0,,OK? And of course cdr is the same thing.
Dialogue: 0,0:03:10.69,0:03:15.57,EN,,0,0,0,,It's the number of factors of 3 in x.
Dialogue: 0,0:03:16.51,0:03:18.65,EN,,0,0,0,,Now this is a perfectly reasonable scheme,
Dialogue: 0,0:03:19.10,0:03:20.11,EN,,0,0,0,,except for the fact that
Dialogue: 0,0:03:20.12,0:03:22.52,EN,,0,0,0,,the numbers rapidly get to be much larger
Dialogue: 0,0:03:22.83,0:03:23.98,EN,,0,0,0,,in number of digits
Dialogue: 0,0:03:24.32,0:03:26.55,EN,,0,0,0,,than the number of protons in the universe.
Dialogue: 0,0:03:27.95,0:03:29.88,EN,,0,0,0,,So there's no easy way to use this scheme
Dialogue: 0,0:03:29.90,0:03:31.21,EN,,0,0,0,,other than the theoretical one.
Dialogue: 0,0:03:33.43,0:03:34.48,EN,,0,0,0,,On the other hand,
Dialogue: 0,0:03:35.12,0:03:37.55,EN,,0,0,0,,there are other ways of representing these things.
Dialogue: 0,0:03:38.45,0:03:40.01,EN,,0,0,0,,We have been thinking in terms
Dialogue: 0,0:03:40.25,0:03:42.42,EN,,0,0,0,,of little boxes, boxes.
Dialogue: 0,0:03:43.32,0:03:46.43,EN,,0,0,0,,We've been thinking about our cons structures
Dialogue: 0,0:03:46.50,0:03:48.05,EN,,0,0,0,,as looking sort of like this.
Dialogue: 0,0:03:50.28,0:03:52.57,EN,,0,0,0,,They're little pigeon holes with things in them.
Dialogue: 0,0:03:53.56,0:03:55.47,EN,,0,0,0,,And of course we arrange them in little trees.
Dialogue: 0,0:03:57.21,0:03:59.97,EN,,0,0,0,,I wish that the semiconductor manufacturers
Dialogue: 0,0:03:59.97,0:04:02.07,EN,,0,0,0,,would supply me with something appropriate for this,
Dialogue: 0,0:04:02.70,0:04:03.76,EN,,0,0,0,,but actually
Dialogue: 0,0:04:03.85,0:04:05.31,EN,,0,0,0,,what they do supply me with
Dialogue: 0,0:04:06.20,0:04:07.96,EN,,0,0,0,,is a linear memory.
Dialogue: 0,0:04:09.38,0:04:13.46,EN,,0,0,0,,Memory is sort of a big pile of pigeonholes,
Dialogue: 0,0:04:15.12,0:04:16.34,EN,,0,0,0,,pigeonholes like this.
Dialogue: 0,0:04:17.72,0:04:20.25,EN,,0,0,0,,Each of which can hold a certain sized object,
Dialogue: 0,0:04:20.94,0:04:22.20,EN,,0,0,0,,a fixed size object.
Dialogue: 0,0:04:23.39,0:04:24.07,EN,,0,0,0,,So, for example,
Dialogue: 0,0:04:24.07,0:04:25.66,EN,,0,0,0,,a complicated list with 25 elements
Dialogue: 0,0:04:25.66,0:04:26.64,EN,,0,0,0,,won't fit in one of these.
Dialogue: 0,0:04:28.55,0:04:29.26,EN,,0,0,0,,However, each of these
Dialogue: 0,0:04:29.29,0:04:30.88,EN,,0,0,0,,is indexed by an address.
Dialogue: 0,0:04:33.97,0:04:34.99,EN,,0,0,0,,So the address might be
Dialogue: 0,0:04:35.02,0:04:35.50,EN,,0,0,0,,zero here,
Dialogue: 0,0:04:35.50,0:04:36.22,EN,,0,0,0,,one here,
Dialogue: 0,0:04:36.22,0:04:36.70,EN,,0,0,0,,two here,
Dialogue: 0,0:04:36.70,0:04:37.25,EN,,0,0,0,,three here,
Dialogue: 0,0:04:37.25,0:04:37.94,EN,,0,0,0,,and so on.
Dialogue: 0,0:04:38.06,0:04:40.40,EN,,0,0,0,,That we write these down as numbers is unimportant.
Dialogue: 0,0:04:40.40,0:04:41.68,EN,,0,0,0,,What matters is that they're distinct
Dialogue: 0,0:04:41.95,0:04:43.42,EN,,0,0,0,,as a way to get to the next one.
Dialogue: 0,0:04:44.97,0:04:46.14,EN,,0,0,0,,And inside of each of these,
Dialogue: 0,0:04:46.36,0:04:49.11,EN,,0,0,0,,we can stuff something into these pigeonholes.
Dialogue: 0,0:04:49.53,0:04:50.77,EN,,0,0,0,,That's what memory is like,
Dialogue: 0,0:04:51.02,0:04:53.66,EN,,0,0,0,,for those of you who haven't built a computer.
Dialogue: 0,0:04:54.15,0:04:54.65,EN,,0,0,0,,Now.
Dialogue: 0,0:04:56.69,0:04:57.53,EN,,0,0,0,,Now the problem is
Dialogue: 0,0:04:57.53,0:04:59.97,EN,,0,0,0,,how are we going to impose on this type of structure,
Dialogue: 0,0:05:00.42,0:05:01.72,EN,,0,0,0,,this nice tree structure.
Dialogue: 0,0:05:03.29,0:05:04.57,EN,,0,0,0,,Well it's not very hard,
Dialogue: 0,0:05:04.57,0:05:06.35,EN,,0,0,0,,and there have been numerous schemes involved in this.
Dialogue: 0,0:05:06.87,0:05:08.80,EN,,0,0,0,,The most important one is to say,
Dialogue: 0,0:05:08.80,0:05:11.18,EN,,0,0,0,,well assuming that the semiconductor manufacturer
Dialogue: 0,0:05:11.20,0:05:13.90,EN,,0,0,0,,allows me to arrange my memory
Dialogue: 0,0:05:13.98,0:05:15.77,EN,,0,0,0,,so that one of these pigeonholes is big enough
Dialogue: 0,0:05:16.28,0:05:18.20,EN,,0,0,0,,to hold the address of another
Dialogue: 0,0:05:19.35,0:05:20.83,EN,,0,0,0,,OK. I have been made.
Dialogue: 0,0:05:22.05,0:05:23.45,EN,,0,0,0,,Now it actually has to be a little bit bigger
Dialogue: 0,0:05:23.48,0:05:27.52,EN,,0,0,0,,because I have to also install or store some information
Dialogue: 0,0:05:27.56,0:05:30.09,EN,,0,0,0,,as to a tag which describes the kind of thing that's there.
Dialogue: 0,0:05:30.39,0:05:31.64,EN,,0,0,0,,And we'll see that in a second.
Dialogue: 0,0:05:32.62,0:05:34.40,EN,,0,0,0,,And of course if the semiconductor manufacturer
Dialogue: 0,0:05:34.43,0:05:35.88,EN,,0,0,0,,doesn't arrange it so I can do that,
Dialogue: 0,0:05:36.08,0:05:38.44,EN,,0,0,0,,then of course I can, with some cleverness,
Dialogue: 0,0:05:38.57,0:05:41.82,EN,,0,0,0,,arrange combinations of these to fit together in that way.
Dialogue: 0,0:05:43.77,0:05:47.05,EN,,0,0,0,,So we're going to have to imagine
Dialogue: 0,0:05:47.05,0:05:49.54,EN,,0,0,0,,imposing this complicated tree structure
Dialogue: 0,0:05:49.54,0:05:51.20,EN,,0,0,0,,on our nice linear memory.
Dialogue: 0,0:05:51.74,0:05:54.47,EN,,0,0,0,,If we look at the first still store,
Dialogue: 0,0:05:54.47,0:05:58.30,EN,,0,0,0,,we see a classic scheme for doing that.
Dialogue: 0,0:05:59.49,0:06:02.62,EN,,0,0,0,,It's a standard way of representing list structures
Dialogue: 0,0:06:03.22,0:06:05.87,EN,,0,0,0,,in a linear memory.
Dialogue: 0,0:06:06.27,0:06:08.32,EN,,0,0,0,,What we do is we divide this memory
Dialogue: 0,0:06:08.88,0:06:11.12,EN,,0,0,0,,into two parts.
Dialogue: 0,0:06:12.03,0:06:13.42,EN,,0,0,0,,An array called the cars,
Dialogue: 0,0:06:14.45,0:06:15.88,EN,,0,0,0,,and an array called the cdrs.
Dialogue: 0,0:06:17.58,0:06:18.86,EN,,0,0,0,,Now whether those happen to be
Dialogue: 0,0:06:18.88,0:06:21.04,EN,,0,0,0,,sequential addresses or whatever,
Dialogue: 0,0:06:21.12,0:06:22.00,EN,,0,0,0,,it's not important.
Dialogue: 0,0:06:22.87,0:06:25.20,EN,,0,0,0,,That's somebody's implementation details.
Dialogue: 0,0:06:25.80,0:06:28.40,EN,,0,0,0,,But there are two arrays here.
Dialogue: 0,0:06:28.96,0:06:30.36,EN,,0,0,0,,Linear arrays indexed
Dialogue: 0,0:06:30.46,0:06:32.59,EN,,0,0,0,,by sequential indices like this.
Dialogue: 0,0:06:34.84,0:06:36.85,EN,,0,0,0,,What is stored in each of these pigeonholes
Dialogue: 0,0:06:37.46,0:06:39.85,EN,,0,0,0,,is a typed object.
Dialogue: 0,0:06:41.43,0:06:42.57,EN,,0,0,0,,And what we have here
Dialogue: 0,0:06:42.57,0:06:45.71,EN,,0,0,0,,are types which begin with letters like p,
Dialogue: 0,0:06:45.71,0:06:46.57,EN,,0,0,0,,standing for a pair.
Dialogue: 0,0:06:47.79,0:06:49.37,EN,,0,0,0,,Or n, standing for a number.
Dialogue: 0,0:06:50.04,0:06:52.25,EN,,0,0,0,,Or e, standing for an empty list.
Dialogue: 0,0:06:54.81,0:06:55.83,EN,,0,0,0,,The end of the list.
Dialogue: 0,0:06:57.02,0:06:58.59,EN,,0,0,0,,And so if we wish to represent
Dialogue: 0,0:06:58.99,0:06:59.97,EN,,0,0,0,,an object like this,
Dialogue: 0,0:07:00.01,0:07:02.16,EN,,0,0,0,,the list beginning with 1, 2
Dialogue: 0,0:07:02.65,0:07:04.01,EN,,0,0,0,,and then having a 3 and a 4
Dialogue: 0,0:07:04.01,0:07:05.50,EN,,0,0,0,,and then having a 3 and a 4 as its second and third elements.
Dialogue: 0,0:07:06.43,0:07:08.83,EN,,0,0,0,,A list containing a list as its first part
Dialogue: 0,0:07:09.35,0:07:10.65,EN,,0,0,0,,and then two numbers
Dialogue: 0,0:07:10.65,0:07:12.00,EN,,0,0,0,,as a second and third parts.
Dialogue: 0,0:07:12.87,0:07:14.81,EN,,0,0,0,,Then of course we draw it sort of like this these days,
Dialogue: 0,0:07:14.84,0:07:16.67,EN,,0,0,0,,in box-and-pointer notation.
Dialogue: 0,0:07:17.32,0:07:18.00,EN,,0,0,0,,And you see,
Dialogue: 0,0:07:18.00,0:07:20.04,EN,,0,0,0,,these are the three cells
Dialogue: 0,0:07:20.25,0:07:22.01,EN,,0,0,0,,that have as their car pointer
Dialogue: 0,0:07:22.27,0:07:27.10,EN,,0,0,0,,the object which is either 1, 2 or 3 or 4.
Dialogue: 0,0:07:28.39,0:07:29.75,EN,,0,0,0,,And then of course the 1, 2,
Dialogue: 0,0:07:29.75,0:07:31.32,EN,,0,0,0,,the car of this entire structure,
Dialogue: 0,0:07:31.32,0:07:32.65,EN,,0,0,0,,is itself a substructure
Dialogue: 0,0:07:32.88,0:07:34.75,EN,,0,0,0,,which contains a sublist like that.
Dialogue: 0,0:07:35.94,0:07:37.07,EN,,0,0,0,,What I'm about to do
Dialogue: 0,0:07:37.20,0:07:39.92,EN,,0,0,0,,is put down places which are--
Dialogue: 0,0:07:39.95,0:07:41.46,EN,,0,0,0,,I'm going to assign indices.
Dialogue: 0,0:07:41.84,0:07:43.40,EN,,0,0,0,,Like this 1, over here,
Dialogue: 0,0:07:43.56,0:07:47.05,EN,,0,0,0,,represents the index of this cell.
Dialogue: 0,0:07:49.85,0:07:51.47,EN,,0,0,0,,But that pointer that we see here
Dialogue: 0,0:07:52.37,0:07:54.86,EN,,0,0,0,,is a reference to the
Dialogue: 0,0:07:55.07,0:07:57.29,EN,,0,0,0,,pair of pigeonholes in the cars and the cdrs
Dialogue: 0,0:07:57.40,0:07:58.67,EN,,0,0,0,,that are labeled by 1
Dialogue: 0,0:07:58.76,0:08:00.33,EN,,0,0,0,,in my linear memory down here.
Dialogue: 0,0:08:02.00,0:08:04.06,EN,,0,0,0,,So if I wish to impose this structure
Dialogue: 0,0:08:04.16,0:08:05.26,EN,,0,0,0,,on my linear memory,
Dialogue: 0,0:08:05.85,0:08:07.52,EN,,0,0,0,,what I do is I say, oh yes,
Dialogue: 0,0:08:07.52,0:08:11.88,EN,,0,0,0,,why don't we drop this into cell 1?
Dialogue: 0,0:08:11.95,0:08:12.66,EN,,0,0,0,,Well I said, I pick 1.
Dialogue: 0,0:08:12.66,0:08:13.85,EN,,0,0,0,,There's 1. OK?
Dialogue: 0,0:08:14.27,0:08:16.22,EN,,0,0,0,,And that says that its car,
Dialogue: 0,0:08:16.22,0:08:17.74,EN,,0,0,0,,I'm going to assign it to be a pair.
Dialogue: 0,0:08:17.95,0:08:18.72,EN,,0,0,0,,It's a pair,
Dialogue: 0,0:08:20.02,0:08:21.55,EN,,0,0,0,,which is in index 5.
Dialogue: 0,0:08:22.59,0:08:23.90,EN,,0,0,0,,And the cdr,
Dialogue: 0,0:08:23.90,0:08:25.13,EN,,0,0,0,,which is this one over here,
Dialogue: 0,0:08:25.39,0:08:26.13,EN,,0,0,0,,is a pair
Dialogue: 0,0:08:26.13,0:08:27.70,EN,,0,0,0,,which I'm going to stick into place 2.
Dialogue: 0,0:08:28.34,0:08:28.98,EN,,0,0,0,,p2.
Dialogue: 0,0:08:30.89,0:08:32.95,EN,,0,0,0,,And take a look at p2.
Dialogue: 0,0:08:32.95,0:08:34.72,EN,,0,0,0,,Oh yes, well p2 is a thing
Dialogue: 0,0:08:34.90,0:08:37.22,EN,,0,0,0,,whose car is the number 3,
Dialogue: 0,0:08:37.34,0:08:38.64,EN,,0,0,0,,so as you see, an n3.
Dialogue: 0,0:08:39.52,0:08:41.52,EN,,0,0,0,,And whose cdr, over here,
Dialogue: 0,0:08:41.72,0:08:43.40,EN,,0,0,0,,is a pair,
Dialogue: 0,0:08:43.97,0:08:45.81,EN,,0,0,0,,which lives in place 4.
Dialogue: 0,0:08:46.64,0:08:47.79,EN,,0,0,0,,So that's what this p4 is.
Dialogue: 0,0:08:48.65,0:08:51.16,EN,,0,0,0,,p4 is a number
Dialogue: 0,0:08:51.85,0:08:53.87,EN,,0,0,0,,whose value is 4 in its car
Dialogue: 0,0:08:54.60,0:08:55.65,EN,,0,0,0,,and whose cdr
Dialogue: 0,0:08:55.84,0:08:58.48,EN,,0,0,0,,is an empty list right there.
Dialogue: 0,0:08:59.17,0:08:59.90,EN,,0,0,0,,And that ends it.
Dialogue: 0,0:09:00.69,0:09:04.57,EN,,0,0,0,,So this is the traditional way of representing
Dialogue: 0,0:09:04.90,0:09:09.55,EN,,0,0,0,,this kind of binary tree in a linear memory.
Dialogue: 0,0:09:11.62,0:09:15.10,EN,,0,0,0,,Now the next question, of course,
Dialogue: 0,0:09:15.10,0:09:16.36,EN,,0,0,0,,that we might want to worry about
Dialogue: 0,0:09:16.60,0:09:18.19,EN,,0,0,0,,is just a little bit of implementation.
Dialogue: 0,0:09:18.44,0:09:20.33,EN,,0,0,0,,That means that when I write procedures
Dialogue: 0,0:09:20.36,0:09:23.62,EN,,0,0,0,,of the form assigned a,
Dialogue: 0,0:09:24.54,0:09:27.10,EN,,0,0,0,,lines of register machine code
Dialogue: 0,0:09:27.21,0:09:30.14,EN,,0,0,0,,of the form assigned a, the car of fetch of b,
Dialogue: 0,0:09:30.84,0:09:31.85,EN,,0,0,0,,what I really mean
Dialogue: 0,0:09:31.97,0:09:37.10,EN,,0,0,0,,is addressing these elements.
Dialogue: 0,0:09:38.74,0:09:40.25,EN,,0,0,0,,And so we're going to think of that as
Dialogue: 0,0:09:40.68,0:09:42.94,EN,,0,0,0,,a abbreviation for it.
Dialogue: 0,0:09:44.47,0:09:46.33,EN,,0,0,0,,Now of course in order to write that down
Dialogue: 0,0:09:46.35,0:09:48.59,EN,,0,0,0,,I'm going to introduce some sort of a structure
Dialogue: 0,0:09:48.62,0:09:49.42,EN,,0,0,0,,called a vector.
Dialogue: 0,0:09:52.12,0:09:53.31,EN,,0,0,0,,And we're going to have something which will
Dialogue: 0,0:09:53.48,0:09:54.54,EN,,0,0,0,,reference a vector,
Dialogue: 0,0:09:56.84,0:09:58.51,EN,,0,0,0,,just so we can write it down.
Dialogue: 0,0:09:58.71,0:10:00.22,EN,,0,0,0,,Which takes the name of the vector,
Dialogue: 0,0:10:01.02,0:10:03.97,EN,,0,0,0,,or the-- I don't think that name is the right word.
Dialogue: 0,0:10:03.97,0:10:09.40,EN,,0,0,0,,Which takes the vector and the index,
Dialogue: 0,0:10:11.20,0:10:13.05,EN,,0,0,0,,and I have to have a way of setting one of those
Dialogue: 0,0:10:13.10,0:10:14.27,EN,,0,0,0,,with something called a vector set,
Dialogue: 0,0:10:14.65,0:10:15.60,EN,,0,0,0,,I don't really care.
Dialogue: 0,0:10:16.28,0:10:17.55,EN,,0,0,0,,But let's look, for example,
Dialogue: 0,0:10:18.11,0:10:20.42,EN,,0,0,0,,at then that kind of implementation
Dialogue: 0,0:10:21.25,0:10:23.18,EN,,0,0,0,,of car and cdr.
Dialogue: 0,0:10:26.47,0:10:28.41,EN,,0,0,0,,So for example if I happen to have
Dialogue: 0,0:10:28.88,0:10:30.80,EN,,0,0,0,,a register b,
Dialogue: 0,0:10:31.15,0:10:34.64,EN,,0,0,0,,which contains the type index of a pair,
Dialogue: 0,0:10:35.95,0:10:38.80,EN,,0,0,0,,and therefore it is the pointer to a pair,
Dialogue: 0,0:10:39.35,0:10:40.85,EN,,0,0,0,,then I could take the car of that and
Dialogue: 0,0:10:41.55,0:10:44.11,EN,,0,0,0,,OK if I-- write this down-- I might put that in register a.
Dialogue: 0,0:10:44.49,0:10:46.86,EN,,0,0,0,,What that really is is a representation of
Dialogue: 0,0:10:47.37,0:10:50.19,EN,,0,0,0,,the assign to a,
Dialogue: 0,0:10:50.19,0:10:51.92,EN,,0,0,0,,the value of vector reffing--
Dialogue: 0,0:10:52.80,0:10:55.24,EN,,0,0,0,,or array indexing, if you will-- or something,
Dialogue: 0,0:10:55.42,0:10:57.63,EN,,0,0,0,,the cars object--
Dialogue: 0,0:10:58.40,0:11:00.92,EN,,0,0,0,,whatever that is-- with the index, b.
Dialogue: 0,0:11:02.65,0:11:03.63,EN,,0,0,0,,And similarly for cdr.
Dialogue: 0,0:11:04.10,0:11:05.72,EN,,0,0,0,,And we can do the same thing
Dialogue: 0,0:11:05.90,0:11:08.32,EN,,0,0,0,,for assignment to data structures,
Dialogue: 0,0:11:08.92,0:11:10.92,EN,,0,0,0,,If we need to do that sort of things at all.
Dialogue: 0,0:11:11.84,0:11:13.80,EN,,0,0,0,,It's not too hard to build that.
Dialogue: 0,0:11:14.58,0:11:15.72,EN,,0,0,0,,Well now the next question is
Dialogue: 0,0:11:15.72,0:11:17.00,EN,,0,0,0,,how are we going to do allocation.
Dialogue: 0,0:11:18.01,0:11:20.13,EN,,0,0,0,,And every so often I say I want a cons.
Dialogue: 0,0:11:21.40,0:11:23.42,EN,,0,0,0,,Now conses don't grow on trees.
Dialogue: 0,0:11:23.79,0:11:24.81,EN,,0,0,0,,Or maybe they should.
Dialogue: 0,0:11:25.34,0:11:26.56,EN,,0,0,0,,But I have to have some way
Dialogue: 0,0:11:26.70,0:11:28.97,EN,,0,0,0,,I have to have some way of getting the next one.
Dialogue: 0,0:11:29.98,0:11:31.47,EN,,0,0,0,,I have to have some idea of
Dialogue: 0,0:11:31.47,0:11:33.04,EN,,0,0,0,,if their memory is unused
Dialogue: 0,0:11:33.69,0:11:35.05,EN,,0,0,0,,that I might want to allocate from.
Dialogue: 0,0:11:35.63,0:11:37.38,EN,,0,0,0,,And there are many schemes for doing this.
Dialogue: 0,0:11:37.38,0:11:39.07,EN,,0,0,0,,And the particular thing I'm showing you right now
Dialogue: 0,0:11:39.23,0:11:40.45,EN,,0,0,0,,is not essential.
Dialogue: 0,0:11:42.10,0:11:43.18,EN,,0,0,0,,However it's convenient
Dialogue: 0,0:11:43.20,0:11:44.44,EN,,0,0,0,,and has been done many times.
Dialogue: 0,0:11:44.60,0:11:47.20,EN,,0,0,0,,It's one schemes called the free list allocation scheme.
Dialogue: 0,0:11:47.66,0:11:48.68,EN,,0,0,0,,What that means is
Dialogue: 0,0:11:48.68,0:11:51.12,EN,,0,0,0,,that all of the free memory that there is in the world
Dialogue: 0,0:11:51.55,0:11:53.08,EN,,0,0,0,,is linked together in a linked list,
Dialogue: 0,0:11:54.55,0:11:56.22,EN,,0,0,0,,just like all the other stuff.
Dialogue: 0,0:11:56.96,0:11:59.07,EN,,0,0,0,,And whenever you need a free cell
Dialogue: 0,0:11:59.07,0:12:00.12,EN,,0,0,0,,to make a new cons,
Dialogue: 0,0:12:00.95,0:12:02.26,EN,,0,0,0,,you grab the first one
Dialogue: 0,0:12:02.26,0:12:03.82,EN,,0,0,0,,make the free list be the cdr of it,
Dialogue: 0,0:12:04.32,0:12:05.55,EN,,0,0,0,,and then allocate that.
Dialogue: 0,0:12:06.03,0:12:08.32,EN,,0,0,0,,And so what that looks like is something like this.
Dialogue: 0,0:12:09.53,0:12:13.32,EN,,0,0,0,,Here we have the free list
Dialogue: 0,0:12:13.95,0:12:16.81,EN,,0,0,0,,starting in 6.
Dialogue: 0,0:12:18.51,0:12:23.47,EN,,0,0,0,,And what that is is a pointer-off to say 8.
Dialogue: 0,0:12:24.86,0:12:25.62,EN,,0,0,0,,So what it says is,
Dialogue: 0,0:12:25.62,0:12:26.55,EN,,0,0,0,,this one is free
Dialogue: 0,0:12:26.55,0:12:27.95,EN,,0,0,0,,and the next one is an 8.
Dialogue: 0,0:12:28.87,0:12:29.88,EN,,0,0,0,,This one is free
Dialogue: 0,0:12:30.04,0:12:32.08,EN,,0,0,0,,and the next one is in 3,
Dialogue: 0,0:12:32.32,0:12:33.45,EN,,0,0,0,,the next one that's free.
Dialogue: 0,0:12:33.93,0:12:34.95,EN,,0,0,0,,That one's free
Dialogue: 0,0:12:35.04,0:12:37.68,EN,,0,0,0,,and the next one is in 0.
Dialogue: 0,0:12:37.87,0:12:38.49,EN,,0,0,0,,That one's free
Dialogue: 0,0:12:38.52,0:12:39.82,EN,,0,0,0,,and the next one's in 15.
Dialogue: 0,0:12:40.94,0:12:41.84,EN,,0,0,0,,Something like that.
Dialogue: 0,0:12:42.78,0:12:44.64,EN,,0,0,0,,We can imagine having such a structure.
Dialogue: 0,0:12:46.40,0:12:48.03,EN,,0,0,0,,Given that we have something like that,
Dialogue: 0,0:12:49.45,0:12:50.92,EN,,0,0,0,,then it's possible to
Dialogue: 0,0:12:50.92,0:12:52.22,EN,,0,0,0,,just get one when you need it.
Dialogue: 0,0:12:53.82,0:12:56.46,EN,,0,0,0,,And so a program for doing cons,
Dialogue: 0,0:12:57.45,0:12:59.13,EN,,0,0,0,,this is what cons might turn into.
Dialogue: 0,0:12:59.32,0:13:02.57,EN,,0,0,0,,To assign to a register A the result of cons-ing,
Dialogue: 0,0:13:02.95,0:13:05.82,EN,,0,0,0,,a B onto C,
Dialogue: 0,0:13:06.20,0:13:09.04,EN,,0,0,0,,the value in this containing B and the value containing C,
Dialogue: 0,0:13:09.27,0:13:10.52,EN,,0,0,0,,what we have to do is
Dialogue: 0,0:13:10.56,0:13:12.24,EN,,0,0,0,,get the current tail ahead of the freelist,
Dialogue: 0,0:13:12.47,0:13:14.30,EN,,0,0,0,,make the free list be its cdr.
Dialogue: 0,0:13:15.64,0:13:18.33,EN,,0,0,0,,Then we have to change the cars
Dialogue: 0,0:13:18.41,0:13:22.49,EN,,0,0,0,,to be the thing we're making up to be in A
Dialogue: 0,0:13:23.13,0:13:25.45,EN,,0,0,0,,to be the B, the thing in B.
Dialogue: 0,0:13:25.90,0:13:28.65,EN,,0,0,0,,And we have to make change the cdrs of
Dialogue: 0,0:13:29.20,0:13:31.72,EN,,0,0,0,,the thing that's in A to be C.
Dialogue: 0,0:13:33.20,0:13:34.76,EN,,0,0,0,,And then what we have in A
Dialogue: 0,0:13:34.78,0:13:36.65,EN,,0,0,0,,is the right new frob, whatever it is.
Dialogue: 0,0:13:36.81,0:13:37.92,EN,,0,0,0,,The object that we want.
Dialogue: 0,0:13:40.47,0:13:42.50,EN,,0,0,0,,Now there's a little bit of
Dialogue: 0,0:13:42.50,0:13:43.97,EN,,0,0,0,,a cheat here that I haven't told you about,
Dialogue: 0,0:13:43.97,0:13:45.32,EN,,0,0,0,,which is somewhere around here
Dialogue: 0,0:13:45.53,0:13:47.32,EN,,0,0,0,,I haven't set the type of the thing that I've
Dialogue: 0,0:13:48.45,0:13:50.48,EN,,0,0,0,,the type of the thing
Dialogue: 0,0:13:50.51,0:13:51.87,EN,,0,0,0,,that I'm cons-ing up to be a pair,
Dialogue: 0,0:13:52.30,0:13:53.05,EN,,0,0,0,,and I ought to.
Dialogue: 0,0:13:53.51,0:13:56.57,EN,,0,0,0,,So there should be some sort of bits here are being set,
Dialogue: 0,0:13:56.60,0:13:57.76,EN,,0,0,0,,and I just haven't written that down.
Dialogue: 0,0:13:59.81,0:14:00.86,EN,,0,0,0,,We could have arranged it, of course,
Dialogue: 0,0:14:00.89,0:14:02.45,EN,,0,0,0,,for the free list to be made out of pairs.
Dialogue: 0,0:14:03.10,0:14:04.88,EN,,0,0,0,,And so then there's no problem with that.
Dialogue: 0,0:14:06.43,0:14:07.74,EN,,0,0,0,,But that sort of--
Dialogue: 0,0:14:07.82,0:14:09.92,EN,,0,0,0,,again, an inessential detail in a way
Dialogue: 0,0:14:10.22,0:14:12.88,EN,,0,0,0,,some particular programmer or architect
Dialogue: 0,0:14:12.92,0:14:14.27,EN,,0,0,0,,or whatever might manufacture
Dialogue: 0,0:14:14.33,0:14:16.68,EN,,0,0,0,,his machine or Lisp system.
Dialogue: 0,0:14:17.54,0:14:18.71,EN,,0,0,0,,So for example,
Dialogue: 0,0:14:19.07,0:14:20.24,EN,,0,0,0,,just looking at this,
Dialogue: 0,0:14:20.65,0:14:23.45,EN,,0,0,0,,to allocate
Dialogue: 0,0:14:23.55,0:14:26.83,EN,,0,0,0,,given that I had already the structure that you saw before,
Dialogue: 0,0:14:27.21,0:14:30.26,EN,,0,0,0,,supposing I wanted to allocate a new cell,
Dialogue: 0,0:14:30.55,0:14:36.61,EN,,0,0,0,,which is going to be representation of list one, one, two,
Dialogue: 0,0:14:37.24,0:14:39.87,EN,,0,0,0,,where already one two was the car
Dialogue: 0,0:14:40.28,0:14:42.16,EN,,0,0,0,,of the list we were playing with before.
Dialogue: 0,0:14:43.43,0:14:44.45,EN,,0,0,0,,Well that's not so hard.
Dialogue: 0,0:14:44.78,0:14:46.20,EN,,0,0,0,,I stored that one in one,
Dialogue: 0,0:14:46.20,0:14:49.17,EN,,0,0,0,,so p1 one is the representation of this.
Dialogue: 0,0:14:49.53,0:14:50.83,EN,,0,0,0,,This is p5.
Dialogue: 0,0:14:51.67,0:14:53.51,EN,,0,0,0,,That's going to be the cdr of this.
Dialogue: 0,0:14:54.07,0:14:55.52,EN,,0,0,0,,Now we're going to pull something off the free list,
Dialogue: 0,0:14:55.52,0:14:57.30,EN,,0,0,0,,but remember the free list started at six.
Dialogue: 0,0:14:57.78,0:15:00.18,EN,,0,0,0,,The new free list after this allocation is eight,
Dialogue: 0,0:15:00.60,0:15:02.55,EN,,0,0,0,,a free list beginning at eight.
Dialogue: 0,0:15:02.89,0:15:03.52,EN,,0,0,0,,And of course
Dialogue: 0,0:15:03.72,0:15:06.04,EN,,0,0,0,,in six now we have a number one,
Dialogue: 0,0:15:06.15,0:15:07.10,EN,,0,0,0,,which is what we wanted,
Dialogue: 0,0:15:07.39,0:15:11.56,EN,,0,0,0,,with its cdr being the pair starting in location five.
Dialogue: 0,0:15:13.33,0:15:14.50,EN,,0,0,0,,And that's no big deal.
Dialogue: 0,0:15:16.81,0:15:20.45,EN,,0,0,0,,So the only problem really remaining here is,
Dialogue: 0,0:15:21.00,0:15:23.40,EN,,0,0,0,,well, I don't have an infinitely large memory.
Dialogue: 0,0:15:25.08,0:15:26.66,EN,,0,0,0,,If I do this for a little while,
Dialogue: 0,0:15:27.25,0:15:28.00,EN,,0,0,0,,say, for example,
Dialogue: 0,0:15:28.01,0:15:30.14,EN,,0,0,0,,supposing it takes me a microsecond to do a cons,
Dialogue: 0,0:15:30.60,0:15:32.97,EN,,0,0,0,,and I have a million cons memory
Dialogue: 0,0:15:33.60,0:15:35.27,EN,,0,0,0,,then I'm only going to run out in a second,
Dialogue: 0,0:15:35.95,0:15:37.00,EN,,0,0,0,,and that's pretty bad.
Dialogue: 0,0:15:38.00,0:15:40.62,EN,,0,0,0,,So what we do to prevent that disaster,
Dialogue: 0,0:15:40.62,0:15:42.19,EN,,0,0,0,,that ecological disaster,
Dialogue: 0,0:15:42.60,0:15:44.30,EN,,0,0,0,,talk about right after questions.
Dialogue: 0,0:15:44.30,0:15:45.26,EN,,0,0,0,,Are there any questions?
Dialogue: 0,0:15:51.50,0:15:51.69,EN,,0,0,0,,Yes.
Dialogue: 0,0:15:52.03,0:15:54.67,EN,,0,0,0,,AUDIENCE: In the environment diagrams that we were drawing
Dialogue: 0,0:15:54.67,0:15:58.25,EN,,0,0,0,,we would use the body of procedures,
Dialogue: 0,0:15:58.25,0:16:00.67,EN,,0,0,0,,and you would eventually wind up with
Dialogue: 0,0:16:00.80,0:16:03.60,EN,,0,0,0,,things that were no longer useful in that structure.
Dialogue: 0,0:16:03.60,0:16:04.16,EN,,0,0,0,,PROFESSOR: Yes, madam.
Dialogue: 0,0:16:04.93,0:16:06.67,EN,,0,0,0,,AUDIENCE: How is that represented?
Dialogue: 0,0:16:06.76,0:16:08.75,EN,,0,0,0,,PROFESSOR: There's two problems here. OK?
Dialogue: 0,0:16:09.18,0:16:10.25,EN,,0,0,0,,One you were asking
Dialogue: 0,0:16:10.25,0:16:13.43,EN,,0,0,0,,is that material becomes useless.
Dialogue: 0,0:16:13.87,0:16:14.92,EN,,0,0,0,,We'll talk about that in a second.
Dialogue: 0,0:16:14.92,0:16:17.00,EN,,0,0,0,,That has to do with how to prevent ecological disasters.
Dialogue: 0,0:16:17.63,0:16:19.20,EN,,0,0,0,,Right? If I make a lot of garbage
Dialogue: 0,0:16:19.20,0:16:21.39,EN,,0,0,0,,I have to somehow be able to clean up after myself.
Dialogue: 0,0:16:21.82,0:16:22.97,EN,,0,0,0,,And we'll talk about that in a second.
Dialogue: 0,0:16:23.43,0:16:24.57,EN,,0,0,0,,The other question you're asking
Dialogue: 0,0:16:24.57,0:16:27.21,EN,,0,0,0,,is how you represent the environments, I think.
Dialogue: 0,0:16:27.28,0:16:27.60,EN,,0,0,0,,AUDIENCE: Yes.
Dialogue: 0,0:16:27.60,0:16:28.19,EN,,0,0,0,,PROFESSOR: OK.
Dialogue: 0,0:16:28.19,0:16:30.62,EN,,0,0,0,,And the environment structures can be represented in arbitrary ways.
Dialogue: 0,0:16:30.92,0:16:31.78,EN,,0,0,0,,There are lots of them.
Dialogue: 0,0:16:31.78,0:16:33.34,EN,,0,0,0,,I mean, here I'm just telling you about list cells.
Dialogue: 0,0:16:33.63,0:16:34.92,EN,,0,0,0,,Of course every real system
Dialogue: 0,0:16:34.92,0:16:36.72,EN,,0,0,0,,has vectors of arbitrary length
Dialogue: 0,0:16:36.72,0:16:39.15,EN,,0,0,0,,as well as the vectors of length, too,
Dialogue: 0,0:16:39.31,0:16:40.51,EN,,0,0,0,,which represent list cells.
Dialogue: 0,0:16:41.08,0:16:44.90,EN,,0,0,0,,And the environment structures that one uses in a
Dialogue: 0,0:16:44.90,0:16:46.99,EN,,0,0,0,,professionally written Lisp system
Dialogue: 0,0:16:47.30,0:16:49.69,EN,,0,0,0,,tend to be vectors
Dialogue: 0,0:16:49.69,0:16:51.92,EN,,0,0,0,,which contain a number of elements approximately
Dialogue: 0,0:16:51.92,0:16:54.60,EN,,0,0,0,,equal to the number of arguments-- a little bit more
Dialogue: 0,0:16:55.35,0:16:56.86,EN,,0,0,0,,because you need sort of glue.
Dialogue: 0,0:16:57.40,0:17:00.74,EN,,0,0,0,,OK? So remember, the environment is in a frame.
Dialogue: 0,0:17:00.74,0:17:03.98,EN,,0,0,0,,The frames are constructed by applying a procedure.
Dialogue: 0,0:17:03.98,0:17:04.78,EN,,0,0,0,,In doing so,
Dialogue: 0,0:17:04.80,0:17:07.60,EN,,0,0,0,,an allocation is made of a place
Dialogue: 0,0:17:07.64,0:17:11.27,EN,,0,0,0,,which is the number of arguments long plus some glue
Dialogue: 0,0:17:11.27,0:17:12.71,EN,,0,0,0,,that gets linked into a chain.
Dialogue: 0,0:17:13.32,0:17:15.66,EN,,0,0,0,,It's just like algol at that level.
Dialogue: 0,0:17:19.81,0:17:20.72,EN,,0,0,0,,There any other questions?
Dialogue: 0,0:17:23.70,0:17:23.92,EN,,0,0,0,,OK.
Dialogue: 0,0:17:23.92,0:17:25.55,EN,,0,0,0,,Thank you, and let's take a short break.
Dialogue: 0,0:17:26.35,0:17:45.48,EN,,0,0,0,,[JESU, JOY OF MAN'S DESIRING]
Dialogue: 0,0:18:12.27,0:18:14.24,EN,,0,0,0,,PROFESSOR: Well, as I just said,
Dialogue: 0,0:18:14.55,0:18:15.50,EN,,0,0,0,,computer memories
Dialogue: 0,0:18:15.82,0:18:17.96,EN,,0,0,0,,supplied by the semiconductor manufacturers
Dialogue: 0,0:18:18.16,0:18:19.00,EN,,0,0,0,,are finite.
Dialogue: 0,0:18:19.42,0:18:20.40,EN,,0,0,0,,And that's quite a pity.
Dialogue: 0,0:18:21.62,0:18:23.35,EN,,0,0,0,,It might not always be that way.
Dialogue: 0,0:18:24.03,0:18:25.40,EN,,0,0,0,,Just for a quick calculation,
Dialogue: 0,0:18:25.44,0:18:28.86,EN,,0,0,0,,you can see that it's possible that if memory's
Dialogue: 0,0:18:28.86,0:18:30.80,EN,,0,0,0,,prices keep going at the rate they're going
Dialogue: 0,0:18:31.22,0:18:33.68,EN,,0,0,0,,that if you still took a microsecond second to do a cons,
Dialogue: 0,0:18:34.42,0:18:35.90,EN,,0,0,0,,then-- first of all, everybody
Dialogue: 0,0:18:35.90,0:18:37.07,EN,,0,0,0,,should know that there's about pi
Dialogue: 0,0:18:37.10,0:18:38.86,EN,,0,0,0,,times ten to the seventh seconds in a year.
Dialogue: 0,0:18:39.45,0:18:41.12,EN,,0,0,0,,And so that would be
Dialogue: 0,0:18:41.50,0:18:42.73,EN,,0,0,0,,ten to the seventh plus ten to the sixth
Dialogue: 0,0:18:42.73,0:18:43.94,EN,,0,0,0,,is ten to the thirteenth.
Dialogue: 0,0:18:43.94,0:18:45.50,EN,,0,0,0,,So there's maybe ten to the fourteenth conses
Dialogue: 0,0:18:45.50,0:18:46.80,EN,,0,0,0,,in the life of a machine.
Dialogue: 0,0:18:47.52,0:18:49.40,EN,,0,0,0,,If there was ten to the fourteenth words of memory
Dialogue: 0,0:18:49.68,0:18:50.57,EN,,0,0,0,,on your machine,
Dialogue: 0,0:18:51.20,0:18:52.16,EN,,0,0,0,,you'd never run out.
Dialogue: 0,0:18:53.04,0:18:53.85,EN,,0,0,0,,OK so that will be,
Dialogue: 0,0:18:53.95,0:18:55.76,EN,,0,0,0,,And that's not completely unreasonable.
Dialogue: 0,0:18:56.31,0:18:58.46,EN,,0,0,0,,Ten to the fourteenth is not a very large number.
Dialogue: 0,0:19:01.45,0:19:04.70,EN,,0,0,0,,Even for... I don't think it is.
Dialogue: 0,0:19:05.18,0:19:07.39,EN,,0,0,0,,But then again I like to play with astronomy.
Dialogue: 0,0:19:07.93,0:19:11.04,EN,,0,0,0,,It's at least ten to the eighteenth centimeters
Dialogue: 0,0:19:11.10,0:19:12.45,EN,,0,0,0,,between us and the nearest star.
Dialogue: 0,0:19:12.93,0:19:18.85,EN,,0,0,0,,But the thing I'm about to worry about is,
Dialogue: 0,0:19:19.15,0:19:21.27,EN,,0,0,0,,at least in the current economic state of affairs,
Dialogue: 0,0:19:21.27,0:19:23.57,EN,,0,0,0,,ten to the fourteenth pieces of memory is expensive.
Dialogue: 0,0:19:24.20,0:19:26.62,EN,,0,0,0,,And so I suppose what we have to do
Dialogue: 0,0:19:26.81,0:19:28.51,EN,,0,0,0,,is make do with much smaller memories.
Dialogue: 0,0:19:30.02,0:19:30.59,EN,,0,0,0,,Now
Dialogue: 0,0:19:32.84,0:19:35.07,EN,,0,0,0,,in general we want to have an illusion of infinity.
Dialogue: 0,0:19:35.80,0:19:37.22,EN,,0,0,0,,All we need to do is arrange it
Dialogue: 0,0:19:37.82,0:19:39.68,EN,,0,0,0,,so that whenever you look, the thing is there.
Dialogue: 0,0:19:41.92,0:19:45.55,EN,,0,0,0,,That's, that's really an important idea.
Dialogue: 0,0:19:49.54,0:19:51.97,EN,,0,0,0,,A person or a computer lives only a finite amount of time
Dialogue: 0,0:19:52.32,0:19:54.59,EN,,0,0,0,,and can only take a finite number of looks at something.
Dialogue: 0,0:19:55.28,0:19:57.37,EN,,0,0,0,,And so you really only need a finite amount of stuff.
Dialogue: 0,0:19:58.19,0:19:59.00,EN,,0,0,0,,But you have to arrange it
Dialogue: 0,0:19:59.00,0:20:00.38,EN,,0,0,0,,so no matter how much there is,
Dialogue: 0,0:20:00.77,0:20:03.46,EN,,0,0,0,,how much you really claim there is,
Dialogue: 0,0:20:03.46,0:20:04.74,EN,,0,0,0,,there's always enough stuff
Dialogue: 0,0:20:04.74,0:20:06.90,EN,,0,0,0,,so that when you take a look, it's there.
Dialogue: 0,0:20:06.90,0:20:08.15,EN,,0,0,0,,And so you only need a finite amount.
Dialogue: 0,0:20:08.75,0:20:09.94,EN,,0,0,0,,But let's see.
Dialogue: 0,0:20:11.63,0:20:13.32,EN,,0,0,0,,One problem is, as was brought up,
Dialogue: 0,0:20:13.92,0:20:15.45,EN,,0,0,0,,that there are possible ways
Dialogue: 0,0:20:15.72,0:20:17.84,EN,,0,0,0,,that there is lots of stuff
Dialogue: 0,0:20:17.88,0:20:19.16,EN,,0,0,0,,that we make that we don't need.
Dialogue: 0,0:20:19.41,0:20:21.81,EN,,0,0,0,,And we could recycle the material out of which its made.
Dialogue: 0,0:20:22.62,0:20:23.53,EN,,0,0,0,,An example
Dialogue: 0,0:20:24.15,0:20:25.79,EN,,0,0,0,,for is, is the fact
Dialogue: 0,0:20:25.79,0:20:28.40,EN,,0,0,0,,when we're building environment structures,
Dialogue: 0,0:20:28.40,0:20:30.47,EN,,0,0,0,,and we do so every time we call a procedure.
Dialogue: 0,0:20:30.47,0:20:32.56,EN,,0,0,0,,We have built in it a environment frame.
Dialogue: 0,0:20:33.14,0:20:34.03,EN,,0,0,0,,That environment frame
Dialogue: 0,0:20:34.22,0:20:36.07,EN,,0,0,0,,doesn't necessarily have a very long lifetime.
Dialogue: 0,0:20:36.73,0:20:38.69,EN,,0,0,0,,Its lifetime, meaning its usefulness,
Dialogue: 0,0:20:39.42,0:20:42.60,EN,,0,0,0,,may exist only over the invocation of the procedure.
Dialogue: 0,0:20:42.85,0:20:45.27,EN,,0,0,0,,Or if the procedure exports another procedure
Dialogue: 0,0:20:45.27,0:20:46.67,EN,,0,0,0,,by returning it as a value
Dialogue: 0,0:20:46.87,0:20:48.52,EN,,0,0,0,,and that procedure is defined inside of it,
Dialogue: 0,0:20:48.52,0:20:50.80,EN,,0,0,0,,well then the lifetime of the
Dialogue: 0,0:20:51.07,0:20:53.39,EN,,0,0,0,,frame of the outer procedure still is
Dialogue: 0,0:20:53.50,0:20:56.12,EN,,0,0,0,,only the lifetime of the procedure
Dialogue: 0,0:20:57.02,0:20:57.90,EN,,0,0,0,,which was exported.
Dialogue: 0,0:20:58.53,0:20:59.57,EN,,0,0,0,,And so ultimately,
Dialogue: 0,0:20:59.57,0:21:00.97,EN,,0,0,0,,a lot of that is garbage.
Dialogue: 0,0:21:01.96,0:21:04.10,EN,,0,0,0,,There are other ways of producing garbage as well.
Dialogue: 0,0:21:05.37,0:21:06.67,EN,,0,0,0,,Users produce garbage.
Dialogue: 0,0:21:07.24,0:21:08.07,EN,,0,0,0,,An example of
Dialogue: 0,0:21:08.07,0:21:10.22,EN,,0,0,0,,user garbage is something like this.
Dialogue: 0,0:21:10.93,0:21:14.00,EN,,0,0,0,,If we write a program to, for example,
Dialogue: 0,0:21:14.00,0:21:15.80,EN,,0,0,0,,append two lists together,
Dialogue: 0,0:21:16.05,0:21:18.14,EN,,0,0,0,,well one way to do it is to
Dialogue: 0,0:21:18.32,0:21:21.37,EN,,0,0,0,,reverse the first list onto the empty list
Dialogue: 0,0:21:21.37,0:21:23.72,EN,,0,0,0,,and reverse that onto the second list.
Dialogue: 0,0:21:24.70,0:21:26.92,EN,,0,0,0,,Now that's not terribly bad way of doing it.
Dialogue: 0,0:21:28.16,0:21:28.85,EN,,0,0,0,,And however,
Dialogue: 0,0:21:28.85,0:21:30.09,EN,,0,0,0,,the intermediate result,
Dialogue: 0,0:21:30.11,0:21:32.02,EN,,0,0,0,,which is the reversal of the first list
Dialogue: 0,0:21:33.87,0:21:35.57,EN,,0,0,0,,as done by this program,
Dialogue: 0,0:21:36.70,0:21:38.52,EN,,0,0,0,,is never going to be accessed ever again
Dialogue: 0,0:21:38.52,0:21:40.56,EN,,0,0,0,,after it's copied back on to the second.
Dialogue: 0,0:21:41.01,0:21:42.23,EN,,0,0,0,,It's an intermediate result.
Dialogue: 0,0:21:43.58,0:21:45.43,EN,,0,0,0,,It's going to be hard to ever see
Dialogue: 0,0:21:46.07,0:21:48.05,EN,,0,0,0,,how anybody would ever be able to access it.
Dialogue: 0,0:21:48.60,0:21:49.84,EN,,0,0,0,,In fact, it will go away.
Dialogue: 0,0:21:51.05,0:21:52.90,EN,,0,0,0,,Now if we make a lot of garbage like that,
Dialogue: 0,0:21:52.90,0:21:54.20,EN,,0,0,0,,and we should be allowed to,
Dialogue: 0,0:21:54.80,0:21:57.29,EN,,0,0,0,,then there's got to be some way to reclaim that garbage.
Dialogue: 0,0:21:58.80,0:22:00.90,EN,,0,0,0,,Well, what I'd like to tell you about now
Dialogue: 0,0:22:01.70,0:22:03.77,EN,,0,0,0,,is a very clever technique
Dialogue: 0,0:22:04.32,0:22:07.58,EN,,0,0,0,,whereby a Lisp system
Dialogue: 0,0:22:07.95,0:22:11.21,EN,,0,0,0,,can prove a small theorem every so often
Dialogue: 0,0:22:11.29,0:22:13.50,EN,,0,0,0,,on the form the following piece of junk
Dialogue: 0,0:22:14.72,0:22:16.09,EN,,0,0,0,,will never be accessed again.
Dialogue: 0,0:22:17.41,0:22:19.80,EN,,0,0,0,,It can have no affect on the future of the computation.
Dialogue: 0,0:22:21.40,0:22:23.61,EN,,0,0,0,,It's actually based on a very simple idea.
Dialogue: 0,0:22:24.72,0:22:28.06,EN,,0,0,0,,We've designed our computers to look sort of like this.
Dialogue: 0,0:22:28.95,0:22:30.67,EN,,0,0,0,,There's some data path,
Dialogue: 0,0:22:31.87,0:22:33.40,EN,,0,0,0,,which contains the registers.
Dialogue: 0,0:22:34.92,0:22:38.04,EN,,0,0,0,,You know, there are things like exp, and env,
Dialogue: 0,0:22:39.04,0:22:42.19,EN,,0,0,0,,and val, and so on.
Dialogue: 0,0:22:42.61,0:22:44.02,EN,,0,0,0,,And there's one here called stack,
Dialogue: 0,0:22:46.02,0:22:49.45,EN,,0,0,0,,some sort which points off to a structure somewhere,
Dialogue: 0,0:22:49.50,0:22:50.22,EN,,0,0,0,,which is the stack.
Dialogue: 0,0:22:50.24,0:22:51.48,EN,,0,0,0,,And we'll worry about that in a second.
Dialogue: 0,0:22:51.64,0:22:53.62,EN,,0,0,0,,There's some finite controller,
Dialogue: 0,0:22:54.38,0:22:56.57,EN,,0,0,0,,finite state machine controller.
Dialogue: 0,0:22:56.73,0:22:59.51,EN,,0,0,0,,And there's some control signals that go this way and
Dialogue: 0,0:22:59.80,0:23:01.44,EN,,0,0,0,,predicate results that come this way,
Dialogue: 0,0:23:01.87,0:23:03.13,EN,,0,0,0,,not the interesting part.
Dialogue: 0,0:23:03.35,0:23:06.51,EN,,0,0,0,,There's some sort of structured memory,
Dialogue: 0,0:23:06.80,0:23:08.27,EN,,0,0,0,,which I just told you how to make,
Dialogue: 0,0:23:08.27,0:23:10.17,EN,,0,0,0,,which may contain a stack.
Dialogue: 0,0:23:10.46,0:23:11.48,EN,,0,0,0,,I didn't tell you how to make things
Dialogue: 0,0:23:11.48,0:23:12.43,EN,,0,0,0,,of arbitrary shape,
Dialogue: 0,0:23:12.56,0:23:13.39,EN,,0,0,0,,only pairs.
Dialogue: 0,0:23:13.60,0:23:14.20,EN,,0,0,0,,But in fact
Dialogue: 0,0:23:14.35,0:23:15.44,EN,,0,0,0,,with what I've told you can
Dialogue: 0,0:23:15.47,0:23:16.96,EN,,0,0,0,,with what I've told you can simulate a stack by a big list.
Dialogue: 0,0:23:17.77,0:23:18.85,EN,,0,0,0,,I don't plan to do that,
Dialogue: 0,0:23:18.85,0:23:20.01,EN,,0,0,0,,it's not a nice way to do it.
Dialogue: 0,0:23:20.36,0:23:22.60,EN,,0,0,0,,But we could have something like that.
Dialogue: 0,0:23:22.99,0:23:25.28,EN,,0,0,0,,We have all sorts of little data structures in here
Dialogue: 0,0:23:25.64,0:23:27.75,EN,,0,0,0,,that are hooked together in funny ways.
Dialogue: 0,0:23:30.11,0:23:32.02,EN,,0,0,0,,They connect to other things.
Dialogue: 0,0:23:32.56,0:23:33.25,EN,,0,0,0,,And so on.
Dialogue: 0,0:23:33.25,0:23:34.22,EN,,0,0,0,,And ultimately
Dialogue: 0,0:23:34.45,0:23:37.19,EN,,0,0,0,,things up there are pointers to these.
Dialogue: 0,0:23:37.19,0:23:38.87,EN,,0,0,0,,The things that are in the registers
Dialogue: 0,0:23:39.40,0:23:41.40,EN,,0,0,0,,are pointers off to the data structures
Dialogue: 0,0:23:41.44,0:23:43.08,EN,,0,0,0,,that live in this list structure memory.
Dialogue: 0,0:23:44.91,0:23:49.80,EN,,0,0,0,,Now the truth of the matter is
Dialogue: 0,0:23:51.05,0:23:52.56,EN,,0,0,0,,that the entire consciousness
Dialogue: 0,0:23:52.57,0:23:53.92,EN,,0,0,0,,of this machine is in these registers.
Dialogue: 0,0:23:55.76,0:23:58.51,EN,,0,0,0,,There is no possible way that the machine,
Dialogue: 0,0:23:58.75,0:24:01.07,EN,,0,0,0,,if done correctly, if built correctly,
Dialogue: 0,0:24:01.37,0:24:03.41,EN,,0,0,0,,can access anything in this list structure memory
Dialogue: 0,0:24:04.57,0:24:07.05,EN,,0,0,0,,unless the thing in that list structure memory is
Dialogue: 0,0:24:08.09,0:24:10.88,EN,,0,0,0,,is connected by a sequence of data structures
Dialogue: 0,0:24:11.64,0:24:13.06,EN,,0,0,0,,to the registers.
Dialogue: 0,0:24:15.07,0:24:15.98,EN,,0,0,0,,If it's accessible
Dialogue: 0,0:24:16.22,0:24:18.31,EN,,0,0,0,,by legitimate data structure selectors
Dialogue: 0,0:24:19.08,0:24:21.12,EN,,0,0,0,,from the pointers that are stored in these registers.
Dialogue: 0,0:24:22.28,0:24:24.46,EN,,0,0,0,,Things like array references, perhaps.
Dialogue: 0,0:24:24.94,0:24:27.92,EN,,0,0,0,,Or cons cell references, cars and cdrs.
Dialogue: 0,0:24:29.08,0:24:30.95,EN,,0,0,0,,But I can't just talk about a random place in this memory,
Dialogue: 0,0:24:30.95,0:24:31.95,EN,,0,0,0,,because I can't get to it.
Dialogue: 0,0:24:32.74,0:24:34.90,EN,,0,0,0,,These are being arbitrary names I'm not allowed to count,
Dialogue: 0,0:24:37.00,0:24:39.16,EN,,0,0,0,,at least as I'm evaluating expressions.
Dialogue: 0,0:24:41.62,0:24:42.57,EN,,0,0,0,,If that's the case
Dialogue: 0,0:24:43.27,0:24:45.07,EN,,0,0,0,,then there's a very simple theorem to be proved.
Dialogue: 0,0:24:47.16,0:24:47.69,EN,,0,0,0,,Which is,
Dialogue: 0,0:24:47.90,0:24:50.52,EN,,0,0,0,,if I start with all lead pointers that are in all these registers
Dialogue: 0,0:24:51.16,0:24:52.55,EN,,0,0,0,,and recursively chase out,
Dialogue: 0,0:24:52.82,0:24:56.15,EN,,0,0,0,,marking all the places I can get to by selectors,
Dialogue: 0,0:24:56.90,0:24:59.40,EN,,0,0,0,,then eventually I mark everything they can be gotten to.
Dialogue: 0,0:25:00.65,0:25:02.69,EN,,0,0,0,,Anything which is not so marked is garbage
Dialogue: 0,0:25:02.69,0:25:03.75,EN,,0,0,0,,and can be recycled.
Dialogue: 0,0:25:05.56,0:25:06.20,EN,,0,0,0,,Very simple.
Dialogue: 0,0:25:07.20,0:25:09.10,EN,,0,0,0,,Cannot affect the future of the computation.
Dialogue: 0,0:25:11.18,0:25:12.84,EN,,0,0,0,,So let me show you that in a particular
Dialogue: 0,0:25:13.93,0:25:15.75,EN,,0,0,0,,in a particular example.
Dialogue: 0,0:25:17.12,0:25:19.37,EN,,0,0,0,,Now that means I'm going to have to append to my
Dialogue: 0,0:25:19.69,0:25:22.08,EN,,0,0,0,,description of the list structure a mark.
Dialogue: 0,0:25:23.64,0:25:24.89,EN,,0,0,0,,And so here, for example,
Dialogue: 0,0:25:25.37,0:25:27.28,EN,,0,0,0,,is a list structured memory.
Dialogue: 0,0:25:29.08,0:25:30.32,EN,,0,0,0,,And in this list structured memory
Dialogue: 0,0:25:30.33,0:25:31.33,EN,,0,0,0,,is a list structure
Dialogue: 0,0:25:31.33,0:25:33.95,EN,,0,0,0,,beginning in a place I'm going to call--
Dialogue: 0,0:25:35.87,0:25:36.62,EN,,0,0,0,,this is the root.
Dialogue: 0,0:25:38.59,0:25:40.12,EN,,0,0,0,,Now it doesn't really have to have a root.
Dialogue: 0,0:25:40.12,0:25:41.95,EN,,0,0,0,,It could be a bunch of them, like all the registers.
Dialogue: 0,0:25:42.67,0:25:43.98,EN,,0,0,0,,But I could cleverly arrange it
Dialogue: 0,0:25:44.13,0:25:46.30,EN,,0,0,0,,so all the registers, all the things that are in old registers
Dialogue: 0,0:25:46.30,0:25:47.77,EN,,0,0,0,,are also at the right moment
Dialogue: 0,0:25:48.28,0:25:50.46,EN,,0,0,0,,put into this root structure,
Dialogue: 0,0:25:50.46,0:25:51.85,EN,,0,0,0,,and then we've got one pointer to it.
Dialogue: 0,0:25:51.85,0:25:52.67,EN,,0,0,0,,I don't really care.
Dialogue: 0,0:25:54.57,0:25:55.63,EN,,0,0,0,,So the idea is
Dialogue: 0,0:25:55.64,0:25:56.65,EN,,0,0,0,,we're going to cons up stuff
Dialogue: 0,0:25:56.67,0:25:58.01,EN,,0,0,0,,until our free list is empty.
Dialogue: 0,0:25:58.72,0:25:59.67,EN,,0,0,0,,We've run out of things.
Dialogue: 0,0:26:00.95,0:26:04.47,EN,,0,0,0,,Now we're going to do this process of proving the theorem
Dialogue: 0,0:26:04.47,0:26:05.90,EN,,0,0,0,,that a certain percentage of the memory
Dialogue: 0,0:26:05.95,0:26:06.90,EN,,0,0,0,,is got crap in it.
Dialogue: 0,0:26:07.85,0:26:09.15,EN,,0,0,0,,And then we're going to recycle that
Dialogue: 0,0:26:09.78,0:26:10.87,EN,,0,0,0,,to grow new trees,
Dialogue: 0,0:26:12.19,0:26:14.57,EN,,0,0,0,,a standard use of such garbage.
Dialogue: 0,0:26:17.09,0:26:18.64,EN,,0,0,0,,So in any case, what do we have here?
Dialogue: 0,0:26:18.84,0:26:20.78,EN,,0,0,0,,Well we have some data structure
Dialogue: 0,0:26:20.89,0:26:24.27,EN,,0,0,0,,which starts out over here in p5.
Dialogue: 0,0:26:25.15,0:26:26.75,EN,,0,0,0,,Sorry, and it will start at one
Dialogue: 0,0:26:27.27,0:26:28.51,EN,,0,0,0,,And in fact
Dialogue: 0,0:26:28.89,0:26:32.20,EN,,0,0,0,,it has a car in p5,
Dialogue: 0,0:26:32.27,0:26:33.58,EN,,0,0,0,,and its cdr is in two.
Dialogue: 0,0:26:33.98,0:26:35.64,EN,,0,0,0,,And all the marks start out at zero.
Dialogue: 0,0:26:36.70,0:26:39.00,EN,,0,0,0,,Well let's start marking, just to play this game.
Dialogue: 0,0:26:39.92,0:26:40.52,EN,,0,0,0,,OK.
Dialogue: 0,0:26:42.54,0:26:44.27,EN,,0,0,0,,So for example,
Dialogue: 0,0:26:44.47,0:26:46.95,EN,,0,0,0,,since I can access one from the root
Dialogue: 0,0:26:46.95,0:26:47.82,EN,,0,0,0,,I will mark that.
Dialogue: 0,0:26:48.39,0:26:49.17,EN,,0,0,0,,Let me mark it.
Dialogue: 0,0:26:50.96,0:26:51.45,EN,,0,0,0,,Bang.
Dialogue: 0,0:26:52.22,0:26:52.94,EN,,0,0,0,,That's marked.
Dialogue: 0,0:26:54.41,0:26:57.51,EN,,0,0,0,,OK. Now since I have a five here
Dialogue: 0,0:26:57.64,0:26:58.64,EN,,0,0,0,,I can go to five
Dialogue: 0,0:26:59.02,0:27:00.72,EN,,0,0,0,,and see, well I'll mark that.
Dialogue: 0,0:27:01.45,0:27:01.76,EN,,0,0,0,,Bang.
Dialogue: 0,0:27:01.76,0:27:02.60,EN,,0,0,0,,That's useful stuff.
Dialogue: 0,0:27:02.90,0:27:05.10,EN,,0,0,0,,But five references as a number in its car,
Dialogue: 0,0:27:05.27,0:27:06.65,EN,,0,0,0,,I'm not interested in marking numbers
Dialogue: 0,0:27:06.91,0:27:08.17,EN,,0,0,0,,but its cdr is seven.
Dialogue: 0,0:27:08.70,0:27:09.75,EN,,0,0,0,,So I can mark that.
Dialogue: 0,0:27:10.45,0:27:10.81,EN,,0,0,0,,Bang.
Dialogue: 0,0:27:11.80,0:27:13.40,EN,,0,0,0,,OK? Seven is the empty list,
Dialogue: 0,0:27:13.67,0:27:15.10,EN,,0,0,0,,the only thing that references,
Dialogue: 0,0:27:15.59,0:27:17.12,EN,,0,0,0,,and it's got a number in its car.
Dialogue: 0,0:27:17.12,0:27:17.85,EN,,0,0,0,,Not interesting.
Dialogue: 0,0:27:19.49,0:27:20.50,EN,,0,0,0,,Well now let's go back here.
Dialogue: 0,0:27:20.50,0:27:21.65,EN,,0,0,0,,I forgot about something.
Dialogue: 0,0:27:21.65,0:27:22.17,EN,,0,0,0,,Two.
Dialogue: 0,0:27:22.84,0:27:24.85,EN,,0,0,0,,See in other words, if I'm looking at cell one,
Dialogue: 0,0:27:25.42,0:27:29.45,EN,,0,0,0,,cell one contains a two right over here.
Dialogue: 0,0:27:30.37,0:27:31.30,EN,,0,0,0,,A reference to two.
Dialogue: 0,0:27:32.01,0:27:34.97,EN,,0,0,0,,That means I should go mark two.
Dialogue: 0,0:27:35.70,0:27:36.27,EN,,0,0,0,,Bang.
Dialogue: 0,0:27:37.14,0:27:38.89,EN,,0,0,0,,Two contains a reference to four.
Dialogue: 0,0:27:39.13,0:27:40.27,EN,,0,0,0,,It's got a number in its car,
Dialogue: 0,0:27:40.27,0:27:41.20,EN,,0,0,0,,I'm not interested in that
Dialogue: 0,0:27:41.47,0:27:42.60,EN,,0,0,0,,so I'm going to go mark that.
Dialogue: 0,0:27:43.78,0:27:46.10,EN,,0,0,0,,Four refers to seven through its car,
Dialogue: 0,0:27:46.75,0:27:48.17,EN,,0,0,0,,and is empty in its cdr,
Dialogue: 0,0:27:48.47,0:27:49.57,EN,,0,0,0,,but I've already marked that one
Dialogue: 0,0:27:49.57,0:27:50.75,EN,,0,0,0,,so I don't have to mark it again.
Dialogue: 0,0:27:51.40,0:27:53.05,EN,,0,0,0,,This is all the accessible structure
Dialogue: 0,0:27:53.07,0:27:53.87,EN,,0,0,0,,from that place.
Dialogue: 0,0:27:55.00,0:27:56.57,EN,,0,0,0,,Simple recursive mark algorithm.
Dialogue: 0,0:27:58.71,0:28:01.79,EN,,0,0,0,,Now there are some unhappinesses about that algorithm,
Dialogue: 0,0:28:01.90,0:28:04.02,EN,,0,0,0,,and we can worry about that a second.
Dialogue: 0,0:28:04.92,0:28:06.16,EN,,0,0,0,,But basically you'll see
Dialogue: 0,0:28:06.19,0:28:07.85,EN,,0,0,0,,that all the things that have not been marked
Dialogue: 0,0:28:09.62,0:28:11.50,EN,,0,0,0,,are places that are free,
Dialogue: 0,0:28:11.50,0:28:12.41,EN,,0,0,0,,and I could recycle.
Dialogue: 0,0:28:14.25,0:28:15.75,EN,,0,0,0,,So the next stage after that is going to be
Dialogue: 0,0:28:15.75,0:28:17.05,EN,,0,0,0,,to scan through all of my memory,
Dialogue: 0,0:28:17.94,0:28:20.35,EN,,0,0,0,,looking for things that are not marked.
Dialogue: 0,0:28:21.18,0:28:22.45,EN,,0,0,0,,Every time I come across a marked thing
Dialogue: 0,0:28:22.45,0:28:23.22,EN,,0,0,0,,I unmark it,
Dialogue: 0,0:28:23.22,0:28:24.86,EN,,0,0,0,,and every time I come across an unmarked thing
Dialogue: 0,0:28:25.07,0:28:27.82,EN,,0,0,0,,I'm going to link it together in my free list.
Dialogue: 0,0:28:28.77,0:28:30.30,EN,,0,0,0,,Classic, very simple algorithm.
Dialogue: 0,0:28:32.12,0:28:33.10,EN,,0,0,0,,So let's see.
Dialogue: 0,0:28:33.84,0:28:34.77,EN,,0,0,0,,Is that very simple?
Dialogue: 0,0:28:34.77,0:28:35.42,EN,,0,0,0,,Yes it is.
Dialogue: 0,0:28:35.57,0:28:37.79,EN,,0,0,0,,I'm not going to go through the code in any detail,
Dialogue: 0,0:28:38.00,0:28:39.65,EN,,0,0,0,,but I just want to show you about how long it is.
Dialogue: 0,0:28:40.09,0:28:41.10,EN,,0,0,0,,Let's look at the mark phase.
Dialogue: 0,0:28:41.72,0:28:43.98,EN,,0,0,0,,Here's the first part of the mark phase.
Dialogue: 0,0:28:45.06,0:28:46.00,EN,,0,0,0,,We pick up the root.
Dialogue: 0,0:28:46.32,0:28:47.52,EN,,0,0,0,,We're going to do some
Dialogue: 0,0:28:47.67,0:28:51.05,EN,,0,0,0,,We're going to use that as a recursive procedure call.
Dialogue: 0,0:28:52.38,0:28:54.47,EN,,0,0,0,,We're going to sweep from there,
Dialogue: 0,0:28:54.77,0:28:56.95,EN,,0,0,0,,after when we're done with marking.
Dialogue: 0,0:28:57.38,0:28:59.79,EN,,0,0,0,,And then we're going to do a little couple of instructions
Dialogue: 0,0:28:59.80,0:29:01.36,EN,,0,0,0,,that do this checking out on the marks
Dialogue: 0,0:29:01.39,0:29:03.07,EN,,0,0,0,,and changing the marks and things like that,
Dialogue: 0,0:29:03.07,0:29:04.90,EN,,0,0,0,,according to the algorithm I've just shown you.
Dialogue: 0,0:29:05.23,0:29:06.47,EN,,0,0,0,,OK? It comes out here.
Dialogue: 0,0:29:06.47,0:29:07.65,EN,,0,0,0,,You have to mark the cars of things
Dialogue: 0,0:29:07.87,0:29:10.21,EN,,0,0,0,,and you also have to be able to mark the cdrs of things.
Dialogue: 0,0:29:10.66,0:29:12.10,EN,,0,0,0,,That's the entire mark phase.
Dialogue: 0,0:29:14.37,0:29:16.16,EN,,0,0,0,,I'll just tell you a little story about this.
Dialogue: 0,0:29:16.59,0:29:19.37,EN,,0,0,0,,The old DEC PDP-6 computer,
Dialogue: 0,0:29:20.93,0:29:22.09,EN,,0,0,0,,this was the way that
Dialogue: 0,0:29:22.35,0:29:24.85,EN,,0,0,0,,the mark-sweep garbage collection, as it was, was written.
Dialogue: 0,0:29:26.91,0:29:28.40,EN,,0,0,0,,The program was so small
Dialogue: 0,0:29:29.25,0:29:31.60,EN,,0,0,0,,that with the data that it needed,
Dialogue: 0,0:29:32.20,0:29:34.87,EN,,0,0,0,,with the registers that it needed to manipulate the memory,
Dialogue: 0,0:29:36.16,0:29:38.14,EN,,0,0,0,,it fit into the fast registers of the machine,
Dialogue: 0,0:29:38.16,0:29:38.97,EN,,0,0,0,,which were 16.
Dialogue: 0,0:29:39.28,0:29:39.80,EN,,0,0,0,,The whole program.
Dialogue: 0,0:29:40.01,0:29:42.01,EN,,0,0,0,,And you could execute instructions in the fast registers.
Dialogue: 0,0:29:43.17,0:29:44.83,EN,,0,0,0,,So it's an extremely small program,
Dialogue: 0,0:29:45.85,0:29:46.88,EN,,0,0,0,,and it could run very fast.
Dialogue: 0,0:29:48.87,0:29:51.30,EN,,0,0,0,,Now unfortunately, of course,
Dialogue: 0,0:29:51.61,0:29:54.02,EN,,0,0,0,,this program, because the fact that it's recursive
Dialogue: 0,0:29:54.80,0:29:57.55,EN,,0,0,0,,in the way that you do something first
Dialogue: 0,0:29:57.55,0:29:58.99,EN,,0,0,0,,and then you do something after that,
Dialogue: 0,0:29:59.21,0:30:00.88,EN,,0,0,0,,you have to work on the cars and then the cdrs,
Dialogue: 0,0:30:01.15,0:30:02.75,EN,,0,0,0,,it requires auxiliary memory.
Dialogue: 0,0:30:03.41,0:30:05.23,EN,,0,0,0,,So Lisp systems--
Dialogue: 0,0:30:05.44,0:30:07.42,EN,,0,0,0,,those requires a stack for marking.
Dialogue: 0,0:30:08.26,0:30:11.05,EN,,0,0,0,,Lisp systems that are built this way
Dialogue: 0,0:30:11.57,0:30:14.16,EN,,0,0,0,,have a limit to the depth of recursion you can have
Dialogue: 0,0:30:14.42,0:30:17.37,EN,,0,0,0,,in data structures in either the car or the cdr,
Dialogue: 0,0:30:17.81,0:30:19.35,EN,,0,0,0,,and that doesn't work very nicely.
Dialogue: 0,0:30:19.93,0:30:20.60,EN,,0,0,0,,On the other hand,
Dialogue: 0,0:30:20.64,0:30:22.12,EN,,0,0,0,,you never notice it if it's big enough.
Dialogue: 0,0:30:23.18,0:30:25.13,EN,,0,0,0,,And that's certainly been
Dialogue: 0,0:30:25.55,0:30:28.17,EN,,0,0,0,,the case for most Maclisp, for example,
Dialogue: 0,0:30:28.69,0:30:29.88,EN,,0,0,0,,which ran Macsyma
Dialogue: 0,0:30:29.96,0:30:31.10,EN,,0,0,0,,where you could deal with expressions
Dialogue: 0,0:30:31.10,0:30:32.72,EN,,0,0,0,,of thousands of elements long.
Dialogue: 0,0:30:33.56,0:30:36.02,EN,,0,0,0,,These are algebraic expressions with thousand of terms.
Dialogue: 0,0:30:36.82,0:30:38.10,EN,,0,0,0,,And there's no problem with that.
Dialogue: 0,0:30:39.49,0:30:40.82,EN,,0,0,0,,Such, the garbage collector does work.
Dialogue: 0,0:30:42.19,0:30:42.92,EN,,0,0,0,,On the other hand,
Dialogue: 0,0:30:42.92,0:30:45.37,EN,,0,0,0,,there's a very clever modification to this algorithm,
Dialogue: 0,0:30:45.37,0:30:46.47,EN,,0,0,0,,which I will not describe,
Dialogue: 0,0:30:46.80,0:30:48.22,EN,,0,0,0,,by Peter Deutsch and Schorr and Waite--
Dialogue: 0,0:30:48.64,0:30:51.82,EN,,0,0,0,,and Schorr and Waite, Herb Schorr from IBM
Dialogue: 0,0:30:51.87,0:30:53.52,EN,,0,0,0,,and Waite who I don't know.
Dialogue: 0,0:30:54.01,0:30:56.51,EN,,0,0,0,,Whrere... That algorithm
Dialogue: 0,0:30:56.67,0:30:57.79,EN,,0,0,0,,allows you build
Dialogue: 0,0:30:57.84,0:30:59.55,EN,,0,0,0,,you do can do this without auxiliary memory,
Dialogue: 0,0:31:00.50,0:31:02.80,EN,,0,0,0,,by remembering as you walk the data structures
Dialogue: 0,0:31:02.97,0:31:05.52,EN,,0,0,0,,where you came from by reversing the pointers as you go down
Dialogue: 0,0:31:05.52,0:31:07.52,EN,,0,0,0,,and crawling up the reverse pointers as you go up.
Dialogue: 0,0:31:07.79,0:31:08.99,EN,,0,0,0,,It's a rather tricky algorithm.
Dialogue: 0,0:31:09.13,0:31:10.24,EN,,0,0,0,,The first time you write it--
Dialogue: 0,0:31:10.25,0:31:11.71,EN,,0,0,0,,or in fact, the first three times you write it it
Dialogue: 0,0:31:11.71,0:31:12.72,EN,,0,0,0,,it has a terrible bug in it.
Dialogue: 0,0:31:14.35,0:31:16.72,EN,,0,0,0,,And it's also about, it's quite rather slow,
Dialogue: 0,0:31:16.72,0:31:17.67,EN,,0,0,0,,because it's complicated.
Dialogue: 0,0:31:18.11,0:31:20.30,EN,,0,0,0,,It takes about six times as many memory references
Dialogue: 0,0:31:20.85,0:31:23.22,EN,,0,0,0,,to do the sorts of things that we're talking about.
Dialogue: 0,0:31:24.58,0:31:27.07,EN,,0,0,0,,Well now once I've done this marking phase,
Dialogue: 0,0:31:27.50,0:31:30.12,EN,,0,0,0,,and I get into a position where things look like this,
Dialogue: 0,0:31:30.17,0:31:31.26,EN,,0,0,0,,let's look-- yes.
Dialogue: 0,0:31:31.51,0:31:34.03,EN,,0,0,0,,Here we have the mark done,
Dialogue: 0,0:31:34.08,0:31:35.00,EN,,0,0,0,,just as I did it.
Dialogue: 0,0:31:35.59,0:31:37.33,EN,,0,0,0,,Now we have to perform the sweep phase.
Dialogue: 0,0:31:37.60,0:31:39.32,EN,,0,0,0,,And I described to you what this sweep is like.
Dialogue: 0,0:31:39.82,0:31:42.34,EN,,0,0,0,,I'm going to walk down from one end of memory or the other,
Dialogue: 0,0:31:42.34,0:31:43.34,EN,,0,0,0,,I don't care where,
Dialogue: 0,0:31:43.62,0:31:46.17,EN,,0,0,0,,scanning every cell that's in the memory.
Dialogue: 0,0:31:47.17,0:31:48.67,EN,,0,0,0,,And as I scan these cells,
Dialogue: 0,0:31:49.20,0:31:50.97,EN,,0,0,0,,I'm going to link them together,
Dialogue: 0,0:31:50.99,0:31:52.84,EN,,0,0,0,,if they are free, into the free list.
Dialogue: 0,0:31:53.15,0:31:54.05,EN,,0,0,0,,And if they're not free,
Dialogue: 0,0:31:54.05,0:31:56.07,EN,,0,0,0,,I'm going to unmark them so the marks become zero.
Dialogue: 0,0:31:57.50,0:31:58.57,EN,,0,0,0,,And in fact what I get--
Dialogue: 0,0:31:58.70,0:32:00.46,EN,,0,0,0,,well the program is not very complicated.
Dialogue: 0,0:32:00.46,0:32:02.22,EN,,0,0,0,,It looks sort of like this-- it's a little longer.
Dialogue: 0,0:32:02.78,0:32:04.17,EN,,0,0,0,,Here's the first piece of it.
Dialogue: 0,0:32:04.82,0:32:06.71,EN,,0,0,0,,This one's coming down from the top of memory.
Dialogue: 0,0:32:06.71,0:32:09.58,EN,,0,0,0,,I don't want you to try to understand this at this point.
Dialogue: 0,0:32:09.58,0:32:10.55,EN,,0,0,0,,It's rather simple.
Dialogue: 0,0:32:11.03,0:32:12.52,EN,,0,0,0,,It's a very simple algorithm,
Dialogue: 0,0:32:13.07,0:32:15.97,EN,,0,0,0,,but there's pieces of it that just sort of look like this.
Dialogue: 0,0:32:15.97,0:32:17.37,EN,,0,0,0,,They're all sort of obvious.
Dialogue: 0,0:32:18.60,0:32:20.08,EN,,0,0,0,,And after we've done the sweep,
Dialogue: 0,0:32:20.30,0:32:21.77,EN,,0,0,0,,we get an answer that looks like that.
Dialogue: 0,0:32:25.33,0:32:26.54,EN,,0,0,0,,Now there are some disadvantages
Dialogue: 0,0:32:26.56,0:32:28.20,EN,,0,0,0,,with mark-sweep algorithms of this sort.
Dialogue: 0,0:32:29.59,0:32:30.35,EN,,0,0,0,,Serious ones.
Dialogue: 0,0:32:31.45,0:32:33.20,EN,,0,0,0,,One important disadvantage is
Dialogue: 0,0:32:33.20,0:32:34.97,EN,,0,0,0,,that your memories get larger and larger.
Dialogue: 0,0:32:36.82,0:32:38.87,EN,,0,0,0,,As you say, address spaces get larger and larger,
Dialogue: 0,0:32:38.87,0:32:40.80,EN,,0,0,0,,you're willing to represent more and more stuff,
Dialogue: 0,0:32:41.37,0:32:44.52,EN,,0,0,0,,then it gets very costly to scan all of memory.
Dialogue: 0,0:32:46.36,0:32:47.39,EN,,0,0,0,,What you'd really like to do
Dialogue: 0,0:32:47.40,0:32:48.68,EN,,0,0,0,,is only scan useful stuff.
Dialogue: 0,0:32:50.49,0:32:51.55,EN,,0,0,0,,It would even be better
Dialogue: 0,0:32:52.07,0:32:53.90,EN,,0,0,0,,if you realized that some stuff
Dialogue: 0,0:32:54.48,0:32:57.72,EN,,0,0,0,,was known to be good and useful,
Dialogue: 0,0:32:58.28,0:33:00.37,EN,,0,0,0,,and you don't have to look at it more than once or twice.
Dialogue: 0,0:33:00.37,0:33:01.20,EN,,0,0,0,,Or very rarely.
Dialogue: 0,0:33:01.55,0:33:04.32,EN,,0,0,0,,Whereas other stuff that you're not so sure about,
Dialogue: 0,0:33:05.00,0:33:06.22,EN,,0,0,0,,you can look at more detail
Dialogue: 0,0:33:07.10,0:33:08.75,EN,,0,0,0,,every time you want to do this,
Dialogue: 0,0:33:09.93,0:33:10.85,EN,,0,0,0,,want to garbage collect.
Dialogue: 0,0:33:11.91,0:33:13.74,EN,,0,0,0,,Well there are algorithms
Dialogue: 0,0:33:13.76,0:33:15.10,EN,,0,0,0,,that are organized in this way.
Dialogue: 0,0:33:15.66,0:33:18.16,EN,,0,0,0,,Let me tell you about a famous old algorithm
Dialogue: 0,0:33:18.28,0:33:19.47,EN,,0,0,0,,which allows you only look at
Dialogue: 0,0:33:19.50,0:33:21.37,EN,,0,0,0,,the part of memory which is known to be useful.
Dialogue: 0,0:33:23.12,0:33:23.85,EN,,0,0,0,,And which happens to be
Dialogue: 0,0:33:23.87,0:33:25.29,EN,,0,0,0,,the fastest known garbage collector algorithm.
Dialogue: 0,0:33:26.31,0:33:29.45,EN,,0,0,0,,This is the Minsky-Fenichel-Yochelson garbage collector algorithm.
Dialogue: 0,0:33:30.40,0:33:33.18,EN,,0,0,0,,It was invented by Minsky
Dialogue: 0,0:33:33.20,0:33:36.06,EN,,0,0,0,,in 1961 or '60 or something,
Dialogue: 0,0:33:36.52,0:33:40.48,EN,,0,0,0,,for the RLE PDP-1 Lisp,
Dialogue: 0,0:33:40.51,0:33:43.44,EN,,0,0,0,,which had 4,096 words of list memory,
Dialogue: 0,0:33:45.79,0:33:46.76,EN,,0,0,0,,and a drum.
Dialogue: 0,0:33:48.48,0:33:49.39,EN,,0,0,0,,And the whole idea
Dialogue: 0,0:33:50.03,0:33:51.87,EN,,0,0,0,,was to garbage collect this terrible memory.
Dialogue: 0,0:33:53.05,0:33:54.35,EN,,0,0,0,,What Minsky realized
Dialogue: 0,0:33:54.38,0:33:55.62,EN,,0,0,0,,was the easiest way to do this
Dialogue: 0,0:33:56.20,0:33:58.47,EN,,0,0,0,,is to scan the memory in the same sense,
Dialogue: 0,0:33:58.47,0:34:00.60,EN,,0,0,0,,walking the good structure,
Dialogue: 0,0:34:01.57,0:34:03.52,EN,,0,0,0,,copying it out into the drum,
Dialogue: 0,0:34:04.70,0:34:05.47,EN,,0,0,0,,compacted.
Dialogue: 0,0:34:06.35,0:34:08.86,EN,,0,0,0,,And then when we were done copying it all out,
Dialogue: 0,0:34:09.12,0:34:10.90,EN,,0,0,0,,then you swap that back into your memory.
Dialogue: 0,0:34:12.30,0:34:13.68,EN,,0,0,0,,Now whether or you not use a drum,
Dialogue: 0,0:34:13.72,0:34:14.71,EN,,0,0,0,,or another piece of memory,
Dialogue: 0,0:34:14.71,0:34:16.42,EN,,0,0,0,,or something like that isn't important.
Dialogue: 0,0:34:17.03,0:34:17.42,EN,,0,0,0,,In fact,
Dialogue: 0,0:34:17.44,0:34:19.60,EN,,0,0,0,,I don't think people use drums anymore for anything.
Dialogue: 0,0:34:20.35,0:34:23.77,EN,,0,0,0,,But this algorithm basically
Dialogue: 0,0:34:24.03,0:34:25.42,EN,,0,0,0,,depends upon having
Dialogue: 0,0:34:25.42,0:34:27.42,EN,,0,0,0,,about twice as much address space
Dialogue: 0,0:34:27.48,0:34:28.57,EN,,0,0,0,,you're actually using.
Dialogue: 0,0:34:30.27,0:34:32.96,EN,,0,0,0,,And so what you have is some, initially,
Dialogue: 0,0:34:33.12,0:34:36.60,EN,,0,0,0,,some mixture of useful data and garbage.
Dialogue: 0,0:34:37.11,0:34:38.97,EN,,0,0,0,,So this is called fromspace.
Dialogue: 0,0:34:45.17,0:34:47.05,EN,,0,0,0,,And this is a mixture of crud.
Dialogue: 0,0:34:47.87,0:34:49.79,EN,,0,0,0,,Some of it's important and some of it isn't.
Dialogue: 0,0:34:52.00,0:34:53.85,EN,,0,0,0,,Now there's another place
Dialogue: 0,0:34:54.17,0:34:55.61,EN,,0,0,0,,which is hopefully big enough,
Dialogue: 0,0:34:55.77,0:34:57.00,EN,,0,0,0,,if we recall, tospace,
Dialogue: 0,0:34:57.12,0:34:58.24,EN,,0,0,0,,which is where we're copying to.
Dialogue: 0,0:35:01.59,0:35:02.60,EN,,0,0,0,,And what happens is--
Dialogue: 0,0:35:02.60,0:35:04.06,EN,,0,0,0,,and I'm not going to go through this detail.
Dialogue: 0,0:35:04.16,0:35:07.07,EN,,0,0,0,,It's in our book quite explicitly.
Dialogue: 0,0:35:07.59,0:35:10.40,EN,,0,0,0,,There's a root point where you start from.
Dialogue: 0,0:35:11.03,0:35:14.30,EN,,0,0,0,,And the idea is that you start with the root.
Dialogue: 0,0:35:14.60,0:35:16.42,EN,,0,0,0,,You copy the first thing you see,
Dialogue: 0,0:35:17.83,0:35:19.37,EN,,0,0,0,,the first thing that the root points at,
Dialogue: 0,0:35:19.75,0:35:21.31,EN,,0,0,0,,to the beginning of tospace.
Dialogue: 0,0:35:22.81,0:35:24.12,EN,,0,0,0,,The first thing is a pair
Dialogue: 0,0:35:24.16,0:35:25.60,EN,,0,0,0,,or something like, a data structure.
Dialogue: 0,0:35:27.56,0:35:30.19,EN,,0,0,0,,You then also leave behind
Dialogue: 0,0:35:30.38,0:35:31.56,EN,,0,0,0,,a broken heart saying,
Dialogue: 0,0:35:31.77,0:35:35.74,EN,,0,0,0,,I moved this object from here to here,
Dialogue: 0,0:35:35.74,0:35:37.05,EN,,0,0,0,,giving the place where it moved to.
Dialogue: 0,0:35:37.80,0:35:39.65,EN,,0,0,0,,This is called a broken heart because
Dialogue: 0,0:35:39.65,0:35:40.78,EN,,0,0,0,,a friend of mine who implemented
Dialogue: 0,0:35:40.78,0:35:43.39,EN,,0,0,0,,one of these in 1966
Dialogue: 0,0:35:43.82,0:35:45.26,EN,,0,0,0,,was a very romantic character
Dialogue: 0,0:35:45.26,0:35:46.76,EN,,0,0,0,,and called it a broken heart.
Dialogue: 0,0:35:49.58,0:35:50.54,EN,,0,0,0,,But in any case,
Dialogue: 0,0:35:51.15,0:35:52.72,EN,,0,0,0,,the next thing you do
Dialogue: 0,0:35:52.94,0:35:55.00,EN,,0,0,0,,is now you have a new free pointer which is here,
Dialogue: 0,0:35:55.17,0:35:56.38,EN,,0,0,0,,and you start scanning.
Dialogue: 0,0:35:56.88,0:35:59.68,EN,,0,0,0,,You scan this data structure you just copied.
Dialogue: 0,0:36:00.55,0:36:02.19,EN,,0,0,0,,And every time you encounter a pointer in it,
Dialogue: 0,0:36:02.19,0:36:03.92,EN,,0,0,0,,you treat it as if it was the root pointer here.
Dialogue: 0,0:36:04.00,0:36:04.59,EN,,0,0,0,,Oh, I'm sorry.
Dialogue: 0,0:36:04.60,0:36:05.69,EN,,0,0,0,,The other thing you do
Dialogue: 0,0:36:05.71,0:36:07.08,EN,,0,0,0,,is you now move the root pointer to there.
Dialogue: 0,0:36:09.22,0:36:10.17,EN,,0,0,0,,So now you scan this,
Dialogue: 0,0:36:10.17,0:36:10.99,EN,,0,0,0,,and everything you see
Dialogue: 0,0:36:11.00,0:36:12.41,EN,,0,0,0,,you treat as it were the root pointer.
Dialogue: 0,0:36:14.11,0:36:15.45,EN,,0,0,0,,So if you see something,
Dialogue: 0,0:36:15.45,0:36:17.40,EN,,0,0,0,,well it points up into there somewhere.
Dialogue: 0,0:36:18.51,0:36:19.92,EN,,0,0,0,,Is it pointing at a thing
Dialogue: 0,0:36:19.93,0:36:20.99,EN,,0,0,0,,which you've not copied yet?
Dialogue: 0,0:36:21.78,0:36:22.87,EN,,0,0,0,,Is there a broken heart there?
Dialogue: 0,0:36:23.88,0:36:24.84,EN,,0,0,0,,If there's a broken heart there
Dialogue: 0,0:36:24.84,0:36:26.11,EN,,0,0,0,,and it's something you have copied,
Dialogue: 0,0:36:26.20,0:36:27.34,EN,,0,0,0,,you've just replaced this pointer
Dialogue: 0,0:36:27.36,0:36:28.75,EN,,0,0,0,,with the thing a broken heart points at.
Dialogue: 0,0:36:29.82,0:36:32.03,EN,,0,0,0,,If this thing has not been copied,
Dialogue: 0,0:36:32.12,0:36:34.08,EN,,0,0,0,,you copy it to the next place over here.
Dialogue: 0,0:36:34.43,0:36:35.95,EN,,0,0,0,,Move your free pointer over here,
Dialogue: 0,0:36:37.05,0:36:40.60,EN,,0,0,0,,and then leave a broken heart behind
Dialogue: 0,0:36:41.05,0:36:41.80,EN,,0,0,0,,and scan.
Dialogue: 0,0:36:43.67,0:36:46.40,EN,,0,0,0,,And eventually when the scant pointer hits the free pointer,
Dialogue: 0,0:36:46.82,0:36:48.52,EN,,0,0,0,,everything in memory has been copied.
Dialogue: 0,0:36:50.14,0:36:51.04,EN,,0,0,0,,And then there's a whole bunch
Dialogue: 0,0:36:51.05,0:36:51.95,EN,,0,0,0,,of empty space up here,
Dialogue: 0,0:36:51.96,0:36:53.28,EN,,0,0,0,,which you could either make into a free list,
Dialogue: 0,0:36:53.31,0:36:54.47,EN,,0,0,0,,if that's what you want to do.
Dialogue: 0,0:36:54.47,0:36:56.27,EN,,0,0,0,,But generally you don't in this kind of system.
Dialogue: 0,0:36:56.27,0:36:59.15,EN,,0,0,0,,In this system you sequentially allocate your memory.
Dialogue: 0,0:37:00.91,0:37:02.48,EN,,0,0,0,,That is a very, very nice algorithm,
Dialogue: 0,0:37:02.97,0:37:04.57,EN,,0,0,0,,and sort of the one we use in the
Dialogue: 0,0:37:04.67,0:37:05.97,EN,,0,0,0,,the scheme that you've been using.
Dialogue: 0,0:37:06.79,0:37:09.47,EN,,0,0,0,,And it's known to be... it's expected--
Dialogue: 0,0:37:09.47,0:37:10.86,EN,,0,0,0,,I believe no one has found
Dialogue: 0,0:37:10.89,0:37:12.12,EN,,0,0,0,,a faster algorithm than that.
Dialogue: 0,0:37:12.40,0:37:14.85,EN,,0,0,0,,There are very simple modifications to this algorithm
Dialogue: 0,0:37:14.85,0:37:16.77,EN,,0,0,0,,invented by Henry Baker
Dialogue: 0,0:37:17.17,0:37:20.31,EN,,0,0,0,,which allow one to run this algorithm in real time,
Dialogue: 0,0:37:20.31,0:37:21.92,EN,,0,0,0,,meaning you don't have to stop to garbage collect.
Dialogue: 0,0:37:22.14,0:37:24.33,EN,,0,0,0,,But you could interleave the consing
Dialogue: 0,0:37:24.36,0:37:26.17,EN,,0,0,0,,that the machine does when its running
Dialogue: 0,0:37:26.32,0:37:28.40,EN,,0,0,0,,with steps of the garbage collection process,
Dialogue: 0,0:37:28.85,0:37:31.20,EN,,0,0,0,,so that the thing, the garbage collector's distributed
Dialogue: 0,0:37:31.20,0:37:32.19,EN,,0,0,0,,and the machine doesn't have to stop,
Dialogue: 0,0:37:32.41,0:37:33.47,EN,,0,0,0,,and garbage collecting can start.
Dialogue: 0,0:37:34.64,0:37:37.87,EN,,0,0,0,,Of course in the case of machines with virtual memory
Dialogue: 0,0:37:38.90,0:37:41.20,EN,,0,0,0,,where a lot of it is in inaccessible places,
Dialogue: 0,0:37:41.50,0:37:43.60,EN,,0,0,0,,this becomes a very expensive process.
Dialogue: 0,0:37:44.28,0:37:46.43,EN,,0,0,0,,And there have been numerous
Dialogue: 0,0:37:47.16,0:37:48.65,EN,,0,0,0,,attempts to make this much better.
Dialogue: 0,0:37:49.19,0:37:51.15,EN,,0,0,0,,There is a nice paper,
Dialogue: 0,0:37:51.16,0:37:52.41,EN,,0,0,0,,for those of you who are interested,
Dialogue: 0,0:37:52.64,0:37:54.27,EN,,0,0,0,,by Moon and other people
Dialogue: 0,0:37:54.65,0:37:56.89,EN,,0,0,0,,which describes a modification to
Dialogue: 0,0:37:56.92,0:37:59.44,EN,,0,0,0,,the incremental Minsky-Fenichel-Yochelson algorithm,
Dialogue: 0,0:37:59.51,0:38:01.20,EN,,0,0,0,,and modification the Baker algorithm
Dialogue: 0,0:38:01.42,0:38:06.54,EN,,0,0,0,,which is more efficient for virtual memory systems.
Dialogue: 0,0:38:08.27,0:38:12.32,EN,,0,0,0,,Well I think now the mystery to this is sort of gone.
Dialogue: 0,0:38:12.84,0:38:14.09,EN,,0,0,0,,And I'd like to see if there are any questions.
Dialogue: 0,0:38:19.78,0:38:19.95,EN,,0,0,0,,Yes.
Dialogue: 0,0:38:20.60,0:38:23.58,EN,,0,0,0,,AUDIENCE: I saw one of you run the garbage collector
Dialogue: 0,0:38:23.64,0:38:25.05,EN,,0,0,0,,on the systems upstairs,
Dialogue: 0,0:38:25.93,0:38:27.88,EN,,0,0,0,,and it seemed to me to run extremely fast.
Dialogue: 0,0:38:27.96,0:38:28.40,EN,,0,0,0,,PROFESSOR: Yes
Dialogue: 0,0:38:28.49,0:38:29.52,EN,,0,0,0,,AUDIENCE: Did the whole thing take--
Dialogue: 0,0:38:30.11,0:38:31.88,EN,,0,0,0,,does it sweep through all of memory?
Dialogue: 0,0:38:31.88,0:38:32.22,EN,,0,0,0,,PROFESSOR: No.
Dialogue: 0,0:38:32.25,0:38:34.11,EN,,0,0,0,,It swept through exactly what was needed
Dialogue: 0,0:38:34.33,0:38:35.63,EN,,0,0,0,,to copy the useful structure.
Dialogue: 0,0:38:37.32,0:38:38.36,EN,,0,0,0,,It's a copying collector.
Dialogue: 0,0:38:38.44,0:38:38.91,EN,,0,0,0,,AUDIENCE: OK.
Dialogue: 0,0:38:39.30,0:38:40.88,EN,,0,0,0,,PROFESSOR: And it's rather... it is very fast.
Dialogue: 0,0:38:41.85,0:38:45.88,EN,,0,0,0,,On the whole, I suppose to copy in a Bobcat
Dialogue: 0,0:38:47.12,0:38:51.56,EN,,0,0,0,,to copy, I think, a three megabyte thing or something
Dialogue: 0,0:38:52.43,0:38:53.24,EN,,0,0,0,,is less than a second,
Dialogue: 0,0:38:55.00,0:38:55.69,EN,,0,0,0,,real time
Dialogue: 0,0:38:56.54,0:38:58.46,EN,,0,0,0,,Really, these are very small programs.
Dialogue: 0,0:38:58.62,0:39:01.50,EN,,0,0,0,,One thing you should realise is that
Dialogue: 0,0:39:02.91,0:39:04.40,EN,,0,0,0,,garbage collectors have to be small.
Dialogue: 0,0:39:05.40,0:39:07.10,EN,,0,0,0,,Not because they have to be fast,
Dialogue: 0,0:39:07.90,0:39:09.23,EN,,0,0,0,,but because no one can debug
Dialogue: 0,0:39:09.26,0:39:10.48,EN,,0,0,0,,a complicated garbage collector.
Dialogue: 0,0:39:11.34,0:39:12.91,EN,,0,0,0,,A garbage collector, if it doesn't work,
Dialogue: 0,0:39:14.04,0:39:15.93,EN,,0,0,0,,will trash your memory in such a way
Dialogue: 0,0:39:15.93,0:39:17.39,EN,,0,0,0,,that you cannot figure out what the hell happened.
Dialogue: 0,0:39:18.35,0:39:19.67,EN,,0,0,0,,You need an audit trail.
Dialogue: 0,0:39:20.66,0:39:22.01,EN,,0,0,0,,Because it rearranges everything,
Dialogue: 0,0:39:22.04,0:39:23.24,EN,,0,0,0,,and how do you know what happened there?
Dialogue: 0,0:39:23.74,0:39:26.58,EN,,0,0,0,,So this is the only kind of program that
Dialogue: 0,0:39:26.92,0:39:28.40,EN,,0,0,0,,it really, seriously matters
Dialogue: 0,0:39:28.54,0:39:29.79,EN,,0,0,0,,if you stare at it long enough
Dialogue: 0,0:39:29.82,0:39:31.07,EN,,0,0,0,,so you believe that it works.
Dialogue: 0,0:39:31.34,0:39:33.36,EN,,0,0,0,,That means and sort of prove it to yourself.
Dialogue: 0,0:39:33.92,0:39:36.11,EN,,0,0,0,,And that, that... So there's no way to debug it.
Dialogue: 0,0:39:36.94,0:39:38.96,EN,,0,0,0,,And that takes it being small enough
Dialogue: 0,0:39:38.96,0:39:39.97,EN,,0,0,0,,so you can hold it in your head.
Dialogue: 0,0:39:41.45,0:39:43.90,EN,,0,0,0,,So garbage collectors are special in this way.
Dialogue: 0,0:39:45.02,0:39:47.12,EN,,0,0,0,,So every reasonable garbage collector has gotten small,
Dialogue: 0,0:39:47.13,0:39:48.45,EN,,0,0,0,,and generally small programs are fast.
Dialogue: 0,0:39:52.05,0:39:52.43,EN,,0,0,0,,Yes.
Dialogue: 0,0:39:52.43,0:39:54.51,EN,,0,0,0,,AUDIENCE: Can you repeat the name of this technique once again?
Dialogue: 0,0:39:54.68,0:39:56.92,EN,,0,0,0,,PROFESSOR: That's the Minsky-Fenichel-Yochelson garbage collector.
Dialogue: 0,0:39:57.88,0:39:58.43,EN,,0,0,0,,AUDIENCE: You got that?
Dialogue: 0,0:39:59.00,0:40:00.78,EN,,0,0,0,,PROFESSOR: Minsky invented it in '61
Dialogue: 0,0:40:00.81,0:40:02.21,EN,,0,0,0,,for the RLE PDP-1.
Dialogue: 0,0:40:02.21,0:40:06.17,EN,,0,0,0,,A version of it was developed and elaborated
Dialogue: 0,0:40:06.45,0:40:10.27,EN,,0,0,0,,to be used in Multics Maclisp by Fenichel and Yochelson
Dialogue: 0,0:40:11.37,0:40:14.75,EN,,0,0,0,,in somewhere around 1968 or '69.
Dialogue: 0,0:40:19.57,0:40:21.36,EN,,0,0,0,,OK. Let's take a break.
Dialogue: 0,0:40:22.64,0:40:32.36,EN,,0,0,0,,[JESU, JOY OF MAN'S DESIRING]
Dialogue: 0,0:41:17.31,0:41:19.67,EN,,0,0,0,,PROFESSOR: Well we've come to the end of this subject,
Dialogue: 0,0:41:20.08,0:41:23.85,EN,,0,0,0,,and we've already shown you a universal machine
Dialogue: 0,0:41:24.47,0:41:26.74,EN,,0,0,0,,which is down to evaluator.
Dialogue: 0,0:41:27.02,0:41:28.38,EN,,0,0,0,,It's down to the level of detail
Dialogue: 0,0:41:28.38,0:41:29.67,EN,,0,0,0,,you could imagine you could make one.
Dialogue: 0,0:41:30.19,0:41:33.32,EN,,0,0,0,,This is a particular implementation of Lisp,
Dialogue: 0,0:41:33.90,0:41:36.01,EN,,0,0,0,,built on one of those
Dialogue: 0,0:41:36.16,0:41:38.05,EN,,0,0,0,,scheme chips that was talked about yesterday,
Dialogue: 0,0:41:38.20,0:41:38.91,EN,,0,0,0,,sitting over here.
Dialogue: 0,0:41:39.35,0:41:42.00,EN,,0,0,0,,This is mostly interface to somebody's memory
Dialogue: 0,0:41:42.60,0:41:44.75,EN,,0,0,0,,with a little bit of timing and other such stuff.
Dialogue: 0,0:41:45.22,0:41:47.25,EN,,0,0,0,,But this fellow actually ran Lisp
Dialogue: 0,0:41:47.77,0:41:50.17,EN,,0,0,0,,at a fairly reasonable rate, as interpretive.
Dialogue: 0,0:41:50.61,0:41:53.82,EN,,0,0,0,,It ran Lisp as fast as a DEC PDP-10
Dialogue: 0,0:41:54.22,0:41:55.65,EN,,0,0,0,,back in 1979.
Dialogue: 0,0:41:56.50,0:41:59.67,EN,,0,0,0,,And so it's gotten pretty hardware.
Dialogue: 0,0:42:00.02,0:42:00.89,EN,,0,0,0,,Pretty concrete.
Dialogue: 0,0:42:02.47,0:42:04.70,EN,,0,0,0,,We've also downed you a bit
Dialogue: 0,0:42:04.72,0:42:06.07,EN,,0,0,0,,with the things you can compute.
Dialogue: 0,0:42:07.37,0:42:08.76,EN,,0,0,0,,But is it the case that
Dialogue: 0,0:42:09.32,0:42:10.55,EN,,0,0,0,,there are things we can't compute?
Dialogue: 0,0:42:11.85,0:42:13.50,EN,,0,0,0,,And so I'd like to end this with
Dialogue: 0,0:42:13.75,0:42:15.87,EN,,0,0,0,,showing you some things that you'd like be able to compute
Dialogue: 0,0:42:16.60,0:42:17.22,EN,,0,0,0,,that you can't.
Dialogue: 0,0:42:18.19,0:42:19.45,EN,,0,0,0,,The answer is yes,
Dialogue: 0,0:42:19.45,0:42:20.82,EN,,0,0,0,,there are things you can't compute.
Dialogue: 0,0:42:22.72,0:42:23.47,EN,,0,0,0,,For example,
Dialogue: 0,0:42:24.45,0:42:25.82,EN,,0,0,0,,something you'd really like is--
Dialogue: 0,0:42:27.80,0:42:29.36,EN,,0,0,0,,if you're writing a compiler
Dialogue: 0,0:42:29.77,0:42:31.42,EN,,0,0,0,,you'd like a program that would check
Dialogue: 0,0:42:32.00,0:42:33.97,EN,,0,0,0,,that the thing you're going to do will work.
Dialogue: 0,0:42:34.63,0:42:35.40,EN,,0,0,0,,Wouldn't that be nice?
Dialogue: 0,0:42:36.08,0:42:37.87,EN,,0,0,0,,You'd like something that would catch infinite loops,
Dialogue: 0,0:42:37.87,0:42:38.54,EN,,0,0,0,,for example,
Dialogue: 0,0:42:39.45,0:42:42.42,EN,,0,0,0,,in programs that were written by users.
Dialogue: 0,0:42:43.19,0:42:45.12,EN,,0,0,0,,But in general you can't write such a program
Dialogue: 0,0:42:45.35,0:42:46.49,EN,,0,0,0,,that will read any program
Dialogue: 0,0:42:46.51,0:42:47.45,EN,,0,0,0,,and determine whether or not
Dialogue: 0,0:42:48.35,0:42:49.30,EN,,0,0,0,,it's an infinite loop.
Dialogue: 0,0:42:50.99,0:42:51.71,EN,,0,0,0,,Let me show you that.
Dialogue: 0,0:42:51.76,0:42:53.80,EN,,0,0,0,,It's a little bit of a minor mathematics.
Dialogue: 0,0:42:58.78,0:42:59.65,EN,,0,0,0,,Let's imagine
Dialogue: 0,0:43:00.05,0:43:01.78,EN,,0,0,0,,that we just had a mathematical function
Dialogue: 0,0:43:01.78,0:43:02.62,EN,,0,0,0,,before we start.
Dialogue: 0,0:43:02.62,0:43:03.42,EN,,0,0,0,,And there is one,
Dialogue: 0,0:43:03.84,0:43:04.67,EN,,0,0,0,,called s,
Dialogue: 0,0:43:05.47,0:43:07.54,EN,,0,0,0,,which takes a procedure
Dialogue: 0,0:43:12.64,0:43:14.23,EN,,0,0,0,,and its argument, a.
Dialogue: 0,0:43:19.17,0:43:20.52,EN,,0,0,0,,And what s does
Dialogue: 0,0:43:21.65,0:43:24.01,EN,,0,0,0,,is it determines whether or not
Dialogue: 0,0:43:24.01,0:43:25.97,EN,,0,0,0,,it's safe to run p on a.
Dialogue: 0,0:43:26.90,0:43:28.17,EN,,0,0,0,,And what I mean by that is this:
Dialogue: 0,0:43:28.76,0:43:35.12,EN,,0,0,0,,it's true if p applied to a
Dialogue: 0,0:43:35.62,0:43:36.74,EN,,0,0,0,,will converge
Dialogue: 0,0:43:41.40,0:43:42.45,EN,,0,0,0,,to a value
Dialogue: 0,0:43:44.35,0:43:45.33,EN,,0,0,0,,without an error.
Dialogue: 0,0:43:52.70,0:43:53.68,EN,,0,0,0,,And it's false
Dialogue: 0,0:43:56.10,0:43:57.04,EN,,0,0,0,,if p of a
Dialogue: 0,0:43:59.67,0:44:00.76,EN,,0,0,0,,loops forever
Dialogue: 0,0:44:05.87,0:44:06.95,EN,,0,0,0,,or makes an error.
Dialogue: 0,0:44:15.23,0:44:17.22,EN,,0,0,0,,Now that's surely a function.
Dialogue: 0,0:44:18.78,0:44:20.72,EN,,0,0,0,,There is some for every procedure
Dialogue: 0,0:44:21.20,0:44:22.85,EN,,0,0,0,,and for every argument you could give it
Dialogue: 0,0:44:23.92,0:44:25.45,EN,,0,0,0,,that is either true or false
Dialogue: 0,0:44:25.92,0:44:27.85,EN,,0,0,0,,that it converges without making an error.
Dialogue: 0,0:44:28.44,0:44:30.15,EN,,0,0,0,,And you could make a giant table of them.
Dialogue: 0,0:44:32.22,0:44:32.92,EN,,0,0,0,,But the question is,
Dialogue: 0,0:44:32.92,0:44:34.09,EN,,0,0,0,,can you write a procedure
Dialogue: 0,0:44:34.09,0:44:35.92,EN,,0,0,0,,that compute the values of this function?
Dialogue: 0,0:44:37.43,0:44:38.92,EN,,0,0,0,,Well let's assume that we can.
Dialogue: 0,0:44:39.72,0:44:40.55,EN,,0,0,0,,Suppose
Dialogue: 0,0:44:44.33,0:44:45.58,EN,,0,0,0,,that we have a procedure
Dialogue: 0,0:44:48.55,0:44:52.73,EN,,0,0,0,,procedure called "safe"
Dialogue: 0,0:44:56.54,0:44:59.90,EN,,0,0,0,,that computes the value of s.
Dialogue: 0,0:45:12.65,0:45:14.89,EN,,0,0,0,,Now I'm going to show you by several methods
Dialogue: 0,0:45:15.90,0:45:18.51,EN,,0,0,0,,that you can't do this.
Dialogue: 0,0:45:19.76,0:45:20.62,EN,,0,0,0,,The easiest one,
Dialogue: 0,0:45:20.62,0:45:21.28,EN,,0,0,0,,or the first one,
Dialogue: 0,0:45:21.31,0:45:23.45,EN,,0,0,0,,let's define a procedure called diag1.
Dialogue: 0,0:45:23.76,0:45:24.86,EN,,0,0,0,,Given that we have safe,
Dialogue: 0,0:45:25.20,0:45:26.99,EN,,0,0,0,,we can define diag1
Dialogue: 0,0:45:34.42,0:45:35.55,EN,,0,0,0,,diag1
Dialogue: 0,0:45:37.82,0:45:41.60,EN,,0,0,0,,to be the procedure of one argument, p,
Dialogue: 0,0:45:42.45,0:45:44.05,EN,,0,0,0,,which has the following properties.
Dialogue: 0,0:45:44.78,0:45:50.67,EN,,0,0,0,,If it's safe to apply p to itself,
Dialogue: 0,0:45:53.32,0:45:55.32,EN,,0,0,0,,then I wish to have an infinite loop.
Dialogue: 0,0:45:59.22,0:46:00.92,EN,,0,0,0,,Otherwise I'm going to return 3.
Dialogue: 0,0:46:03.68,0:46:04.47,EN,,0,0,0,,Maybe it was 42.
Dialogue: 0,0:46:04.47,0:46:06.42,EN,,0,0,0,,What's the answer to the big question?
Dialogue: 0,0:46:07.06,0:46:08.87,EN,,0,0,0,,Where of course we know what an infinite loop is.
Dialogue: 0,0:46:12.05,0:46:12.96,EN,,0,0,0,,Infinite loop,
Dialogue: 0,0:46:13.82,0:46:16.02,EN,,0,0,0,,to be a procedure of no arguments,
Dialogue: 0,0:46:16.02,0:46:18.07,EN,,0,0,0,,which is that nice lambda calculus loop.
Dialogue: 0,0:46:18.35,0:46:20.44,EN,,0,0,0,,Lambda of x,
Dialogue: 0,0:46:21.30,0:46:24.68,EN,,0,0,0,,applied to lambda of x, x of x.
Dialogue: 0,0:46:24.68,0:46:26.55,EN,,0,0,0,,So there's nothing left to the imagination here.
Dialogue: 0,0:46:29.83,0:46:31.17,EN,,0,0,0,,Well let's see what the story is.
Dialogue: 0,0:46:32.50,0:46:33.90,EN,,0,0,0,,I'm supposing it's the case
Dialogue: 0,0:46:35.45,0:46:38.77,EN,,0,0,0,,that we worry about the procedure
Dialogue: 0,0:46:39.00,0:46:43.45,EN,,0,0,0,,called diag1 applied to diag1.
Dialogue: 0,0:46:46.27,0:46:47.77,EN,,0,0,0,,Well what could it possibly be?
Dialogue: 0,0:46:49.97,0:46:51.39,EN,,0,0,0,,Well I don't know.
Dialogue: 0,0:46:51.39,0:46:53.21,EN,,0,0,0,,We're going to substitute diag1
Dialogue: 0,0:46:53.55,0:46:55.50,EN,,0,0,0,,for p in the body here.
Dialogue: 0,0:46:57.31,0:47:00.22,EN,,0,0,0,,Well is it safe to compute diag1 of diag1?
Dialogue: 0,0:47:00.22,0:47:00.78,EN,,0,0,0,,I don't know.
Dialogue: 0,0:47:00.78,0:47:01.82,EN,,0,0,0,,There are two possibilities.
Dialogue: 0,0:47:03.40,0:47:05.50,EN,,0,0,0,,If it's safe to compute diag1 of diag1
Dialogue: 0,0:47:05.92,0:47:06.89,EN,,0,0,0,,that means it shouldn't loop.
Dialogue: 0,0:47:08.49,0:47:09.22,EN,,0,0,0,,That means I go to here,
Dialogue: 0,0:47:09.22,0:47:10.35,EN,,0,0,0,,but then I produce an infinite loop.
Dialogue: 0,0:47:10.56,0:47:11.57,EN,,0,0,0,,So it can't be safe.
Dialogue: 0,0:47:12.21,0:47:14.78,EN,,0,0,0,,But if it's not safe to compute diag1 of diag1
Dialogue: 0,0:47:14.90,0:47:16.02,EN,,0,0,0,,then the answer to this is 3.
Dialogue: 0,0:47:16.02,0:47:17.26,EN,,0,0,0,,But that's diag1 of diag1,
Dialogue: 0,0:47:17.26,0:47:17.93,EN,,0,0,0,,so it had to be safe.
Dialogue: 0,0:47:20.53,0:47:23.60,EN,,0,0,0,,So therefore by contradiction
Dialogue: 0,0:47:24.32,0:47:26.30,EN,,0,0,0,,you cannot produce safe.
Dialogue: 0,0:47:27.40,0:47:29.80,EN,,0,0,0,,For those of you who were boggled by that one
Dialogue: 0,0:47:30.25,0:47:32.15,EN,,0,0,0,,I'm going to say it again, in a different way.
Dialogue: 0,0:47:32.82,0:47:34.00,EN,,0,0,0,,Listen to one more alternative.
Dialogue: 0,0:47:35.53,0:47:36.95,EN,,0,0,0,,Let's define diag2.
Dialogue: 0,0:47:39.84,0:47:41.60,EN,,0,0,0,,These are named diag because
Dialogue: 0,0:47:42.65,0:47:44.72,EN,,0,0,0,,of Cantor's diagonal argument.
Dialogue: 0,0:47:45.00,0:47:47.05,EN,,0,0,0,,These are instances of
Dialogue: 0,0:47:47.05,0:47:49.05,EN,,0,0,0,,a famous argument which was originally used by
Dialogue: 0,0:47:49.45,0:47:52.65,EN,,0,0,0,,Cantor in the late part of the last century
Dialogue: 0,0:47:52.77,0:47:56.10,EN,,0,0,0,,to prove that the real numbers were not countable,
Dialogue: 0,0:47:56.67,0:47:58.00,EN,,0,0,0,,that there are too many real numbers
Dialogue: 0,0:47:58.06,0:47:59.42,EN,,0,0,0,,to be counted by integers.
Dialogue: 0,0:48:00.19,0:48:01.74,EN,,0,0,0,,That there are more points on a line,
Dialogue: 0,0:48:01.74,0:48:02.50,EN,,0,0,0,,for example,
Dialogue: 0,0:48:02.50,0:48:04.42,EN,,0,0,0,,than there are counting numbers.
Dialogue: 0,0:48:05.26,0:48:06.85,EN,,0,0,0,,It may or may not be obvious,
Dialogue: 0,0:48:06.85,0:48:08.17,EN,,0,0,0,,and I don't want to get into that now.
Dialogue: 0,0:48:10.90,0:48:12.45,EN,,0,0,0,,But diag2
Dialogue: 0,0:48:13.30,0:48:15.82,EN,,0,0,0,,is again a procedure of one argument p.
Dialogue: 0,0:48:15.82,0:48:17.47,EN,,0,0,0,,It's almost the same as the previous one,
Dialogue: 0,0:48:17.72,0:48:24.32,EN,,0,0,0,,which is, if it's safe to compute p on p,
Dialogue: 0,0:48:25.17,0:48:26.67,EN,,0,0,0,,then I'm going to produce--
Dialogue: 0,0:48:27.26,0:48:28.14,EN,,0,0,0,,Oops, if
Dialogue: 0,0:48:29.31,0:48:31.02,EN,,0,0,0,,then I want to compute
Dialogue: 0,0:48:31.57,0:48:37.58,EN,,0,0,0,,some other things
Dialogue: 0,0:48:38.96,0:48:40.21,EN,,0,0,0,,Otherwise I'm going to put out false.
Dialogue: 0,0:48:43.60,0:48:45.30,EN,,0,0,0,,Where other then it says,
Dialogue: 0,0:48:45.47,0:48:46.35,EN,,0,0,0,,whatever p of p,
Dialogue: 0,0:48:46.35,0:48:47.47,EN,,0,0,0,,I'm going to put out something else.
Dialogue: 0,0:48:48.88,0:48:50.03,EN,,0,0,0,,I can give you an example of
Dialogue: 0,0:48:50.07,0:48:51.52,EN,,0,0,0,,a definition of other than
Dialogue: 0,0:48:51.60,0:48:52.57,EN,,0,0,0,,which I think works.
Dialogue: 0,0:48:53.89,0:48:54.51,EN,,0,0,0,,Let's see.
Dialogue: 0,0:48:55.64,0:48:56.08,EN,,0,0,0,,Yes.
Dialogue: 0,0:48:56.33,0:48:57.26,EN,,0,0,0,,Where other than
Dialogue: 0,0:49:04.03,0:49:06.11,EN,,0,0,0,,be a procedure of one argument x
Dialogue: 0,0:49:06.57,0:49:07.26,EN,,0,0,0,,which says,
Dialogue: 0,0:49:08.05,0:49:12.96,EN,,0,0,0,,if its eq x to, say, quote a,
Dialogue: 0,0:49:13.47,0:49:15.07,EN,,0,0,0,,then the answer is quote b.
Dialogue: 0,0:49:15.72,0:49:16.80,EN,,0,0,0,,Otherwise it's quote a.
Dialogue: 0,0:49:20.27,0:49:21.90,EN,,0,0,0,,That always produces something
Dialogue: 0,0:49:22.07,0:49:23.45,EN,,0,0,0,,which is not what its argument is.
Dialogue: 0,0:49:25.20,0:49:26.12,EN,,0,0,0,,That's all it is.
Dialogue: 0,0:49:26.54,0:49:27.37,EN,,0,0,0,,That's all I wanted.
Dialogue: 0,0:49:28.25,0:49:29.58,EN,,0,0,0,,Well now let's consider this one,
Dialogue: 0,0:49:29.58,0:49:31.15,EN,,0,0,0,,diag2 of diag2.
Dialogue: 0,0:49:38.28,0:49:38.94,EN,,0,0,0,,Well look.
Dialogue: 0,0:49:39.95,0:49:41.72,EN,,0,0,0,,This only does something dangerous,
Dialogue: 0,0:49:42.00,0:49:43.45,EN,,0,0,0,,like calling p of p,
Dialogue: 0,0:49:44.75,0:49:45.95,EN,,0,0,0,,if it's safe to do so.
Dialogue: 0,0:49:47.47,0:49:49.16,EN,,0,0,0,,So if safe defined at all,
Dialogue: 0,0:49:50.30,0:49:52.49,EN,,0,0,0,,if you can define such a procedure, safe,
Dialogue: 0,0:49:52.97,0:49:54.32,EN,,0,0,0,,then this procedure
Dialogue: 0,0:49:54.60,0:49:56.40,EN,,0,0,0,,is always defined and therefore safe
Dialogue: 0,0:49:56.52,0:49:57.22,EN,,0,0,0,,on any inputs.
Dialogue: 0,0:50:01.54,0:50:03.50,EN,,0,0,0,,So diag2 of diag2
Dialogue: 0,0:50:03.87,0:50:12.20,EN,,0,0,0,,must reduce to other than diag2 of diag2.
Dialogue: 0,0:50:15.82,0:50:16.97,EN,,0,0,0,,And that doesn't make sense,
Dialogue: 0,0:50:17.80,0:50:19.02,EN,,0,0,0,,so we have a contradiction,
Dialogue: 0,0:50:19.85,0:50:21.57,EN,,0,0,0,,and therefore we can't define safe.
Dialogue: 0,0:50:22.95,0:50:24.23,EN,,0,0,0,,I just waned to do that twice,
Dialogue: 0,0:50:24.78,0:50:25.82,EN,,0,0,0,,slightly differently,
Dialogue: 0,0:50:26.84,0:50:27.90,EN,,0,0,0,,so you wouldn't feel
Dialogue: 0,0:50:29.07,0:50:30.86,EN,,0,0,0,,that the first one was a trick.
Dialogue: 0,0:50:32.54,0:50:33.45,EN,,0,0,0,,They may be both tricks,
Dialogue: 0,0:50:33.80,0:50:35.15,EN,,0,0,0,,but they're at least slightly different.
Dialogue: 0,0:50:37.30,0:50:39.20,EN,,0,0,0,,So I suppose that pretty much wraps it up.
Dialogue: 0,0:50:40.03,0:50:41.97,EN,,0,0,0,,I've just proved what we call the halting theorem,
Dialogue: 0,0:50:43.00,0:50:44.70,EN,,0,0,0,,and I suppose with that we're going to halt.
Dialogue: 0,0:50:46.72,0:50:47.63,EN,,0,0,0,,I hope you have a good time.
Dialogue: 0,0:50:50.90,0:50:51.76,EN,,0,0,0,,Are there any questions?
Dialogue: 0,0:50:53.30,0:50:53.56,EN,,0,0,0,,Yes.
Dialogue: 0,0:50:53.81,0:50:56.27,EN,,0,0,0,,AUDIENCE: What is the value of s of diag1?
Dialogue: 0,0:50:56.75,0:50:57.23,EN,,0,0,0,,PROFESSOR: Of what?
Dialogue: 0,0:50:57.50,0:50:58.80,EN,,0,0,0,,AUDIENCE: S of diag1.
Dialogue: 0,0:51:00.12,0:51:02.20,EN,,0,0,0,,If you said s is a function, and then we can
Dialogue: 0,0:51:02.30,0:51:03.63,EN,,0,0,0,,PROFESSOR: Oh, I don't know.
Dialogue: 0,0:51:03.87,0:51:04.35,EN,,0,0,0,,I don't know.
Dialogue: 0,0:51:04.35,0:51:04.88,EN,,0,0,0,,It's a function,
Dialogue: 0,0:51:04.88,0:51:05.85,EN,,0,0,0,,but I don't know how to compute it.
Dialogue: 0,0:51:06.80,0:51:08.00,EN,,0,0,0,,I can't do it.
Dialogue: 0,0:51:08.61,0:51:09.64,EN,,0,0,0,,I'm just a machine, too.
Dialogue: 0,0:51:11.53,0:51:11.88,EN,,0,0,0,,Right?
Dialogue: 0,0:51:11.90,0:51:13.37,EN,,0,0,0,,And there's no machine
Dialogue: 0,0:51:13.37,0:51:14.05,EN,,0,0,0,,that in principle--
Dialogue: 0,0:51:14.47,0:51:16.87,EN,,0,0,0,,it might be that in that particular case you just asked,
Dialogue: 0,0:51:16.87,0:51:18.32,EN,,0,0,0,,with some thinking I could figure it out.
Dialogue: 0,0:51:18.58,0:51:19.37,EN,,0,0,0,,But in general
Dialogue: 0,0:51:19.60,0:51:21.05,EN,,0,0,0,,I can't compute the value of s
Dialogue: 0,0:51:21.05,0:51:22.52,EN,,0,0,0,,any better than any other machine can.
Dialogue: 0,0:51:23.78,0:51:24.92,EN,,0,0,0,,There is such a function,
Dialogue: 0,0:51:25.92,0:51:28.00,EN,,0,0,0,,it's just that no machine can be built to compute it.
Dialogue: 0,0:51:29.58,0:51:30.05,EN,,0,0,0,,Now
Dialogue: 0,0:51:30.67,0:51:33.67,EN,,0,0,0,,there's a way of saying that that should not be surprising.
Dialogue: 0,0:51:35.22,0:51:36.25,EN,,0,0,0,,Going through this--
Dialogue: 0,0:51:36.25,0:51:38.36,EN,,0,0,0,,I mean, I don't have time to do this here,
Dialogue: 0,0:51:38.45,0:51:43.00,EN,,0,0,0,,but the number of functions is very large.
Dialogue: 0,0:51:44.40,0:51:47.58,EN,,0,0,0,,If there's a certain number of answers possible
Dialogue: 0,0:51:47.75,0:51:49.62,EN,,0,0,0,,and a certain number of inputs possible,
Dialogue: 0,0:51:49.87,0:51:51.80,EN,,0,0,0,,then it's the number of answers raised to the number inputs
Dialogue: 0,0:51:51.80,0:51:53.20,EN,,0,0,0,,is the number of possible functions.
Dialogue: 0,0:51:54.50,0:51:55.48,EN,,0,0,0,,On one variable.
Dialogue: 0,0:51:56.51,0:51:59.24,EN,,0,0,0,,Now that's always bigger
Dialogue: 0,0:52:00.09,0:52:03.21,EN,,0,0,0,,than the thing you're raising to,
Dialogue: 0,0:52:03.58,0:52:04.32,EN,,0,0,0,,the exponent.
Dialogue: 0,0:52:05.48,0:52:09.80,EN,,0,0,0,,The number of functions is larger
Dialogue: 0,0:52:09.95,0:52:12.72,EN,,0,0,0,,than the number of programs
Dialogue: 0,0:52:13.30,0:52:14.10,EN,,0,0,0,,that one can write,
Dialogue: 0,0:52:14.82,0:52:16.45,EN,,0,0,0,,by an infinity counting argument.
Dialogue: 0,0:52:17.57,0:52:19.00,EN,,0,0,0,,And it's much larger.
Dialogue: 0,0:52:19.47,0:52:22.12,EN,,0,0,0,,So there must be a lot of functions
Dialogue: 0,0:52:22.12,0:52:23.48,EN,,0,0,0,,that can't be computed by programs.
Dialogue: 0,0:52:25.92,0:52:26.59,EN,,0,0,0,,AUDIENCE: A few moments ago
Dialogue: 0,0:52:26.64,0:52:28.25,EN,,0,0,0,,you were talking about specifications
Dialogue: 0,0:52:28.30,0:52:30.04,EN,,0,0,0,,and automatic generation of solutions.
Dialogue: 0,0:52:30.64,0:52:31.61,EN,,0,0,0,,Do you see any steps
Dialogue: 0,0:52:31.82,0:52:33.36,EN,,0,0,0,,between specifications and solutions?
Dialogue: 0,0:52:37.25,0:52:38.22,EN,,0,0,0,,PROFESSOR: Steps between.
Dialogue: 0,0:52:38.72,0:52:39.37,EN,,0,0,0,,You mean, you're saying,
Dialogue: 0,0:52:39.37,0:52:42.60,EN,,0,0,0,,how you go about constructing
Dialogue: 0,0:52:42.60,0:52:44.78,EN,,0,0,0,,devices given that have specifications for the device?
Dialogue: 0,0:52:45.05,0:52:48.36,EN,,0,0,0,,AUDIENCE: There's a lot of software engineering
Dialogue: 0,0:52:48.36,0:52:49.90,EN,,0,0,0,,that goes through specifications through
Dialogue: 0,0:52:49.90,0:52:51.90,EN,,0,0,0,,many layers of design and then implementation.
Dialogue: 0,0:52:52.43,0:52:52.85,EN,,0,0,0,,PROFESSOR: Yes?
Dialogue: 0,0:52:52.85,0:52:53.70,EN,,0,0,0,,AUDIENCE: I was curious
Dialogue: 0,0:52:53.70,0:52:54.62,EN,,0,0,0,,if you think that's realistic.
Dialogue: 0,0:52:55.60,0:52:57.17,EN,,0,0,0,,PROFESSOR: Well I think that some of it's realistic
Dialogue: 0,0:52:57.17,0:52:58.10,EN,,0,0,0,,and some of it isn't.
Dialogue: 0,0:52:58.10,0:53:00.32,EN,,0,0,0,,I mean, surely if I want to build an electrical filter
Dialogue: 0,0:53:01.17,0:53:07.16,EN,,0,0,0,,and I have a rather interesting possibility.
Dialogue: 0,0:53:07.16,0:53:09.42,EN,,0,0,0,,Supposing I want to build a thing that matches
Dialogue: 0,0:53:09.64,0:53:14.07,EN,,0,0,0,,that matches some power output to the radio transmitter,
Dialogue: 0,0:53:14.47,0:53:18.75,EN,,0,0,0,,to some antenna.
Dialogue: 0,0:53:19.90,0:53:21.47,EN,,0,0,0,,And I'm really out of this power--
Dialogue: 0,0:53:21.48,0:53:23.04,EN,,0,0,0,,it's output tube out here.
Dialogue: 0,0:53:23.23,0:53:25.26,EN,,0,0,0,,And the problem is that they have different impedances.
Dialogue: 0,0:53:25.92,0:53:27.55,EN,,0,0,0,,I want them to match the impedances.
Dialogue: 0,0:53:27.55,0:53:28.97,EN,,0,0,0,,I also want to make a filter in there
Dialogue: 0,0:53:29.15,0:53:31.71,EN,,0,0,0,,which is going to get rid of some harmonic radiation.
Dialogue: 0,0:53:32.78,0:53:36.63,EN,,0,0,0,,Well one old-fashioned technique for doing this is called
Dialogue: 0,0:53:36.82,0:53:38.67,EN,,0,0,0,,image impedances, or something like that.
Dialogue: 0,0:53:38.86,0:53:39.50,EN,,0,0,0,,And what you do
Dialogue: 0,0:53:39.50,0:53:40.85,EN,,0,0,0,,is you say you have a basic module
Dialogue: 0,0:53:40.85,0:53:42.75,EN,,0,0,0,,called an L-section.
Dialogue: 0,0:53:43.30,0:53:43.98,EN,,0,0,0,,Looks like this.
Dialogue: 0,0:53:47.08,0:53:49.80,EN,,0,0,0,,If I happen to connect this to some resistance, r,
Dialogue: 0,0:53:50.05,0:53:52.60,EN,,0,0,0,,and if I make this impedance x, xl,
Dialogue: 0,0:53:52.72,0:53:55.20,EN,,0,0,0,,and if it happens to be q times r,
Dialogue: 0,0:53:55.26,0:53:58.52,EN,,0,0,0,,then this produces a low pass filter
Dialogue: 0,0:53:58.52,0:54:00.72,EN,,0,0,0,,with a q square plus one impedance match.
Dialogue: 0,0:54:02.11,0:54:02.86,EN,,0,0,0,,Just what I need.
Dialogue: 0,0:54:03.12,0:54:04.28,EN,,0,0,0,,Because now I can take two of these,
Dialogue: 0,0:54:04.30,0:54:05.08,EN,,0,0,0,,hook them together
Dialogue: 0,0:54:05.82,0:54:06.38,EN,,0,0,0,,like this.
Dialogue: 0,0:54:11.66,0:54:13.15,EN,,0,0,0,,OK, and I take another one
Dialogue: 0,0:54:16.00,0:54:17.45,EN,,0,0,0,,and I'll hook them together like that.
Dialogue: 0,0:54:18.29,0:54:19.95,EN,,0,0,0,,And I have two L-sections hooked together.
Dialogue: 0,0:54:20.32,0:54:23.07,EN,,0,0,0,,And this will step the impedance down to one that I know,
Dialogue: 0,0:54:23.37,0:54:25.22,EN,,0,0,0,,and this will step it up to one I know.
Dialogue: 0,0:54:25.53,0:54:26.64,EN,,0,0,0,,Each of these is a low pass filter
Dialogue: 0,0:54:26.67,0:54:27.82,EN,,0,0,0,,getting rid of some harmonics.
Dialogue: 0,0:54:28.09,0:54:29.07,EN,,0,0,0,,It's good filter,
Dialogue: 0,0:54:29.07,0:54:30.27,EN,,0,0,0,,it's called a pie-section filter.
Dialogue: 0,0:54:30.27,0:54:30.62,EN,,0,0,0,,Great.
Dialogue: 0,0:54:31.70,0:54:34.09,EN,,0,0,0,,Except for the fact that in doing what I just did,
Dialogue: 0,0:54:34.12,0:54:37.85,EN,,0,0,0,,I've made a terrible inefficiency in this system.
Dialogue: 0,0:54:38.62,0:54:39.60,EN,,0,0,0,,I've made two coils
Dialogue: 0,0:54:39.61,0:54:40.59,EN,,0,0,0,,where I should have made one.
Dialogue: 0,0:54:41.62,0:54:44.60,EN,,0,0,0,,And the problem with most software engineering art
Dialogue: 0,0:54:44.89,0:54:46.88,EN,,0,0,0,,is that there's no mechanism,
Dialogue: 0,0:54:46.92,0:54:48.65,EN,,0,0,0,,other than people optimization and compilers,
Dialogue: 0,0:54:48.80,0:54:51.34,EN,,0,0,0,,for getting rid of the redundant parts
Dialogue: 0,0:54:51.34,0:54:53.55,EN,,0,0,0,,that are constructed when doing top down design.
Dialogue: 0,0:54:55.35,0:54:56.07,EN,,0,0,0,,It's even worse,
Dialogue: 0,0:54:56.07,0:54:57.58,EN,,0,0,0,,there are lots of very important structures
Dialogue: 0,0:54:57.60,0:54:59.02,EN,,0,0,0,,that you can't construct at all this way.
Dialogue: 0,0:55:01.11,0:55:03.53,EN,,0,0,0,,So I think that the standard top down design
Dialogue: 0,0:55:03.53,0:55:04.87,EN,,0,0,0,,is a rather shallow business.
Dialogue: 0,0:55:05.71,0:55:06.60,EN,,0,0,0,,Doesn't really capture
Dialogue: 0,0:55:06.60,0:55:08.10,EN,,0,0,0,,what people want to do in design.
Dialogue: 0,0:55:08.31,0:55:10.10,EN,,0,0,0,,I'll give you another electrical example.
Dialogue: 0,0:55:10.10,0:55:11.75,EN,,0,0,0,,Electrical examples are so much clearer
Dialogue: 0,0:55:11.90,0:55:13.13,EN,,0,0,0,,than computational examples,
Dialogue: 0,0:55:13.16,0:55:14.78,EN,,0,0,0,,because computation examples require
Dialogue: 0,0:55:14.80,0:55:16.52,EN,,0,0,0,,a certain degree of complexity to explain them.
Dialogue: 0,0:55:17.22,0:55:19.16,EN,,0,0,0,,But one of my favorite examples
Dialogue: 0,0:55:19.16,0:55:20.04,EN,,0,0,0,,in the electrical world
Dialogue: 0,0:55:20.60,0:55:22.80,EN,,0,0,0,,is how would I ever come up with the output stage
Dialogue: 0,0:55:23.28,0:55:26.55,EN,,0,0,0,,of this inter-stage connection in an IF amplifier.
Dialogue: 0,0:55:27.53,0:55:29.44,EN,,0,0,0,,It's a little transistor here,
Dialogue: 0,0:55:29.52,0:55:31.50,EN,,0,0,0,,and let's see.
Dialogue: 0,0:55:32.41,0:55:33.40,EN,,0,0,0,,Well I'm going to have a tank,
Dialogue: 0,0:55:36.45,0:55:39.17,EN,,0,0,0,,and I'm going to hook this up to, say,
Dialogue: 0,0:55:41.37,0:55:43.97,EN,,0,0,0,,I'm going to link-couple that to the input of the next stage.
Dialogue: 0,0:55:44.36,0:55:47.47,EN,,0,0,0,,Here's a perfectly plausible plan--
Dialogue: 0,0:55:48.22,0:55:50.87,EN,,0,0,0,,well except for the fact that since I put that going up
Dialogue: 0,0:55:50.87,0:55:52.92,EN,,0,0,0,,I should make that going that way. OK?
Dialogue: 0,0:55:53.17,0:55:55.45,EN,,0,0,0,,Here's a perfectly plausible plan for a--
Dialogue: 0,0:55:55.98,0:55:56.57,EN,,0,0,0,,no I shouldn't.
Dialogue: 0,0:55:57.12,0:55:57.79,EN,,0,0,0,,I'm dumb.
Dialogue: 0,0:55:58.40,0:55:59.07,EN,,0,0,0,,Excuse me.
Dialogue: 0,0:55:59.69,0:56:00.42,EN,,0,0,0,,Doesn't matter.
Dialogue: 0,0:56:00.73,0:56:01.54,EN,,0,0,0,,The point is it's a perfect
Dialogue: 0,0:56:01.54,0:56:03.42,EN,,0,0,0,,plan for a couple two stages together.
Dialogue: 0,0:56:04.54,0:56:06.92,EN,,0,0,0,,Now what the problem is what's this hierarchically?
Dialogue: 0,0:56:07.62,0:56:08.80,EN,,0,0,0,,It's not one thing.
Dialogue: 0,0:56:09.48,0:56:11.99,EN,,0,0,0,,Hierarchically it doesn't make any sense at all.
Dialogue: 0,0:56:11.99,0:56:14.32,EN,,0,0,0,,It's the inductance of a tuned circuit,
Dialogue: 0,0:56:15.55,0:56:18.02,EN,,0,0,0,,it's the primary of a transformer,
Dialogue: 0,0:56:19.10,0:56:21.82,EN,,0,0,0,,and it's also the DC path by
Dialogue: 0,0:56:21.82,0:56:23.57,EN,,0,0,0,,which bias conditions get to the
Dialogue: 0,0:56:23.57,0:56:25.10,EN,,0,0,0,,collector of that transistor.
Dialogue: 0,0:56:26.46,0:56:28.35,EN,,0,0,0,,And there's no simple top-down design
Dialogue: 0,0:56:28.38,0:56:30.17,EN,,0,0,0,,that's going to produce a structure like that
Dialogue: 0,0:56:30.22,0:56:34.02,EN,,0,0,0,,with so many overlapping uses for a particular thing.
Dialogue: 0,0:56:34.53,0:56:36.72,EN,,0,0,0,,Playing Scrabble,
Dialogue: 0,0:56:36.96,0:56:39.88,EN,,0,0,0,,where you have to do triple word scores, or whatever,
Dialogue: 0,0:56:40.49,0:56:43.60,EN,,0,0,0,,is not so easy in top-down design strategy.
Dialogue: 0,0:56:44.95,0:56:47.08,EN,,0,0,0,,Yet most of real engineering is based on
Dialogue: 0,0:56:47.36,0:56:50.70,EN,,0,0,0,,on getting the most oomph for effort.
Dialogue: 0,0:56:52.14,0:56:53.52,EN,,0,0,0,,And that's what you're seeing here.
Dialogue: 0,0:56:54.86,0:56:55.55,EN,,0,0,0,,Yeah?
Dialogue: 0,0:56:55.55,0:56:56.81,EN,,0,0,0,,AUDIENCE: Is this the last question?
Dialogue: 0,0:57:00.28,0:57:02.03,EN,,0,0,0,,[LAUGHTER]
Dialogue: 0,0:57:18.64,0:57:19.63,EN,,0,0,0,,PROFESSOR: Apparently so.
Dialogue: 0,0:57:23.57,0:57:24.12,EN,,0,0,0,,Thank you.
Dialogue: 0,0:57:25.90,0:57:36.50,EN,,0,0,0,,[APPLAUSE]
Dialogue: 0,0:00:00.00,0:00:03.48,Declare,,0,0,0,,{\an2\fad(500,500)}Learning-SICP学习小组\N倾情制作
Dialogue: 0,0:00:00.00,0:00:03.48,Declare,,0,0,0,,{\fad(500,500)\pos(313,99)}“让我们举杯，祝福那些\N\N\N\N将他们的思想镶嵌在\N\N\N\N　　　重重括号之间的Lisp程序员。”
Dialogue: 0,0:00:04.75,0:00:11.77,staff,,0,0,0,,{\fad(600,800)\pos(110.666,403.334)}翻译&&时间轴\N杨启钊\N（windfarer）
Dialogue: 0,0:00:04.75,0:00:11.77,staff,,0,0,0,,{\fad(600,800)\pos(534.666,404)}压制&&特效\N邓雄飞\N（Dysprosium）
Dialogue: 0,0:00:04.75,0:00:11.77,staff,,0,0,0,,{\fad(600,800)\pos(574.667,277.333)}校对\N邓雄飞
Dialogue: 0,0:00:04.75,0:00:11.77,staff,,0,0,0,,{\fad(600,800)\pos(89.334,273.333)}特别感谢\N裘宗燕教授
Dialogue: 0,0:00:04.75,0:00:11.77,title,,0,0,0,,{\fad(600,800)\pos(324,32)}《计算机程序的构造和解释》
Dialogue: 0,0:00:11.88,0:00:15.72,Declare,,0,0,0,,{\an2\fad(500,500)}存储分配与垃圾收集
Dialogue: 0,0:00:18.91,0:00:20.61,Default,,0,0,0,,教授: 接下来我要解开
Dialogue: 0,0:00:21.16,0:00:23.36,Default,,0,0,0,,目前仅剩的谜团
Dialogue: 0,0:00:24.44,0:00:28.80,Default,,0,0,0,,我们能毫无顾虑地进行CONS
Dialogue: 0,0:00:30.00,0:00:31.62,Default,,0,0,0,,就好像空间足够多一样
Dialogue: 0,0:00:32.80,0:00:36.32,Default,,0,0,0,,我们总是在使用
Dialogue: 0,0:00:36.51,0:00:37.44,Default,,0,0,0,,CAR和CDR
Dialogue: 0,0:00:37.47,0:00:38.72,Default,,0,0,0,,并假设知道我们知道
Dialogue: 0,0:00:38.75,0:00:39.74,Default,,0,0,0,,它们是如何实现的
Dialogue: 0,0:00:40.02,0:00:40.67,Default,,0,0,0,,事实上
Dialogue: 0,0:00:41.07,0:00:44.40,Default,,0,0,0,,我们认为它们是基本过程
Dialogue: 0,0:00:45.37,0:00:47.57,Default,,0,0,0,,但这没有真正解决问题
Dialogue: 0,0:00:47.73,0:00:50.25,Default,,0,0,0,,因为过程依赖各种复杂的机制
Dialogue: 0,0:00:50.27,0:00:51.37,Default,,0,0,0,,需要诸如环境结构之类的东西
Dialogue: 0,0:00:51.64,0:00:52.76,Default,,0,0,0,,才能运行起来
Dialogue: 0,0:00:53.01,0:00:54.89,Default,,0,0,0,,而归根结底它们也是
Dialogue: 0,0:00:54.89,0:00:56.42,Default,,0,0,0,,由CONS之类的东西构成的
Dialogue: 0,0:00:56.70,0:00:58.47,Default,,0,0,0,,这的确没有解决问题
Dialogue: 0,0:00:59.38,0:01:01.13,Default,,0,0,0,,目前的问题是
Dialogue: 0,0:01:01.31,0:01:03.97,Default,,0,0,0,,粘合这些数据结构的是什么东西？
Dialogue: 0,0:01:04.76,0:01:06.40,Default,,0,0,0,,它可能是怎样的一个东西?
Dialogue: 0,0:01:07.04,0:01:10.46,Default,,0,0,0,,我们已经见过了一台机器
Dialogue: 0,0:01:10.46,0:01:13.96,Default,,0,0,0,,一台计算机具有一个控制器
Dialogue: 0,0:01:14.27,0:01:15.45,Default,,0,0,0,,和一些寄存器
Dialogue: 0,0:01:15.45,0:01:16.47,Default,,0,0,0,,还可能有一个栈
Dialogue: 0,0:01:16.98,0:01:18.12,Default,,0,0,0,,但是我们还没提到一些东西
Dialogue: 0,0:01:18.16,0:01:19.95,Default,,0,0,0,,例如 大内存
Dialogue: 0,0:01:20.57,0:01:22.38,Default,,0,0,0,,我想 现在是时候讨论它们了
Dialogue: 0,0:01:23.74,0:01:26.56,Default,,0,0,0,,但是先要说清楚
Dialogue: 0,0:01:26.59,0:01:27.88,Default,,0,0,0,,这个并不是必须的
Dialogue: 0,0:01:28.82,0:01:30.79,Default,,0,0,0,,只是一些实现上的细节
Dialogue: 0,0:01:31.10,0:01:32.60,Default,,0,0,0,,让我举个例子
Dialogue: 0,0:01:32.60,0:01:34.20,Default,,0,0,0,,如何用数字来表示这些东西
Dialogue: 0,0:01:35.23,0:01:36.82,Default,,0,0,0,,有个比较简单的方法
Dialogue: 0,0:01:37.59,0:01:39.00,Default,,0,0,0,,一位著名的逻辑学家 哥德尔
Dialogue: 0,0:01:44.09,0:01:46.01,Default,,0,0,0,,在20世纪30年代末
Dialogue: 0,0:01:46.38,0:01:48.70,Default,,0,0,0,,发明了一个很巧妙的方法
Dialogue: 0,0:01:48.70,0:01:52.27,Default,,0,0,0,,能够把复杂的表达式
Dialogue: 0,0:01:52.81,0:01:53.52,Default,,0,0,0,,表示成数字
Dialogue: 0,0:01:54.32,0:01:55.05,Default,,0,0,0,,例如
Dialogue: 0,0:01:55.05,0:01:58.00,Default,,0,0,0,,我不会照搬哥德尔的方法
Dialogue: 0,0:01:58.00,0:01:59.48,Default,,0,0,0,,因为他没有使用CONS之类的术语
Dialogue: 0,0:01:59.66,0:02:00.60,Default,,0,0,0,,他使用了其它的组合手段
Dialogue: 0,0:02:00.91,0:02:02.60,Default,,0,0,0,,来编码表达式
Dialogue: 0,0:02:03.09,0:02:03.88,Default,,0,0,0,,他的思路是
Dialogue: 0,0:02:03.92,0:02:06.81,Default,,0,0,0,,用不同数字分别代表每个代数式
Dialogue: 0,0:02:07.92,0:02:09.72,Default,,0,0,0,,通过组合各个部分的数字
Dialogue: 0,0:02:09.72,0:02:11.65,Default,,0,0,0,,来形成新的表达式
Dialogue: 0,0:02:12.47,0:02:13.45,Default,,0,0,0,,举例来说
Dialogue: 0,0:02:13.62,0:02:15.35,Default,,0,0,0,,我们在创造世界的时候
Dialogue: 0,0:02:15.35,0:02:18.01,Default,,0,0,0,,如果用数字
Dialogue: 0,0:02:20.78,0:02:22.22,Default,,0,0,0,,来表示对象
Dialogue: 0,0:02:30.67,0:02:37.93,Default,,0,0,0,,那么(CONS X Y)
Dialogue: 0,0:02:38.04,0:02:41.07,Default,,0,0,0,,就可以表示为
Dialogue: 0,0:02:41.55,0:02:43.77,Default,,0,0,0,,2^X * 3^Y
Dialogue: 0,0:02:46.13,0:02:48.03,Default,,0,0,0,,因为这样我们还能取出它的每一部分
Dialogue: 0,0:02:49.56,0:02:50.97,Default,,0,0,0,,举例来说
Dialogue: 0,0:02:51.18,0:02:55.88,Default,,0,0,0,,(CAR X)
Dialogue: 0,0:02:56.55,0:03:05.18,Default,,0,0,0,,就是X中因数2的个数
Dialogue: 0,0:03:06.69,0:03:08.78,Default,,0,0,0,,当然(CDR X)是一样的
Dialogue: 0,0:03:10.69,0:03:15.57,Default,,0,0,0,,它就X中因数3的个数
Dialogue: 0,0:03:16.51,0:03:18.65,Default,,0,0,0,,这是个非常合理的方案
Dialogue: 0,0:03:19.10,0:03:20.11,Default,,0,0,0,,只不过就是
Dialogue: 0,0:03:20.12,0:03:22.52,Default,,0,0,0,,数字的位数
Dialogue: 0,0:03:22.83,0:03:23.98,Default,,0,0,0,,会急剧地增大
Dialogue: 0,0:03:24.32,0:03:26.55,Default,,0,0,0,,甚至比宇宙中的粒子还多
Dialogue: 0,0:03:27.95,0:03:29.88,Default,,0,0,0,,所以除了在理论中
Dialogue: 0,0:03:29.90,0:03:31.21,Default,,0,0,0,,没有实现这种方案的好办法
Dialogue: 0,0:03:33.43,0:03:34.48,Default,,0,0,0,,另一方面
Dialogue: 0,0:03:35.12,0:03:37.55,Default,,0,0,0,,也有其它的表示方式
Dialogue: 0,0:03:38.45,0:03:40.01,Default,,0,0,0,,我们把它们表示为
Dialogue: 0,0:03:40.25,0:03:42.42,Default,,0,0,0,,一些小盒子
Dialogue: 0,0:03:43.32,0:03:46.43,Default,,0,0,0,,我们把CONS结构
Dialogue: 0,0:03:46.50,0:03:48.05,Default,,0,0,0,,想象为这样的东西
Dialogue: 0,0:03:50.28,0:03:52.57,Default,,0,0,0,,它们是里面装着东西的小隔间
Dialogue: 0,0:03:53.56,0:03:55.47,Default,,0,0,0,,这些格子组成一个树
Dialogue: 0,0:03:57.21,0:03:59.97,Default,,0,0,0,,我希望半导体制造商
Dialogue: 0,0:03:59.97,0:04:02.07,Default,,0,0,0,,能够提供适配这样需求的芯片
Dialogue: 0,0:04:02.70,0:04:03.76,Default,,0,0,0,,但事实上
Dialogue: 0,0:04:03.85,0:04:05.31,Default,,0,0,0,,他们提供给我的却是
Dialogue: 0,0:04:06.20,0:04:07.96,Default,,0,0,0,,线性的内存
Dialogue: 0,0:04:09.38,0:04:13.46,Default,,0,0,0,,内存是一串小隔间
Dialogue: 0,0:04:15.12,0:04:16.34,Default,,0,0,0,,像这样的小隔间
Dialogue: 0,0:04:17.72,0:04:20.25,Default,,0,0,0,,每个小隔间里可以保存确定大小的对象
Dialogue: 0,0:04:20.94,0:04:22.20,Default,,0,0,0,,一个尺寸固定的对象
Dialogue: 0,0:04:23.39,0:04:24.07,Default,,0,0,0,,例如
Dialogue: 0,0:04:24.07,0:04:25.66,Default,,0,0,0,,一个含25个元素的表
Dialogue: 0,0:04:25.66,0:04:26.64,Default,,0,0,0,,就放不进这里
Dialogue: 0,0:04:28.55,0:04:29.26,Default,,0,0,0,,然而 它们中的每一个
Dialogue: 0,0:04:29.29,0:04:30.88,Default,,0,0,0,,都是由地址索引的
Dialogue: 0,0:04:33.97,0:04:34.99,Default,,0,0,0,,因此它们的地址可能是
Dialogue: 0,0:04:35.02,0:04:35.50,Default,,0,0,0,,这里是0
Dialogue: 0,0:04:35.50,0:04:36.22,Default,,0,0,0,,这里是1
Dialogue: 0,0:04:36.22,0:04:36.70,Default,,0,0,0,,这里是2
Dialogue: 0,0:04:36.70,0:04:37.25,Default,,0,0,0,,这里是3
Dialogue: 0,0:04:37.25,0:04:37.94,Default,,0,0,0,,以此类推
Dialogue: 0,0:04:38.06,0:04:40.40,Default,,0,0,0,,这里写的数字并不重要
Dialogue: 0,0:04:40.40,0:04:41.68,Default,,0,0,0,,重要的是 它们不重复
Dialogue: 0,0:04:41.95,0:04:43.42,Default,,0,0,0,,有了它们就能找到下一个在哪
Dialogue: 0,0:04:44.97,0:04:46.14,Default,,0,0,0,,在其中每一个小隔间里面
Dialogue: 0,0:04:46.36,0:04:49.11,Default,,0,0,0,,我们可以把东西放进去
Dialogue: 0,0:04:49.53,0:04:50.77,Default,,0,0,0,,对于没有造过计算机的我们来说
Dialogue: 0,0:04:51.02,0:04:53.66,Default,,0,0,0,,内存就是这样子的
Dialogue: 0,0:04:54.15,0:04:54.65,Default,,0,0,0,,现在
Dialogue: 0,0:04:56.69,0:04:57.53,Default,,0,0,0,,现在的问题是
Dialogue: 0,0:04:57.53,0:04:59.97,Default,,0,0,0,,如何用这样的结构
Dialogue: 0,0:05:00.42,0:05:01.72,Default,,0,0,0,,来实现这个树形结构
Dialogue: 0,0:05:03.29,0:05:04.57,Default,,0,0,0,,其实并不难
Dialogue: 0,0:05:04.57,0:05:06.35,Default,,0,0,0,,已经有大量的方案来做这个了
Dialogue: 0,0:05:06.87,0:05:08.80,Default,,0,0,0,,最重要的一个方案是
Dialogue: 0,0:05:08.80,0:05:11.18,Default,,0,0,0,,假设半导体制造商
Dialogue: 0,0:05:11.20,0:05:13.90,Default,,0,0,0,,允许我安排自己的内存
Dialogue: 0,0:05:13.98,0:05:15.77,Default,,0,0,0,,使得其中每个小隔间都足够大
Dialogue: 0,0:05:16.28,0:05:18.20,Default,,0,0,0,,能够装得下另一个的地址
Dialogue: 0,0:05:19.35,0:05:20.83,Default,,0,0,0,,我需要这么来安排
Dialogue: 0,0:05:22.05,0:05:23.45,Default,,0,0,0,,事实上它需要更大一点
Dialogue: 0,0:05:23.48,0:05:27.52,Default,,0,0,0,,因为我还要在里面存放一些信息
Dialogue: 0,0:05:27.56,0:05:30.09,Default,,0,0,0,,它标示了这里面是什么东西
Dialogue: 0,0:05:30.39,0:05:31.64,Default,,0,0,0,,我们过一会就能看到
Dialogue: 0,0:05:32.62,0:05:34.40,Default,,0,0,0,,当然 如果半导体制造商
Dialogue: 0,0:05:34.43,0:05:35.88,Default,,0,0,0,,没有这么来制造
Dialogue: 0,0:05:36.08,0:05:38.44,Default,,0,0,0,,我就需要用一些机智的方式
Dialogue: 0,0:05:38.57,0:05:41.82,Default,,0,0,0,,把它们组合起来以供使用
Dialogue: 0,0:05:43.77,0:05:47.05,Default,,0,0,0,,我们想象一下
Dialogue: 0,0:05:47.05,0:05:49.54,Default,,0,0,0,,把这个复杂的树形结构
Dialogue: 0,0:05:49.54,0:05:51.20,Default,,0,0,0,,塞进线性内存里
Dialogue: 0,0:05:51.74,0:05:54.47,Default,,0,0,0,,我们来看第一张幻灯片
Dialogue: 0,0:05:54.47,0:05:58.30,Default,,0,0,0,,可以看到一个传统的实现方案
Dialogue: 0,0:05:59.49,0:06:02.62,Default,,0,0,0,,它是把表结构放入线性内存
Dialogue: 0,0:06:03.22,0:06:05.87,Default,,0,0,0,,的标准方式
Dialogue: 0,0:06:06.27,0:06:08.32,Default,,0,0,0,,我们把这块内存
Dialogue: 0,0:06:08.88,0:06:11.12,Default,,0,0,0,,分为两部分
Dialogue: 0,0:06:12.03,0:06:13.42,Default,,0,0,0,,一个叫THE-CARS的数组
Dialogue: 0,0:06:14.45,0:06:15.88,Default,,0,0,0,,一个叫THE-CDRS的数组
Dialogue: 0,0:06:17.58,0:06:18.86,Default,,0,0,0,,无论它们是
Dialogue: 0,0:06:18.88,0:06:21.04,Default,,0,0,0,,顺序的地址或是其它的
Dialogue: 0,0:06:21.12,0:06:22.00,Default,,0,0,0,,其实并不重要
Dialogue: 0,0:06:22.87,0:06:25.20,Default,,0,0,0,,这是实现细节了
Dialogue: 0,0:06:25.80,0:06:28.40,Default,,0,0,0,,但有两个数组
Dialogue: 0,0:06:28.96,0:06:30.36,Default,,0,0,0,,线性数组是由
Dialogue: 0,0:06:30.46,0:06:32.59,Default,,0,0,0,,顺序的下标索引的
Dialogue: 0,0:06:34.84,0:06:36.85,Default,,0,0,0,,每个小格子里存的
Dialogue: 0,0:06:37.46,0:06:39.85,Default,,0,0,0,,是一个带类型的对象
Dialogue: 0,0:06:41.43,0:06:42.57,Default,,0,0,0,,这里的类型
Dialogue: 0,0:06:42.57,0:06:45.71,Default,,0,0,0,,以字母P开头
Dialogue: 0,0:06:45.71,0:06:46.57,Default,,0,0,0,,表示序对
Dialogue: 0,0:06:47.79,0:06:49.37,Default,,0,0,0,,以N开头 表示数字
Dialogue: 0,0:06:50.04,0:06:52.25,Default,,0,0,0,,E开头 表示空表
Dialogue: 0,0:06:54.81,0:06:55.83,Default,,0,0,0,,也就是表尾标志
Dialogue: 0,0:06:57.02,0:06:58.59,Default,,0,0,0,,如果我们想表示
Dialogue: 0,0:06:58.99,0:06:59.97,Default,,0,0,0,,这样一个对象
Dialogue: 0,0:07:00.01,0:07:02.16,Default,,0,0,0,,首元素为(1 2)
Dialogue: 0,0:07:02.65,0:07:04.01,Default,,0,0,0,,然后3、4分别作为
Dialogue: 0,0:07:04.01,0:07:05.50,Default,,0,0,0,,它的第二和第三个元素
Dialogue: 0,0:07:06.43,0:07:08.83,Default,,0,0,0,,这个表的第一部分也是一个表
Dialogue: 0,0:07:09.35,0:07:10.65,Default,,0,0,0,,后面接着是两个数字
Dialogue: 0,0:07:10.65,0:07:12.00,Default,,0,0,0,,分别为第二和第三部分
Dialogue: 0,0:07:12.87,0:07:14.81,Default,,0,0,0,,现在我们用盒子-指针表示法
Dialogue: 0,0:07:14.84,0:07:16.67,Default,,0,0,0,,来描绘它
Dialogue: 0,0:07:17.32,0:07:18.00,Default,,0,0,0,,你能发现
Dialogue: 0,0:07:18.00,0:07:20.04,Default,,0,0,0,,这里有三个单元
Dialogue: 0,0:07:20.25,0:07:22.01,Default,,0,0,0,,它们的CAR指针
Dialogue: 0,0:07:22.27,0:07:27.10,Default,,0,0,0,,分别指向对象(1 2)、3以及4
Dialogue: 0,0:07:28.39,0:07:29.75,Default,,0,0,0,,当然这个(1 2)
Dialogue: 0,0:07:29.75,0:07:31.32,Default,,0,0,0,,即整个结构的CAR
Dialogue: 0,0:07:31.32,0:07:32.65,Default,,0,0,0,,本身就是一个子结构
Dialogue: 0,0:07:32.88,0:07:34.75,Default,,0,0,0,,包含一个像这样的子表
Dialogue: 0,0:07:35.94,0:07:37.07,Default,,0,0,0,,我要做的是
Dialogue: 0,0:07:37.20,0:07:39.92,Default,,0,0,0,,就是按照下标
Dialogue: 0,0:07:39.95,0:07:41.46,Default,,0,0,0,,把它们放进去
Dialogue: 0,0:07:41.84,0:07:43.40,Default,,0,0,0,,像这里的1
Dialogue: 0,0:07:43.56,0:07:47.05,Default,,0,0,0,,代表了这个格子的下标
Dialogue: 0,0:07:49.85,0:07:51.47,Default,,0,0,0,,这里的指针
Dialogue: 0,0:07:52.37,0:07:54.86,Default,,0,0,0,,是对THE-CARS
Dialogue: 0,0:07:55.07,0:07:57.29,Default,,0,0,0,,和THE-CDRS里的小格子的引用
Dialogue: 0,0:07:57.40,0:07:58.67,Default,,0,0,0,,它在我的线性内存中
Dialogue: 0,0:07:58.76,0:08:00.33,Default,,0,0,0,,被标记为1的地方
Dialogue: 0,0:08:02.00,0:08:04.06,Default,,0,0,0,,如果我想把这个结构
Dialogue: 0,0:08:04.16,0:08:05.26,Default,,0,0,0,,塞进线性内存中
Dialogue: 0,0:08:05.85,0:08:07.52,Default,,0,0,0,,要做的是
Dialogue: 0,0:08:07.52,0:08:11.88,Default,,0,0,0,,把它放进格子1中
Dialogue: 0,0:08:11.95,0:08:12.66,Default,,0,0,0,,我要选取1号格子
Dialogue: 0,0:08:12.66,0:08:13.85,Default,,0,0,0,,这个就是1号格子
Dialogue: 0,0:08:14.27,0:08:16.22,Default,,0,0,0,,这是它的CAR
Dialogue: 0,0:08:16.22,0:08:17.74,Default,,0,0,0,,我要把它赋值给一个序对
Dialogue: 0,0:08:17.95,0:08:18.72,Default,,0,0,0,,这个序对
Dialogue: 0,0:08:20.02,0:08:21.55,Default,,0,0,0,,序号是5
Dialogue: 0,0:08:22.59,0:08:23.90,Default,,0,0,0,,它的CDR
Dialogue: 0,0:08:23.90,0:08:25.13,Default,,0,0,0,,就是这个
Dialogue: 0,0:08:25.39,0:08:26.13,Default,,0,0,0,,它是个序对
Dialogue: 0,0:08:26.13,0:08:27.70,Default,,0,0,0,,我会把它放到2的位置
Dialogue: 0,0:08:28.34,0:08:28.98,Default,,0,0,0,,即P2
Dialogue: 0,0:08:30.89,0:08:32.95,Default,,0,0,0,,我们看P2
Dialogue: 0,0:08:32.95,0:08:34.72,Default,,0,0,0,,P2的CAR
Dialogue: 0,0:08:34.90,0:08:37.22,Default,,0,0,0,,是数字3
Dialogue: 0,0:08:37.34,0:08:38.64,Default,,0,0,0,,如你所见N3
Dialogue: 0,0:08:39.52,0:08:41.52,Default,,0,0,0,,这里 它的CDR
Dialogue: 0,0:08:41.72,0:08:43.40,Default,,0,0,0,,是一个序对
Dialogue: 0,0:08:43.97,0:08:45.81,Default,,0,0,0,,在位置4
Dialogue: 0,0:08:46.64,0:08:47.79,Default,,0,0,0,,这就是P4
Dialogue: 0,0:08:48.65,0:08:51.16,Default,,0,0,0,,P4是一个数字
Dialogue: 0,0:08:51.85,0:08:53.87,Default,,0,0,0,,它的CAR部分是数字4
Dialogue: 0,0:08:54.60,0:08:55.65,Default,,0,0,0,,它的CDR
Dialogue: 0,0:08:55.84,0:08:58.48,Default,,0,0,0,,是个空表 就在这儿
Dialogue: 0,0:08:59.17,0:08:59.90,Default,,0,0,0,,这个表就结束了
Dialogue: 0,0:09:00.69,0:09:04.57,Default,,0,0,0,,这就是在线性内存中
Dialogue: 0,0:09:04.90,0:09:09.55,Default,,0,0,0,,表示二叉树的传统方式
Dialogue: 0,0:09:11.62,0:09:15.10,Default,,0,0,0,,那么 下一个问题是
Dialogue: 0,0:09:15.10,0:09:16.36,Default,,0,0,0,,我们需要关心
Dialogue: 0,0:09:16.60,0:09:18.19,Default,,0,0,0,,如何去实现
Dialogue: 0,0:09:18.44,0:09:20.33,Default,,0,0,0,,这意味着当我写下一个过程
Dialogue: 0,0:09:20.36,0:09:23.62,Default,,0,0,0,,用来给A赋值时
Dialogue: 0,0:09:24.54,0:09:27.10,Default,,0,0,0,,使用寄存机器的代码来编写的
Dialogue: 0,0:09:27.21,0:09:30.14,Default,,0,0,0,,(ASSIGN A (FETCH B))
Dialogue: 0,0:09:30.84,0:09:31.85,Default,,0,0,0,,我实际上想做的是
Dialogue: 0,0:09:31.97,0:09:37.10,Default,,0,0,0,,定位这些元素
Dialogue: 0,0:09:38.74,0:09:40.25,Default,,0,0,0,,那段机器代码只是
Dialogue: 0,0:09:40.68,0:09:42.94,Default,,0,0,0,,这个复杂过程的简写
Dialogue: 0,0:09:44.47,0:09:46.33,Default,,0,0,0,,当然 为了把它“写下来”
Dialogue: 0,0:09:46.35,0:09:48.59,Default,,0,0,0,,我要引入一种
Dialogue: 0,0:09:48.62,0:09:49.42,Default,,0,0,0,,称为“向量”的结构
Dialogue: 0,0:09:52.12,0:09:53.31,Default,,0,0,0,,我们得有一种东西
Dialogue: 0,0:09:53.48,0:09:54.54,Default,,0,0,0,,用来引用向量
Dialogue: 0,0:09:56.84,0:09:58.51,Default,,0,0,0,,这样我们就能把它写下来
Dialogue: 0,0:09:58.71,0:10:00.22,Default,,0,0,0,,它的参数之一是向量的名字
Dialogue: 0,0:10:01.02,0:10:03.97,Default,,0,0,0,,我觉得这个名字起得不太靠谱
Dialogue: 0,0:10:03.97,0:10:09.40,Default,,0,0,0,,它接受VECTOR和INDEX两个参数
Dialogue: 0,0:10:11.20,0:10:13.05,Default,,0,0,0,,我可以用VECTOR-SET!
Dialogue: 0,0:10:13.10,0:10:14.27,Default,,0,0,0,,来为其中的分量赋值
Dialogue: 0,0:10:14.65,0:10:15.60,Default,,0,0,0,,我不太在意
Dialogue: 0,0:10:16.28,0:10:17.55,Default,,0,0,0,,我们来看一看
Dialogue: 0,0:10:18.11,0:10:20.42,Default,,0,0,0,,在这种实现中
Dialogue: 0,0:10:21.25,0:10:23.18,Default,,0,0,0,,CAR和CDR是什么样子的
Dialogue: 0,0:10:26.47,0:10:28.41,Default,,0,0,0,,比如说 如果我刚好有
Dialogue: 0,0:10:28.88,0:10:30.80,Default,,0,0,0,,一个寄存器B
Dialogue: 0,0:10:31.15,0:10:34.64,Default,,0,0,0,,它存了一个序对的下标
Dialogue: 0,0:10:35.95,0:10:38.80,Default,,0,0,0,,即它是指向一个序对的指针
Dialogue: 0,0:10:39.35,0:10:40.85,Default,,0,0,0,,我可以取它的CAR
Dialogue: 0,0:10:41.55,0:10:44.11,Default,,0,0,0,,存到寄存器A里面
Dialogue: 0,0:10:44.49,0:10:46.86,Default,,0,0,0,,事实上它是
Dialogue: 0,0:10:47.37,0:10:50.19,Default,,0,0,0,,把A赋值为--
Dialogue: 0,0:10:50.19,0:10:51.92,Default,,0,0,0,,引用向量的一个分量--
Dialogue: 0,0:10:52.80,0:10:55.24,Default,,0,0,0,,或者你可以把它叫做索引一个数组
Dialogue: 0,0:10:55.42,0:10:57.63,Default,,0,0,0,,目标向量为THE-CARS
Dialogue: 0,0:10:58.40,0:11:00.92,Default,,0,0,0,,而目标分量是B
Dialogue: 0,0:11:02.65,0:11:03.63,Default,,0,0,0,,CDR的操作也类似
Dialogue: 0,0:11:04.10,0:11:05.72,Default,,0,0,0,,我们可以用同样的方式
Dialogue: 0,0:11:05.90,0:11:08.32,Default,,0,0,0,,来对数据结构赋值
Dialogue: 0,0:11:08.92,0:11:10.92,Default,,0,0,0,,如果我们需要这么做的话
Dialogue: 0,0:11:11.84,0:11:13.80,Default,,0,0,0,,构建这个并不太难
Dialogue: 0,0:11:14.58,0:11:15.72,Default,,0,0,0,,下一个问题是
Dialogue: 0,0:11:15.72,0:11:17.00,Default,,0,0,0,,我们如何分配它们
Dialogue: 0,0:11:18.01,0:11:20.13,Default,,0,0,0,,我们经常需要一个新的序对
Dialogue: 0,0:11:21.40,0:11:23.42,Default,,0,0,0,,当然 CONS并没有长在树上
Dialogue: 0,0:11:23.79,0:11:24.81,Default,,0,0,0,,或许它们应该那样
Dialogue: 0,0:11:25.34,0:11:26.56,Default,,0,0,0,,我必须得有某种方法
Dialogue: 0,0:11:26.70,0:11:28.97,Default,,0,0,0,,来获得一个可用的序对
Dialogue: 0,0:11:29.98,0:11:31.47,Default,,0,0,0,,我需要某种方案
Dialogue: 0,0:11:31.47,0:11:33.04,Default,,0,0,0,,当内存不再使用的时候
Dialogue: 0,0:11:33.69,0:11:35.05,Default,,0,0,0,,我可以重新分配它们
Dialogue: 0,0:11:35.63,0:11:37.38,Default,,0,0,0,,有很多方案可以实现这一点
Dialogue: 0,0:11:37.38,0:11:39.07,Default,,0,0,0,,现在我给你们展示的这个东西
Dialogue: 0,0:11:39.23,0:11:40.45,Default,,0,0,0,,并是不必要的
Dialogue: 0,0:11:42.10,0:11:43.18,Default,,0,0,0,,然而它很方便
Dialogue: 0,0:11:43.20,0:11:44.44,Default,,0,0,0,,并且被实现很多次了
Dialogue: 0,0:11:44.60,0:11:47.20,Default,,0,0,0,,其中一种基于“空闲表”的分配方案
Dialogue: 0,0:11:47.66,0:11:48.68,Default,,0,0,0,,它的意思就是
Dialogue: 0,0:11:48.68,0:11:51.12,Default,,0,0,0,,世界上所有的空闲内存
Dialogue: 0,0:11:51.55,0:11:53.08,Default,,0,0,0,,都连在一个链表中
Dialogue: 0,0:11:54.55,0:11:56.22,Default,,0,0,0,,就像其它东西一样
Dialogue: 0,0:11:56.96,0:11:59.07,Default,,0,0,0,,每当你需要一个新的格子
Dialogue: 0,0:11:59.07,0:12:00.12,Default,,0,0,0,,来进行CONS的时候
Dialogue: 0,0:12:00.95,0:12:02.26,Default,,0,0,0,,你选择第一个格子
Dialogue: 0,0:12:02.26,0:12:03.82,Default,,0,0,0,,将它的CDR指向空闲表
Dialogue: 0,0:12:04.32,0:12:05.55,Default,,0,0,0,,然后分配它
Dialogue: 0,0:12:06.03,0:12:08.32,Default,,0,0,0,,就像这样
Dialogue: 0,0:12:09.53,0:12:13.32,Default,,0,0,0,,这里 我们的空闲表
Dialogue: 0,0:12:13.95,0:12:16.81,Default,,0,0,0,,就是从6开始
Dialogue: 0,0:12:18.51,0:12:23.47,Default,,0,0,0,,它是一个指向8的指针
Dialogue: 0,0:12:24.86,0:12:25.62,Default,,0,0,0,,它表示
Dialogue: 0,0:12:25.62,0:12:26.55,Default,,0,0,0,,当前这个是空闲的
Dialogue: 0,0:12:26.55,0:12:27.95,Default,,0,0,0,,下一个在位置8
Dialogue: 0,0:12:28.87,0:12:29.88,Default,,0,0,0,,这个是空闲的
Dialogue: 0,0:12:30.04,0:12:32.08,Default,,0,0,0,,下一个在位置3
Dialogue: 0,0:12:32.32,0:12:33.45,Default,,0,0,0,,下一个是空闲的
Dialogue: 0,0:12:33.93,0:12:34.95,Default,,0,0,0,,这个是空闲的
Dialogue: 0,0:12:35.04,0:12:37.68,Default,,0,0,0,,下一个在位置0
Dialogue: 0,0:12:37.87,0:12:38.49,Default,,0,0,0,,这个是空闲的
Dialogue: 0,0:12:38.52,0:12:39.82,Default,,0,0,0,,下一个在位置15
Dialogue: 0,0:12:40.94,0:12:41.84,Default,,0,0,0,,以此类推
Dialogue: 0,0:12:42.78,0:12:44.64,Default,,0,0,0,,我们可以想象有这样的结构
Dialogue: 0,0:12:46.40,0:12:48.03,Default,,0,0,0,,一旦我们有了这样的机制
Dialogue: 0,0:12:49.45,0:12:50.92,Default,,0,0,0,,那么当你需要空间的时候
Dialogue: 0,0:12:50.92,0:12:52.22,Default,,0,0,0,,就能获取一个
Dialogue: 0,0:12:53.82,0:12:56.46,Default,,0,0,0,,那些使用了CONS的程序
Dialogue: 0,0:12:57.45,0:12:59.13,Default,,0,0,0,,内存可能就是像这样的
Dialogue: 0,0:12:59.32,0:13:02.57,Default,,0,0,0,,把B和C进行CONS之后的值
Dialogue: 0,0:13:02.95,0:13:05.82,Default,,0,0,0,,赋值给A寄存器
Dialogue: 0,0:13:06.20,0:13:09.04,Default,,0,0,0,,结果包括B和C
Dialogue: 0,0:13:09.27,0:13:10.52,Default,,0,0,0,,我们要做的是
Dialogue: 0,0:13:10.56,0:13:12.24,Default,,0,0,0,,把当前的尾部格子 即空闲表的前个格子
Dialogue: 0,0:13:12.47,0:13:14.30,Default,,0,0,0,,让它的CDR指向空闲表
Dialogue: 0,0:13:15.64,0:13:18.33,Default,,0,0,0,,我们要把THE-CARS中
Dialogue: 0,0:13:18.41,0:13:22.49,Default,,0,0,0,,由A索引的格子
Dialogue: 0,0:13:23.13,0:13:25.45,Default,,0,0,0,,修改为B中的内容
Dialogue: 0,0:13:25.90,0:13:28.65,Default,,0,0,0,,THE-CDRS中由A索引的格子
Dialogue: 0,0:13:29.20,0:13:31.72,Default,,0,0,0,,修改为C的值
Dialogue: 0,0:13:33.20,0:13:34.76,Default,,0,0,0,,现在A所指的格子里面
Dialogue: 0,0:13:34.78,0:13:36.65,Default,,0,0,0,,就是新构建好的对象了
Dialogue: 0,0:13:36.81,0:13:37.92,Default,,0,0,0,,这就是我们要的对象
Dialogue: 0,0:13:40.47,0:13:42.50,Default,,0,0,0,,我之前告诉过你们
Dialogue: 0,0:13:42.50,0:13:43.97,Default,,0,0,0,,这里撒了个谎
Dialogue: 0,0:13:43.97,0:13:45.32,Default,,0,0,0,,也就是在这里的某处
Dialogue: 0,0:13:45.53,0:13:47.32,Default,,0,0,0,,我本来应该
Dialogue: 0,0:13:48.45,0:13:50.48,Default,,0,0,0,,把我CONS起来的对象
Dialogue: 0,0:13:50.51,0:13:51.87,Default,,0,0,0,,设置为序对类型
Dialogue: 0,0:13:52.30,0:13:53.05,Default,,0,0,0,,但我没有
Dialogue: 0,0:13:53.51,0:13:56.57,Default,,0,0,0,,因此这里应该需要设置一些比特位
Dialogue: 0,0:13:56.60,0:13:57.76,Default,,0,0,0,,我只是还没把它写下来
Dialogue: 0,0:13:59.81,0:14:00.86,Default,,0,0,0,,当然 这个很好实现
Dialogue: 0,0:14:00.89,0:14:02.45,Default,,0,0,0,,因为空闲表本来就是用序对实现的
Dialogue: 0,0:14:03.10,0:14:04.88,Default,,0,0,0,,因此这是没问题的
Dialogue: 0,0:14:06.43,0:14:07.74,Default,,0,0,0,,但这也就是--
Dialogue: 0,0:14:07.82,0:14:09.92,Default,,0,0,0,,这些都是无关紧要的细节
Dialogue: 0,0:14:10.22,0:14:12.88,Default,,0,0,0,,取决于那些想要自制
Dialogue: 0,0:14:12.92,0:14:14.27,Default,,0,0,0,,计算机或Lisp系统的
Dialogue: 0,0:14:14.33,0:14:16.68,Default,,0,0,0,,程序员或架构师
Dialogue: 0,0:14:17.54,0:14:18.71,Default,,0,0,0,,例如
Dialogue: 0,0:14:19.07,0:14:20.24,Default,,0,0,0,,看这个
Dialogue: 0,0:14:20.65,0:14:23.45,Default,,0,0,0,,假设我们要为
Dialogue: 0,0:14:23.55,0:14:26.83,Default,,0,0,0,,这个之前见过的数据结构分配空间
Dialogue: 0,0:14:27.21,0:14:30.26,Default,,0,0,0,,假设我要分配一个新格子
Dialogue: 0,0:14:30.55,0:14:36.61,Default,,0,0,0,,来表示表(1 1 2)
Dialogue: 0,0:14:37.24,0:14:39.87,Default,,0,0,0,,其中(1 2)又是
Dialogue: 0,0:14:40.28,0:14:42.16,Default,,0,0,0,,之前一个表的CAR元素
Dialogue: 0,0:14:43.43,0:14:44.45,Default,,0,0,0,,这不怎么难
Dialogue: 0,0:14:44.78,0:14:46.20,Default,,0,0,0,,我用1号单元来存放数字“1”
Dialogue: 0,0:14:46.20,0:14:49.17,Default,,0,0,0,,那么P1表示的就是这个单元
Dialogue: 0,0:14:49.53,0:14:50.83,Default,,0,0,0,,这个是P5
Dialogue: 0,0:14:51.67,0:14:53.51,Default,,0,0,0,,它是应该是这个的CDR
Dialogue: 0,0:14:54.07,0:14:55.52,Default,,0,0,0,,现在我们要从空闲表中取出一些东西
Dialogue: 0,0:14:55.52,0:14:57.30,Default,,0,0,0,,空闲表现在是从6开始的
Dialogue: 0,0:14:57.78,0:15:00.18,Default,,0,0,0,,而在分配之后 空闲表将从8开始
Dialogue: 0,0:15:00.60,0:15:02.55,Default,,0,0,0,,一个从8开始的空闲表
Dialogue: 0,0:15:02.89,0:15:03.52,Default,,0,0,0,,当然
Dialogue: 0,0:15:03.72,0:15:06.04,Default,,0,0,0,,现在6里面是数字1
Dialogue: 0,0:15:06.15,0:15:07.10,Default,,0,0,0,,就是我们想要的
Dialogue: 0,0:15:07.39,0:15:11.56,Default,,0,0,0,,它的CDR是在位置5的序对
Dialogue: 0,0:15:13.33,0:15:14.50,Default,,0,0,0,,没费多少力气
Dialogue: 0,0:15:16.81,0:15:20.45,Default,,0,0,0,,这里依然存在的一个问题是
Dialogue: 0,0:15:21.00,0:15:23.40,Default,,0,0,0,,我们没有无限大的内存
Dialogue: 0,0:15:25.08,0:15:26.66,Default,,0,0,0,,如果我像这么操作了一会儿
Dialogue: 0,0:15:27.25,0:15:28.00,Default,,0,0,0,,比如说
Dialogue: 0,0:15:28.01,0:15:30.14,Default,,0,0,0,,假设进行一次CONS花费1微秒
Dialogue: 0,0:15:30.60,0:15:32.97,Default,,0,0,0,,如果要进行一百万次CONS
Dialogue: 0,0:15:33.60,0:15:35.27,Default,,0,0,0,,那么我就要消耗1秒钟的时间
Dialogue: 0,0:15:35.95,0:15:37.00,Default,,0,0,0,,这就很糟糕了
Dialogue: 0,0:15:38.00,0:15:40.62,Default,,0,0,0,,如何预防这样的灾难
Dialogue: 0,0:15:40.62,0:15:42.19,Default,,0,0,0,,这种生态灾难
Dialogue: 0,0:15:42.60,0:15:44.30,Default,,0,0,0,,在提问环节之后我们再继续讨论
Dialogue: 0,0:15:44.30,0:15:45.26,Default,,0,0,0,,有人要提问吗?
Dialogue: 0,0:15:51.50,0:15:51.69,Default,,0,0,0,,请讲
Dialogue: 0,0:15:52.03,0:15:54.67,Default,,0,0,0,,学生：在环境图表中
Dialogue: 0,0:15:54.67,0:15:58.25,Default,,0,0,0,,我们画了过程体
Dialogue: 0,0:15:58.25,0:16:00.67,Default,,0,0,0,,但是在过程应用结束后
Dialogue: 0,0:16:00.80,0:16:03.60,Default,,0,0,0,,这些环境中的东西就不再有用了
Dialogue: 0,0:16:03.60,0:16:04.16,Default,,0,0,0,,教授：说得很对
Dialogue: 0,0:16:04.93,0:16:06.67,Default,,0,0,0,,学生：它是如何表示的？
Dialogue: 0,0:16:06.76,0:16:08.75,Default,,0,0,0,,教授：这其实是两个问题
Dialogue: 0,0:16:09.18,0:16:10.25,Default,,0,0,0,,第一个问题是
Dialogue: 0,0:16:10.25,0:16:13.43,Default,,0,0,0,,材料没用了
Dialogue: 0,0:16:13.87,0:16:14.92,Default,,0,0,0,,我们稍后就会讲
Dialogue: 0,0:16:14.92,0:16:17.00,Default,,0,0,0,,如何预防生态灾难
Dialogue: 0,0:16:17.63,0:16:19.20,Default,,0,0,0,,如果我制造了一堆垃圾
Dialogue: 0,0:16:19.20,0:16:21.39,Default,,0,0,0,,我需要自己清理掉
Dialogue: 0,0:16:21.82,0:16:22.97,Default,,0,0,0,,我们一会儿就要讲
Dialogue: 0,0:16:23.43,0:16:24.57,Default,,0,0,0,,第二个问题
Dialogue: 0,0:16:24.57,0:16:27.21,Default,,0,0,0,,你问的是如何表示环境
Dialogue: 0,0:16:27.28,0:16:27.60,Default,,0,0,0,,学生：对
Dialogue: 0,0:16:27.60,0:16:28.19,Default,,0,0,0,,教授：好
Dialogue: 0,0:16:28.19,0:16:30.62,Default,,0,0,0,,环境结构能够以任意的方式表示
Dialogue: 0,0:16:30.92,0:16:31.78,Default,,0,0,0,,有很多种表示方式
Dialogue: 0,0:16:31.78,0:16:33.34,Default,,0,0,0,,这里 我只讲了基于表结构的内存
Dialogue: 0,0:16:33.63,0:16:34.92,Default,,0,0,0,,当然 每个真实的系统
Dialogue: 0,0:16:34.92,0:16:36.72,Default,,0,0,0,,都有任意长度的向量
Dialogue: 0,0:16:36.72,0:16:39.15,Default,,0,0,0,,也有固定长度的向量
Dialogue: 0,0:16:39.31,0:16:40.51,Default,,0,0,0,,它们都可以作为内存的表示方法
Dialogue: 0,0:16:41.08,0:16:44.90,Default,,0,0,0,,在一个专业的Lisp系统中
Dialogue: 0,0:16:44.90,0:16:46.99,Default,,0,0,0,,环境结构是用
Dialogue: 0,0:16:47.30,0:16:49.69,Default,,0,0,0,,向量表示的
Dialogue: 0,0:16:49.69,0:16:51.92,Default,,0,0,0,,它所包含的元素的数量
Dialogue: 0,0:16:51.92,0:16:54.60,Default,,0,0,0,,比参数的个数稍微多一点
Dialogue: 0,0:16:55.35,0:16:56.86,Default,,0,0,0,,因为你需要某种“粘合剂”
Dialogue: 0,0:16:57.40,0:17:00.74,Default,,0,0,0,,记住环境是在框架里的
Dialogue: 0,0:17:00.74,0:17:03.98,Default,,0,0,0,,框架是应用过程时被构建出来的
Dialogue: 0,0:17:03.98,0:17:04.78,Default,,0,0,0,,这种情况下
Dialogue: 0,0:17:04.80,0:17:07.60,Default,,0,0,0,,所分配的空间大小为
Dialogue: 0,0:17:07.64,0:17:11.27,Default,,0,0,0,,实际参数加上“粘合剂”占用的空间
Dialogue: 0,0:17:11.27,0:17:12.71,Default,,0,0,0,,然后将它连接到某条链上
Dialogue: 0,0:17:13.32,0:17:15.66,Default,,0,0,0,,在这个层次上 和ALGOL差不多
Dialogue: 0,0:17:19.81,0:17:20.72,Default,,0,0,0,,还有其它问题吗?
Dialogue: 0,0:17:23.70,0:17:23.92,Default,,0,0,0,,好
Dialogue: 0,0:17:23.92,0:17:25.55,Default,,0,0,0,,谢谢 我们休息一下
Dialogue: 0,0:17:26.35,0:17:45.48,Default,,0,0,0,,[音乐]
Dialogue: 0,0:17:45.53,0:17:50.01,Declare,,0,0,0,,{\an2\fad(500,500)}《计算机程序的构造和解释》
Dialogue: 0,0:17:55.74,0:17:59.04,Declare,,0,0,0,,{\an2\fad(500,500)}讲师： 哈罗德·艾伯森教授 及 格兰德·杰·萨斯曼教授
Dialogue: 0,0:17:59.13,0:18:04.22,Declare,,0,0,0,,{\an2\fad(500,500)}《计算机程序的构造和解释》
Dialogue: 0,0:18:04.32,0:18:09.87,Declare,,0,0,0,,{\an2\fad(500,500)}存储分配与垃圾收集
Dialogue: 0,0:18:12.27,0:18:14.24,Default,,0,0,0,,教授：如同我刚才说过的那样
Dialogue: 0,0:18:14.55,0:18:15.50,Default,,0,0,0,,半导体厂商
Dialogue: 0,0:18:15.82,0:18:17.96,Default,,0,0,0,,所生产的计算机内存
Dialogue: 0,0:18:18.16,0:18:19.00,Default,,0,0,0,,容量是有限的
Dialogue: 0,0:18:19.42,0:18:20.40,Default,,0,0,0,,这的确很可惜
Dialogue: 0,0:18:21.62,0:18:23.35,Default,,0,0,0,,但它也可能不总是这样
Dialogue: 0,0:18:24.03,0:18:25.40,Default,,0,0,0,,简单算一下
Dialogue: 0,0:18:25.44,0:18:28.86,Default,,0,0,0,,你可以看到 如果内存的价格
Dialogue: 0,0:18:28.86,0:18:30.80,Default,,0,0,0,,继续保持当前的趋势的话
Dialogue: 0,0:18:31.22,0:18:33.68,Default,,0,0,0,,如果你执行CONS的时候也只需要1微秒
Dialogue: 0,0:18:34.42,0:18:35.90,Default,,0,0,0,,那么 首先大家知道
Dialogue: 0,0:18:35.90,0:18:37.07,Default,,0,0,0,,一年大约有
Dialogue: 0,0:18:37.10,0:18:38.86,Default,,0,0,0,,PI*10^7秒
Dialogue: 0,0:18:39.45,0:18:41.12,Default,,0,0,0,,那么就有
Dialogue: 0,0:18:41.50,0:18:42.73,Default,,0,0,0,,10^6乘以10^7
Dialogue: 0,0:18:42.73,0:18:43.94,Default,,0,0,0,,也就是10^13
Dialogue: 0,0:18:43.94,0:18:45.50,Default,,0,0,0,,那么在机器的一生中
Dialogue: 0,0:18:45.50,0:18:46.80,Default,,0,0,0,,就能有10^14个CONS
Dialogue: 0,0:18:47.52,0:18:49.40,Default,,0,0,0,,如果你的机器上
Dialogue: 0,0:18:49.68,0:18:50.57,Default,,0,0,0,,有10^14个字的内存
Dialogue: 0,0:18:51.20,0:18:52.16,Default,,0,0,0,,你就永远不会用完
Dialogue: 0,0:18:53.04,0:18:53.85,Default,,0,0,0,,这样就会……
Dialogue: 0,0:18:53.95,0:18:55.76,Default,,0,0,0,,这并不是完全没有道理
Dialogue: 0,0:18:56.31,0:18:58.46,Default,,0,0,0,,10^14次方不是个非常大的数字
Dialogue: 0,0:19:01.45,0:19:04.70,Default,,0,0,0,,我不觉得它是个很大的数字
Dialogue: 0,0:19:05.18,0:19:07.39,Default,,0,0,0,,但我喜欢在天文学领域进行比较
Dialogue: 0,0:19:07.93,0:19:11.04,Default,,0,0,0,,距离我们最近的星星
Dialogue: 0,0:19:11.10,0:19:12.45,Default,,0,0,0,,至少有10^18次方厘米远
Dialogue: 0,0:19:12.93,0:19:18.85,Default,,0,0,0,,我担心的是
Dialogue: 0,0:19:19.15,0:19:21.27,Default,,0,0,0,,至少以现在的经济状况
Dialogue: 0,0:19:21.27,0:19:23.57,Default,,0,0,0,,10^14大小的内存很贵
Dialogue: 0,0:19:24.20,0:19:26.62,Default,,0,0,0,,因此我认为我们需要
Dialogue: 0,0:19:26.81,0:19:28.51,Default,,0,0,0,,适应更小的内存
Dialogue: 0,0:19:30.02,0:19:30.59,Default,,0,0,0,,现在
Dialogue: 0,0:19:32.84,0:19:35.07,Default,,0,0,0,,广义地说 我们营造一种无限内存的假象
Dialogue: 0,0:19:35.80,0:19:37.22,Default,,0,0,0,,我们需要整理它
Dialogue: 0,0:19:37.82,0:19:39.68,Default,,0,0,0,,以便在我们需要内存的时候就能获得它
Dialogue: 0,0:19:41.92,0:19:45.55,Default,,0,0,0,,这个想法非常重要
Dialogue: 0,0:19:49.54,0:19:51.97,Default,,0,0,0,,人或者计算机只能存在有限的时间
Dialogue: 0,0:19:52.32,0:19:54.59,Default,,0,0,0,,只能看有限的东西
Dialogue: 0,0:19:55.28,0:19:57.37,Default,,0,0,0,,因此你只需要有限的东西
Dialogue: 0,0:19:58.19,0:19:59.00,Default,,0,0,0,,只要你合理地安排它们
Dialogue: 0,0:19:59.00,0:20:00.38,Default,,0,0,0,,使得不管实际有多少内存
Dialogue: 0,0:20:00.77,0:20:03.46,Default,,0,0,0,,你要求这里有多少
Dialogue: 0,0:20:03.46,0:20:04.74,Default,,0,0,0,,当你去看的时候
Dialogue: 0,0:20:04.74,0:20:06.90,Default,,0,0,0,,总有足够的东西
Dialogue: 0,0:20:06.90,0:20:08.15,Default,,0,0,0,,因此你只需要有限的数量
Dialogue: 0,0:20:08.75,0:20:09.94,Default,,0,0,0,,我们来看看
Dialogue: 0,0:20:11.63,0:20:13.32,Default,,0,0,0,,我们之前提过一个问题
Dialogue: 0,0:20:13.92,0:20:15.45,Default,,0,0,0,,在很多情况下
Dialogue: 0,0:20:15.72,0:20:17.84,Default,,0,0,0,,我们制造了大量
Dialogue: 0,0:20:17.88,0:20:19.16,Default,,0,0,0,,不需要的东西
Dialogue: 0,0:20:19.41,0:20:21.81,Default,,0,0,0,,我们可以进行回收再利用
Dialogue: 0,0:20:22.62,0:20:23.53,Default,,0,0,0,,举个例子
Dialogue: 0,0:20:24.15,0:20:25.79,Default,,0,0,0,,事实上
Dialogue: 0,0:20:25.79,0:20:28.40,Default,,0,0,0,,当我们调用一个过程的时候
Dialogue: 0,0:20:28.40,0:20:30.47,Default,,0,0,0,,都会构建环境结构
Dialogue: 0,0:20:30.47,0:20:32.56,Default,,0,0,0,,我们把它构建在一个环境框架中
Dialogue: 0,0:20:33.14,0:20:34.03,Default,,0,0,0,,这个环境框架
Dialogue: 0,0:20:34.22,0:20:36.07,Default,,0,0,0,,不用存在很长时间
Dialogue: 0,0:20:36.73,0:20:38.69,Default,,0,0,0,,只有在进行过程调用的时候
Dialogue: 0,0:20:39.42,0:20:42.60,Default,,0,0,0,,它的存在才是有用的
Dialogue: 0,0:20:42.85,0:20:45.27,Default,,0,0,0,,如果过程把另一个过程
Dialogue: 0,0:20:45.27,0:20:46.67,Default,,0,0,0,,作为返回值返回
Dialogue: 0,0:20:46.87,0:20:48.52,Default,,0,0,0,,并且这个过程是在它的内部定义的
Dialogue: 0,0:20:48.52,0:20:50.80,Default,,0,0,0,,那么外层过程的
Dialogue: 0,0:20:51.07,0:20:53.39,Default,,0,0,0,,存活时间仍然是
Dialogue: 0,0:20:53.50,0:20:56.12,Default,,0,0,0,,被返回的过程的
Dialogue: 0,0:20:57.02,0:20:57.90,Default,,0,0,0,,存活时间
Dialogue: 0,0:20:58.53,0:20:59.57,Default,,0,0,0,,最终
Dialogue: 0,0:20:59.57,0:21:00.97,Default,,0,0,0,,就会制造很多垃圾
Dialogue: 0,0:21:01.96,0:21:04.10,Default,,0,0,0,,还有其它的途径可以制造垃圾
Dialogue: 0,0:21:05.37,0:21:06.67,Default,,0,0,0,,用户也会制造垃圾
Dialogue: 0,0:21:07.24,0:21:08.07,Default,,0,0,0,,举例来说
Dialogue: 0,0:21:08.07,0:21:10.22,Default,,0,0,0,,用户制造的垃圾像是这样
Dialogue: 0,0:21:10.93,0:21:14.00,Default,,0,0,0,,如果我们写个程序
Dialogue: 0,0:21:14.00,0:21:15.80,Default,,0,0,0,,把两个表连接到一起
Dialogue: 0,0:21:16.05,0:21:18.14,Default,,0,0,0,,唯一的办法是
Dialogue: 0,0:21:18.32,0:21:21.37,Default,,0,0,0,,把第一个表逆序塞到空表中
Dialogue: 0,0:21:21.37,0:21:23.72,Default,,0,0,0,,再把新表逆序塞到第二个表中
Dialogue: 0,0:21:24.70,0:21:26.92,Default,,0,0,0,,这种解法并不是很糟糕
Dialogue: 0,0:21:28.16,0:21:28.85,Default,,0,0,0,,然而
Dialogue: 0,0:21:28.85,0:21:30.09,Default,,0,0,0,,程序所生成的
Dialogue: 0,0:21:30.11,0:21:32.02,Default,,0,0,0,,中间结果
Dialogue: 0,0:21:33.87,0:21:35.57,Default,,0,0,0,,即第一个表的逆序表
Dialogue: 0,0:21:36.70,0:21:38.52,Default,,0,0,0,,在它被复制到第二个表之后
Dialogue: 0,0:21:38.52,0:21:40.56,Default,,0,0,0,,就再也不会被用到了
Dialogue: 0,0:21:41.01,0:21:42.23,Default,,0,0,0,,它是个中间结果
Dialogue: 0,0:21:43.58,0:21:45.43,Default,,0,0,0,,它很难被找到
Dialogue: 0,0:21:46.07,0:21:48.05,Default,,0,0,0,,没有人能访问到它
Dialogue: 0,0:21:48.60,0:21:49.84,Default,,0,0,0,,事实上 它会消失掉
Dialogue: 0,0:21:51.05,0:21:52.90,Default,,0,0,0,,如果我们像这样制造了大量的垃圾
Dialogue: 0,0:21:52.90,0:21:54.20,Default,,0,0,0,,系统也应该允许我们这么干
Dialogue: 0,0:21:54.80,0:21:57.29,Default,,0,0,0,,但应该有某些方法去回收这些垃圾
Dialogue: 0,0:21:58.80,0:22:00.90,Default,,0,0,0,,现在 我要告诉你
Dialogue: 0,0:22:01.70,0:22:03.77,Default,,0,0,0,,一个非常聪明的技巧
Dialogue: 0,0:22:04.32,0:22:07.58,Default,,0,0,0,,一个Lisp系统
Dialogue: 0,0:22:07.95,0:22:11.21,Default,,0,0,0,,通常可以证明一条小定理
Dialogue: 0,0:22:11.29,0:22:13.50,Default,,0,0,0,,也就是 某段内存中的值
Dialogue: 0,0:22:14.72,0:22:16.09,Default,,0,0,0,,之后不再会被用到
Dialogue: 0,0:22:17.41,0:22:19.80,Default,,0,0,0,,它对以后的计算没有任何影响
Dialogue: 0,0:22:21.40,0:22:23.61,Default,,0,0,0,,事实上 这基于一个很简单的想法
Dialogue: 0,0:22:24.72,0:22:28.06,Default,,0,0,0,,我们已经把计算机设计成这个样子
Dialogue: 0,0:22:28.95,0:22:30.67,Default,,0,0,0,,有一些数据通路
Dialogue: 0,0:22:31.87,0:22:33.40,Default,,0,0,0,,其中有寄存器
Dialogue: 0,0:22:34.92,0:22:38.04,Default,,0,0,0,,有EXP、ENV
Dialogue: 0,0:22:39.04,0:22:42.19,Default,,0,0,0,,和VAL之类的寄存器
Dialogue: 0,0:22:42.61,0:22:44.02,Default,,0,0,0,,这里有个叫STACK的东西
Dialogue: 0,0:22:46.02,0:22:49.45,Default,,0,0,0,,某种指向一个结构的东西
Dialogue: 0,0:22:49.50,0:22:50.22,Default,,0,0,0,,它是个栈
Dialogue: 0,0:22:50.24,0:22:51.48,Default,,0,0,0,,我们过一会再研究它
Dialogue: 0,0:22:51.64,0:22:53.62,Default,,0,0,0,,这里有一些
Dialogue: 0,0:22:54.38,0:22:56.57,Default,,0,0,0,,有穷状态控制器
Dialogue: 0,0:22:56.73,0:22:59.51,Default,,0,0,0,,控制信号在这之间流通
Dialogue: 0,0:22:59.80,0:23:01.44,Default,,0,0,0,,比如谓词的返回结果
Dialogue: 0,0:23:01.87,0:23:03.13,Default,,0,0,0,,这部分并不太有趣
Dialogue: 0,0:23:03.35,0:23:06.51,Default,,0,0,0,,这里有某种结构化的内存
Dialogue: 0,0:23:06.80,0:23:08.27,Default,,0,0,0,,我刚才给你讲过如何构建它
Dialogue: 0,0:23:08.27,0:23:10.17,Default,,0,0,0,,它可能包括一个栈
Dialogue: 0,0:23:10.46,0:23:11.48,Default,,0,0,0,,我没有告诉你如何把东西
Dialogue: 0,0:23:11.48,0:23:12.43,Default,,0,0,0,,构建成任意形状
Dialogue: 0,0:23:12.56,0:23:13.39,Default,,0,0,0,,只有序对
Dialogue: 0,0:23:13.60,0:23:14.20,Default,,0,0,0,,但事实上
Dialogue: 0,0:23:14.35,0:23:15.44,Default,,0,0,0,,我告诉过你
Dialogue: 0,0:23:15.47,0:23:16.96,Default,,0,0,0,,可以用一张大表来模拟栈
Dialogue: 0,0:23:17.77,0:23:18.85,Default,,0,0,0,,我没准备干这个
Dialogue: 0,0:23:18.85,0:23:20.01,Default,,0,0,0,,这不是个好办法
Dialogue: 0,0:23:20.36,0:23:22.60,Default,,0,0,0,,但是我们可以有这样一个东西
Dialogue: 0,0:23:22.99,0:23:25.28,Default,,0,0,0,,这里有各种数据结构
Dialogue: 0,0:23:25.64,0:23:27.75,Default,,0,0,0,,它们通过有趣的方式互相连接
Dialogue: 0,0:23:30.11,0:23:32.02,Default,,0,0,0,,它们和其它东西连接到一起
Dialogue: 0,0:23:32.56,0:23:33.25,Default,,0,0,0,,以此类推
Dialogue: 0,0:23:33.25,0:23:34.22,Default,,0,0,0,,归根结底
Dialogue: 0,0:23:34.45,0:23:37.19,Default,,0,0,0,,这里的东西是指向这里的指针
Dialogue: 0,0:23:37.19,0:23:38.87,Default,,0,0,0,,寄存器里的指针
Dialogue: 0,0:23:39.40,0:23:41.40,Default,,0,0,0,,指向的是表结构内存中
Dialogue: 0,0:23:41.44,0:23:43.08,Default,,0,0,0,,数据结构
Dialogue: 0,0:23:44.91,0:23:49.80,Default,,0,0,0,,现在 我们的问题是
Dialogue: 0,0:23:51.05,0:23:52.56,Default,,0,0,0,,机器的整个意识
Dialogue: 0,0:23:52.57,0:23:53.92,Default,,0,0,0,,是在寄存器里的
Dialogue: 0,0:23:55.76,0:23:58.51,Default,,0,0,0,,如果这个机器
Dialogue: 0,0:23:58.75,0:24:01.07,Default,,0,0,0,,构建得正确的话
Dialogue: 0,0:24:01.37,0:24:03.41,Default,,0,0,0,,它无法访问表结构内存中任何的东西
Dialogue: 0,0:24:04.57,0:24:07.05,Default,,0,0,0,,除非这个表结构内存中的数据
Dialogue: 0,0:24:08.09,0:24:10.88,Default,,0,0,0,,通过一系列的数据结构
Dialogue: 0,0:24:11.64,0:24:13.06,Default,,0,0,0,,与寄存器相连接
Dialogue: 0,0:24:15.07,0:24:15.98,Default,,0,0,0,,如果它能够
Dialogue: 0,0:24:16.22,0:24:18.31,Default,,0,0,0,,被合法的数据结构选择函数访问到
Dialogue: 0,0:24:19.08,0:24:21.12,Default,,0,0,0,,通过寄存器里保存的指针能够访问它
Dialogue: 0,0:24:22.28,0:24:24.46,Default,,0,0,0,,比如说 数组引用
Dialogue: 0,0:24:24.94,0:24:27.92,Default,,0,0,0,,或者针对序对的引用--CAR或者CDR
Dialogue: 0,0:24:29.08,0:24:30.95,Default,,0,0,0,,但我不能随意访问内存中的位置
Dialogue: 0,0:24:30.95,0:24:31.95,Default,,0,0,0,,因为我找不到它
Dialogue: 0,0:24:32.74,0:24:34.90,Default,,0,0,0,,至少在我求值某条表达式的时候
Dialogue: 0,0:24:37.00,0:24:39.16,Default,,0,0,0,,我是不允许去访问那个任意名字的
Dialogue: 0,0:24:41.62,0:24:42.57,Default,,0,0,0,,如果是这样的话
Dialogue: 0,0:24:43.27,0:24:45.07,Default,,0,0,0,,就可以证明一个简单的理论
Dialogue: 0,0:24:47.16,0:24:47.69,Default,,0,0,0,,就是说
Dialogue: 0,0:24:47.90,0:24:50.52,Default,,0,0,0,,如果我从这些寄存器指向的地方开始
Dialogue: 0,0:24:51.16,0:24:52.55,Default,,0,0,0,,递归地遍历
Dialogue: 0,0:24:52.82,0:24:56.15,Default,,0,0,0,,标记选择函数所有能访问到内存
Dialogue: 0,0:24:56.90,0:24:59.40,Default,,0,0,0,,最终就能标记所有能访问的东西
Dialogue: 0,0:25:00.65,0:25:02.69,Default,,0,0,0,,任何未标记的都是垃圾
Dialogue: 0,0:25:02.69,0:25:03.75,Default,,0,0,0,,它们可以被回收
Dialogue: 0,0:25:05.56,0:25:06.20,Default,,0,0,0,,非常简单
Dialogue: 0,0:25:07.20,0:25:09.10,Default,,0,0,0,,不会影响之后的计算
Dialogue: 0,0:25:11.18,0:25:12.84,Default,,0,0,0,,我来举一个
Dialogue: 0,0:25:13.93,0:25:15.75,Default,,0,0,0,,具体的例子
Dialogue: 0,0:25:17.12,0:25:19.37,Default,,0,0,0,,在此之前 需要给我的表结构内存
Dialogue: 0,0:25:19.69,0:25:22.08,Default,,0,0,0,,添加一个叫MARK的标志位
Dialogue: 0,0:25:23.64,0:25:24.89,Default,,0,0,0,,因此 在这里
Dialogue: 0,0:25:25.37,0:25:27.28,Default,,0,0,0,,就有一个表结构内存
Dialogue: 0,0:25:29.08,0:25:30.32,Default,,0,0,0,,这块表内存中
Dialogue: 0,0:25:30.33,0:25:31.33,Default,,0,0,0,,存放了一个表数据结构
Dialogue: 0,0:25:31.33,0:25:33.95,Default,,0,0,0,,我们把这个起始位置
Dialogue: 0,0:25:35.87,0:25:36.62,Default,,0,0,0,,称为“根”
Dialogue: 0,0:25:38.59,0:25:40.12,Default,,0,0,0,,不一定只有一个根
Dialogue: 0,0:25:40.12,0:25:41.95,Default,,0,0,0,,与寄存器类似 可以有很多这种东西
Dialogue: 0,0:25:42.67,0:25:43.98,Default,,0,0,0,,但我可以巧妙地安排它们
Dialogue: 0,0:25:44.13,0:25:46.30,Default,,0,0,0,,把所有在旧寄存器里的东西
Dialogue: 0,0:25:46.30,0:25:47.77,Default,,0,0,0,,在何时的时间点
Dialogue: 0,0:25:48.28,0:25:50.46,Default,,0,0,0,,放入到这个根结构中
Dialogue: 0,0:25:50.46,0:25:51.85,Default,,0,0,0,,然后用一个指针指向它
Dialogue: 0,0:25:51.85,0:25:52.67,Default,,0,0,0,,这不是重点
Dialogue: 0,0:25:54.57,0:25:55.63,Default,,0,0,0,,思路就是
Dialogue: 0,0:25:55.64,0:25:56.65,Default,,0,0,0,,我们要不断地进行CONS
Dialogue: 0,0:25:56.67,0:25:58.01,Default,,0,0,0,,直到空闲表为空
Dialogue: 0,0:25:58.72,0:25:59.67,Default,,0,0,0,,这样就用尽了所有空间
Dialogue: 0,0:26:00.95,0:26:04.47,Default,,0,0,0,,现在我们要证明这个理论
Dialogue: 0,0:26:04.47,0:26:05.90,Default,,0,0,0,,也就是一部分的内存
Dialogue: 0,0:26:05.95,0:26:06.90,Default,,0,0,0,,已经没有用了
Dialogue: 0,0:26:07.85,0:26:09.15,Default,,0,0,0,,然后我们要回收它
Dialogue: 0,0:26:09.78,0:26:10.87,Default,,0,0,0,,构建一个新的树
Dialogue: 0,0:26:12.19,0:26:14.57,Default,,0,0,0,,这是这些垃圾的标准使用方式
Dialogue: 0,0:26:17.09,0:26:18.64,Default,,0,0,0,,那么我们要做什么呢?
Dialogue: 0,0:26:18.84,0:26:20.78,Default,,0,0,0,,从P5这个位置开始
Dialogue: 0,0:26:20.89,0:26:24.27,Default,,0,0,0,,存了一些数据结构
Dialogue: 0,0:26:25.15,0:26:26.75,Default,,0,0,0,,说错了--是从1开始
Dialogue: 0,0:26:27.27,0:26:28.51,Default,,0,0,0,,事实上
Dialogue: 0,0:26:28.89,0:26:32.20,Default,,0,0,0,,它的CAR部分存放在P5这个位置
Dialogue: 0,0:26:32.27,0:26:33.58,Default,,0,0,0,,而CDR部分存在在P2这个位置
Dialogue: 0,0:26:33.98,0:26:35.64,Default,,0,0,0,,最开始 所有的标记都是0
Dialogue: 0,0:26:36.70,0:26:39.00,Default,,0,0,0,,我们要开始标记了
Dialogue: 0,0:26:39.92,0:26:40.52,Default,,0,0,0,,好
Dialogue: 0,0:26:42.54,0:26:44.27,Default,,0,0,0,,例如
Dialogue: 0,0:26:44.47,0:26:46.95,Default,,0,0,0,,因为我可以从根访问到位置P1
Dialogue: 0,0:26:46.95,0:26:47.82,Default,,0,0,0,,我就标记一下
Dialogue: 0,0:26:48.39,0:26:49.17,Default,,0,0,0,,我来标一下
Dialogue: 0,0:26:50.96,0:26:51.45,Default,,0,0,0,,好了
Dialogue: 0,0:26:52.22,0:26:52.94,Default,,0,0,0,,这个被标记了
Dialogue: 0,0:26:54.41,0:26:57.51,Default,,0,0,0,,因为它指向位置P5
Dialogue: 0,0:26:57.64,0:26:58.64,Default,,0,0,0,,所以我来到了5号格子
Dialogue: 0,0:26:59.02,0:27:00.72,Default,,0,0,0,,然后 我要标记这个
Dialogue: 0,0:27:01.45,0:27:01.76,Default,,0,0,0,,标好了
Dialogue: 0,0:27:01.76,0:27:02.60,Default,,0,0,0,,这个笔真好用
Dialogue: 0,0:27:02.90,0:27:05.10,Default,,0,0,0,,但是5号位置的CAR部分是一个数字
Dialogue: 0,0:27:05.27,0:27:06.65,Default,,0,0,0,,我对标记数字不感兴趣
Dialogue: 0,0:27:06.91,0:27:08.17,Default,,0,0,0,,但它的CDR部分是P7
Dialogue: 0,0:27:08.70,0:27:09.75,Default,,0,0,0,,所以我可以标记它
Dialogue: 0,0:27:10.45,0:27:10.81,Default,,0,0,0,,又标好了
Dialogue: 0,0:27:11.80,0:27:13.40,Default,,0,0,0,,P7的CDR部分是空表
Dialogue: 0,0:27:13.67,0:27:15.10,Default,,0,0,0,,而它唯一所引用的元素则是
Dialogue: 0,0:27:15.59,0:27:17.12,Default,,0,0,0,,它的CAR部分是个数字
Dialogue: 0,0:27:17.12,0:27:17.85,Default,,0,0,0,,我对它不感兴趣
Dialogue: 0,0:27:19.49,0:27:20.50,Default,,0,0,0,,让我们回到这里
Dialogue: 0,0:27:20.50,0:27:21.65,Default,,0,0,0,,我忘记了一些事情
Dialogue: 0,0:27:21.65,0:27:22.17,Default,,0,0,0,,P2
Dialogue: 0,0:27:22.84,0:27:24.85,Default,,0,0,0,,换句话说 如果我看1号格子
Dialogue: 0,0:27:25.42,0:27:29.45,Default,,0,0,0,,1号格子的CDR部分指向P2
Dialogue: 0,0:27:30.37,0:27:31.30,Default,,0,0,0,,一个指向P2的引用
Dialogue: 0,0:27:32.01,0:27:34.97,Default,,0,0,0,,这意味着我应该标记P2
Dialogue: 0,0:27:35.70,0:27:36.27,Default,,0,0,0,,好了
Dialogue: 0,0:27:37.14,0:27:38.89,Default,,0,0,0,,P2包含了了一个到P4的引用
Dialogue: 0,0:27:39.13,0:27:40.27,Default,,0,0,0,,而P2的CAR部分是个数字
Dialogue: 0,0:27:40.27,0:27:41.20,Default,,0,0,0,,我对它不感兴趣
Dialogue: 0,0:27:41.47,0:27:42.60,Default,,0,0,0,,所以我要标记P4
Dialogue: 0,0:27:43.78,0:27:46.10,Default,,0,0,0,,P4的CAR部分引用了P7
Dialogue: 0,0:27:46.75,0:27:48.17,Default,,0,0,0,,它的CDR是空的
Dialogue: 0,0:27:48.47,0:27:49.57,Default,,0,0,0,,但由于我已经标记过P7了
Dialogue: 0,0:27:49.57,0:27:50.75,Default,,0,0,0,,就不再次标记它了
Dialogue: 0,0:27:51.40,0:27:53.05,Default,,0,0,0,,这就是这个地方
Dialogue: 0,0:27:53.07,0:27:53.87,Default,,0,0,0,,所能访问的所有单元
Dialogue: 0,0:27:55.00,0:27:56.57,Default,,0,0,0,,很简单的递归标记算法
Dialogue: 0,0:27:58.71,0:28:01.79,Default,,0,0,0,,这个算法有一些不足的地方
Dialogue: 0,0:28:01.90,0:28:04.02,Default,,0,0,0,,我们稍后会说
Dialogue: 0,0:28:04.92,0:28:06.16,Default,,0,0,0,,但基本上你能看到
Dialogue: 0,0:28:06.19,0:28:07.85,Default,,0,0,0,,所有没被标记的地方
Dialogue: 0,0:28:09.62,0:28:11.50,Default,,0,0,0,,都是无用的
Dialogue: 0,0:28:11.50,0:28:12.41,Default,,0,0,0,,可以回收
Dialogue: 0,0:28:14.25,0:28:15.75,Default,,0,0,0,,所以下一步就是
Dialogue: 0,0:28:15.75,0:28:17.05,Default,,0,0,0,,扫描整个内存
Dialogue: 0,0:28:17.94,0:28:20.35,Default,,0,0,0,,寻找未被标记的格子
Dialogue: 0,0:28:21.18,0:28:22.45,Default,,0,0,0,,每当遇到一个已标记的格子
Dialogue: 0,0:28:22.45,0:28:23.22,Default,,0,0,0,,就把标记去掉
Dialogue: 0,0:28:23.22,0:28:24.86,Default,,0,0,0,,每当遇到未标记的格子时
Dialogue: 0,0:28:25.07,0:28:27.82,Default,,0,0,0,,我就把它连接到我的空闲表中
Dialogue: 0,0:28:28.77,0:28:30.30,Default,,0,0,0,,传统而且非常简单的算法
Dialogue: 0,0:28:32.12,0:28:33.10,Default,,0,0,0,,我们来看看
Dialogue: 0,0:28:33.84,0:28:34.77,Default,,0,0,0,,它很简单吗?
Dialogue: 0,0:28:34.77,0:28:35.42,Default,,0,0,0,,是的
Dialogue: 0,0:28:35.57,0:28:37.79,Default,,0,0,0,,我不会深入代码细节
Dialogue: 0,0:28:38.00,0:28:39.65,Default,,0,0,0,,只是想给你看看它有多长
Dialogue: 0,0:28:40.09,0:28:41.10,Default,,0,0,0,,看这个标记阶段
Dialogue: 0,0:28:41.72,0:28:43.98,Default,,0,0,0,,这是标记阶段的第一部分
Dialogue: 0,0:28:45.06,0:28:46.00,Default,,0,0,0,,我们找到根
Dialogue: 0,0:28:46.32,0:28:47.52,Default,,0,0,0,,我们要
Dialogue: 0,0:28:47.67,0:28:51.05,Default,,0,0,0,,对它进行递归过程调用
Dialogue: 0,0:28:52.38,0:28:54.47,Default,,0,0,0,,当我们完成标记之后
Dialogue: 0,0:28:54.77,0:28:56.95,Default,,0,0,0,,就从这里开始清除
Dialogue: 0,0:28:57.38,0:28:59.79,Default,,0,0,0,,然后我们将执行一些指令
Dialogue: 0,0:28:59.80,0:29:01.36,Default,,0,0,0,,来检查这些标记
Dialogue: 0,0:29:01.39,0:29:03.07,Default,,0,0,0,,或者更改这些标记
Dialogue: 0,0:29:03.07,0:29:04.90,Default,,0,0,0,,按照我刚才讲的那个算法进行
Dialogue: 0,0:29:05.23,0:29:06.47,Default,,0,0,0,,代码在这里
Dialogue: 0,0:29:06.47,0:29:07.65,Default,,0,0,0,,你需要标记它们的CAR
Dialogue: 0,0:29:07.87,0:29:10.21,Default,,0,0,0,,也需要标记它们的CDR
Dialogue: 0,0:29:10.66,0:29:12.10,Default,,0,0,0,,这就是整个标记阶段
Dialogue: 0,0:29:14.37,0:29:16.16,Default,,0,0,0,,我给你讲个关于它的小故事
Dialogue: 0,0:29:16.59,0:29:19.37,Default,,0,0,0,,古董货DEC PDP-6计算机
Dialogue: 0,0:29:20.93,0:29:22.09,Default,,0,0,0,,它上面的
Dialogue: 0,0:29:22.35,0:29:24.85,Default,,0,0,0,,标记-清除垃圾回收系统就是这么写的
Dialogue: 0,0:29:26.91,0:29:28.40,Default,,0,0,0,,程序很短
Dialogue: 0,0:29:29.25,0:29:31.60,Default,,0,0,0,,以至于它需要的数据
Dialogue: 0,0:29:32.20,0:29:34.87,Default,,0,0,0,,以及用来操作内存的所需的寄存器
Dialogue: 0,0:29:36.16,0:29:38.14,Default,,0,0,0,,都能够放入到计算机的
Dialogue: 0,0:29:38.16,0:29:38.97,Default,,0,0,0,,16个快速寄存器中
Dialogue: 0,0:29:39.28,0:29:39.80,Default,,0,0,0,,整个程序
Dialogue: 0,0:29:40.01,0:29:42.01,Default,,0,0,0,,你可以在快速寄存器里执行指令
Dialogue: 0,0:29:43.17,0:29:44.83,Default,,0,0,0,,所以这是个非常小的程序
Dialogue: 0,0:29:45.85,0:29:46.88,Default,,0,0,0,,它跑得飞快
Dialogue: 0,0:29:48.87,0:29:51.30,Default,,0,0,0,,然而很不幸
Dialogue: 0,0:29:51.61,0:29:54.02,Default,,0,0,0,,因为这个程序是递归的
Dialogue: 0,0:29:54.80,0:29:57.55,Default,,0,0,0,,因为你需要先做某件事儿
Dialogue: 0,0:29:57.55,0:29:58.99,Default,,0,0,0,,然后再去做另外一件事儿
Dialogue: 0,0:29:59.21,0:30:00.88,Default,,0,0,0,,你得先处理CAR 再处理CDR
Dialogue: 0,0:30:01.15,0:30:02.75,Default,,0,0,0,,这就需要辅助内存
Dialogue: 0,0:30:03.41,0:30:05.23,Default,,0,0,0,,所以Lisp系统
Dialogue: 0,0:30:05.44,0:30:07.42,Default,,0,0,0,,需要一个栈来进行标记
Dialogue: 0,0:30:08.26,0:30:11.05,Default,,0,0,0,,Lisp系统通过这样的方式
Dialogue: 0,0:30:11.57,0:30:14.16,Default,,0,0,0,,限制了你在数据结构上
Dialogue: 0,0:30:14.42,0:30:17.37,Default,,0,0,0,,进行CAR或者CDR递归的深度
Dialogue: 0,0:30:17.81,0:30:19.35,Default,,0,0,0,,这并不太靠谱
Dialogue: 0,0:30:19.93,0:30:20.60,Default,,0,0,0,,另外一方面
Dialogue: 0,0:30:20.64,0:30:22.12,Default,,0,0,0,,当它足够大的时候你不会发现
Dialogue: 0,0:30:23.18,0:30:25.13,Default,,0,0,0,,例如 这样的情况
Dialogue: 0,0:30:25.55,0:30:28.17,Default,,0,0,0,,发生在大多数MacLisp系统上
Dialogue: 0,0:30:28.69,0:30:29.88,Default,,0,0,0,,在它上面运行的Macsyma
Dialogue: 0,0:30:29.96,0:30:31.10,Default,,0,0,0,,允许你处理
Dialogue: 0,0:30:31.10,0:30:32.72,Default,,0,0,0,,有成千上万个元素的表达式
Dialogue: 0,0:30:33.56,0:30:36.02,Default,,0,0,0,,有很多代数式有大量的项
Dialogue: 0,0:30:36.82,0:30:38.10,Default,,0,0,0,,这没什么问题
Dialogue: 0,0:30:39.49,0:30:40.82,Default,,0,0,0,,垃圾回收器能正常工作
Dialogue: 0,0:30:42.19,0:30:42.92,Default,,0,0,0,,另一方面
Dialogue: 0,0:30:42.92,0:30:45.37,Default,,0,0,0,,这个算法有个很精妙的修改版
Dialogue: 0,0:30:45.37,0:30:46.47,Default,,0,0,0,,但我不会去讲
Dialogue: 0,0:30:46.80,0:30:48.22,Default,,0,0,0,,它是由Peter Deutsch
Dialogue: 0,0:30:48.64,0:30:51.82,Default,,0,0,0,,来自IBM的Herb Schorr
Dialogue: 0,0:30:51.87,0:30:53.52,Default,,0,0,0,,和我不太认识的Waite所提出
Dialogue: 0,0:30:54.01,0:30:56.51,Default,,0,0,0,,这个算法
Dialogue: 0,0:30:56.67,0:30:57.79,Default,,0,0,0,,可以不使用
Dialogue: 0,0:30:57.84,0:30:59.55,Default,,0,0,0,,额外的辅助内存
Dialogue: 0,0:31:00.50,0:31:02.80,Default,,0,0,0,,只需要在遍历整个数据结构的时候
Dialogue: 0,0:31:02.97,0:31:05.52,Default,,0,0,0,,记住你是从哪里来的并反转指针
Dialogue: 0,0:31:05.52,0:31:07.52,Default,,0,0,0,,回溯的时候 再去反转这个指针
Dialogue: 0,0:31:07.79,0:31:08.99,Default,,0,0,0,,这是个很取巧的算法
Dialogue: 0,0:31:09.13,0:31:10.24,Default,,0,0,0,,你第一次写它的时候
Dialogue: 0,0:31:10.25,0:31:11.71,Default,,0,0,0,,事实上 你前三次写它的时候
Dialogue: 0,0:31:11.71,0:31:12.72,Default,,0,0,0,,都会遇到严重的BUG
Dialogue: 0,0:31:14.35,0:31:16.72,Default,,0,0,0,,也可能奇慢无比
Dialogue: 0,0:31:16.72,0:31:17.67,Default,,0,0,0,,因为这个算法太复杂了
Dialogue: 0,0:31:18.11,0:31:20.30,Default,,0,0,0,,它用了大概六倍的内存引用
Dialogue: 0,0:31:20.85,0:31:23.22,Default,,0,0,0,,来完成我们刚才讨论的任务
Dialogue: 0,0:31:24.58,0:31:27.07,Default,,0,0,0,,一旦我完成了标记阶段
Dialogue: 0,0:31:27.50,0:31:30.12,Default,,0,0,0,,我们就面临着这样的状况
Dialogue: 0,0:31:30.17,0:31:31.26,Default,,0,0,0,,请看
Dialogue: 0,0:31:31.51,0:31:34.03,Default,,0,0,0,,这里完成了标记工作
Dialogue: 0,0:31:34.08,0:31:35.00,Default,,0,0,0,,和我刚才描述的一样
Dialogue: 0,0:31:35.59,0:31:37.33,Default,,0,0,0,,现在我们要进行清除阶段
Dialogue: 0,0:31:37.60,0:31:39.32,Default,,0,0,0,,我刚才已经讲过如何清除了
Dialogue: 0,0:31:39.82,0:31:42.34,Default,,0,0,0,,我要从内存的一端开始
Dialogue: 0,0:31:42.34,0:31:43.34,Default,,0,0,0,,哪一端都可以
Dialogue: 0,0:31:43.62,0:31:46.17,Default,,0,0,0,,扫描内存中的每个格子
Dialogue: 0,0:31:47.17,0:31:48.67,Default,,0,0,0,,在扫描的同时
Dialogue: 0,0:31:49.20,0:31:50.97,Default,,0,0,0,,如果是空闲内存
Dialogue: 0,0:31:50.99,0:31:52.84,Default,,0,0,0,,就把它们连接到空闲表中
Dialogue: 0,0:31:53.15,0:31:54.05,Default,,0,0,0,,如果它们不是空闲内存
Dialogue: 0,0:31:54.05,0:31:56.07,Default,,0,0,0,,我就把它们的标记清除掉
Dialogue: 0,0:31:57.50,0:31:58.57,Default,,0,0,0,,事实上
Dialogue: 0,0:31:58.70,0:32:00.46,Default,,0,0,0,,最终的程序并不很复杂
Dialogue: 0,0:32:00.46,0:32:02.22,Default,,0,0,0,,它只是变长了一些
Dialogue: 0,0:32:02.78,0:32:04.17,Default,,0,0,0,,这是第一部分
Dialogue: 0,0:32:04.82,0:32:06.71,Default,,0,0,0,,它从内存的顶端向下遍历
Dialogue: 0,0:32:06.71,0:32:09.58,Default,,0,0,0,,我不期望你现在就搞懂它
Dialogue: 0,0:32:09.58,0:32:10.55,Default,,0,0,0,,它挺简单的
Dialogue: 0,0:32:11.03,0:32:12.52,Default,,0,0,0,,这是个非常简单的算法
Dialogue: 0,0:32:13.07,0:32:15.97,Default,,0,0,0,,其中的一段代码像是这样
Dialogue: 0,0:32:15.97,0:32:17.37,Default,,0,0,0,,非常显而易见
Dialogue: 0,0:32:18.60,0:32:20.08,Default,,0,0,0,,在清理结束后
Dialogue: 0,0:32:20.30,0:32:21.77,Default,,0,0,0,,我们就得到了像这样的结果
Dialogue: 0,0:32:25.33,0:32:26.54,Default,,0,0,0,,这种标记-清除算法
Dialogue: 0,0:32:26.56,0:32:28.20,Default,,0,0,0,,有一些缺点
Dialogue: 0,0:32:29.59,0:32:30.35,Default,,0,0,0,,最严重的一个是
Dialogue: 0,0:32:31.45,0:32:33.20,Default,,0,0,0,,最严重的缺点是
Dialogue: 0,0:32:33.20,0:32:34.97,Default,,0,0,0,,当你的内存越来越大
Dialogue: 0,0:32:36.82,0:32:38.87,Default,,0,0,0,,地址空间也就会越来越大
Dialogue: 0,0:32:38.87,0:32:40.80,Default,,0,0,0,,你想用它存更多东西
Dialogue: 0,0:32:41.37,0:32:44.52,Default,,0,0,0,,那么扫描整个内存就会非常耗时
Dialogue: 0,0:32:46.36,0:32:47.39,Default,,0,0,0,,你真正想做的是
Dialogue: 0,0:32:47.40,0:32:48.68,Default,,0,0,0,,只扫描有用的东西
Dialogue: 0,0:32:50.49,0:32:51.55,Default,,0,0,0,,这样就会好一点
Dialogue: 0,0:32:52.07,0:32:53.90,Default,,0,0,0,,如果你意识到
Dialogue: 0,0:32:54.48,0:32:57.72,Default,,0,0,0,,哪些东西已知是有用的
Dialogue: 0,0:32:58.28,0:33:00.37,Default,,0,0,0,,你就没必要去多次检查它
Dialogue: 0,0:33:00.37,0:33:01.20,Default,,0,0,0,,或者不用经常去检查它
Dialogue: 0,0:33:01.55,0:33:04.32,Default,,0,0,0,,对于那些你不太确定的
Dialogue: 0,0:33:05.00,0:33:06.22,Default,,0,0,0,,你可以在每次需要的时候
Dialogue: 0,0:33:07.10,0:33:08.75,Default,,0,0,0,,进行仔细检查
Dialogue: 0,0:33:09.93,0:33:10.85,Default,,0,0,0,,也就是垃圾收集的时候
Dialogue: 0,0:33:11.91,0:33:13.74,Default,,0,0,0,,这些算法
Dialogue: 0,0:33:13.76,0:33:15.10,Default,,0,0,0,,就是用了这样的方法
Dialogue: 0,0:33:15.66,0:33:18.16,Default,,0,0,0,,我要介绍一个著名的古老算法
Dialogue: 0,0:33:18.28,0:33:19.47,Default,,0,0,0,,这种算法允许你
Dialogue: 0,0:33:19.50,0:33:21.37,Default,,0,0,0,,只检查内存中已知是有用的部分
Dialogue: 0,0:33:23.12,0:33:23.85,Default,,0,0,0,,这让它成为了
Dialogue: 0,0:33:23.87,0:33:25.29,Default,,0,0,0,,目前已知最快的垃圾收集算法
Dialogue: 0,0:33:26.31,0:33:29.45,Default,,0,0,0,,它就是 Minsky-Fenichel-Yochelson 垃圾收集算法
Dialogue: 0,0:33:30.40,0:33:33.18,Default,,0,0,0,,它是由Minsky
Dialogue: 0,0:33:33.20,0:33:36.06,Default,,0,0,0,,在1960、61年左右发明的
Dialogue: 0,0:33:36.52,0:33:40.48,Default,,0,0,0,,当时是给RLE PDP-1 Lisp用的
Dialogue: 0,0:33:40.51,0:33:43.44,Default,,0,0,0,,这个机器只有4096个字的线性内存
Dialogue: 0,0:33:45.79,0:33:46.76,Default,,0,0,0,,还有个磁鼓
Dialogue: 0,0:33:48.48,0:33:49.39,Default,,0,0,0,,为了能够
Dialogue: 0,0:33:50.03,0:33:51.87,Default,,0,0,0,,在这种恶劣的条件下进行垃圾收集
Dialogue: 0,0:33:53.05,0:33:54.35,Default,,0,0,0,,Minsky意识到
Dialogue: 0,0:33:54.38,0:33:55.62,Default,,0,0,0,,达成目的最容易的方法是
Dialogue: 0,0:33:56.20,0:33:58.47,Default,,0,0,0,,在扫描内存的同时
Dialogue: 0,0:33:58.47,0:34:00.60,Default,,0,0,0,,遍历那些好的数据结构
Dialogue: 0,0:34:01.57,0:34:03.52,Default,,0,0,0,,把它复制到磁鼓中
Dialogue: 0,0:34:04.70,0:34:05.47,Default,,0,0,0,,压缩一下
Dialogue: 0,0:34:06.35,0:34:08.86,Default,,0,0,0,,之后把它们复制出来
Dialogue: 0,0:34:09.12,0:34:10.90,Default,,0,0,0,,并把它们交换回内存里
Dialogue: 0,0:34:12.30,0:34:13.68,Default,,0,0,0,,不管是使用的是磁鼓
Dialogue: 0,0:34:13.72,0:34:14.71,Default,,0,0,0,,或者其它的内存
Dialogue: 0,0:34:14.71,0:34:16.42,Default,,0,0,0,,这都不重要
Dialogue: 0,0:34:17.03,0:34:17.42,Default,,0,0,0,,事实上
Dialogue: 0,0:34:17.44,0:34:19.60,Default,,0,0,0,,我觉得现在应该没人用磁鼓了吧
Dialogue: 0,0:34:20.35,0:34:23.77,Default,,0,0,0,,但这个算法基本上
Dialogue: 0,0:34:24.03,0:34:25.42,Default,,0,0,0,,要依赖于
Dialogue: 0,0:34:25.42,0:34:27.42,Default,,0,0,0,,大约两倍于
Dialogue: 0,0:34:27.48,0:34:28.57,Default,,0,0,0,,你实际使用的内存
Dialogue: 0,0:34:30.27,0:34:32.96,Default,,0,0,0,,最开始的情况是
Dialogue: 0,0:34:33.12,0:34:36.60,Default,,0,0,0,,有用的数据和垃圾混在了一起
Dialogue: 0,0:34:37.11,0:34:38.97,Default,,0,0,0,,它被称为FROMSPACE
Dialogue: 0,0:34:45.17,0:34:47.05,Default,,0,0,0,,这是CRUD的混合
Dialogue: 0,0:34:47.87,0:34:49.79,Default,,0,0,0,,有些是有用的 有些没有用
Dialogue: 0,0:34:52.00,0:34:53.85,Default,,0,0,0,,现在还有另外一块空间
Dialogue: 0,0:34:54.17,0:34:55.61,Default,,0,0,0,,它需要足够大
Dialogue: 0,0:34:55.77,0:34:57.00,Default,,0,0,0,,这个地方叫TOSPACE
Dialogue: 0,0:34:57.12,0:34:58.24,Default,,0,0,0,,要把东西复制进去
Dialogue: 0,0:35:01.59,0:35:02.60,Default,,0,0,0,,接下来会发生的是
Dialogue: 0,0:35:02.60,0:35:04.06,Default,,0,0,0,,我不会深入细节
Dialogue: 0,0:35:04.16,0:35:07.07,Default,,0,0,0,,书上写得很清楚了
Dialogue: 0,0:35:07.59,0:35:10.40,Default,,0,0,0,,这里有一个根节点
Dialogue: 0,0:35:11.03,0:35:14.30,Default,,0,0,0,,你从根节点开始
Dialogue: 0,0:35:14.60,0:35:16.42,Default,,0,0,0,,复制你看到的第一个东西
Dialogue: 0,0:35:17.83,0:35:19.37,Default,,0,0,0,,根指针指向的第一个东西
Dialogue: 0,0:35:19.75,0:35:21.31,Default,,0,0,0,,复制到TOSPACE的头部
Dialogue: 0,0:35:22.81,0:35:24.12,Default,,0,0,0,,这些东西一般是一个序对
Dialogue: 0,0:35:24.16,0:35:25.60,Default,,0,0,0,,或者是类似的数据结构
Dialogue: 0,0:35:27.56,0:35:30.19,Default,,0,0,0,,然后在那里留下
Dialogue: 0,0:35:30.38,0:35:31.56,Default,,0,0,0,,一颗“破碎的心”
Dialogue: 0,0:35:31.77,0:35:35.74,Default,,0,0,0,,表示我把东西从这里移动到了这里
Dialogue: 0,0:35:35.74,0:35:37.05,Default,,0,0,0,,指示了移动的目的地
Dialogue: 0,0:35:37.80,0:35:39.65,Default,,0,0,0,,叫作破碎的心是因为
Dialogue: 0,0:35:39.65,0:35:40.78,Default,,0,0,0,,我的一个朋友
Dialogue: 0,0:35:40.78,0:35:43.39,Default,,0,0,0,,在1966年实现了这个算法
Dialogue: 0,0:35:43.82,0:35:45.26,Default,,0,0,0,,而他是个文艺青年
Dialogue: 0,0:35:45.26,0:35:46.76,Default,,0,0,0,,就取名叫“破碎的心”
Dialogue: 0,0:35:49.58,0:35:50.54,Default,,0,0,0,,不论如何
Dialogue: 0,0:35:51.15,0:35:52.72,Default,,0,0,0,,接下来要做的是
Dialogue: 0,0:35:52.94,0:35:55.00,Default,,0,0,0,,FREE指针现在指向这里
Dialogue: 0,0:35:55.17,0:35:56.38,Default,,0,0,0,,然后开始扫描
Dialogue: 0,0:35:56.88,0:35:59.68,Default,,0,0,0,,扫描这个刚复制过来的数据结构
Dialogue: 0,0:36:00.55,0:36:02.19,Default,,0,0,0,,每当你遇到其中的指针
Dialogue: 0,0:36:02.19,0:36:03.92,Default,,0,0,0,,你把它当作是这里的根指针
Dialogue: 0,0:36:04.00,0:36:04.59,Default,,0,0,0,,哦 不好意思
Dialogue: 0,0:36:04.60,0:36:05.69,Default,,0,0,0,,我们还需要做的是
Dialogue: 0,0:36:05.71,0:36:07.08,Default,,0,0,0,,你将根指针移动到这里
Dialogue: 0,0:36:09.22,0:36:10.17,Default,,0,0,0,,因此在扫描的过程中
Dialogue: 0,0:36:10.17,0:36:10.99,Default,,0,0,0,,把遇到的每个指针
Dialogue: 0,0:36:11.00,0:36:12.41,Default,,0,0,0,,都可以当作是ROOT指针
Dialogue: 0,0:36:14.11,0:36:15.45,Default,,0,0,0,,如果你遇到了某个指针
Dialogue: 0,0:36:15.45,0:36:17.40,Default,,0,0,0,,指向了这里的某个地方
Dialogue: 0,0:36:18.51,0:36:19.92,Default,,0,0,0,,它指向的东西
Dialogue: 0,0:36:19.93,0:36:20.99,Default,,0,0,0,,你复制过了吗？
Dialogue: 0,0:36:21.78,0:36:22.87,Default,,0,0,0,,这里是“破碎的心”吗
Dialogue: 0,0:36:23.88,0:36:24.84,Default,,0,0,0,,如果那里是破碎的心
Dialogue: 0,0:36:24.84,0:36:26.11,Default,,0,0,0,,就说明那里的东西复制过了
Dialogue: 0,0:36:26.20,0:36:27.34,Default,,0,0,0,,只需要用破碎的心所指向的地址
Dialogue: 0,0:36:27.36,0:36:28.75,Default,,0,0,0,,来替换它指针即可
Dialogue: 0,0:36:29.82,0:36:32.03,Default,,0,0,0,,如果它还没被复制
Dialogue: 0,0:36:32.12,0:36:34.08,Default,,0,0,0,,你把它复制到这里
Dialogue: 0,0:36:34.43,0:36:35.95,Default,,0,0,0,,把FREE指针移到这里
Dialogue: 0,0:36:37.05,0:36:40.60,Default,,0,0,0,,然后在那里放置一颗破碎的心
Dialogue: 0,0:36:41.05,0:36:41.80,Default,,0,0,0,,继续扫描
Dialogue: 0,0:36:43.67,0:36:46.40,Default,,0,0,0,,最终SCAN指针追上了FREE指针
Dialogue: 0,0:36:46.82,0:36:48.52,Default,,0,0,0,,内存里的所有东西都被复制了
Dialogue: 0,0:36:50.14,0:36:51.04,Default,,0,0,0,,这样这里就剩下了
Dialogue: 0,0:36:51.05,0:36:51.95,Default,,0,0,0,,大量的空闲空间
Dialogue: 0,0:36:51.96,0:36:53.28,Default,,0,0,0,,如果你需要的话
Dialogue: 0,0:36:53.31,0:36:54.47,Default,,0,0,0,,你可以把它组织为空闲表
Dialogue: 0,0:36:54.47,0:36:56.27,Default,,0,0,0,,但这种系统通常不这么来做
Dialogue: 0,0:36:56.27,0:36:59.15,Default,,0,0,0,,这类系统中 内存是顺序分配的
Dialogue: 0,0:37:00.91,0:37:02.48,Default,,0,0,0,,这是个非常 非常好的算法
Dialogue: 0,0:37:02.97,0:37:04.57,Default,,0,0,0,,你们现在使用的Scheme系统中
Dialogue: 0,0:37:04.67,0:37:05.97,Default,,0,0,0,,就使用了这种算法
Dialogue: 0,0:37:06.79,0:37:09.47,Default,,0,0,0,,它应该是--
Dialogue: 0,0:37:09.47,0:37:10.86,Default,,0,0,0,,我相信还没有人发现
Dialogue: 0,0:37:10.89,0:37:12.12,Default,,0,0,0,,比它跑得更快的算法
Dialogue: 0,0:37:12.40,0:37:14.85,Default,,0,0,0,,有一些对这个算法的简单修改
Dialogue: 0,0:37:14.85,0:37:16.77,Default,,0,0,0,,由Henry Baker发明
Dialogue: 0,0:37:17.17,0:37:20.31,Default,,0,0,0,,它让你能实时运行这个算法
Dialogue: 0,0:37:20.31,0:37:21.92,Default,,0,0,0,,也就是说进行回收时不需要暂停程序
Dialogue: 0,0:37:22.14,0:37:24.33,Default,,0,0,0,,你能够让机器运行时
Dialogue: 0,0:37:24.36,0:37:26.17,Default,,0,0,0,,进行的各种CONS操作
Dialogue: 0,0:37:26.32,0:37:28.40,Default,,0,0,0,,与垃圾回收过程交错进行
Dialogue: 0,0:37:28.85,0:37:31.20,Default,,0,0,0,,垃圾回收器是分散的
Dialogue: 0,0:37:31.20,0:37:32.19,Default,,0,0,0,,机器不需要停下来
Dialogue: 0,0:37:32.41,0:37:33.47,Default,,0,0,0,,再让垃圾回收开始运作
Dialogue: 0,0:37:34.64,0:37:37.87,Default,,0,0,0,,当然 在使用虚拟内存的机器中
Dialogue: 0,0:37:38.90,0:37:41.20,Default,,0,0,0,,有很多内存无法访问
Dialogue: 0,0:37:41.50,0:37:43.60,Default,,0,0,0,,这会让整个过程变得耗时
Dialogue: 0,0:37:44.28,0:37:46.43,Default,,0,0,0,,有很多人尝试
Dialogue: 0,0:37:47.16,0:37:48.65,Default,,0,0,0,,将它改进得更好
Dialogue: 0,0:37:49.19,0:37:51.15,Default,,0,0,0,,对于感兴趣的同学
Dialogue: 0,0:37:51.16,0:37:52.41,Default,,0,0,0,,这有一篇论文
Dialogue: 0,0:37:52.64,0:37:54.27,Default,,0,0,0,,作者是Moon等人
Dialogue: 0,0:37:54.65,0:37:56.89,Default,,0,0,0,,这篇论文描述了
Dialogue: 0,0:37:56.92,0:37:59.44,Default,,0,0,0,,增量式Minsky-Fenichel-Yochelson算法
Dialogue: 0,0:37:59.51,0:38:01.20,Default,,0,0,0,,和Baker算法的修改
Dialogue: 0,0:38:01.42,0:38:06.54,Default,,0,0,0,,让使用虚拟内存的系统更加高效
Dialogue: 0,0:38:08.27,0:38:12.32,Default,,0,0,0,,现在最后一个谜团也解开了
Dialogue: 0,0:38:12.84,0:38:14.09,Default,,0,0,0,,有什么疑惑吗？
Dialogue: 0,0:38:19.78,0:38:19.95,Default,,0,0,0,,请讲
Dialogue: 0,0:38:20.60,0:38:23.58,Default,,0,0,0,,学生：我在楼上的系统上
Dialogue: 0,0:38:23.64,0:38:25.05,Default,,0,0,0,,你们运行垃圾收集器的时候
Dialogue: 0,0:38:25.93,0:38:27.88,Default,,0,0,0,,它看起来跑得飞快
Dialogue: 0,0:38:27.96,0:38:28.40,Default,,0,0,0,,教授：是的
Dialogue: 0,0:38:28.49,0:38:29.52,Default,,0,0,0,,学生：整个过程花费了--
Dialogue: 0,0:38:30.11,0:38:31.88,Default,,0,0,0,,它真的扫描了整个内存吗？
Dialogue: 0,0:38:31.88,0:38:32.22,Default,,0,0,0,,教授：没有
Dialogue: 0,0:38:32.25,0:38:34.11,Default,,0,0,0,,它只扫描了那些需要的
Dialogue: 0,0:38:34.33,0:38:35.63,Default,,0,0,0,,去复制那些有用的数据结构
Dialogue: 0,0:38:37.32,0:38:38.36,Default,,0,0,0,,它是个复制收集器
Dialogue: 0,0:38:38.44,0:38:38.91,Default,,0,0,0,,学生：好吧
Dialogue: 0,0:38:39.30,0:38:40.88,Default,,0,0,0,,教授：但它确实很快
Dialogue: 0,0:38:41.85,0:38:45.88,Default,,0,0,0,,整体来说 我想如果要复制
Dialogue: 0,0:38:47.12,0:38:51.56,Default,,0,0,0,,一个大约3MB的东西
Dialogue: 0,0:38:52.43,0:38:53.24,Default,,0,0,0,,将在一秒内完成
Dialogue: 0,0:38:55.00,0:38:55.69,Default,,0,0,0,,而且是实时的
Dialogue: 0,0:38:56.54,0:38:58.46,Default,,0,0,0,,它们是非常小的程序
Dialogue: 0,0:38:58.62,0:39:01.50,Default,,0,0,0,,你需要注意到的一件事是
Dialogue: 0,0:39:02.91,0:39:04.40,Default,,0,0,0,,垃圾收集器必须要小
Dialogue: 0,0:39:05.40,0:39:07.10,Default,,0,0,0,,不是因为它们需要运行得快
Dialogue: 0,0:39:07.90,0:39:09.23,Default,,0,0,0,,因为没有人能够调试
Dialogue: 0,0:39:09.26,0:39:10.48,Default,,0,0,0,,复杂的垃圾收集器
Dialogue: 0,0:39:11.34,0:39:12.91,Default,,0,0,0,,如果一个垃圾收集器不能正常工作
Dialogue: 0,0:39:14.04,0:39:15.93,Default,,0,0,0,,它会把你的内存搞得一团糟
Dialogue: 0,0:39:15.93,0:39:17.39,Default,,0,0,0,,而你却束手无策
Dialogue: 0,0:39:18.35,0:39:19.67,Default,,0,0,0,,你需要跟踪审计
Dialogue: 0,0:39:20.66,0:39:22.01,Default,,0,0,0,,因为它把所有东西都换了位置
Dialogue: 0,0:39:22.04,0:39:23.24,Default,,0,0,0,,你需要知道那里发生了什么
Dialogue: 0,0:39:23.74,0:39:26.58,Default,,0,0,0,,所以这是唯一一种
Dialogue: 0,0:39:26.92,0:39:28.40,Default,,0,0,0,,真正非常重要的程序
Dialogue: 0,0:39:28.54,0:39:29.79,Default,,0,0,0,,如果你盯着它看足够久
Dialogue: 0,0:39:29.82,0:39:31.07,Default,,0,0,0,,那么你就相信它有效
Dialogue: 0,0:39:31.34,0:39:33.36,Default,,0,0,0,,这意味着某种“自我证明”
Dialogue: 0,0:39:33.92,0:39:36.11,Default,,0,0,0,,因此我们无法对它进行查错
Dialogue: 0,0:39:36.94,0:39:38.96,Default,,0,0,0,,这意味着它需要足够小
Dialogue: 0,0:39:38.96,0:39:39.97,Default,,0,0,0,,你的大脑能够思考它的工作情况
Dialogue: 0,0:39:41.45,0:39:43.90,Default,,0,0,0,,正因如此 垃圾收集器十分特殊
Dialogue: 0,0:39:45.02,0:39:47.12,Default,,0,0,0,,所以实用的垃圾收集器一定要短小
Dialogue: 0,0:39:47.13,0:39:48.45,Default,,0,0,0,,而通常短小的程序运行得就快
Dialogue: 0,0:39:52.05,0:39:52.43,Default,,0,0,0,,请讲
Dialogue: 0,0:39:52.43,0:39:54.51,Default,,0,0,0,,学生：您能再重复一遍这个技术的名字吗?
Dialogue: 0,0:39:54.68,0:39:56.92,Default,,0,0,0,,教授：Minsky-Fenichel-Yochelson垃圾回收器
Dialogue: 0,0:39:57.88,0:39:58.43,Default,,0,0,0,,学生：什么?
Dialogue: 0,0:39:59.00,0:40:00.78,Default,,0,0,0,,教授：Minsky在1961年
Dialogue: 0,0:40:00.81,0:40:02.21,Default,,0,0,0,,为RLE PDP-1设计了这个算法
Dialogue: 0,0:40:02.21,0:40:06.17,Default,,0,0,0,,Fenichel和Yochelson改进并精化了算法
Dialogue: 0,0:40:06.45,0:40:10.27,Default,,0,0,0,,将它用在了Multics平台的MacLisp中
Dialogue: 0,0:40:11.37,0:40:14.75,Default,,0,0,0,,那时大约是1968或者1969年
Dialogue: 0,0:40:19.57,0:40:21.36,Default,,0,0,0,,好吧 我们休息一下
Dialogue: 0,0:40:22.64,0:40:32.36,Default,,0,0,0,,[音乐]
Dialogue: 0,0:40:32.41,0:40:36.19,Declare,,0,0,0,,{\an2\fad(500,500)}《计算机程序的构造和解释》
Dialogue: 0,0:41:03.15,0:41:07.18,Declare,,0,0,0,,{\an2\fad(500,500)}讲师： 哈罗德·艾伯森教授 及 格兰德·杰·萨斯曼教授
Dialogue: 0,0:41:07.20,0:41:10.17,Declare,,0,0,0,,{\an2\fad(500,500)\pos(320,470)}《计算机程序的构造和解释》
Dialogue: 0,0:41:10.20,0:41:14.22,Declare,,0,0,0,,{\an2\fad(500,500)}计算的极限
Dialogue: 0,0:41:17.31,0:41:19.67,Default,,0,0,0,,教授：我们已经到课程的最后一部分了
Dialogue: 0,0:41:20.08,0:41:23.85,Default,,0,0,0,,我已经给你们展示了一台通用机器
Dialogue: 0,0:41:24.47,0:41:26.74,Default,,0,0,0,,它被简化为求值器
Dialogue: 0,0:41:27.02,0:41:28.38,Default,,0,0,0,,它被简化到
Dialogue: 0,0:41:28.38,0:41:29.67,Default,,0,0,0,,你自己也能构造出来
Dialogue: 0,0:41:30.19,0:41:33.32,Default,,0,0,0,,这是一个特定的Lisp实现
Dialogue: 0,0:41:33.90,0:41:36.01,Default,,0,0,0,,它是用
Dialogue: 0,0:41:36.16,0:41:38.05,Default,,0,0,0,,昨天讲过的Scheme芯片制作的
Dialogue: 0,0:41:38.20,0:41:38.91,Default,,0,0,0,,就是这个
Dialogue: 0,0:41:39.35,0:41:42.00,Default,,0,0,0,,这基本上就是暴露给他人内存的接口了
Dialogue: 0,0:41:42.60,0:41:44.75,Default,,0,0,0,,里面有节拍发生器等组件
Dialogue: 0,0:41:45.22,0:41:47.25,Default,,0,0,0,,尽管是解释执行
Dialogue: 0,0:41:47.77,0:41:50.17,Default,,0,0,0,,但它们运行Lisp的速度还算不错
Dialogue: 0,0:41:50.61,0:41:53.82,Default,,0,0,0,,它跑得像1979年的
Dialogue: 0,0:41:54.22,0:41:55.65,Default,,0,0,0,,DEC PDP-10一样快
Dialogue: 0,0:41:56.50,0:41:59.67,Default,,0,0,0,,作为一个十足的硬件
Dialogue: 0,0:42:00.02,0:42:00.89,Default,,0,0,0,,算是十分“实在”了
Dialogue: 0,0:42:02.47,0:42:04.70,Default,,0,0,0,,我们为你们讲解了一些
Dialogue: 0,0:42:04.72,0:42:06.07,Default,,0,0,0,,可以被计算的东西
Dialogue: 0,0:42:07.37,0:42:08.76,Default,,0,0,0,,但我们是否可能遇到
Dialogue: 0,0:42:09.32,0:42:10.55,Default,,0,0,0,,我们无法计算的情况？
Dialogue: 0,0:42:11.85,0:42:13.50,Default,,0,0,0,,课程的最后
Dialogue: 0,0:42:13.75,0:42:15.87,Default,,0,0,0,,我想展示一些你认为可以被计算
Dialogue: 0,0:42:16.60,0:42:17.22,Default,,0,0,0,,但实际上不能的东西
Dialogue: 0,0:42:18.19,0:42:19.45,Default,,0,0,0,,实际上
Dialogue: 0,0:42:19.45,0:42:20.82,Default,,0,0,0,,确实有我们无法计算的东西
Dialogue: 0,0:42:22.72,0:42:23.47,Default,,0,0,0,,例如
Dialogue: 0,0:42:24.45,0:42:25.82,Default,,0,0,0,,我们想要这样的一种东西
Dialogue: 0,0:42:27.80,0:42:29.36,Default,,0,0,0,,当我们在编写编译器时
Dialogue: 0,0:42:29.77,0:42:31.42,Default,,0,0,0,,你想用一个程序检查
Dialogue: 0,0:42:32.00,0:42:33.97,Default,,0,0,0,,你的代码能否正常运行
Dialogue: 0,0:42:34.63,0:42:35.40,Default,,0,0,0,,这不是很棒吗?
Dialogue: 0,0:42:36.08,0:42:37.87,Default,,0,0,0,,你希望能够捕获死循环
Dialogue: 0,0:42:37.87,0:42:38.54,Default,,0,0,0,,例如
Dialogue: 0,0:42:39.45,0:42:42.42,Default,,0,0,0,,用户编写的程序里的死循环
Dialogue: 0,0:42:43.19,0:42:45.12,Default,,0,0,0,,但通常来说 你写不出这样的程序
Dialogue: 0,0:42:45.35,0:42:46.49,Default,,0,0,0,,它读取某个程序
Dialogue: 0,0:42:46.51,0:42:47.45,Default,,0,0,0,,并检测它
Dialogue: 0,0:42:48.35,0:42:49.30,Default,,0,0,0,,是不是死循环
Dialogue: 0,0:42:50.99,0:42:51.71,Default,,0,0,0,,我来展示一下
Dialogue: 0,0:42:51.76,0:42:53.80,Default,,0,0,0,,这个需要涉及到数学知识
Dialogue: 0,0:42:58.78,0:42:59.65,Default,,0,0,0,,设想
Dialogue: 0,0:43:00.05,0:43:01.78,Default,,0,0,0,,在我们开始之前
Dialogue: 0,0:43:01.78,0:43:02.62,Default,,0,0,0,,有一个数学函数
Dialogue: 0,0:43:02.62,0:43:03.42,Default,,0,0,0,,这里就有一个
Dialogue: 0,0:43:03.84,0:43:04.67,Default,,0,0,0,,记作S
Dialogue: 0,0:43:05.47,0:43:07.54,Default,,0,0,0,,它接受一个过程
Dialogue: 0,0:43:12.64,0:43:14.23,Default,,0,0,0,,和它的参数A
Dialogue: 0,0:43:19.17,0:43:20.52,Default,,0,0,0,,S所做的是
Dialogue: 0,0:43:21.65,0:43:24.01,Default,,0,0,0,,检测以A为参数运行P时
Dialogue: 0,0:43:24.01,0:43:25.97,Default,,0,0,0,,是否安全
Dialogue: 0,0:43:26.90,0:43:28.17,Default,,0,0,0,,换句话说就是
Dialogue: 0,0:43:28.76,0:43:35.12,Default,,0,0,0,,如果(P A)
Dialogue: 0,0:43:35.62,0:43:36.74,Default,,0,0,0,,在没有出错的情况下
Dialogue: 0,0:43:41.40,0:43:42.45,Default,,0,0,0,,能够返回一个值
Dialogue: 0,0:43:44.35,0:43:45.33,Default,,0,0,0,,那么S就为TRUE
Dialogue: 0,0:43:52.70,0:43:53.68,Default,,0,0,0,,但如果(P A)
Dialogue: 0,0:43:56.10,0:43:57.04,Default,,0,0,0,,是死循环
Dialogue: 0,0:43:59.67,0:44:00.76,Default,,0,0,0,,或者抛出错误
Dialogue: 0,0:44:05.87,0:44:06.95,Default,,0,0,0,,那么S就为FALSE
Dialogue: 0,0:44:15.23,0:44:17.22,Default,,0,0,0,,这确实是个函数
Dialogue: 0,0:44:18.78,0:44:20.72,Default,,0,0,0,,对于你输入的任何过程
Dialogue: 0,0:44:21.20,0:44:22.85,Default,,0,0,0,,或者任何参数
Dialogue: 0,0:44:23.92,0:44:25.45,Default,,0,0,0,,它只能返回TRUE或FALSE
Dialogue: 0,0:44:25.92,0:44:27.85,Default,,0,0,0,,它会返回一个值而且不会报错
Dialogue: 0,0:44:28.44,0:44:30.15,Default,,0,0,0,,你可以为它们画一张巨大的表格
Dialogue: 0,0:44:32.22,0:44:32.92,Default,,0,0,0,,但问题是
Dialogue: 0,0:44:32.92,0:44:34.09,Default,,0,0,0,,你能写一个过程
Dialogue: 0,0:44:34.09,0:44:35.92,Default,,0,0,0,,来计算这个函数的值吗?
Dialogue: 0,0:44:37.43,0:44:38.92,Default,,0,0,0,,假设我们能做到
Dialogue: 0,0:44:39.72,0:44:40.55,Default,,0,0,0,,假设
Dialogue: 0,0:44:44.33,0:44:45.58,Default,,0,0,0,,我们有个过程
Dialogue: 0,0:44:48.55,0:44:52.73,Default,,0,0,0,,一个叫作SAFE?的过程
Dialogue: 0,0:44:56.54,0:44:59.90,Default,,0,0,0,,它能计算S的值
Dialogue: 0,0:45:12.65,0:45:14.89,Default,,0,0,0,,现在我要用几种方法
Dialogue: 0,0:45:15.90,0:45:18.51,Default,,0,0,0,,证明你做不到
Dialogue: 0,0:45:19.76,0:45:20.62,Default,,0,0,0,,最简单的一个
Dialogue: 0,0:45:20.62,0:45:21.28,Default,,0,0,0,,或者说第一个
Dialogue: 0,0:45:21.31,0:45:23.45,Default,,0,0,0,,我们定义一个叫DIAG1的过程
Dialogue: 0,0:45:23.76,0:45:24.86,Default,,0,0,0,,给定了SAFE?过程
Dialogue: 0,0:45:25.20,0:45:26.99,Default,,0,0,0,,我们可以把DIAG1定义为
Dialogue: 0,0:45:34.42,0:45:35.55,Default,,0,0,0,,把DIAG1定义为
Dialogue: 0,0:45:37.82,0:45:41.60,Default,,0,0,0,,只含有参数P的过程
Dialogue: 0,0:45:42.45,0:45:44.05,Default,,0,0,0,,它有着这样的属性
Dialogue: 0,0:45:44.78,0:45:50.67,Default,,0,0,0,,如果(SAFE? P P)为真
Dialogue: 0,0:45:53.32,0:45:55.32,Default,,0,0,0,,那么我就主动陷入死循环
Dialogue: 0,0:45:59.22,0:46:00.92,Default,,0,0,0,,否则我会返回3
Dialogue: 0,0:46:03.68,0:46:04.47,Default,,0,0,0,,它也可能是42
Dialogue: 0,0:46:04.47,0:46:06.42,Default,,0,0,0,,宇宙的终极答案是什么?
Dialogue: 0,0:46:07.06,0:46:08.87,Default,,0,0,0,,我们当然知道死循环是什么
Dialogue: 0,0:46:12.05,0:46:12.96,Default,,0,0,0,,死循环INF是
Dialogue: 0,0:46:13.82,0:46:16.02,Default,,0,0,0,,一个无参过程
Dialogue: 0,0:46:16.02,0:46:18.07,Default,,0,0,0,,这是一个极好的LAMBADA演算循环
Dialogue: 0,0:46:18.35,0:46:20.44,Default,,0,0,0,,(LAMBDA (X) (X X))
Dialogue: 0,0:46:21.30,0:46:24.68,Default,,0,0,0,,应用到(LAMBDA (X) (X X))
Dialogue: 0,0:46:24.68,0:46:26.55,Default,,0,0,0,,没什么想象的余地了
Dialogue: 0,0:46:29.83,0:46:31.17,Default,,0,0,0,,我们来看下会发生什么
Dialogue: 0,0:46:32.50,0:46:33.90,Default,,0,0,0,,我假设
Dialogue: 0,0:46:35.45,0:46:38.77,Default,,0,0,0,,我们考虑
Dialogue: 0,0:46:39.00,0:46:43.45,Default,,0,0,0,,把DIAG1应用到DIAG1上
Dialogue: 0,0:46:46.27,0:46:47.77,Default,,0,0,0,,那会发生什么呢?
Dialogue: 0,0:46:49.97,0:46:51.39,Default,,0,0,0,,我不知道
Dialogue: 0,0:46:51.39,0:46:53.21,Default,,0,0,0,,将DIAG1代换为
Dialogue: 0,0:46:53.55,0:46:55.50,Default,,0,0,0,,P的过程体
Dialogue: 0,0:46:57.31,0:47:00.22,Default,,0,0,0,,(SAFE? DIAG1 DIAG1)会返回什么呢？
Dialogue: 0,0:47:00.22,0:47:00.78,Default,,0,0,0,,我不知道
Dialogue: 0,0:47:00.78,0:47:01.82,Default,,0,0,0,,有两种可能
Dialogue: 0,0:47:03.40,0:47:05.50,Default,,0,0,0,,如果计算(DIAG1 DIAG1)是安全的
Dialogue: 0,0:47:05.92,0:47:06.89,Default,,0,0,0,,这意味着没有死循环
Dialogue: 0,0:47:08.49,0:47:09.22,Default,,0,0,0,,那么我就要来到这里
Dialogue: 0,0:47:09.22,0:47:10.35,Default,,0,0,0,,但是随即我就陷入了死循环
Dialogue: 0,0:47:10.56,0:47:11.57,Default,,0,0,0,,所以它不是安全的
Dialogue: 0,0:47:12.21,0:47:14.78,Default,,0,0,0,,但如果计算(DIAG1 DIAG1)不安全
Dialogue: 0,0:47:14.90,0:47:16.02,Default,,0,0,0,,那么它的结果是3
Dialogue: 0,0:47:16.02,0:47:17.26,Default,,0,0,0,,但是调用(DIAG1 DIAG1)又必须能够返回
Dialogue: 0,0:47:17.26,0:47:17.93,Default,,0,0,0,,所以它必须安全才行
Dialogue: 0,0:47:20.53,0:47:23.60,Default,,0,0,0,,因此 通过归纳出这个矛盾
Dialogue: 0,0:47:24.32,0:47:26.30,Default,,0,0,0,,我们无法写出这个SAFE?过程
Dialogue: 0,0:47:27.40,0:47:29.80,Default,,0,0,0,,如果大家没有听明白这种表述
Dialogue: 0,0:47:30.25,0:47:32.15,Default,,0,0,0,,我换个方式再讲一遍
Dialogue: 0,0:47:32.82,0:47:34.00,Default,,0,0,0,,请听另一个版本
Dialogue: 0,0:47:35.53,0:47:36.95,Default,,0,0,0,,我们定义DIAG2
Dialogue: 0,0:47:39.84,0:47:41.60,Default,,0,0,0,,取名叫DIAG是因为
Dialogue: 0,0:47:42.65,0:47:44.72,Default,,0,0,0,,它来源于康托尔的对角论证法
Dialogue: 0,0:47:45.00,0:47:47.05,Default,,0,0,0,,这些事例最初都来自于
Dialogue: 0,0:47:47.05,0:47:49.05,Default,,0,0,0,,一个著名的论证
Dialogue: 0,0:47:49.45,0:47:52.65,Default,,0,0,0,,也就是康托尔在19世纪末
Dialogue: 0,0:47:52.77,0:47:56.10,Default,,0,0,0,,证明了实数是不可数的
Dialogue: 0,0:47:56.67,0:47:58.00,Default,,0,0,0,,整数与实数
Dialogue: 0,0:47:58.06,0:47:59.42,Default,,0,0,0,,无法形成一一映射
Dialogue: 0,0:48:00.19,0:48:01.74,Default,,0,0,0,,数轴上的点
Dialogue: 0,0:48:01.74,0:48:02.50,Default,,0,0,0,,举例来说
Dialogue: 0,0:48:02.50,0:48:04.42,Default,,0,0,0,,比数轴上的刻度还要多
Dialogue: 0,0:48:05.26,0:48:06.85,Default,,0,0,0,,这或许不是个显而易见的结论
Dialogue: 0,0:48:06.85,0:48:08.17,Default,,0,0,0,,但我不想深入讨论这个
Dialogue: 0,0:48:10.90,0:48:12.45,Default,,0,0,0,,但是DIAG2
Dialogue: 0,0:48:13.30,0:48:15.82,Default,,0,0,0,,也是一个参数为P的单参过程
Dialogue: 0,0:48:15.82,0:48:17.47,Default,,0,0,0,,这几乎与之前的例子相同
Dialogue: 0,0:48:17.72,0:48:24.32,Default,,0,0,0,,如果计算(P P)是安全的
Dialogue: 0,0:48:25.17,0:48:26.67,Default,,0,0,0,,那么我就要
Dialogue: 0,0:48:27.26,0:48:28.14,Default,,0,0,0,,哦 漏了一个IF
Dialogue: 0,0:48:29.31,0:48:31.02,Default,,0,0,0,,那么我就去计算
Dialogue: 0,0:48:31.57,0:48:37.58,Default,,0,0,0,,一些(P P)之外的东西
Dialogue: 0,0:48:38.96,0:48:40.21,Default,,0,0,0,,否则我就返回FALSE
Dialogue: 0,0:48:43.60,0:48:45.30,Default,,0,0,0,,这里的OTHER-THAN意思是
Dialogue: 0,0:48:45.47,0:48:46.35,Default,,0,0,0,,不管这个(P P)是什么
Dialogue: 0,0:48:46.35,0:48:47.47,Default,,0,0,0,,我都返回一些别的东西
Dialogue: 0,0:48:48.88,0:48:50.03,Default,,0,0,0,,我来给出一个
Dialogue: 0,0:48:50.07,0:48:51.52,Default,,0,0,0,,OTHER-THAN的一个定义
Dialogue: 0,0:48:51.60,0:48:52.57,Default,,0,0,0,,我觉得它是可用的
Dialogue: 0,0:48:53.89,0:48:54.51,Default,,0,0,0,,来看看
Dialogue: 0,0:48:55.64,0:48:56.08,Default,,0,0,0,,好
Dialogue: 0,0:48:56.33,0:48:57.26,Default,,0,0,0,,定义OTHER-THAN
Dialogue: 0,0:49:04.03,0:49:06.11,Default,,0,0,0,,参数为X的单参过程
Dialogue: 0,0:49:06.57,0:49:07.26,Default,,0,0,0,,过程体是
Dialogue: 0,0:49:08.05,0:49:12.96,Default,,0,0,0,,如果(EQ? X 'A)
Dialogue: 0,0:49:13.47,0:49:15.07,Default,,0,0,0,,那么结果是'B
Dialogue: 0,0:49:15.72,0:49:16.80,Default,,0,0,0,,否则结果是'A
Dialogue: 0,0:49:20.27,0:49:21.90,Default,,0,0,0,,这样无论参数是什么
Dialogue: 0,0:49:22.07,0:49:23.45,Default,,0,0,0,,返回值跟参数总是不相同的
Dialogue: 0,0:49:25.20,0:49:26.12,Default,,0,0,0,,就是这样了
Dialogue: 0,0:49:26.54,0:49:27.37,Default,,0,0,0,,这就是我要的
Dialogue: 0,0:49:28.25,0:49:29.58,Default,,0,0,0,,我们考虑一下这个
Dialogue: 0,0:49:29.58,0:49:31.15,Default,,0,0,0,,(DIAG2 DIAG2)
Dialogue: 0,0:49:38.28,0:49:38.94,Default,,0,0,0,,看
Dialogue: 0,0:49:39.95,0:49:41.72,Default,,0,0,0,,这个东西会做些危险的事情
Dialogue: 0,0:49:42.00,0:49:43.45,Default,,0,0,0,,比如求值(P P)
Dialogue: 0,0:49:44.75,0:49:45.95,Default,,0,0,0,,如果它是安全的
Dialogue: 0,0:49:47.47,0:49:49.16,Default,,0,0,0,,如果SAFE?能够被定义的话
Dialogue: 0,0:49:50.30,0:49:52.49,Default,,0,0,0,,如果你能定义SAFE?过程
Dialogue: 0,0:49:52.97,0:49:54.32,Default,,0,0,0,,那么这个过程
Dialogue: 0,0:49:54.60,0:49:56.40,Default,,0,0,0,,也就顺理成章地是安全的
Dialogue: 0,0:49:56.52,0:49:57.22,Default,,0,0,0,,对于任意输入来说都是
Dialogue: 0,0:50:01.54,0:50:03.50,Default,,0,0,0,,那么(DIAG2 DIAG2)
Dialogue: 0,0:50:03.87,0:50:12.20,Default,,0,0,0,,就会返回(OTHER-THAN (DIAG2 DIAG2))
Dialogue: 0,0:50:15.82,0:50:16.97,Default,,0,0,0,,这说不通
Dialogue: 0,0:50:17.80,0:50:19.02,Default,,0,0,0,,又产生了悖论
Dialogue: 0,0:50:19.85,0:50:21.57,Default,,0,0,0,,因此我们不能定义SAFE?
Dialogue: 0,0:50:22.95,0:50:24.23,Default,,0,0,0,,我只想这样证明两次
Dialogue: 0,0:50:24.78,0:50:25.82,Default,,0,0,0,,有些许不同
Dialogue: 0,0:50:26.84,0:50:27.90,Default,,0,0,0,,你不会感到
Dialogue: 0,0:50:29.07,0:50:30.86,Default,,0,0,0,,第一个证明是个把戏
Dialogue: 0,0:50:32.54,0:50:33.45,Default,,0,0,0,,它们可能都是把戏
Dialogue: 0,0:50:33.80,0:50:35.15,Default,,0,0,0,,但它们稍微有些不同
Dialogue: 0,0:50:37.30,0:50:39.20,Default,,0,0,0,,因此 我想这就基本上讲清楚了
Dialogue: 0,0:50:40.03,0:50:41.97,Default,,0,0,0,,我们刚刚证明了所谓的“停机问题”
Dialogue: 0,0:50:43.00,0:50:44.70,Default,,0,0,0,,我想 本课程也即将画上句号
Dialogue: 0,0:50:46.72,0:50:47.63,Default,,0,0,0,,希望你们有所收获
Dialogue: 0,0:50:50.90,0:50:51.76,Default,,0,0,0,,有什么问题吗?
Dialogue: 0,0:50:53.30,0:50:53.56,Default,,0,0,0,,请讲
Dialogue: 0,0:50:53.81,0:50:56.27,Default,,0,0,0,,学生: (S DIAG1)的值是什么?
Dialogue: 0,0:50:56.75,0:50:57.23,Default,,0,0,0,,教授: 什么的值?
Dialogue: 0,0:50:57.50,0:50:58.80,Default,,0,0,0,,学生: (S DIAG1)的值
Dialogue: 0,0:51:00.12,0:51:02.20,Default,,0,0,0,,如果你说S是个函数 我们就可以--
Dialogue: 0,0:51:02.30,0:51:03.63,Default,,0,0,0,,教授: 噢 我不知道啊
Dialogue: 0,0:51:03.87,0:51:04.35,Default,,0,0,0,,我不知道
Dialogue: 0,0:51:04.35,0:51:04.88,Default,,0,0,0,,它是一个函数
Dialogue: 0,0:51:04.88,0:51:05.85,Default,,0,0,0,,但我不知道如何计算它
Dialogue: 0,0:51:06.80,0:51:08.00,Default,,0,0,0,,我做不到
Dialogue: 0,0:51:08.61,0:51:09.64,Default,,0,0,0,,我也只是个机器
Dialogue: 0,0:51:11.53,0:51:11.88,Default,,0,0,0,,对吧?
Dialogue: 0,0:51:11.90,0:51:13.37,Default,,0,0,0,,原则上来说
Dialogue: 0,0:51:13.37,0:51:14.05,Default,,0,0,0,,没有机器
Dialogue: 0,0:51:14.47,0:51:16.87,Default,,0,0,0,,当然 也有可能会处在你刚才问的那个情况中
Dialogue: 0,0:51:16.87,0:51:18.32,Default,,0,0,0,,花点时间还是可以计算出来
Dialogue: 0,0:51:18.58,0:51:19.37,Default,,0,0,0,,但通常情况下
Dialogue: 0,0:51:19.60,0:51:21.05,Default,,0,0,0,,我无法计算S的值
Dialogue: 0,0:51:21.05,0:51:22.52,Default,,0,0,0,,别的机器也做不到
Dialogue: 0,0:51:23.78,0:51:24.92,Default,,0,0,0,,存在这样一个函数
Dialogue: 0,0:51:25.92,0:51:28.00,Default,,0,0,0,,没有任何机器能够计算它
Dialogue: 0,0:51:29.58,0:51:30.05,Default,,0,0,0,,现在
Dialogue: 0,0:51:30.67,0:51:33.67,Default,,0,0,0,,我这么来说也不会让你们吃惊
Dialogue: 0,0:51:35.22,0:51:36.25,Default,,0,0,0,,来想一想
Dialogue: 0,0:51:36.25,0:51:38.36,Default,,0,0,0,,现在我没有时间给你们展示
Dialogue: 0,0:51:38.45,0:51:43.00,Default,,0,0,0,,但这样的函数非常多
Dialogue: 0,0:51:44.40,0:51:47.58,Default,,0,0,0,,如果有一定量的可能输入
Dialogue: 0,0:51:47.75,0:51:49.62,Default,,0,0,0,,和一定量可能的结果
Dialogue: 0,0:51:49.87,0:51:51.80,Default,,0,0,0,,那么结果数量的输入数量次幂
Dialogue: 0,0:51:51.80,0:51:53.20,Default,,0,0,0,,就是可能的函数的数量
Dialogue: 0,0:51:54.50,0:51:55.48,Default,,0,0,0,,这还是单参的函数
Dialogue: 0,0:51:56.51,0:51:59.24,Default,,0,0,0,,而多参函数的个数
Dialogue: 0,0:52:00.09,0:52:03.21,Default,,0,0,0,,又比这个幂次方
Dialogue: 0,0:52:03.58,0:52:04.32,Default,,0,0,0,,这个指数还要大
Dialogue: 0,0:52:05.48,0:52:09.80,Default,,0,0,0,,函数的数量
Dialogue: 0,0:52:09.95,0:52:12.72,Default,,0,0,0,,比一个人能写出的
Dialogue: 0,0:52:13.30,0:52:14.10,Default,,0,0,0,,程序的数量更多
Dialogue: 0,0:52:14.82,0:52:16.45,Default,,0,0,0,,因为有无穷多的参数
Dialogue: 0,0:52:17.57,0:52:19.00,Default,,0,0,0,,可能会更多
Dialogue: 0,0:52:19.47,0:52:22.12,Default,,0,0,0,,所以不可计算的函数数量
Dialogue: 0,0:52:22.12,0:52:23.48,Default,,0,0,0,,一定会非常多
Dialogue: 0,0:52:25.92,0:52:26.59,Default,,0,0,0,,学生：不久前
Dialogue: 0,0:52:26.64,0:52:28.25,Default,,0,0,0,,你讲了规范
Dialogue: 0,0:52:28.30,0:52:30.04,Default,,0,0,0,,和自动生成解决方案
Dialogue: 0,0:52:30.64,0:52:31.61,Default,,0,0,0,,您觉得通过规范
Dialogue: 0,0:52:31.82,0:52:33.36,Default,,0,0,0,,能够生成解决方案么？
Dialogue: 0,0:52:37.25,0:52:38.22,Default,,0,0,0,,教授：“生成”
Dialogue: 0,0:52:38.72,0:52:39.37,Default,,0,0,0,,你是说
Dialogue: 0,0:52:39.37,0:52:42.60,Default,,0,0,0,,如何按照规范
Dialogue: 0,0:52:42.60,0:52:44.78,Default,,0,0,0,,构建相应的装置吗?
Dialogue: 0,0:52:45.05,0:52:48.36,Default,,0,0,0,,学生：软件工程中有很多
Dialogue: 0,0:52:48.36,0:52:49.90,Default,,0,0,0,,层次化的设计
Dialogue: 0,0:52:49.90,0:52:51.90,Default,,0,0,0,,并进行实现的规范
Dialogue: 0,0:52:52.43,0:52:52.85,Default,,0,0,0,,教授：是的
Dialogue: 0,0:52:52.85,0:52:53.70,Default,,0,0,0,,学生：我很好奇
Dialogue: 0,0:52:53.70,0:52:54.62,Default,,0,0,0,,您觉得这现实吗?
Dialogue: 0,0:52:55.60,0:52:57.17,Default,,0,0,0,,教授：我觉得其中一些是现实的
Dialogue: 0,0:52:57.17,0:52:58.10,Default,,0,0,0,,另一些不现实
Dialogue: 0,0:52:58.10,0:53:00.32,Default,,0,0,0,,如果你想制造一个滤波器
Dialogue: 0,0:53:01.17,0:53:07.16,Default,,0,0,0,,我这有个挺有趣的例子
Dialogue: 0,0:53:07.16,0:53:09.42,Default,,0,0,0,,假设我想制造一个东西
Dialogue: 0,0:53:09.64,0:53:14.07,Default,,0,0,0,,把无线电发射器的输出
Dialogue: 0,0:53:14.47,0:53:18.75,Default,,0,0,0,,连接到某条天线上
Dialogue: 0,0:53:19.90,0:53:21.47,Default,,0,0,0,,我先把它引出来
Dialogue: 0,0:53:21.48,0:53:23.04,Default,,0,0,0,,这里是输出管线
Dialogue: 0,0:53:23.23,0:53:25.26,Default,,0,0,0,,问题是它们的阻抗不同
Dialogue: 0,0:53:25.92,0:53:27.55,Default,,0,0,0,,我希望能够匹配阻抗
Dialogue: 0,0:53:27.55,0:53:28.97,Default,,0,0,0,,我也想在其中加入一个滤波器
Dialogue: 0,0:53:29.15,0:53:31.71,Default,,0,0,0,,用来过滤一些谐波辐射
Dialogue: 0,0:53:32.78,0:53:36.63,Default,,0,0,0,,一种老派的技术叫作
Dialogue: 0,0:53:36.82,0:53:38.67,Default,,0,0,0,,“影像阻抗”之类的东西
Dialogue: 0,0:53:38.86,0:53:39.50,Default,,0,0,0,,你要做的是
Dialogue: 0,0:53:39.50,0:53:40.85,Default,,0,0,0,,你有个基础的模块
Dialogue: 0,0:53:40.85,0:53:42.75,Default,,0,0,0,,称为L型滤波器
Dialogue: 0,0:53:43.30,0:53:43.98,Default,,0,0,0,,就像这样
Dialogue: 0,0:53:47.08,0:53:49.80,Default,,0,0,0,,如果把它连接到某些电阻R上
Dialogue: 0,0:53:50.05,0:53:52.60,Default,,0,0,0,,如果我把它的阻抗记作X_L
Dialogue: 0,0:53:52.72,0:53:55.20,Default,,0,0,0,,而它的值刚好又等于Q*R
Dialogue: 0,0:53:55.26,0:53:58.52,Default,,0,0,0,,这就成了一个低通滤波器
Dialogue: 0,0:53:58.52,0:54:00.72,Default,,0,0,0,,有Q^2+1的等效阻抗
Dialogue: 0,0:54:02.11,0:54:02.86,Default,,0,0,0,,这就是我想要的
Dialogue: 0,0:54:03.12,0:54:04.28,Default,,0,0,0,,因为这样我就可以
Dialogue: 0,0:54:04.30,0:54:05.08,Default,,0,0,0,,把它们匹配到一起了
Dialogue: 0,0:54:05.82,0:54:06.38,Default,,0,0,0,,就像这样
Dialogue: 0,0:54:11.66,0:54:13.15,Default,,0,0,0,,我拿来另一个
Dialogue: 0,0:54:16.00,0:54:17.45,Default,,0,0,0,,想这样把它们连到一起
Dialogue: 0,0:54:18.29,0:54:19.95,Default,,0,0,0,,有两个L型滤波器连接起来
Dialogue: 0,0:54:20.32,0:54:23.07,Default,,0,0,0,,这能让它的阻抗降到我知道的值
Dialogue: 0,0:54:23.37,0:54:25.22,Default,,0,0,0,,让它的阻抗升到我知道的值
Dialogue: 0,0:54:25.53,0:54:26.64,Default,,0,0,0,,这两个低通滤波器
Dialogue: 0,0:54:26.67,0:54:27.82,Default,,0,0,0,,都过滤掉了一些谐波
Dialogue: 0,0:54:28.09,0:54:29.07,Default,,0,0,0,,这是个不错的滤波器
Dialogue: 0,0:54:29.07,0:54:30.27,Default,,0,0,0,,这就是π型滤波器
Dialogue: 0,0:54:30.27,0:54:30.62,Default,,0,0,0,,很好
Dialogue: 0,0:54:31.70,0:54:34.09,Default,,0,0,0,,除了实际上
Dialogue: 0,0:54:34.12,0:54:37.85,Default,,0,0,0,,我在系统里放了些无用的东西
Dialogue: 0,0:54:38.62,0:54:39.60,Default,,0,0,0,,我在本该只用一个的地方
Dialogue: 0,0:54:39.61,0:54:40.59,Default,,0,0,0,,用了两个线圈
Dialogue: 0,0:54:41.62,0:54:44.60,Default,,0,0,0,,在大多数软件工程技艺中
Dialogue: 0,0:54:44.89,0:54:46.88,Default,,0,0,0,,在人工优化和编译之外
Dialogue: 0,0:54:46.92,0:54:48.65,Default,,0,0,0,,不存在一种机制
Dialogue: 0,0:54:48.80,0:54:51.34,Default,,0,0,0,,能在自顶向下的设计中
Dialogue: 0,0:54:51.34,0:54:53.55,Default,,0,0,0,,去掉冗余的部分
Dialogue: 0,0:54:55.35,0:54:56.07,Default,,0,0,0,,或许会更糟
Dialogue: 0,0:54:56.07,0:54:57.58,Default,,0,0,0,,有很多重要的结构
Dialogue: 0,0:54:57.60,0:54:59.02,Default,,0,0,0,,你无法采用这种方式构建
Dialogue: 0,0:55:01.11,0:55:03.53,Default,,0,0,0,,我觉得标准的自上而下的设计方式
Dialogue: 0,0:55:03.53,0:55:04.87,Default,,0,0,0,,是一种很短视的手段
Dialogue: 0,0:55:05.71,0:55:06.60,Default,,0,0,0,,它不会真的抓到
Dialogue: 0,0:55:06.60,0:55:08.10,Default,,0,0,0,,设计者真正想要的结果
Dialogue: 0,0:55:08.31,0:55:10.10,Default,,0,0,0,,我再举一个电子学的例子
Dialogue: 0,0:55:10.10,0:55:11.75,Default,,0,0,0,,电子学的例子
Dialogue: 0,0:55:11.90,0:55:13.13,Default,,0,0,0,,要比计算的例子直观得多
Dialogue: 0,0:55:13.16,0:55:14.78,Default,,0,0,0,,因为计算的例子
Dialogue: 0,0:55:14.80,0:55:16.52,Default,,0,0,0,,解释起来比较复杂
Dialogue: 0,0:55:17.22,0:55:19.16,Default,,0,0,0,,在电子学世界中
Dialogue: 0,0:55:19.16,0:55:20.04,Default,,0,0,0,,我最喜欢的例子之一是
Dialogue: 0,0:55:20.60,0:55:22.80,Default,,0,0,0,,是如何设计中频放大器中
Dialogue: 0,0:55:23.28,0:55:26.55,Default,,0,0,0,,输入级和输出级的连接方式
Dialogue: 0,0:55:27.53,0:55:29.44,Default,,0,0,0,,这是一个三极管
Dialogue: 0,0:55:29.52,0:55:31.50,Default,,0,0,0,,我们来看看
Dialogue: 0,0:55:32.41,0:55:33.40,Default,,0,0,0,,这有个LC震荡电路
Dialogue: 0,0:55:36.45,0:55:39.17,Default,,0,0,0,,我要把它
Dialogue: 0,0:55:41.37,0:55:43.97,Default,,0,0,0,,把它与下一级的输入线圈耦合在一起
Dialogue: 0,0:55:44.36,0:55:47.47,Default,,0,0,0,,这是个完美的可行方案
Dialogue: 0,0:55:48.22,0:55:50.87,Default,,0,0,0,,除了我这个电流方向画错了
Dialogue: 0,0:55:50.87,0:55:52.92,Default,,0,0,0,,电流应该是这个方向
Dialogue: 0,0:55:53.17,0:55:55.45,Default,,0,0,0,,这是个完美的可行方案
Dialogue: 0,0:55:55.98,0:55:56.57,Default,,0,0,0,,不对
Dialogue: 0,0:55:57.12,0:55:57.79,Default,,0,0,0,,我犯蠢了
Dialogue: 0,0:55:58.40,0:55:59.07,Default,,0,0,0,,对不起
Dialogue: 0,0:55:59.69,0:56:00.42,Default,,0,0,0,,这不重要
Dialogue: 0,0:56:00.73,0:56:01.54,Default,,0,0,0,,关键在于这是一个
Dialogue: 0,0:56:01.54,0:56:03.42,Default,,0,0,0,,把两级耦合起来的完美方案
Dialogue: 0,0:56:04.54,0:56:06.92,Default,,0,0,0,,分层来看时会产生什么问题?
Dialogue: 0,0:56:07.62,0:56:08.80,Default,,0,0,0,,它就不是同一个东西了
Dialogue: 0,0:56:09.48,0:56:11.99,Default,,0,0,0,,当分层来看时它就没有任何意义了
Dialogue: 0,0:56:11.99,0:56:14.32,Default,,0,0,0,,这是一个调谐电路的电感
Dialogue: 0,0:56:15.55,0:56:18.02,Default,,0,0,0,,这是变压器的初级线圈
Dialogue: 0,0:56:19.10,0:56:21.82,Default,,0,0,0,,这是直流的通路
Dialogue: 0,0:56:21.82,0:56:23.57,Default,,0,0,0,,它是三极管的集电极
Dialogue: 0,0:56:23.57,0:56:25.10,Default,,0,0,0,,的偏置条件
Dialogue: 0,0:56:26.46,0:56:28.35,Default,,0,0,0,,没有任何简单的自顶向下设计
Dialogue: 0,0:56:28.38,0:56:30.17,Default,,0,0,0,,能够得到这样的结构
Dialogue: 0,0:56:30.22,0:56:34.02,Default,,0,0,0,,对于同一个东西有大量的复用
Dialogue: 0,0:56:34.53,0:56:36.72,Default,,0,0,0,,玩拼字游戏
Dialogue: 0,0:56:36.96,0:56:39.88,Default,,0,0,0,,当你要完成三倍分数的词时
Dialogue: 0,0:56:40.49,0:56:43.60,Default,,0,0,0,,自顶向下的设计策略并不容易
Dialogue: 0,0:56:44.95,0:56:47.08,Default,,0,0,0,,然而 大多数实际的工程学都是
Dialogue: 0,0:56:47.36,0:56:50.70,Default,,0,0,0,,秉承着“尽其力而为之”
Dialogue: 0,0:56:52.14,0:56:53.52,Default,,0,0,0,,那就是你所看到的东西
Dialogue: 0,0:56:54.86,0:56:55.55,Default,,0,0,0,,嗯？
Dialogue: 0,0:56:55.55,0:56:56.81,Default,,0,0,0,,学生：这是最后一个问题吗?
Dialogue: 0,0:57:00.28,0:57:02.03,Default,,0,0,0,,[笑声]
Dialogue: 0,0:57:18.64,0:57:19.63,Default,,0,0,0,,教授：看起来是
Dialogue: 0,0:57:23.57,0:57:24.12,Default,,0,0,0,,谢谢大家
Dialogue: 0,0:57:25.90,0:57:36.50,Default,,0,0,0,,[掌声]
Dialogue: 0,0:58:47.29,0:58:51.13,Declare,,0,0,0,,{\fad(500,500)}MIT OpenCourseWare\Nhttp://ocw.mit.edu
Dialogue: 0,0:58:47.29,0:58:51.13,Declare,,0,0,0,,{\an2\fad(500,500)}本项目主页\Nhttps://github.com/DeathKing/Learning-SICP
Dialogue: 0,0:58:51.87,0:58:53.71,Default,,0,0,0,,{\an4\pos(33,231)}　　你所知道的有关计算的东西，其他人也都能学到。绝不要认为\N\N\N似乎成功计算的钥匙就掌握在你的手里。你所掌握的，也是我认为\N\N\N并希望的，也就是智慧：那种看到这一机器比你第一次站在它面前\N\N\N时能做得更多的能力，这样你才能将它向前推进。\N\N\N\N\N　　　　　　　　　　　　　  　Alan J. Perlis (1922.4.1 - 1990.1.7)
