[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 640
PlayResY: 480

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: EN,Calisto MT,21,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,1,0,2,10,10,30,1
Style: Declare,微软雅黑,30,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,2,0,8,10,10,10,1
Style: staff,微软雅黑,30,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,0,2,5,10,10,10,1
Style: title,微软雅黑,35,&H001D64D9,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,0,1,5,10,10,10,1
Style: Default,雅黑宋体,20,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,1,0,2,10,10,30,1


[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:16.30,0:00:18.08,EN,,0,0,0,,PROFESSOR: Well, I hope you appreciate that we have
Dialogue: 0,0:00:20.01,0:00:22.73,EN,,0,0,0,,we have inducted you into some real magic,
Dialogue: 0,0:00:24.20,0:00:27.24,EN,,0,0,0,,the magic of building languages
Dialogue: 0,0:00:27.42,0:00:28.72,EN,,0,0,0,,really building new languages.
Dialogue: 0,0:00:29.69,0:00:30.40,EN,,0,0,0,,What have we looked at?
Dialogue: 0,0:00:30.43,0:00:32.78,EN,,0,0,0,,We've looked at an Escher picture language.
Dialogue: 0,0:00:38.92,0:00:41.15,EN,,0,0,0,,OK? this language invented by Peter Henderson.
Dialogue: 0,0:00:42.01,0:00:46.49,EN,,0,0,0,,We looked at digital logic language.
Dialogue: 0,0:00:53.16,0:00:55.55,EN,,0,0,0,,Let's see.We've looked at the query language.
Dialogue: 0,0:00:59.70,0:01:00.78,EN,,0,0,0,,And the thing you should realize is,
Dialogue: 0,0:01:00.81,0:01:03.10,EN,,0,0,0,,even though these were toy examples,
Dialogue: 0,0:01:04.70,0:01:07.61,EN,,0,0,0,,they really are the kernels of really useful things.
Dialogue: 0,0:01:08.25,0:01:09.48,EN,,0,0,0,,So, for instance,
Dialogue: 0,0:01:10.12,0:01:11.18,EN,,0,0,0,,the Escher picture language
Dialogue: 0,0:01:11.20,0:01:14.33,EN,,0,0,0,,was taken byHenry Wu, who's a student at MIT,
Dialogue: 0,0:01:14.88,0:01:16.43,EN,,0,0,0,,and developed into a real
Dialogue: 0,0:01:16.97,0:01:19.45,EN,,0,0,0,,language for laying out PC boards,
Dialogue: 0,0:01:20.35,0:01:22.56,EN,,0,0,0,,based just on extending those structures.
Dialogue: 0,0:01:23.24,0:01:24.65,EN,,0,0,0,,And the digital logic language,
Dialogue: 0,0:01:24.68,0:01:26.08,EN,,0,0,0,,Gerry mentioned when he showed it to you,
Dialogue: 0,0:01:26.43,0:01:29.92,EN,,0,0,0,,was really extended to be used as the basis for a simulator
Dialogue: 0,0:01:30.85,0:01:32.96,EN,,0,0,0,,that was used to design a real computer.
Dialogue: 0,0:01:33.46,0:01:34.32,EN,,0,0,0,,And the query language,
Dialogue: 0,0:01:34.35,0:01:36.44,EN,,0,0,0,,of course, is kind of the germ of prolog.
Dialogue: 0,0:01:37.51,0:01:39.07,EN,,0,0,0,,So we built all of these languages,
Dialogue: 0,0:01:39.55,0:01:40.65,EN,,0,0,0,,they're all based on LISP.
Dialogue: 0,0:01:43.63,0:01:44.59,EN,,0,0,0,,A lot of people ask
Dialogue: 0,0:01:45.27,0:01:48.73,EN,,0,0,0,,what particular problems is LISP good for solving for?
Dialogue: 0,0:01:48.75,0:01:49.93,EN,,0,0,0,,The answer is LISP is not...
Dialogue: 0,0:01:50.33,0:01:52.65,EN,,0,0,0,,LISP is not good for solving any particular problems.
Dialogue: 0,0:01:53.53,0:01:54.60,EN,,0,0,0,,What LISP is good for
Dialogue: 0,0:01:54.73,0:01:57.15,EN,,0,0,0,,is constructing within it the right language
Dialogue: 0,0:01:57.18,0:01:58.57,EN,,0,0,0,,to solve the problems you want to solve,
Dialogue: 0,0:01:59.17,0:02:00.44,EN,,0,0,0,,and that's how you should think about it.
Dialogue: 0,0:02:01.47,0:02:03.39,EN,,0,0,0,,So all of these languages were based on LISP.
Dialogue: 0,0:02:04.57,0:02:05.72,EN,,0,0,0,,Now, what's LISP based on?
Dialogue: 0,0:02:06.97,0:02:07.88,EN,,0,0,0,,Where's that come from?
Dialogue: 0,0:02:07.90,0:02:09.40,EN,,0,0,0,,Well, we looked at that too.
Dialogue: 0,0:02:09.58,0:02:16.09,EN,,0,0,0,,We looked at the meta-circular evaluator
Dialogue: 0,0:02:21.53,0:02:23.40,EN,,0,0,0,,the meta-circular evaluator and sort of said
Dialogue: 0,0:02:23.42,0:02:25.76,EN,,0,0,0,,well, LISP is based on LISP.
Dialogue: 0,0:02:25.80,0:02:27.48,EN,,0,0,0,,And when we start looking at that,
Dialogue: 0,0:02:28.27,0:02:29.95,EN,,0,0,0,,we've got to do some real magic, right?
Dialogue: 0,0:02:29.95,0:02:31.74,EN,,0,0,0,,So what does that mean, right?
Dialogue: 0,0:02:31.74,0:02:34.96,EN,,0,0,0,,Y operators, and fixed points,
Dialogue: 0,0:02:35.76,0:02:38.33,EN,,0,0,0,,and the idea that what this means is
Dialogue: 0,0:02:38.36,0:02:41.44,EN,,0,0,0,,that LISP is somehow the fixed-point equation for the
Dialogue: 0,0:02:42.20,0:02:45.42,EN,,0,0,0,,for this funny set of things which are defined in terms of themselves.
Dialogue: 0,0:02:47.40,0:02:48.56,EN,,0,0,0,,Now, it's real magic.
Dialogue: 0,0:02:49.07,0:02:52.35,EN,,0,0,0,,Well, today, for a final piece of magic,
Dialogue: 0,0:02:52.62,0:02:54.03,EN,,0,0,0,,we're going to make all the magic go away.
Dialogue: 0,0:03:06.80,0:03:07.98,EN,,0,0,0,,We already know how to do that.
Dialogue: 0,0:03:09.77,0:03:10.76,EN,,0,0,0,,The idea is, we're going to take
Dialogue: 0,0:03:11.13,0:03:12.73,EN,,0,0,0,,the register machine architecture
Dialogue: 0,0:03:13.36,0:03:15.50,EN,,0,0,0,,and show how to implement LISP on terms of that.
Dialogue: 0,0:03:15.50,0:03:17.93,EN,,0,0,0,,And, remember, the idea of the register machine
Dialogue: 0,0:03:19.60,0:03:24.68,EN,,0,0,0,,is that there's a fixed and finite part of the machine.
Dialogue: 0,0:03:24.72,0:03:26.12,EN,,0,0,0,,There's a finite-state controller,
Dialogue: 0,0:03:26.12,0:03:27.87,EN,,0,0,0,,which dose particular thing
Dialogue: 0,0:03:27.88,0:03:29.31,EN,,0,0,0,,with a particular amount of hardware.
Dialogue: 0,0:03:30.51,0:03:31.74,EN,,0,0,0,,There are particular data paths,
Dialogue: 0,0:03:31.76,0:03:33.24,EN,,0,0,0,,the operation the machine does
Dialogue: 0,0:03:33.55,0:03:35.29,EN,,0,0,0,,And then, in order to implement recursion
Dialogue: 0,0:03:35.53,0:03:37.60,EN,,0,0,0,,and sustain the illusion of infinity,
Dialogue: 0,0:03:37.82,0:03:39.77,EN,,0,0,0,,there's some large amount of memory, which is the stack.
Dialogue: 0,0:03:42.06,0:03:43.72,EN,,0,0,0,,So, if we implement LISP
Dialogue: 0,0:03:43.92,0:03:45.50,EN,,0,0,0,,in terms of a register machine,
Dialogue: 0,0:03:47.02,0:03:48.35,EN,,0,0,0,,then everything ought to become,
Dialogue: 0,0:03:48.40,0:03:49.85,EN,,0,0,0,,at this point,completely concrete.
Dialogue: 0,0:03:49.85,0:03:51.23,EN,,0,0,0,,All the magic should go away.
Dialogue: 0,0:03:51.65,0:03:53.52,EN,,0,0,0,,And, by the end of this talk,
Dialogue: 0,0:03:53.53,0:03:54.78,EN,,0,0,0,,I want you get the feeling
Dialogue: 0,0:03:55.14,0:03:59.05,EN,,0,0,0,,that, as opposed to this very mysterious meta-circular evaluator
Dialogue: 0,0:03:59.67,0:04:02.60,EN,,0,0,0,,that a LISP evaluator really is something that's concrete enough
Dialogue: 0,0:04:02.85,0:04:04.57,EN,,0,0,0,,that you can hold in the palm of your hand.
Dialogue: 0,0:04:04.76,0:04:06.24,EN,,0,0,0,,You should be able to imagine holding
Dialogue: 0,0:04:06.57,0:04:07.90,EN,,0,0,0,,holding a LISP interpreter there.
Dialogue: 0,0:04:09.63,0:04:10.94,EN,,0,0,0,,All right, how are we going to do this?
Dialogue: 0,0:04:10.95,0:04:12.76,EN,,0,0,0,,We already have all the ingredients.
Dialogue: 0,0:04:13.96,0:04:17.45,EN,,0,0,0,,See, what you learned last time from Gerry
Dialogue: 0,0:04:17.60,0:04:21.47,EN,,0,0,0,,is how to take any particular couple of LISP procedures.
Dialogue: 0,0:04:22.60,0:04:24.28,EN,,0,0,0,,and hand-translate them
Dialogue: 0,0:04:24.75,0:04:26.67,EN,,0,0,0,,into something that runs on a register machine.
Dialogue: 0,0:04:28.20,0:04:30.52,EN,,0,0,0,,So, to implement all of LISP on a register machine,
Dialogue: 0,0:04:30.57,0:04:31.44,EN,,0,0,0,,all we have to do
Dialogue: 0,0:04:31.69,0:04:33.45,EN,,0,0,0,,is take the particular procedures
Dialogue: 0,0:04:33.68,0:04:35.42,EN,,0,0,0,,that are the meta-circular evaluator
Dialogue: 0,0:04:36.17,0:04:38.11,EN,,0,0,0,,and hand-translate them for a register machine.
Dialogue: 0,0:04:39.04,0:04:40.25,EN,,0,0,0,,And that does all of LISP
Dialogue: 0,0:04:42.14,0:04:43.00,EN,,0,0,0,,Right? So, in principle,
Dialogue: 0,0:04:43.02,0:04:44.43,EN,,0,0,0,,we already know how to do this.
Dialogue: 0,0:04:45.38,0:04:46.54,EN,,0,0,0,,And, indeed, it's going to be no
Dialogue: 0,0:04:46.68,0:04:48.86,EN,,0,0,0,,no different, in kind,
Dialogue: 0,0:04:50.00,0:04:53.40,EN,,0,0,0,,from in say recursive factorial
Dialogue: 0,0:04:53.42,0:04:54.67,EN,,0,0,0,,or recursive Fibonacci.
Dialogue: 0,0:04:54.67,0:04:56.00,EN,,0,0,0,,It's just bigger and there's more of it.
Dialogue: 0,0:04:56.84,0:04:58.03,EN,,0,0,0,,So it'd just be more details,
Dialogue: 0,0:04:58.04,0:04:59.66,EN,,0,0,0,,but nothing really conceptually new.
Dialogue: 0,0:05:01.48,0:05:03.02,EN,,0,0,0,,And also, when we've done that,
Dialogue: 0,0:05:03.08,0:05:04.76,EN,,0,0,0,,and the thing is completely explicit,
Dialogue: 0,0:05:04.87,0:05:06.91,EN,,0,0,0,,and we see how to implement LISP
Dialogue: 0,0:05:06.94,0:05:10.08,EN,,0,0,0,,in terms of the actual sequential register operations,
Dialogue: 0,0:05:10.16,0:05:11.63,EN,,0,0,0,,that's going to be our final
Dialogue: 0,0:05:11.95,0:05:14.16,EN,,0,0,0,,most explicit model of LISP in this course.
Dialogue: 0,0:05:14.81,0:05:16.95,EN,,0,0,0,,And, remember, that's a progression through this course.
Dialogue: 0,0:05:16.95,0:05:18.25,EN,,0,0,0,,We started out with substitution,
Dialogue: 0,0:05:18.28,0:05:19.58,EN,,0,0,0,,which is sort of like algebra.
Dialogue: 0,0:05:20.24,0:05:21.87,EN,,0,0,0,,And then we went to the environment model,
Dialogue: 0,0:05:21.88,0:05:24.00,EN,,0,0,0,,which talked about the actual frames
Dialogue: 0,0:05:24.03,0:05:25.31,EN,,0,0,0,,and how they got linked together.
Dialogue: 0,0:05:26.32,0:05:27.88,EN,,0,0,0,,And then we made that more concrete
Dialogue: 0,0:05:27.90,0:05:29.36,EN,,0,0,0,,in the meta-circular evaluator.
Dialogue: 0,0:05:31.05,0:05:31.64,EN,,0,0,0,,There are things
Dialogue: 0,0:05:31.87,0:05:33.98,EN,,0,0,0,,the meta-circular evaluator doesn't tell us.
Dialogue: 0,0:05:34.36,0:05:35.34,EN,,0,0,0,,You should realize that.
Dialogue: 0,0:05:36.09,0:05:38.64,EN,,0,0,0,,For instance, it left unanswered the question
Dialogue: 0,0:05:38.73,0:05:42.67,EN,,0,0,0,,of how a procedure, like recursive factorial here,
Dialogue: 0,0:05:45.17,0:05:47.13,EN,,0,0,0,,somehow takes space that grows.
Dialogue: 0,0:05:47.21,0:05:47.98,EN,,0,0,0,,On the other hand,
Dialogue: 0,0:05:48.16,0:05:51.94,EN,,0,0,0,,a procedure which also looks syntactically recursive,
Dialogue: 0,0:05:52.11,0:05:55.07,EN,,0,0,0,,called fact-iter, somehow doesn't take space.
Dialogue: 0,0:05:55.10,0:05:59.16,EN,,0,0,0,,We justify that it doesn't need to take space
Dialogue: 0,0:06:00.50,0:06:01.96,EN,,0,0,0,,by showing the substitution model.
Dialogue: 0,0:06:01.96,0:06:02.94,EN,,0,0,0,,But we didn't really say
Dialogue: 0,0:06:03.42,0:06:06.76,EN,,0,0,0,,how it happens that the machine manages to do that,
Dialogue: 0,0:06:07.31,0:06:08.91,EN,,0,0,0,,that that has to do with the details
Dialogue: 0,0:06:09.02,0:06:11.12,EN,,0,0,0,,of how arguments are passed to procedures
Dialogue: 0,0:06:12.48,0:06:13.69,EN,,0,0,0,,And that's the thing we didn't see
Dialogue: 0,0:06:13.71,0:06:15.34,EN,,0,0,0,,in the meta-circular evaluator
Dialogue: 0,0:06:15.36,0:06:17.40,EN,,0,0,0,,precisely because the way arguments
Dialogue: 0,0:06:17.42,0:06:19.20,EN,,0,0,0,,got passed to procedures in this LISP
Dialogue: 0,0:06:19.70,0:06:20.59,EN,,0,0,0,,depended on
Dialogue: 0,0:06:21.02,0:06:23.50,EN,,0,0,0,,the way arguments got passed to procedures in this LISP.
Dialogue: 0,0:06:25.87,0:06:29.02,EN,,0,0,0,,But, now, that's going to become extremely explicit.
Dialogue: 0,0:06:30.74,0:06:31.12,EN,,0,0,0,,OK.
Dialogue: 0,0:06:31.23,0:06:34.30,EN,,0,0,0,,Well, before going on to the evaluator,
Dialogue: 0,0:06:34.36,0:06:35.53,EN,,0,0,0,,let me just give you a sense of
Dialogue: 0,0:06:35.55,0:06:37.00,EN,,0,0,0,,what a whole LISP system looks like
Dialogue: 0,0:06:37.60,0:06:39.36,EN,,0,0,0,,so you can see the parts we're going to talk about
Dialogue: 0,0:06:39.40,0:06:40.81,EN,,0,0,0,,and the parts we're not going to talk about.
Dialogue: 0,0:06:43.18,0:06:47.42,EN,,0,0,0,,Let's see, over here is a happy LISP user,
Dialogue: 0,0:06:48.67,0:06:52.65,EN,,0,0,0,,and the LISP user is talking to something called the reader.
Dialogue: 0,0:07:00.36,0:07:01.53,EN,,0,0,0,,The reader's job in life
Dialogue: 0,0:07:01.95,0:07:13.23,EN,,0,0,0,,is to take characters from the user
Dialogue: 0,0:07:14.17,0:07:16.62,EN,,0,0,0,,and turn them into data structures
Dialogue: 0,0:07:17.20,0:07:19.37,EN,,0,0,0,,in something called a list structure memory.
Dialogue: 0,0:07:30.00,0:07:31.72,EN,,0,0,0,,All right, so the reader is going to take
Dialogue: 0,0:07:32.65,0:07:33.95,EN,,0,0,0,,symbols, parentheses,
Dialogue: 0,0:07:34.48,0:07:37.12,EN,,0,0,0,,and A's and B's, and 1s and 3s that you type in,
Dialogue: 0,0:07:37.18,0:07:39.04,EN,,0,0,0,,and turn these into actual list structure:
Dialogue: 0,0:07:39.15,0:07:40.54,EN,,0,0,0,,pairs, and pointers, and things.
Dialogue: 0,0:07:42.35,0:07:43.92,EN,,0,0,0,,And so, by the time evaluator is going,
Dialogue: 0,0:07:43.93,0:07:45.10,EN,,0,0,0,,there are no characters in the world.
Dialogue: 0,0:07:45.85,0:07:48.16,EN,,0,0,0,,And, of course, in more modern Lisp systems, there's
Dialogue: 0,0:07:49.00,0:07:50.44,EN,,0,0,0,,there's sort a big morass here
Dialogue: 0,0:07:50.44,0:07:52.17,EN,,0,0,0,,that might sit between the user and the reader:
Dialogue: 0,0:07:52.41,0:07:54.52,EN,,0,0,0,,you know, Windows systems, in top levels,
Dialogue: 0,0:07:54.77,0:07:56.03,EN,,0,0,0,,and mice, and all kinds of things.
Dialogue: 0,0:07:56.28,0:07:58.20,EN,,0,0,0,,But conceptually, characters are coming in.
Dialogue: 0,0:07:59.93,0:08:04.32,EN,,0,0,0,,All right, the reader transforms these into pointers
Dialogue: 0,0:08:05.56,0:08:07.28,EN,,0,0,0,,pointers to stuff in this memory,
Dialogue: 0,0:08:08.27,0:08:10.94,EN,,0,0,0,,and that's what the evaluator sees
Dialogue: 0,0:08:15.55,0:08:16.04,EN,,0,0,0,,OK?
Dialogue: 0,0:08:17.02,0:08:18.88,EN,,0,0,0,,The evaluator has a bunch of helpers.
Dialogue: 0,0:08:19.78,0:08:23.16,EN,,0,0,0,,It has all possible primitive operators you might want.
Dialogue: 0,0:08:23.16,0:08:24.91,EN,,0,0,0,,So there's a completely separate box,
Dialogue: 0,0:08:28.40,0:08:30.25,EN,,0,0,0,,a floating point unit,
Dialogue: 0,0:08:32.22,0:08:34.40,EN,,0,0,0,,or all sorts of things, which do the primitive operators.
Dialogue: 0,0:08:35.39,0:08:37.68,EN,,0,0,0,,there's and, if you want more special primitives,
Dialogue: 0,0:08:37.71,0:08:39.02,EN,,0,0,0,,you build more primitive operators,
Dialogue: 0,0:08:39.05,0:08:40.48,EN,,0,0,0,,but they're separate from the evaluator.
Dialogue: 0,0:08:42.08,0:08:43.77,EN,,0,0,0,,The evaluator finally gets an answer
Dialogue: 0,0:08:45.16,0:08:46.76,EN,,0,0,0,,and communicates that to the printer.
Dialogue: 0,0:08:50.62,0:08:52.01,EN,,0,0,0,,And now, the printer's job in life
Dialogue: 0,0:08:52.01,0:08:54.54,EN,,0,0,0,,is this list structure coming from the evaluator,
Dialogue: 0,0:08:55.39,0:08:56.99,EN,,0,0,0,,and turn it back into characters,
Dialogue: 0,0:09:01.85,0:09:04.07,EN,,0,0,0,,and communicate them to the user through
Dialogue: 0,0:09:04.28,0:09:05.66,EN,,0,0,0,,whatever interface there is.
Dialogue: 0,0:09:08.05,0:09:11.23,EN,,0,0,0,,OK. Well, today, what we're going to talk about is this evaluator.
Dialogue: 0,0:09:12.67,0:09:15.20,EN,,0,0,0,,The primitive operators have nothing particular to do with LISP,
Dialogue: 0,0:09:15.20,0:09:18.14,EN,,0,0,0,,they're however you like to implement primitive operations.
Dialogue: 0,0:09:19.36,0:09:22.18,EN,,0,0,0,,The reader and printer are actually complicated,
Dialogue: 0,0:09:22.18,0:09:23.55,EN,,0,0,0,,but we're not going to talk about them.
Dialogue: 0,0:09:24.68,0:09:27.10,EN,,0,0,0,,They sort of have to do with details of how you might build
Dialogue: 0,0:09:27.10,0:09:28.92,EN,,0,0,0,,build up list structure from characters.
Dialogue: 0,0:09:29.90,0:09:31.18,EN,,0,0,0,,So that is a long story,
Dialogue: 0,0:09:31.18,0:09:32.32,EN,,0,0,0,,but we're not going to talk about it,
Dialogue: 0,0:09:32.49,0:09:33.69,EN,,0,0,0,,the list structure memory,
Dialogue: 0,0:09:34.36,0:09:35.63,EN,,0,0,0,,we'll talk about next time.
Dialogue: 0,0:09:36.93,0:09:39.72,EN,,0,0,0,,So, pretty much, except for the details of reading and printing,
Dialogue: 0,0:09:40.12,0:09:41.71,EN,,0,0,0,,the only mystery that's going to be left
Dialogue: 0,0:09:41.72,0:09:43.05,EN,,0,0,0,,after you see the evaluator
Dialogue: 0,0:09:43.25,0:09:45.85,EN,,0,0,0,,is how you build list structure on conventional memories.
Dialogue: 0,0:09:46.65,0:09:48.20,EN,,0,0,0,,But we'll worry about that next time too.
Dialogue: 0,0:09:50.58,0:09:51.04,EN,,0,0,0,,OK.
Dialogue: 0,0:09:53.34,0:09:56.11,EN,,0,0,0,,Well, let's start talking about the evaluator.
Dialogue: 0,0:09:56.20,0:09:58.32,EN,,0,0,0,,The one that we're going to show you,
Dialogue: 0,0:09:58.49,0:10:01.12,EN,,0,0,0,,of course, is not, I think, nothing special about it.
Dialogue: 0,0:10:01.15,0:10:04.56,EN,,0,0,0,,It's just a particular register machine that runs LISP.
Dialogue: 0,0:10:04.81,0:10:06.09,EN,,0,0,0,,And it has seven registers,
Dialogue: 0,0:10:07.88,0:10:09.26,EN,,0,0,0,,and here are the seven registers.
Dialogue: 0,0:10:09.89,0:10:12.38,EN,,0,0,0,,There's a register, called EXP
Dialogue: 0,0:10:14.12,0:10:15.53,EN,,0,0,0,,and its job is to hold
Dialogue: 0,0:10:16.36,0:10:18.03,EN,,0,0,0,,the expression to be evaluated.
Dialogue: 0,0:10:18.37,0:10:19.80,EN,,0,0,0,,And by that, I mean
Dialogue: 0,0:10:20.38,0:10:21.64,EN,,0,0,0,,it's going to hold a pointer
Dialogue: 0,0:10:22.03,0:10:23.55,EN,,0,0,0,,to someplace in list structure memory
Dialogue: 0,0:10:23.56,0:10:25.32,EN,,0,0,0,,the expression to be evaluated.
Dialogue: 0,0:10:26.55,0:10:27.82,EN,,0,0,0,,There's a register, called ENV,
Dialogue: 0,0:10:28.88,0:10:30.28,EN,,0,0,0,,which holds the environment
Dialogue: 0,0:10:31.00,0:10:33.05,EN,,0,0,0,,in which this expression is to be evaluated.
Dialogue: 0,0:10:34.07,0:10:35.02,EN,,0,0,0,,And, again, I made a pointer.
Dialogue: 0,0:10:35.02,0:10:36.75,EN,,0,0,0,,The environment is some data structure.
Dialogue: 0,0:10:38.24,0:10:40.14,EN,,0,0,0,,There's a register, called FUN, which will
Dialogue: 0,0:10:40.75,0:10:42.54,EN,,0,0,0,,which will hold the procedure to be applied
Dialogue: 0,0:10:42.57,0:10:43.96,EN,,0,0,0,,when you go to apply a procedure.
Dialogue: 0,0:10:44.56,0:10:46.24,EN,,0,0,0,,A register, called ARGL,
Dialogue: 0,0:10:47.36,0:10:49.34,EN,,0,0,0,,which holds the list of evaluated arguments.
Dialogue: 0,0:10:50.54,0:10:51.60,EN,,0,0,0,,What you can start seeing here is
Dialogue: 0,0:10:51.63,0:10:53.14,EN,,0,0,0,,the basic structure of the evaluator.
Dialogue: 0,0:10:53.14,0:10:54.49,EN,,0,0,0,,Remember how evaluators work.
Dialogue: 0,0:10:54.49,0:10:56.62,EN,,0,0,0,,There's a piece that takes expressions and environments,
Dialogue: 0,0:10:57.67,0:10:59.71,EN,,0,0,0,,and there's a piece that takes functions
Dialogue: 0,0:10:59.74,0:11:02.14,EN,,0,0,0,,or procedures and arguments.
Dialogue: 0,0:11:03.48,0:11:06.30,EN,,0,0,0,,And going back and forth around here is the eval/apply loop.
Dialogue: 0,0:11:07.40,0:11:09.69,EN,,0,0,0,,So those are the basic pieces of the eval and apply.
Dialogue: 0,0:11:10.20,0:11:10.99,EN,,0,0,0,,Then there's some other things,
Dialogue: 0,0:11:11.00,0:11:11.61,EN,,0,0,0,,there's continue.
Dialogue: 0,0:11:11.61,0:11:15.34,EN,,0,0,0,,You just saw before how the continue register is used to
Dialogue: 0,0:11:15.34,0:11:18.04,EN,,0,0,0,,implement recursion and stack discipline.
Dialogue: 0,0:11:18.94,0:11:20.68,EN,,0,0,0,,There's a register that's going to hold the
Dialogue: 0,0:11:20.94,0:11:22.52,EN,,0,0,0,,result of some evaluation.
Dialogue: 0,0:11:24.14,0:11:24.89,EN,,0,0,0,,And then, besides that,
Dialogue: 0,0:11:24.89,0:11:26.43,EN,,0,0,0,,there's one temporary register,
Dialogue: 0,0:11:26.70,0:11:27.29,EN,,0,0,0,,called UNEV,
Dialogue: 0,0:11:27.29,0:11:29.04,EN,,0,0,0,,which typically, in the evaluator,
Dialogue: 0,0:11:29.28,0:11:32.72,EN,,0,0,0,,is going to be used to hold temporary pieces of the
Dialogue: 0,0:11:32.89,0:11:33.95,EN,,0,0,0,,expression you're working on,
Dialogue: 0,0:11:33.95,0:11:35.72,EN,,0,0,0,,which you haven't gotten around to evaluate yet
Dialogue: 0,0:11:36.97,0:11:39.82,EN,,0,0,0,,Right? So there's my machine: a seven-register machine.
Dialogue: 0,0:11:40.96,0:11:42.98,EN,,0,0,0,,And, of course, you might want to make a machine with
Dialogue: 0,0:11:42.98,0:11:44.96,EN,,0,0,0,,a lot more registers to get better performance,
Dialogue: 0,0:11:44.97,0:11:47.05,EN,,0,0,0,,but this is just a tiny, minimal one.
Dialogue: 0,0:11:48.48,0:11:49.58,EN,,0,0,0,,Well, how about the data paths?
Dialogue: 0,0:11:49.78,0:11:53.66,EN,,0,0,0,,This machine has a lot of special operations for LISP.
Dialogue: 0,0:11:55.10,0:11:58.08,EN,,0,0,0,,So, here are some typical data paths.
Dialogue: 0,0:12:00.12,0:12:01.04,EN,,0,0,0,,A typical one might be,
Dialogue: 0,0:12:01.37,0:12:03.40,EN,,0,0,0,,oh, assign to the VAL register
Dialogue: 0,0:12:03.40,0:12:04.80,EN,,0,0,0,,the contents of the EXP register.
Dialogue: 0,0:12:05.71,0:12:08.01,EN,,0,0,0,,That's in terms of those diagrams you saw,
Dialogue: 0,0:12:08.03,0:12:10.81,EN,,0,0,0,,that's a little button on some arrow.
Dialogue: 0,0:12:11.90,0:12:13.13,EN,,0,0,0,,Here's a more complicated one.
Dialogue: 0,0:12:13.69,0:12:14.80,EN,,0,0,0,,It says branch,
Dialogue: 0,0:12:15.23,0:12:19.58,EN,,0,0,0,,if the thing in the expression register is a conditional
Dialogue: 0,0:12:20.49,0:12:22.72,EN,,0,0,0,,to some label here, called the ev-conditional.
Dialogue: 0,0:12:23.80,0:12:26.23,EN,,0,0,0,,And you can imagine this implemented in a lot of different ways.
Dialogue: 0,0:12:26.23,0:12:28.36,EN,,0,0,0,,You might imagine this conditional test
Dialogue: 0,0:12:28.36,0:12:29.98,EN,,0,0,0,,as a special purpose sub-routine,
Dialogue: 0,0:12:30.60,0:12:33.95,EN,,0,0,0,,and conditional might be represented as some data abstraction
Dialogue: 0,0:12:33.96,0:12:36.00,EN,,0,0,0,,that you don't care about at this level of detail.
Dialogue: 0,0:12:36.61,0:12:37.98,EN,,0,0,0,,So that might be done as a sub-routine.
Dialogue: 0,0:12:37.98,0:12:40.67,EN,,0,0,0,,This might be a machine with hardware-types,
Dialogue: 0,0:12:40.90,0:12:44.04,EN,,0,0,0,,and conditional might be testing some bits for a particular code.
Dialogue: 0,0:12:45.35,0:12:46.41,EN,,0,0,0,,There are all sorts of ways that's
Dialogue: 0,0:12:46.41,0:12:48.48,EN,,0,0,0,,beneath the level of abstraction we're looking at.
Dialogue: 0,0:12:50.19,0:12:51.71,EN,,0,0,0,,Another kind of operation,
Dialogue: 0,0:12:51.71,0:12:53.24,EN,,0,0,0,,and there are a lot of different operations
Dialogue: 0,0:12:53.24,0:12:56.65,EN,,0,0,0,,assigned to EXP, the first clause of what's in EXP.
Dialogue: 0,0:12:56.84,0:12:58.89,EN,,0,0,0,,This might be part of processing a conditional.
Dialogue: 0,0:12:59.26,0:13:01.80,EN,,0,0,0,,And, again, first clause is some selector
Dialogue: 0,0:13:03.07,0:13:04.48,EN,,0,0,0,,whose details we don't care about.
Dialogue: 0,0:13:04.49,0:13:06.46,EN,,0,0,0,,And you can, again, imagine that as a sub-routine
Dialogue: 0,0:13:06.46,0:13:07.90,EN,,0,0,0,,which'll do some list operations,
Dialogue: 0,0:13:08.22,0:13:09.18,EN,,0,0,0,,or you can imagine that as
Dialogue: 0,0:13:09.18,0:13:10.73,EN,,0,0,0,,something that's built directly into hardware.
Dialogue: 0,0:13:12.17,0:13:13.71,EN,,0,0,0,,The reason I keep saying you can imagine it
Dialogue: 0,0:13:14.03,0:13:15.22,EN,,0,0,0,,built directly into hardware
Dialogue: 0,0:13:15.22,0:13:17.80,EN,,0,0,0,,is even though there are a lot of operations,
Dialogue: 0,0:13:18.36,0:13:19.74,EN,,0,0,0,,there are still a fixed number of them.
Dialogue: 0,0:13:20.12,0:13:21.80,EN,,0,0,0,,I forget how many, maybe 150.
Dialogue: 0,0:13:22.37,0:13:25.39,EN,,0,0,0,,So, it's plausible to think of building these directly into hardware.
Dialogue: 0,0:13:26.41,0:13:27.68,EN,,0,0,0,,Here's a more complicated one.
Dialogue: 0,0:13:28.27,0:13:29.47,EN,,0,0,0,,You can see this has to do with
Dialogue: 0,0:13:29.47,0:13:31.10,EN,,0,0,0,,looking up the values of variables.
Dialogue: 0,0:13:31.50,0:13:33.28,EN,,0,0,0,,It says assign to the VAL register
Dialogue: 0,0:13:33.45,0:13:36.91,EN,,0,0,0,,the result of looking up the variable value
Dialogue: 0,0:13:36.99,0:13:38.52,EN,,0,0,0,,of some particular expression,
Dialogue: 0,0:13:39.18,0:13:40.30,EN,,0,0,0,,which, in this case, is supposed to be
Dialogue: 0,0:13:40.33,0:13:42.00,EN,,0,0,0,,a variable in some environment.
Dialogue: 0,0:13:42.80,0:13:44.68,EN,,0,0,0,,And this'll be some operation
Dialogue: 0,0:13:45.21,0:13:47.50,EN,,0,0,0,,that search through the environment structure,
Dialogue: 0,0:13:47.52,0:13:48.97,EN,,0,0,0,,however it is represented,
Dialogue: 0,0:13:49.37,0:13:50.91,EN,,0,0,0,,and goes and looks up that variable.
Dialogue: 0,0:13:52.17,0:13:53.95,EN,,0,0,0,,And, again, that's below the level of detail
Dialogue: 0,0:13:53.96,0:13:54.86,EN,,0,0,0,,that we're thinking about.
Dialogue: 0,0:13:54.89,0:13:57.30,EN,,0,0,0,,This is... this has to do with the details of
Dialogue: 0,0:13:57.55,0:13:59.44,EN,,0,0,0,,the data structures for representing environments.
Dialogue: 0,0:14:00.07,0:14:01.21,EN,,0,0,0,,But, anyway, there is this
Dialogue: 0,0:14:01.31,0:14:03.47,EN,,0,0,0,,there is this fixed and finite number
Dialogue: 0,0:14:04.11,0:14:06.08,EN,,0,0,0,,of operations in the register machine.
Dialogue: 0,0:14:08.50,0:14:11.60,EN,,0,0,0,,Well, what's its overall structure?
Dialogue: 0,0:14:11.72,0:14:13.23,EN,,0,0,0,,Those are some typical operations.
Dialogue: 0,0:14:14.76,0:14:16.33,EN,,0,0,0,,Remember what we have to do,
Dialogue: 0,0:14:16.44,0:14:18.40,EN,,0,0,0,,we have to take the meta-circular evaluator--
Dialogue: 0,0:14:20.43,0:14:22.76,EN,,0,0,0,,and here's a piece of the meta-circular evaluator.
Dialogue: 0,0:14:22.76,0:14:26.89,EN,,0,0,0,,This is the one using abstract syntax that's in the book.
Dialogue: 0,0:14:28.22,0:14:31.53,EN,,0,0,0,,It's a little bit different from the one that Gerry shows you.
Dialogue: 0,0:14:33.50,0:14:35.10,EN,,0,0,0,,And the main thing
Dialogue: 0,0:14:35.13,0:14:37.87,EN,,0,0,0,,to remember about the evaluator is that
Dialogue: 0,0:14:37.87,0:14:40.96,EN,,0,0,0,,it's doing some sort of case analysis on the kinds of expressions:
Dialogue: 0,0:14:43.76,0:14:45.90,EN,,0,0,0,,so if it's either self-evaluated, or quoted,
Dialogue: 0,0:14:45.92,0:14:46.86,EN,,0,0,0,,or whatever else.
Dialogue: 0,0:14:48.56,0:14:50.57,EN,,0,0,0,,And then, in the general case where
Dialogue: 0,0:14:50.86,0:14:52.96,EN,,0,0,0,,the expression it's looking at is an application,
Dialogue: 0,0:14:53.55,0:14:55.36,EN,,0,0,0,,there's some tricky recursions going on.
Dialogue: 0,0:14:55.75,0:14:59.36,EN,,0,0,0,,First of all, eval has to call itself
Dialogue: 0,0:14:59.79,0:15:01.45,EN,,0,0,0,,both to evaluate the operator
Dialogue: 0,0:15:02.14,0:15:04.04,EN,,0,0,0,,and to evaluate all the operands.
Dialogue: 0,0:15:05.88,0:15:07.40,EN,,0,0,0,,So there's this sort of red recursion
Dialogue: 0,0:15:07.63,0:15:09.28,EN,,0,0,0,,of values walking down the tree
Dialogue: 0,0:15:10.94,0:15:12.27,EN,,0,0,0,,that's sort of the easy recursion.
Dialogue: 0,0:15:12.27,0:15:14.44,EN,,0,0,0,,That's just eval walking down this tree of expressions.
Dialogue: 0,0:15:14.75,0:15:15.53,EN,,0,0,0,,Then, in the evaluator,
Dialogue: 0,0:15:15.53,0:15:16.46,EN,,0,0,0,,there's a hard recursion.
Dialogue: 0,0:15:16.49,0:15:17.92,EN,,0,0,0,,There's the red to green.
Dialogue: 0,0:15:18.00,0:15:19.66,EN,,0,0,0,,Eval calls apply.
Dialogue: 0,0:15:22.47,0:15:26.45,EN,,0,0,0,,That's the case where evaluating a procedure argument
Dialogue: 0,0:15:26.45,0:15:28.72,EN,,0,0,0,,reduces to applying the procedure
Dialogue: 0,0:15:28.94,0:15:29.93,EN,,0,0,0,,to the list of arguments.
Dialogue: 0,0:15:30.37,0:15:31.76,EN,,0,0,0,,And then, apply comes over here.
Dialogue: 0,0:15:34.77,0:15:36.67,EN,,0,0,0,,Apply takes a procedure and arguments
Dialogue: 0,0:15:37.65,0:15:39.45,EN,,0,0,0,,and, in the general case
Dialogue: 0,0:15:39.48,0:15:40.81,EN,,0,0,0,,where there's a compound procedure,
Dialogue: 0,0:15:41.05,0:15:42.19,EN,,0,0,0,,apply goes around and
Dialogue: 0,0:15:42.25,0:15:43.15,EN,,0,0,0,,green calls red.
Dialogue: 0,0:15:43.34,0:15:46.44,EN,,0,0,0,,Eval-- Apply comes around and calls eval again.
Dialogue: 0,0:15:48.17,0:15:49.79,EN,,0,0,0,,Eval's the body of the procedure
Dialogue: 0,0:15:50.24,0:15:52.59,EN,,0,0,0,,in the result of extending the environment
Dialogue: 0,0:15:53.69,0:15:55.28,EN,,0,0,0,,with the parameters of the procedure
Dialogue: 0,0:15:55.48,0:15:56.92,EN,,0,0,0,,by binding the arguments.
Dialogue: 0,0:15:59.62,0:16:00.62,EN,,0,0,0,,Except in the primitive case,
Dialogue: 0,0:16:00.64,0:16:02.52,EN,,0,0,0,,where it just calls something else primitive-apply
Dialogue: 0,0:16:02.73,0:16:04.70,EN,,0,0,0,,which is not really the business of the evaluator.
Dialogue: 0,0:16:05.98,0:16:07.47,EN,,0,0,0,,So this sort of red to green,
Dialogue: 0,0:16:07.47,0:16:08.40,EN,,0,0,0,,to red to green,
Dialogue: 0,0:16:09.79,0:16:12.72,EN,,0,0,0,,Right? That's the that's the eval/apply loop,
Dialogue: 0,0:16:14.06,0:16:15.74,EN,,0,0,0,,and that's the thing that we're going to want to see
Dialogue: 0,0:16:16.19,0:16:17.72,EN,,0,0,0,,in the evaluator.
Dialogue: 0,0:16:19.69,0:16:21.07,EN,,0,0,0,,Well, it won't surprise you at all that
Dialogue: 0,0:16:21.07,0:16:23.52,EN,,0,0,0,,the two big pieces of this evaluator
Dialogue: 0,0:16:25.34,0:16:27.04,EN,,0,0,0,,are correspond to eval and apply.
Dialogue: 0,0:16:27.47,0:16:29.44,EN,,0,0,0,,There's a piece called eval-dispatch,
Dialogue: 0,0:16:29.60,0:16:31.20,EN,,0,0,0,,and a piece called apply-dispatch.
Dialogue: 0,0:16:32.00,0:16:34.09,EN,,0,0,0,,And, before we get into the details of the code,
Dialogue: 0,0:16:34.20,0:16:35.76,EN,,0,0,0,,the way to understand this is to think,
Dialogue: 0,0:16:36.09,0:16:39.02,EN,,0,0,0,,again, in terms of these pieces of evaluator
Dialogue: 0,0:16:39.02,0:16:40.97,EN,,0,0,0,,having contracts with the rest of the world.
Dialogue: 0,0:16:41.87,0:16:43.18,EN,,0,0,0,,What do they do from the outside
Dialogue: 0,0:16:43.20,0:16:45.50,EN,,0,0,0,,before getting into the grungy details?
Dialogue: 0,0:16:45.78,0:16:49.32,EN,,0,0,0,,Well, the contract for eval-dispatch--
Dialogue: 0,0:16:50.01,0:16:51.40,EN,,0,0,0,,remember, it corresponds to eval.
Dialogue: 0,0:16:51.55,0:16:54.10,EN,,0,0,0,,It's got to evaluate an expression in an environment.
Dialogue: 0,0:16:54.10,0:16:55.88,EN,,0,0,0,,So, in particular, what this one is going to do,
Dialogue: 0,0:16:56.52,0:16:58.68,EN,,0,0,0,,eval-dispatch will assume that, when you call it,
Dialogue: 0,0:16:59.68,0:17:01.48,EN,,0,0,0,,that the expression you want to evaluate
Dialogue: 0,0:17:01.48,0:17:02.52,EN,,0,0,0,,is in the EXP register.
Dialogue: 0,0:17:03.64,0:17:07.39,EN,,0,0,0,,The environment in which you want the evaluation
Dialogue: 0,0:17:07.45,0:17:09.05,EN,,0,0,0,,to take place is in the ENV register.
Dialogue: 0,0:17:09.56,0:17:10.67,EN,,0,0,0,,And continue tells you
Dialogue: 0,0:17:10.84,0:17:12.46,EN,,0,0,0,,the place where the machine should go next
Dialogue: 0,0:17:12.52,0:17:13.92,EN,,0,0,0,,when the evaluation is done.
Dialogue: 0,0:17:17.28,0:17:19.18,EN,,0,0,0,,Eval-dispatch's contract is that
Dialogue: 0,0:17:19.28,0:17:21.26,EN,,0,0,0,,it'll actually perform that evaluation,
Dialogue: 0,0:17:21.40,0:17:22.46,EN,,0,0,0,,and, at the end of which,
Dialogue: 0,0:17:23.28,0:17:25.63,EN,,0,0,0,,it'll end up at the place specified by continue.
Dialogue: 0,0:17:26.61,0:17:29.16,EN,,0,0,0,,The result of the evaluation will be in the VAL register.
Dialogue: 0,0:17:29.82,0:17:30.96,EN,,0,0,0,,And it just warns you,
Dialogue: 0,0:17:30.99,0:17:32.91,EN,,0,0,0,,it makes no promises about
Dialogue: 0,0:17:32.96,0:17:34.60,EN,,0,0,0,,what happens to rest the registers.
Dialogue: 0,0:17:35.23,0:17:36.81,EN,,0,0,0,,All other registers might be destroyed.
Dialogue: 0,0:17:37.49,0:17:40.14,EN,,0,0,0,,So, there's one piece, OK?
Dialogue: 0,0:17:41.55,0:17:43.48,EN,,0,0,0,,Together, the pieces, apply-dispatch
Dialogue: 0,0:17:43.52,0:17:44.92,EN,,0,0,0,,that corresponds to apply,
Dialogue: 0,0:17:46.09,0:17:48.43,EN,,0,0,0,,it's got to apply a procedure to some arguments,
Dialogue: 0,0:17:48.73,0:17:51.43,EN,,0,0,0,,so it assumes that this register, ARGL,
Dialogue: 0,0:17:51.68,0:17:53.77,EN,,0,0,0,,contains a list of the evaluated arguments.
Dialogue: 0,0:17:54.54,0:17:55.96,EN,,0,0,0,,FUN contains the procedure.
Dialogue: 0,0:17:57.22,0:17:58.83,EN,,0,0,0,,Those correspond to the arguments to
Dialogue: 0,0:17:58.94,0:18:01.36,EN,,0,0,0,,the apply procedure in the meta-circular evaluator.
Dialogue: 0,0:18:03.97,0:18:06.04,EN,,0,0,0,,And apply, in this particular evaluator,
Dialogue: 0,0:18:06.06,0:18:07.58,EN,,0,0,0,,we're going to use a discipline which says
Dialogue: 0,0:18:07.72,0:18:08.97,EN,,0,0,0,,the place that apply
Dialogue: 0,0:18:09.47,0:18:11.20,EN,,0,0,0,,the place the machine should go to next
Dialogue: 0,0:18:11.79,0:18:13.45,EN,,0,0,0,,when apply is done, is at the moment
Dialogue: 0,0:18:13.55,0:18:15.92,EN,,0,0,0,,apply-dispatch is called at the top of the stack
Dialogue: 0,0:18:17.07,0:18:21.24,EN,,0,0,0,,that's just discipline for the way this particular machine's organized.
Dialogue: 0,0:18:21.84,0:18:23.70,EN,,0,0,0,,And now apply's contract is given all that.
Dialogue: 0,0:18:23.93,0:18:25.37,EN,,0,0,0,,It'll perform the application.
Dialogue: 0,0:18:25.54,0:18:27.85,EN,,0,0,0,,The result of that application will end up in VAL.
Dialogue: 0,0:18:28.89,0:18:29.95,EN,,0,0,0,,The stack will be popped.
Dialogue: 0,0:18:31.12,0:18:31.66,EN,,0,0,0,,And, again,
Dialogue: 0,0:18:31.71,0:18:34.03,EN,,0,0,0,,the contents of all the other registers may be destroyed.
Dialogue: 0,0:18:34.84,0:18:37.82,EN,,0,0,0,,All right? So that's the basic organization of this machine.
Dialogue: 0,0:18:38.99,0:18:41.50,EN,,0,0,0,,Let's break for a little bit and see if there are any questions
Dialogue: 0,0:18:41.52,0:18:42.70,EN,,0,0,0,,and then we'll do a real example.
Dialogue: 0,0:18:43.53,0:19:08.11,EN,,0,0,0,,[JESU, JOY OF MAN'S DESIRING]
Dialogue: 0,0:19:08.14,0:19:13.47,EN,,0,0,0,,The Structure And Interpretation of Computer Programs
Dialogue: 0,0:19:33.10,0:19:35.87,EN,,0,0,0,,By: Prof. Harold Abelson && Sussman Jay Sussman
Dialogue: 0,0:19:35.87,0:19:40.38,EN,,0,0,0,,The Structure And Interpretation of Computer Programs
Dialogue: 0,0:19:47.85,0:19:49.95,EN,,0,0,0,,Well, let's take the register machine now,
Dialogue: 0,0:19:50.41,0:19:51.77,EN,,0,0,0,,and actually step through,
Dialogue: 0,0:19:52.27,0:19:56.94,EN,,0,0,0,,and really, in real detail,
Dialogue: 0,0:19:57.07,0:19:58.52,EN,,0,0,0,,so you see completely concrete
Dialogue: 0,0:19:58.86,0:20:01.24,EN,,0,0,0,,how some expressions are evaluated,
Dialogue: 0,0:20:03.15,0:20:06.86,EN,,0,0,0,,Alright? So, let's start with a very simple expression.
Dialogue: 0,0:20:07.45,0:20:13.52,EN,,0,0,0,,Let's evaluate the expression 1.
Dialogue: 0,0:20:18.77,0:20:20.40,EN,,0,0,0,,And we need an environment,
Dialogue: 0,0:20:20.43,0:20:22.35,EN,,0,0,0,,so let's imagine that somewhere there's an environment
Dialogue: 0,0:20:22.38,0:20:23.39,EN,,0,0,0,,we'll call it E0.
Dialogue: 0,0:20:30.06,0:20:34.56,EN,,0,0,0,,And just, since we'll use these later,
Dialogue: 0,0:20:35.62,0:20:37.04,EN,,0,0,0,,we obviously don't really need anything
Dialogue: 0,0:20:37.07,0:20:37.93,EN,,0,0,0,,to evaluate 1.
Dialogue: 0,0:20:38.36,0:20:39.45,EN,,0,0,0,,But, just for reference later,
Dialogue: 0,0:20:39.45,0:20:40.94,EN,,0,0,0,,let's assume that E0 has in it
Dialogue: 0,0:20:41.44,0:20:43.15,EN,,0,0,0,,an X that's bound to 3
Dialogue: 0,0:20:43.72,0:20:45.37,EN,,0,0,0,,and a Y that's bound to 4,
Dialogue: 0,0:20:48.27,0:20:48.78,EN,,0,0,0,,OK?
Dialogue: 0,0:20:49.14,0:20:50.12,EN,,0,0,0,,And now what we're going to do
Dialogue: 0,0:20:50.51,0:20:54.59,EN,,0,0,0,,is we're going to evaluate 1 in this environment
Dialogue: 0,0:20:55.74,0:20:58.54,EN,,0,0,0,,and so the ENV register has a pointer
Dialogue: 0,0:20:59.65,0:21:01.04,EN,,0,0,0,,to this environment, E0, all right?
Dialogue: 0,0:21:03.31,0:21:05.65,EN,,0,0,0,,Right? So let's watch that thing go.
Dialogue: 0,0:21:05.65,0:21:07.26,EN,,0,0,0,,What I'm going to do is step through the code.
Dialogue: 0,0:21:08.26,0:21:10.00,EN,,0,0,0,,And, let's see, I'll be the controller.
Dialogue: 0,0:21:10.04,0:21:10.80,EN,,0,0,0,,And now what I need,
Dialogue: 0,0:21:11.02,0:21:12.49,EN,,0,0,0,,since this gets rather complicated,
Dialogue: 0,0:21:12.98,0:21:16.83,EN,,0,0,0,,is a very little execution unit.
Dialogue: 0,0:21:16.83,0:21:18.16,EN,,0,0,0,,So here's the execution unit, OK?
Dialogue: 0,0:21:22.62,0:21:23.12,EN,,0,0,0,,OK.
Dialogue: 0,0:21:28.59,0:21:29.96,EN,,0,0,0,,All right, now we're going to start.
Dialogue: 0,0:21:30.53,0:21:32.48,EN,,0,0,0,,We're going to start the machine at eval-dispatch。
Dialogue: 0,0:21:33.26,0:21:34.62,EN,,0,0,0,,Right? That's the beginning of this.
Dialogue: 0,0:21:35.87,0:21:38.75,EN,,0,0,0,,Eval-dispatch is going to look at the expression and dispatch,
Dialogue: 0,0:21:39.32,0:21:40.06,EN,,0,0,0,,just like eval
Dialogue: 0,0:21:40.87,0:21:42.00,EN,,0,0,0,,where we look at the very first thing.
Dialogue: 0,0:21:42.04,0:21:47.95,EN,,0,0,0,,We branch on whether or not this expression is self-evaluating.
Dialogue: 0,0:21:47.95,0:21:49.96,EN,,0,0,0,,Self-evaluating is some abstraction
Dialogue: 0,0:21:49.96,0:21:51.10,EN,,0,0,0,,we put into the machine--
Dialogue: 0,0:21:52.22,0:21:53.51,EN,,0,0,0,,it's going to be true for numbers--
Dialogue: 0,0:21:53.64,0:21:55.52,EN,,0,0,0,,to a place called ev-self-eval,
Dialogue: 0,0:21:56.77,0:21:58.20,EN,,0,0,0,,So me, being the controller,
Dialogue: 0,0:21:58.22,0:21:59.55,EN,,0,0,0,,looks at ev-self-eval,
Dialogue: 0,0:22:00.06,0:22:01.07,EN,,0,0,0,,so we'll go over to there.
Dialogue: 0,0:22:02.60,0:22:04.76,EN,,0,0,0,,Ev-self-eval says fine,
Dialogue: 0,0:22:06.54,0:22:09.90,EN,,0,0,0,,assign to val whatever is in the expression unit.
Dialogue: 0,0:22:15.24,0:22:16.51,EN,,0,0,0,,And I have a bug
Dialogue: 0,0:22:17.93,0:22:20.59,EN,,0,0,0,,because what I didn't do when I initialized this machine
Dialogue: 0,0:22:21.62,0:22:22.89,EN,,0,0,0,,is also say what's supposed
Dialogue: 0,0:22:22.91,0:22:24.19,EN,,0,0,0,,to happen when it's done,
Dialogue: 0,0:22:24.65,0:22:26.83,EN,,0,0,0,,so I should have started out the machine
Dialogue: 0,0:22:27.37,0:22:29.85,EN,,0,0,0,,with done being in the continue register,
Dialogue: 0,0:22:31.18,0:22:33.26,EN,,0,0,0,,OK? So we assign to VAL.
Dialogue: 0,0:22:33.37,0:22:35.56,EN,,0,0,0,,And now go to fetch of continue,
Dialogue: 0,0:22:35.63,0:22:36.56,EN,,0,0,0,,and now change--
Dialogue: 0,0:22:38.09,0:22:38.60,EN,,0,0,0,,OK.
Dialogue: 0,0:22:40.00,0:22:41.16,EN,,0,0,0,,OK, let's try something harder.
Dialogue: 0,0:22:42.16,0:22:43.45,EN,,0,0,0,,Let's reset the machine here,
Dialogue: 0,0:22:44.86,0:22:50.88,EN,,0,0,0,,and we'll put in the expression register, X, OK?
Dialogue: 0,0:22:56.71,0:22:58.20,EN,,0,0,0,,Start again at eval-dispatch.
Dialogue: 0,0:22:59.61,0:23:01.69,EN,,0,0,0,,Check, is it self-evaluating?
Dialogue: 0,0:23:01.69,0:23:02.03,EN,,0,0,0,,No.
Dialogue: 0,0:23:02.65,0:23:03.61,EN,,0,0,0,,Is it a variable?
Dialogue: 0,0:23:04.63,0:23:05.02,EN,,0,0,0,,Yes.
Dialogue: 0,0:23:05.56,0:23:07.07,EN,,0,0,0,,We go off to ev-variable.
Dialogue: 0,0:23:08.38,0:23:10.97,EN,,0,0,0,,It says assign to VAL,
Dialogue: 0,0:23:12.13,0:23:15.69,EN,,0,0,0,,look up the variable value in the expression register
Dialogue: 0,0:23:21.23,0:23:22.91,EN,,0,0,0,,Go to fetch of continue.
Dialogue: 0,0:23:23.96,0:23:24.48,EN,,0,0,0,,PROFESSOR: Done.
Dialogue: 0,0:23:27.61,0:23:28.09,EN,,0,0,0,,PROFESSOR: OK.
Dialogue: 0,0:23:29.31,0:23:30.76,EN,,0,0,0,,Alright, Well, that's the basic idea. Those're
Dialogue: 0,0:23:31.33,0:23:32.65,EN,,0,0,0,,That's a simple operation of the machine.
Dialogue: 0,0:23:32.68,0:23:35.07,EN,,0,0,0,,Now, let's actually do something a little bit more interesting.
Dialogue: 0,0:23:36.07,0:23:38.64,EN,,0,0,0,,Let's look at the expression
Dialogue: 0,0:23:43.58,0:23:47.93,EN,,0,0,0,,the sum of x and y.
Dialogue: 0,0:23:49.69,0:23:51.28,EN,,0,0,0,,OK. And now we'll see how you start
Dialogue: 0,0:23:52.41,0:23:54.01,EN,,0,0,0,,unrolling these expression trees.
Dialogue: 0,0:23:57.13,0:23:58.68,EN,,0,0,0,,Well, start again at eval-dispatch.
Dialogue: 0,0:24:04.61,0:24:05.80,EN,,0,0,0,,Self-evaluating?
Dialogue: 0,0:24:05.95,0:24:06.52,EN,,0,0,0,,No.
Dialogue: 0,0:24:06.70,0:24:07.71,EN,,0,0,0,,Variable? No.
Dialogue: 0,0:24:07.82,0:24:08.99,EN,,0,0,0,,All the other special forms
Dialogue: 0,0:24:08.99,0:24:10.12,EN,,0,0,0,,which I didn't write down,
Dialogue: 0,0:24:10.27,0:24:12.48,EN,,0,0,0,,like quote, and lambda, and set, and whatever,
Dialogue: 0,0:24:12.48,0:24:13.08,EN,,0,0,0,,it's none of those.
Dialogue: 0,0:24:13.26,0:24:14.73,EN,,0,0,0,,It turns out to be an application,
Dialogue: 0,0:24:15.88,0:24:17.42,EN,,0,0,0,,so we go off to ev-application.
Dialogue: 0,0:24:19.97,0:24:24.94,EN,,0,0,0,,Ev-application, remember what it's going to do overall.
Dialogue: 0,0:24:25.58,0:24:28.19,EN,,0,0,0,,It is going to evaluate the operator.
Dialogue: 0,0:24:28.27,0:24:31.40,EN,,0,0,0,,It's going to evaluate the arguments,
Dialogue: 0,0:24:32.36,0:24:34.30,EN,,0,0,0,,and then it's going to go apply them.
Dialogue: 0,0:24:35.06,0:24:36.09,EN,,0,0,0,,So, before we start,
Dialogue: 0,0:24:36.94,0:24:37.88,EN,,0,0,0,,since we're being very literal,
Dialogue: 0,0:24:37.88,0:24:38.88,EN,,0,0,0,,we'd better remember that,
Dialogue: 0,0:24:39.07,0:24:40.54,EN,,0,0,0,,somewhere in this environment,
Dialogue: 0,0:24:40.57,0:24:42.36,EN,,0,0,0,,it's linked to another environment
Dialogue: 0,0:24:43.98,0:24:44.94,EN,,0,0,0,,in which plus
Dialogue: 0,0:24:45.72,0:24:49.16,EN,,0,0,0,,is bound to the primitive procedure plus
Dialogue: 0,0:24:51.63,0:24:54.03,EN,,0,0,0,,before we get an unknown variable in our machine.
Dialogue: 0,0:24:55.34,0:24:56.84,EN,,0,0,0,,OK, so we're at ev-application.
Dialogue: 0,0:24:59.85,0:25:04.32,EN,,0,0,0,,OK, assign to UNEV the operands
Dialogue: 0,0:25:04.92,0:25:06.89,EN,,0,0,0,,of what's in the expression register.
Dialogue: 0,0:25:07.61,0:25:08.83,EN,,0,0,0,,OK. Those are the operands.
Dialogue: 0,0:25:09.23,0:25:11.66,EN,,0,0,0,,UNEV's a temporary register
Dialogue: 0,0:25:11.68,0:25:12.59,EN,,0,0,0,,where we're going to save them.
Dialogue: 0,0:25:13.22,0:25:13.86,EN,,0,0,0,,PROFESSOR: I'm assigning.
Dialogue: 0,0:25:14.28,0:25:16.62,EN,,0,0,0,,PROFESSOR: Assign to EXP the operator.
Dialogue: 0,0:25:18.07,0:25:20.09,EN,,0,0,0,,Now, notice we've destroyed that expression in EXP,
Dialogue: 0,0:25:21.84,0:25:23.61,EN,,0,0,0,,but the piece that we need is now in UNEV.
Dialogue: 0,0:25:25.82,0:25:26.81,EN,,0,0,0,,Now, we're going to get set up to
Dialogue: 0,0:25:26.81,0:25:28.59,EN,,0,0,0,,to recursively evaluate the operator.
Dialogue: 0,0:25:28.75,0:25:31.69,EN,,0,0,0,,Save the continue register on the stack.
Dialogue: 0,0:25:34.86,0:25:36.09,EN,,0,0,0,,Save the environment.
Dialogue: 0,0:25:40.48,0:25:41.69,EN,,0,0,0,,Save UNEV.
Dialogue: 0,0:25:49.53,0:25:54.64,EN,,0,0,0,,OK, assign to continue a label called eval-args.
Dialogue: 0,0:26:01.40,0:26:01.95,EN,,0,0,0,,Now, what have we done?
Dialogue: 0,0:26:01.95,0:26:04.38,EN,,0,0,0,,We've set up for a recursive call.
Dialogue: 0,0:26:04.38,0:26:05.88,EN,,0,0,0,,We're about to go to eval-dispatch.
Dialogue: 0,0:26:06.28,0:26:08.83,EN,,0,0,0,,We've set up for a recursive call to eval-dispatch.
Dialogue: 0,0:26:10.23,0:26:10.86,EN,,0,0,0,,What did we do?
Dialogue: 0,0:26:11.02,0:26:13.64,EN,,0,0,0,,We took the things we're going to need later,
Dialogue: 0,0:26:14.48,0:26:15.98,EN,,0,0,0,,those operands that were in UNEV;
Dialogue: 0,0:26:16.36,0:26:18.99,EN,,0,0,0,,the environment in which we're going to eventually have to,
Dialogue: 0,0:26:19.16,0:26:20.72,EN,,0,0,0,,maybe, evaluate those operands;
Dialogue: 0,0:26:22.28,0:26:23.93,EN,,0,0,0,,the place we eventually want to go to,
Dialogue: 0,0:26:23.95,0:26:25.07,EN,,0,0,0,,which, in this case, was done;
Dialogue: 0,0:26:25.34,0:26:26.70,EN,,0,0,0,,we've saved them on the stack.
Dialogue: 0,0:26:27.10,0:26:28.41,EN,,0,0,0,,The reason we saved them on the stack
Dialogue: 0,0:26:28.43,0:26:30.67,EN,,0,0,0,,is because eval-dispatch makes no promises
Dialogue: 0,0:26:30.94,0:26:32.54,EN,,0,0,0,,about what registers it may destroy.
Dialogue: 0,0:26:33.55,0:26:35.02,EN,,0,0,0,,So all that stuff is saved on the stack.
Dialogue: 0,0:26:35.02,0:26:36.91,EN,,0,0,0,,Now, we've set up eval-dispatch's contract.
Dialogue: 0,0:26:37.38,0:26:38.75,EN,,0,0,0,,There's a new expression,
Dialogue: 0,0:26:38.78,0:26:40.04,EN,,0,0,0,,which is the operator plus;
Dialogue: 0,0:26:41.07,0:26:41.95,EN,,0,0,0,,a new environment,
Dialogue: 0,0:26:41.98,0:26:43.60,EN,,0,0,0,,although, in this case, it's the same one;
Dialogue: 0,0:26:44.25,0:26:45.87,EN,,0,0,0,,and a new place to go to when you're done,
Dialogue: 0,0:26:45.87,0:26:46.91,EN,,0,0,0,,which is eval-args.
Dialogue: 0,0:26:47.60,0:26:48.13,EN,,0,0,0,,So that's set up.
Dialogue: 0,0:26:48.13,0:26:49.68,EN,,0,0,0,,Now, we're going to go off to eval-dispatch.
Dialogue: 0,0:26:50.89,0:26:52.36,EN,,0,0,0,,Here we are back at eval-dispatch.
Dialogue: 0,0:26:53.05,0:26:54.40,EN,,0,0,0,,It's not self-evaluating.
Dialogue: 0,0:26:54.44,0:26:55.47,EN,,0,0,0,,Oh, it's a variable,
Dialogue: 0,0:26:56.32,0:26:58.06,EN,,0,0,0,,so we'd better go off to ev-variable,
Dialogue: 0,0:26:59.79,0:27:02.65,EN,,0,0,0,,Right? Ev-variable is assigned to VAL.
Dialogue: 0,0:27:02.70,0:27:06.33,EN,,0,0,0,,Look up the variable value of the expression,
Dialogue: 0,0:27:08.49,0:27:10.75,EN,,0,0,0,,OK? So VAL is the primitive procedure plus.
Dialogue: 0,0:27:13.37,0:27:15.16,EN,,0,0,0,,And go to fetch of continue.
Dialogue: 0,0:27:15.23,0:27:16.11,EN,,0,0,0,,PROFESSOR: Eval-args.
Dialogue: 0,0:27:16.20,0:27:18.73,EN,,0,0,0,,PROFESSOR: Right, which is now eval-args not done.
Dialogue: 0,0:27:19.42,0:27:21.26,EN,,0,0,0,,So we come back here at eval-args,
Dialogue: 0,0:27:22.16,0:27:23.02,EN,,0,0,0,,and what do we do?
Dialogue: 0,0:27:23.07,0:27:24.84,EN,,0,0,0,,We're going to restore the stuff that we saved,
Dialogue: 0,0:27:25.20,0:27:26.57,EN,,0,0,0,,so we restore UNEV.
Dialogue: 0,0:27:29.21,0:27:31.69,EN,,0,0,0,,And notice, there, it wasn't necessary,
Dialogue: 0,0:27:31.74,0:27:32.90,EN,,0,0,0,,although, in general, it would be.
Dialogue: 0,0:27:32.90,0:27:35.16,EN,,0,0,0,,It might be some arbitrary evaluation that happened.
Dialogue: 0,0:27:35.43,0:27:36.70,EN,,0,0,0,,We restore ENV.
Dialogue: 0,0:27:47.87,0:27:52.04,EN,,0,0,0,,OK, we assign to FUN fetch of VAL.
Dialogue: 0,0:27:59.95,0:28:02.81,EN,,0,0,0,,OK, now, we're going to go off and start evaluating some arguments.
Dialogue: 0,0:28:04.34,0:28:06.48,EN,,0,0,0,,Well, first thing we'd better do is save FUN
Dialogue: 0,0:28:07.42,0:28:10.62,EN,,0,0,0,,because some arbitrary stuff might happen in that evaluation.
Dialogue: 0,0:28:15.33,0:28:16.88,EN,,0,0,0,,We initialize the argument list.
Dialogue: 0,0:28:16.91,0:28:19.29,EN,,0,0,0,,Assign to argl an empty argument list,
Dialogue: 0,0:28:20.88,0:28:22.17,EN,,0,0,0,,and go to eval-arg-loop,
Dialogue: 0,0:28:24.86,0:28:26.27,EN,,0,0,0,,At eval-arg-loop,
Dialogue: 0,0:28:27.77,0:28:31.53,EN,,0,0,0,,the idea of this is we're going to evaluate the pieces of the
Dialogue: 0,0:28:31.61,0:28:33.37,EN,,0,0,0,,expressions that are in UNEV, one by one,
Dialogue: 0,0:28:33.54,0:28:35.68,EN,,0,0,0,,and move them from unevaluated in UNEV
Dialogue: 0,0:28:35.90,0:28:37.26,EN,,0,0,0,,to evaluated in the arg list.
Dialogue: 0,0:28:37.84,0:28:39.18,EN,,0,0,0,,OK. So we save argl.
Dialogue: 0,0:28:43.95,0:28:47.26,EN,,0,0,0,,We assign to EXP the first operand
Dialogue: 0,0:28:47.37,0:28:48.38,EN,,0,0,0,,of the stuff in UNEV.
Dialogue: 0,0:28:53.77,0:28:55.89,EN,,0,0,0,,Now, we check and see if that was the last operand.
Dialogue: 0,0:28:55.89,0:28:56.91,EN,,0,0,0,,In this case, it is not.
Dialogue: 0,0:28:58.99,0:29:01.55,EN,,0,0,0,,So we save the environment.
Dialogue: 0,0:29:08.00,0:29:10.06,EN,,0,0,0,,We save UNEV
Dialogue: 0,0:29:11.61,0:29:13.50,EN,,0,0,0,,because those are all things we might need later.
Dialogue: 0,0:29:13.50,0:29:14.40,EN,,0,0,0,,We're going to need the environment
Dialogue: 0,0:29:14.44,0:29:15.64,EN,,0,0,0,,to do some more evaluations.
Dialogue: 0,0:29:15.80,0:29:16.60,EN,,0,0,0,,We're going to need UNEV
Dialogue: 0,0:29:16.62,0:29:19.20,EN,,0,0,0,,to look at what the rest of those arguments were.
Dialogue: 0,0:29:20.34,0:29:21.55,EN,,0,0,0,,We're going to assign continue
Dialogue: 0,0:29:21.56,0:29:24.44,EN,,0,0,0,,a place called accumulate-args, or accumulate-arg.
Dialogue: 0,0:29:31.13,0:29:34.01,EN,,0,0,0,,OK, now, we've set up for another call to eval-dispatch,
Dialogue: 0,0:29:37.07,0:29:38.54,EN,,0,0,0,,All right, now, let me short-circuit this
Dialogue: 0,0:29:39.12,0:29:41.09,EN,,0,0,0,,so we don't go through the details of eval-dispatch.
Dialogue: 0,0:29:41.09,0:29:42.64,EN,,0,0,0,,Eval-dispatch's contract says
Dialogue: 0,0:29:42.97,0:29:45.00,EN,,0,0,0,,i'm going to end up,
Dialogue: 0,0:29:45.13,0:29:45.96,EN,,0,0,0,,the world will end up,
Dialogue: 0,0:29:46.03,0:29:48.20,EN,,0,0,0,,with the value of evaluating this expression
Dialogue: 0,0:29:48.24,0:29:50.27,EN,,0,0,0,,in this environment in the VAL register,
Dialogue: 0,0:29:50.27,0:29:51.07,EN,,0,0,0,,and I'll end up there.
Dialogue: 0,0:29:51.32,0:29:52.62,EN,,0,0,0,,So we short-circuit all of this,
Dialogue: 0,0:29:54.43,0:29:56.36,EN,,0,0,0,,and a 3 ends up in VAL.
Dialogue: 0,0:29:58.01,0:29:59.76,EN,,0,0,0,,And, when we return from eval-dispatch,
Dialogue: 0,0:29:59.76,0:30:01.76,EN,,0,0,0,,we're going to return to accumulate-arg.
Dialogue: 0,0:30:02.30,0:30:03.23,EN,,0,0,0,,PROFESSOR: Accumulate-arg.
Dialogue: 0,0:30:06.22,0:30:08.20,EN,,0,0,0,,PROFESSOR: With 3 in the VAL register, OK?
Dialogue: 0,0:30:08.72,0:30:10.59,EN,,0,0,0,,So that short-circuited that evaluation.
Dialogue: 0,0:30:10.65,0:30:11.32,EN,,0,0,0,,Now, what do we do?
Dialogue: 0,0:30:11.32,0:30:13.68,EN,,0,0,0,,We're going to go back and look at the rest of the arguments,
Dialogue: 0,0:30:13.68,0:30:14.83,EN,,0,0,0,,so we restore UNEV.
Dialogue: 0,0:30:17.51,0:30:19.00,EN,,0,0,0,,We restore ENV.
Dialogue: 0,0:30:25.79,0:30:27.05,EN,,0,0,0,,We restore argl.
Dialogue: 0,0:30:28.65,0:30:29.17,EN,,0,0,0,,One thing.
Dialogue: 0,0:30:30.06,0:30:31.45,EN,,0,0,0,,PROFESSOR: Oops! Parity error.
Dialogue: 0,0:30:33.76,0:30:34.83,EN,,0,0,0,,PROFESSOR: Restore argl.
Dialogue: 0,0:30:45.57,0:30:49.76,EN,,0,0,0,,OK, we assign to argl consing on
Dialogue: 0,0:30:50.65,0:30:52.64,EN,,0,0,0,,fetch of the value register to what's in argl.
Dialogue: 0,0:30:59.36,0:31:02.96,EN,,0,0,0,,OK, we assign to UNEV the rest of the operands
Dialogue: 0,0:31:03.34,0:31:04.52,EN,,0,0,0,,in fetch of UNEV,
Dialogue: 0,0:31:08.91,0:31:10.76,EN,,0,0,0,,and we go back to eval-arg-loop.
Dialogue: 0,0:31:11.51,0:31:12.28,EN,,0,0,0,,PROFESSOR: Eval-arg-loop.
Dialogue: 0,0:31:12.28,0:31:12.86,EN,,0,0,0,,PROFESSOR: OK.
Dialogue: 0,0:31:15.88,0:31:17.08,EN,,0,0,0,,Now, we're about to do the next argument,
Dialogue: 0,0:31:17.58,0:31:19.31,EN,,0,0,0,,so the first thing we do is save argl.
Dialogue: 0,0:31:25.40,0:31:28.27,EN,,0,0,0,,OK, we assign to EXP the first operand
Dialogue: 0,0:31:29.15,0:31:30.81,EN,,0,0,0,,of fetch of UNEV.
Dialogue: 0,0:31:34.72,0:31:37.02,EN,,0,0,0,,OK, we test and see if that's the last operand.
Dialogue: 0,0:31:37.02,0:31:38.00,EN,,0,0,0,,In this case, it is
Dialogue: 0,0:31:39.08,0:31:40.27,EN,,0,0,0,,so we're going to go to a special place
Dialogue: 0,0:31:40.28,0:31:42.06,EN,,0,0,0,,that says evaluate the last argument
Dialogue: 0,0:31:43.37,0:31:45.07,EN,,0,0,0,,because, notice,after evaluating the argument,
Dialogue: 0,0:31:45.10,0:31:46.62,EN,,0,0,0,,we don't need the environment any more.
Dialogue: 0,0:31:47.64,0:31:48.78,EN,,0,0,0,,That's going to be the difference.
Dialogue: 0,0:31:50.25,0:31:51.85,EN,,0,0,0,,So here, at eval-last-arg,
Dialogue: 0,0:31:52.24,0:31:54.92,EN,,0,0,0,,which is assigned to continue accumulate-last-arg,
Dialogue: 0,0:32:04.27,0:32:06.90,EN,,0,0,0,,now, we're set up again for eval-dispatch.
Dialogue: 0,0:32:06.90,0:32:08.51,EN,,0,0,0,,We've got a place to go to when we're done.
Dialogue: 0,0:32:08.62,0:32:09.84,EN,,0,0,0,,We've got an expression.
Dialogue: 0,0:32:09.84,0:32:10.80,EN,,0,0,0,,We've got an environment.
Dialogue: 0,0:32:11.33,0:32:13.64,EN,,0,0,0,,OK, so we'll short-circuit the call to eval-dispatch.
Dialogue: 0,0:32:14.37,0:32:16.41,EN,,0,0,0,,And what'll happen is there's a y there,
Dialogue: 0,0:32:16.70,0:32:18.56,EN,,0,0,0,,it's 4 in that environment,
Dialogue: 0,0:32:18.60,0:32:20.09,EN,,0,0,0,,so VAL will end up with 4 in it.
Dialogue: 0,0:32:21.06,0:32:22.86,EN,,0,0,0,,And, then, we're going to end up at accumulate-last-arg, OK?
Dialogue: 0,0:32:25.45,0:32:26.91,EN,,0,0,0,,So, at accumulate-last-arg,
Dialogue: 0,0:32:29.28,0:32:30.52,EN,,0,0,0,,we restore argl.
Dialogue: 0,0:32:37.69,0:32:42.76,EN,,0,0,0,,We assign to argl, we assign to argl cons,
Dialogue: 0,0:32:43.60,0:32:45.83,EN,,0,0,0,,of fetch of the new value onto it,
Dialogue: 0,0:32:45.93,0:32:47.39,EN,,0,0,0,,so we cons a 4 onto that.
Dialogue: 0,0:32:49.85,0:32:52.52,EN,,0,0,0,,We restore what was saved in the function register.
Dialogue: 0,0:32:53.77,0:32:54.99,EN,,0,0,0,,And notice, in this case,
Dialogue: 0,0:32:55.00,0:32:56.27,EN,,0,0,0,,it had not been destroyed,
Dialogue: 0,0:32:56.38,0:32:57.72,EN,,0,0,0,,but in general, it will be.
Dialogue: 0,0:32:59.13,0:33:01.50,EN,,0,0,0,,And now, we're ready to go off to apply-dispatch,
Dialogue: 0,0:33:02.65,0:33:04.40,EN,,0,0,0,,Alright? So we've just gone through the eval.
Dialogue: 0,0:33:04.51,0:33:05.85,EN,,0,0,0,,We evaluated the argument,
Dialogue: 0,0:33:06.46,0:33:07.98,EN,,0,0,0,,the operator, and the arguments,
Dialogue: 0,0:33:07.98,0:33:09.24,EN,,0,0,0,,and now, we're about to apply them.
Dialogue: 0,0:33:09.58,0:33:11.37,EN,,0,0,0,,So we come off to apply-dispatch here
Dialogue: 0,0:33:18.03,0:33:19.29,EN,,0,0,0,,We come off to apply-dispatch,
Dialogue: 0,0:33:21.05,0:33:22.41,EN,,0,0,0,,and we're going to check whether it's a primitive
Dialogue: 0,0:33:22.41,0:33:23.45,EN,,0,0,0,,or a compound procedure.
Dialogue: 0,0:33:23.64,0:33:24.20,EN,,0,0,0,,PROFESSOR: Yes.
Dialogue: 0,0:33:24.54,0:33:24.83,EN,,0,0,0,,PROFESSOR: All right.
Dialogue: 0,0:33:24.89,0:33:26.52,EN,,0,0,0,,So, in this case, it's a primitive procedure,
Dialogue: 0,0:33:27.45,0:33:28.91,EN,,0,0,0,,and we go off to primitive-apply.
Dialogue: 0,0:33:29.79,0:33:31.36,EN,,0,0,0,,So we go off to primitive-apply,
Dialogue: 0,0:33:33.71,0:33:35.37,EN,,0,0,0,,that says assign to VAL
Dialogue: 0,0:33:35.69,0:33:38.25,EN,,0,0,0,,result of applying primitive procedure
Dialogue: 0,0:33:38.36,0:33:40.30,EN,,0,0,0,,of the function to the argument list.
Dialogue: 0,0:33:41.31,0:33:42.43,EN,,0,0,0,,PROFESSOR: I don't know how to add.
Dialogue: 0,0:33:42.54,0:33:43.80,EN,,0,0,0,,I'm just an execution unit.
Dialogue: 0,0:33:44.14,0:33:45.35,EN,,0,0,0,,PROFESSOR: Well, I don't know how to add either.
Dialogue: 0,0:33:45.35,0:33:46.51,EN,,0,0,0,,I'm just the evaluator,
Dialogue: 0,0:33:47.08,0:33:48.36,EN,,0,0,0,,so we need a primitive operator.
Dialogue: 0,0:33:48.36,0:33:49.72,EN,,0,0,0,,Let's see, so the primitive operator,
Dialogue: 0,0:33:49.76,0:33:52.36,EN,,0,0,0,,What's the... what's the sum of 3 and 4?
Dialogue: 0,0:33:52.86,0:33:53.32,EN,,0,0,0,,AUDIENCE: 7.
Dialogue: 0,0:33:53.71,0:33:54.65,EN,,0,0,0,,PROFESSOR: OK, 7.
Dialogue: 0,0:33:55.32,0:33:55.99,EN,,0,0,0,,PROFESSOR: Thank you.
Dialogue: 0,0:33:59.20,0:34:00.60,EN,,0,0,0,,PROFESSOR: Now, we restore continue,
Dialogue: 0,0:34:11.58,0:34:12.90,EN,,0,0,0,,and we go to fetch of continue.
Dialogue: 0,0:34:13.07,0:34:13.47,EN,,0,0,0,,PROFESSOR: Done.
Dialogue: 0,0:34:14.20,0:34:14.67,EN,,0,0,0,,PROFESSOR: OK.
Dialogue: 0,0:34:14.92,0:34:18.41,EN,,0,0,0,,Well, that was in as much detail as you will ever see.
Dialogue: 0,0:34:18.41,0:34:20.19,EN,,0,0,0,,We'll never do it in as much detail again.
Dialogue: 0,0:34:21.59,0:34:23.92,EN,,0,0,0,,One very important thing to notice
Dialogue: 0,0:34:24.91,0:34:27.55,EN,,0,0,0,,is that we just executed a recursive procedure,
Dialogue: 0,0:34:29.56,0:34:31.17,EN,,0,0,0,,Right? This whole thing, we used a stack
Dialogue: 0,0:34:31.17,0:34:32.75,EN,,0,0,0,,and the evaluator was recursive.
Dialogue: 0,0:34:33.07,0:34:35.88,EN,,0,0,0,,A lot of people think the reason that you need a stack
Dialogue: 0,0:34:36.48,0:34:37.85,EN,,0,0,0,,and recursion in an evaluator
Dialogue: 0,0:34:37.87,0:34:38.97,EN,,0,0,0,,is because you might be
Dialogue: 0,0:34:39.09,0:34:42.15,EN,,0,0,0,,evaluating recursive procedures like factorial or Fibonacci.
Dialogue: 0,0:34:42.15,0:34:42.92,EN,,0,0,0,,It's not true.
Dialogue: 0,0:34:43.67,0:34:44.99,EN,,0,0,0,,So you notice we did recursion here,
Dialogue: 0,0:34:45.00,0:34:46.86,EN,,0,0,0,,and all we evaluated was (+ x y)
Dialogue: 0,0:34:47.77,0:34:50.65,EN,,0,0,0,,Right? The reason that you need recursion in the evaluator
Dialogue: 0,0:34:50.96,0:34:52.97,EN,,0,0,0,,is because the evaluation process,
Dialogue: 0,0:34:52.99,0:34:54.06,EN,,0,0,0,,itself, is recursive.
Dialogue: 0,0:34:54.45,0:34:56.17,EN,,0,0,0,,Right? It's not because the procedure
Dialogue: 0,0:34:56.32,0:34:58.09,EN,,0,0,0,,that you might be evaluating in LISP
Dialogue: 0,0:34:58.12,0:34:59.27,EN,,0,0,0,,is a recursive procedure.
Dialogue: 0,0:34:59.27,0:35:00.52,EN,,0,0,0,,So that's an important thing
Dialogue: 0,0:35:00.52,0:35:02.14,EN,,0,0,0,,that people get confused about a lot.
Dialogue: 0,0:35:03.01,0:35:04.27,EN,,0,0,0,,The other thing to notice is that,
Dialogue: 0,0:35:04.27,0:35:05.64,EN,,0,0,0,,when we're done here,
Dialogue: 0,0:35:06.28,0:35:07.12,EN,,0,0,0,,we're really done.
Dialogue: 0,0:35:07.12,0:35:08.49,EN,,0,0,0,,Not only are we at done,
Dialogue: 0,0:35:09.45,0:35:13.23,EN,,0,0,0,,but there's no accumulated stuff on the stack,
Dialogue: 0,0:35:13.60,0:35:15.71,EN,,0,0,0,,Right? The machine is back to its initial state.
Dialogue: 0,0:35:17.00,0:35:18.75,EN,,0,0,0,,So that's part of what it means to be done.
Dialogue: 0,0:35:19.71,0:35:21.04,EN,,0,0,0,,Another way to say that is
Dialogue: 0,0:35:22.72,0:35:26.04,EN,,0,0,0,,the evaluation process has reduced
Dialogue: 0,0:35:26.41,0:35:28.32,EN,,0,0,0,,the expression, plus X, Y,
Dialogue: 0,0:35:30.54,0:35:32.78,EN,,0,0,0,,to the value here, 7.
Dialogue: 0,0:35:33.24,0:35:35.45,EN,,0,0,0,,And by reduced, I mean a very particular thing.
Dialogue: 0,0:35:36.01,0:35:38.18,EN,,0,0,0,,It means that there's nothing left on the stack.
Dialogue: 0,0:35:38.18,0:35:40.36,EN,,0,0,0,,The machine is now in the same state,
Dialogue: 0,0:35:40.92,0:35:42.65,EN,,0,0,0,,except there's something in the value register.
Dialogue: 0,0:35:42.72,0:35:44.52,EN,,0,0,0,,It's not part of a sub-problem of anything.
Dialogue: 0,0:35:44.52,0:35:45.63,EN,,0,0,0,,There's nothing to go back to.
Dialogue: 0,0:35:46.12,0:35:46.96,EN,,0,0,0,,OK. Let's break.
Dialogue: 0,0:35:50.16,0:35:50.76,EN,,0,0,0,,Question?
Dialogue: 0,0:35:51.08,0:35:54.02,EN,,0,0,0,,AUDIENCE: The question here, in the stack,
Dialogue: 0,0:35:54.02,0:35:55.82,EN,,0,0,0,,is because the data may be recursive.
Dialogue: 0,0:35:56.20,0:35:58.75,EN,,0,0,0,,You may have embedded expressions, for instance.
Dialogue: 0,0:35:59.31,0:36:02.08,EN,,0,0,0,,PROFESSOR: Yes, because you might have embedded expressions.
Dialogue: 0,0:36:02.08,0:36:04.77,EN,,0,0,0,,But, again, don't confuse that
Dialogue: 0,0:36:04.77,0:36:07.98,EN,,0,0,0,,with what people sometimes mean by the data may be recursive,
Dialogue: 0,0:36:08.00,0:36:10.35,EN,,0,0,0,,which is to say you have these list-structured,
Dialogue: 0,0:36:11.04,0:36:12.93,EN,,0,0,0,,recursive data list operations.
Dialogue: 0,0:36:12.93,0:36:13.96,EN,,0,0,0,,That has nothing to do with it.
Dialogue: 0,0:36:13.98,0:36:16.16,EN,,0,0,0,,It's simply that the expressions contain sub-expressions.
Dialogue: 0,0:36:20.04,0:36:23.52,EN,,0,0,0,,AUDIENCE: Why is it that the order of the arguments in the arg list got reversed?
Dialogue: 0,0:36:23.55,0:36:25.29,EN,,0,0,0,,PROFESSOR: Ah! Yes, I should've mentioned that.
Dialogue: 0,0:36:27.26,0:36:29.07,EN,,0,0,0,,Here, the reason the order is reversed--
Dialogue: 0,0:36:32.78,0:36:35.37,EN,,0,0,0,,it's a question of what you mean by reversed.
Dialogue: 0,0:36:36.05,0:36:39.90,EN,,0,0,0,,I believe it was Newton.
Dialogue: 0,0:36:40.91,0:36:42.41,EN,,0,0,0,,In the very early part of optics,
Dialogue: 0,0:36:42.43,0:36:43.26,EN,,0,0,0,,people realized
Dialogue: 0,0:36:43.61,0:36:45.36,EN,,0,0,0,,that when you look through the lens of your eye,
Dialogue: 0,0:36:45.50,0:36:46.73,EN,,0,0,0,,the image was up-side down.
Dialogue: 0,0:36:46.73,0:36:48.04,EN,,0,0,0,,And there was a lot of argument about
Dialogue: 0,0:36:48.04,0:36:50.48,EN,,0,0,0,,why that didn't mean you saw things up-side down.
Dialogue: 0,0:36:51.28,0:36:52.65,EN,,0,0,0,,So it's sort of the same issue.
Dialogue: 0,0:36:52.86,0:36:53.90,EN,,0,0,0,,Reversed from what?
Dialogue: 0,0:36:54.81,0:36:56.24,EN,,0,0,0,,So we just need some convention.
Dialogue: 0,0:36:56.59,0:37:00.35,EN,,0,0,0,,So all we.. The reason that they're coming at 4, 3
Dialogue: 0,0:37:00.80,0:37:02.49,EN,,0,0,0,,is because taking UNEV
Dialogue: 0,0:37:02.52,0:37:04.03,EN,,0,0,0,,and consing the result onto argl.
Dialogue: 0,0:37:04.52,0:37:06.68,EN,,0,0,0,,So you have to realize you've made that convention.
Dialogue: 0,0:37:06.86,0:37:09.37,EN,,0,0,0,,The place that you have to realize that--
Dialogue: 0,0:37:09.98,0:37:11.23,EN,,0,0,0,,well, there's actually two places.
Dialogue: 0,0:37:11.23,0:37:12.91,EN,,0,0,0,,One is in apply-primitive-operator,
Dialogue: 0,0:37:12.91,0:37:14.06,EN,,0,0,0,,which has to realize that
Dialogue: 0,0:37:15.12,0:37:16.75,EN,,0,0,0,,the arguments to primitives go in,
Dialogue: 0,0:37:16.78,0:37:18.72,EN,,0,0,0,,the opposite order from the way you're writing them down.
Dialogue: 0,0:37:19.49,0:37:21.00,EN,,0,0,0,,And the other one is, we'll see later
Dialogue: 0,0:37:21.07,0:37:23.80,EN,,0,0,0,,when you actually go to bind a function's parameters,
Dialogue: 0,0:37:24.01,0:37:25.74,EN,,0,0,0,,you should realize the arguments are going to come in
Dialogue: 0,0:37:25.74,0:37:28.54,EN,,0,0,0,,from the opposite order of the variables to which you're binding them.
Dialogue: 0,0:37:28.87,0:37:30.17,EN,,0,0,0,,So, if you just keep track of that,
Dialogue: 0,0:37:31.08,0:37:31.83,EN,,0,0,0,,there's no problem.
Dialogue: 0,0:37:31.83,0:37:33.69,EN,,0,0,0,,Also, this is completely arbitrary
Dialogue: 0,0:37:33.90,0:37:34.96,EN,,0,0,0,,because, if we'd done,
Dialogue: 0,0:37:35.10,0:37:37.15,EN,,0,0,0,,say, an iteration through a vector assigning them,
Dialogue: 0,0:37:37.42,0:37:38.73,EN,,0,0,0,,they might come out in the other order.
Dialogue: 0,0:37:40.41,0:37:42.04,EN,,0,0,0,,OK. So it's just a convention of the way
Dialogue: 0,0:37:42.06,0:37:43.53,EN,,0,0,0,,this particular evaluator works.
Dialogue: 0,0:37:45.39,0:37:46.24,EN,,0,0,0,,All right, let's take a break.
Dialogue: 0,0:37:46.33,0:38:02.44,EN,,0,0,0,,[JESU, JOY OF MAN'S DESIRING]
Dialogue: 0,0:38:02.44,0:38:07.64,EN,,0,0,0,,The Structure And Interpretation of Computer Programs
Dialogue: 0,0:38:28.62,0:38:32.51,EN,,0,0,0,,By: Prof. Harold Abelson && Sussman Jay Sussman
Dialogue: 0,0:38:32.51,0:38:35.68,EN,,0,0,0,,The Structure And Interpretation of Computer Programs
Dialogue: 0,0:38:41.84,0:38:45.31,EN,,0,0,0,,Professor: We just saw evaluating an expression
Dialogue: 0,0:38:45.60,0:38:47.08,EN,,0,0,0,,and, of course, that was very simple one. But
Dialogue: 0,0:38:48.81,0:38:50.24,EN,,0,0,0,,in essence, it would be no different
Dialogue: 0,0:38:50.24,0:38:52.03,EN,,0,0,0,,if it was some big nested expression,
Dialogue: 0,0:38:52.03,0:38:54.57,EN,,0,0,0,,so there would just be deeper recursion on the stack.
Dialogue: 0,0:38:55.13,0:38:56.03,EN,,0,0,0,,But what I want to do now
Dialogue: 0,0:38:56.04,0:38:56.91,EN,,0,0,0,,is show you the last piece.
Dialogue: 0,0:38:56.92,0:38:59.82,EN,,0,0,0,,I want to walk you around this eval and apply loop,
Dialogue: 0,0:39:01.01,0:39:02.81,EN,,0,0,0,,That's the thing we haven't seen, really.
Dialogue: 0,0:39:03.00,0:39:04.75,EN,,0,0,0,,We haven't seen any compound procedures
Dialogue: 0,0:39:05.20,0:39:07.79,EN,,0,0,0,,where evalutation of procedure reduces to
Dialogue: 0,0:39:07.92,0:39:10.11,EN,,0,0,0,,where applying of procedure reduces to
Dialogue: 0,0:39:10.12,0:39:11.64,EN,,0,0,0,,evaluating the body of the procedure,
Dialogue: 0,0:39:12.44,0:39:15.88,EN,,0,0,0,,so let's just suppose we had this.
Dialogue: 0,0:39:15.93,0:39:17.44,EN,,0,0,0,,Suppose we were looking at the procedure
Dialogue: 0,0:39:18.07,0:39:31.60,EN,,0,0,0,,define F of A and B to be the sum of A and B.
Dialogue: 0,0:39:33.99,0:39:37.32,EN,,0,0,0,,So, as we typed in that procedure previously,
Dialogue: 0,0:39:37.69,0:39:41.64,EN,,0,0,0,,and now we're going to evaluate F of X and Y
Dialogue: 0,0:39:42.27,0:39:44.20,EN,,0,0,0,,again, in this environment, E,0,
Dialogue: 0,0:39:44.35,0:39:47.02,EN,,0,0,0,,where X is bound to 3 and Y is bound to 4.
Dialogue: 0,0:39:50.78,0:39:52.11,EN,,0,0,0,,When the defined is executed,
Dialogue: 0,0:39:52.12,0:39:53.69,EN,,0,0,0,,remember, there's a lambda here,
Dialogue: 0,0:39:53.82,0:39:55.53,EN,,0,0,0,,and lambdas create procedures.
Dialogue: 0,0:39:55.95,0:39:58.49,EN,,0,0,0,,And, basically, what will happen is,
Dialogue: 0,0:39:59.63,0:40:00.68,EN,,0,0,0,,in E0,
Dialogue: 0,0:40:01.00,0:40:02.65,EN,,0,0,0,,we'll end up with a binding for F,
Dialogue: 0,0:40:03.56,0:40:05.61,EN,,0,0,0,,which will say F is a procedure,
Dialogue: 0,0:40:07.15,0:40:11.28,EN,,0,0,0,,and its args are A and B,
Dialogue: 0,0:40:12.57,0:40:16.19,EN,,0,0,0,,and its body is plus a,b.
Dialogue: 0,0:40:18.11,0:40:20.99,EN,,0,0,0,,So that's what the environment would have looked like
Dialogue: 0,0:40:21.21,0:40:22.52,EN,,0,0,0,,had we made that definition.
Dialogue: 0,0:40:24.22,0:40:27.28,EN,,0,0,0,,Then, when we go to evaluate F of X and Y,
Dialogue: 0,0:40:28.80,0:40:30.89,EN,,0,0,0,,we'll go through exactly the same process
Dialogue: 0,0:40:31.02,0:40:31.85,EN,,0,0,0,,that we did before.
Dialogue: 0,0:40:31.88,0:40:33.09,EN,,0,0,0,,It's even the same expression.
Dialogue: 0,0:40:33.28,0:40:34.38,EN,,0,0,0,,The only difference is that
Dialogue: 0,0:40:34.40,0:40:36.64,EN,,0,0,0,,F, instead of having primitive "plus" in it
Dialogue: 0,0:40:37.24,0:40:38.99,EN,,0,0,0,,will have this thing.
Dialogue: 0,0:40:41.04,0:40:43.60,EN,,0,0,0,,And so we'll go through exactly the same process,
Dialogue: 0,0:40:43.60,0:40:44.92,EN,,0,0,0,,except this time, when we end up
Dialogue: 0,0:40:45.26,0:40:47.42,EN,,0,0,0,,at apply-dispatch,
Dialogue: 0,0:40:47.86,0:40:50.28,EN,,0,0,0,,the function register, instead of having primitive plus,
Dialogue: 0,0:40:50.44,0:40:53.58,EN,,0,0,0,,will have a thing that will represent it saying procedure,
Dialogue: 0,0:40:54.30,0:40:59.00,EN,,0,0,0,,where the args are A and B,
Dialogue: 0,0:41:00.64,0:41:06.27,EN,,0,0,0,,and the body is plus A, B.
Dialogue: 0,0:41:07.87,0:41:09.92,EN,,0,0,0,,And, again, what I mean, by its ENV,
Dialogue: 0,0:41:09.96,0:41:11.12,EN,,0,0,0,,I mean there's a pointer to it,
Dialogue: 0,0:41:11.24,0:41:13.07,EN,,0,0,0,,so don't worry that I'm writing a lot of stuff there.
Dialogue: 0,0:41:13.28,0:41:15.63,EN,,0,0,0,,There's a pointer to this procedure data structure.
Dialogue: 0,0:41:17.17,0:41:19.77,EN,,0,0,0,,OK, so, we're in exactly the same situation.
Dialogue: 0,0:41:20.27,0:41:22.43,EN,,0,0,0,,We get to apply-dispatch,
Dialogue: 0,0:41:23.98,0:41:26.48,EN,,0,0,0,,so, here, we come to apply-dispatch.
Dialogue: 0,0:41:26.48,0:41:28.73,EN,,0,0,0,,Last time, we branched off to a primitive procedure.
Dialogue: 0,0:41:30.01,0:41:30.70,EN,,0,0,0,,Here, it says oh,
Dialogue: 0,0:41:30.84,0:41:32.80,EN,,0,0,0,,we now have a compound procedure,
Dialogue: 0,0:41:34.55,0:41:36.60,EN,,0,0,0,,so we're going to go off to compound-apply.
Dialogue: 0,0:41:38.47,0:41:39.92,EN,,0,0,0,,Now, what's compound-apply?
Dialogue: 0,0:41:41.92,0:41:44.54,EN,,0,0,0,,Well, remember what the meta-circular evaluator did?
Dialogue: 0,0:41:45.09,0:41:47.40,EN,,0,0,0,,Compound-apply said we're going to evaluate
Dialogue: 0,0:41:49.90,0:41:51.60,EN,,0,0,0,,the body of the procedure
Dialogue: 0,0:41:52.94,0:41:54.12,EN,,0,0,0,,in some new environment.
Dialogue: 0,0:41:54.12,0:41:55.87,EN,,0,0,0,,Where does that new environment come from?
Dialogue: 0,0:41:56.73,0:42:01.36,EN,,0,0,0,,We take the environment that was packaged with the procedure,
Dialogue: 0,0:42:03.02,0:42:05.79,EN,,0,0,0,,we bind the parameters of the procedure
Dialogue: 0,0:42:06.00,0:42:07.63,EN,,0,0,0,,to the arguments that we're passing in,
Dialogue: 0,0:42:09.75,0:42:11.95,EN,,0,0,0,,and use that as a new frame to extend
Dialogue: 0,0:42:12.59,0:42:13.79,EN,,0,0,0,,the procedure environment.
Dialogue: 0,0:42:14.99,0:42:16.08,EN,,0,0,0,,And that's the environment
Dialogue: 0,0:42:16.30,0:42:18.88,EN,,0,0,0,,in which we evaluate the procedure body,
Dialogue: 0,0:42:20.12,0:42:24.47,EN,,0,0,0,,Right? That's going around the apply/eval loop.
Dialogue: 0,0:42:24.47,0:42:26.25,EN,,0,0,0,,That's apply coming back to call eval,
Dialogue: 0,0:42:32.86,0:42:34.92,EN,,0,0,0,,So, now, that's all we have to do in compound-apply.
Dialogue: 0,0:42:36.78,0:42:37.72,EN,,0,0,0,,What are we going to do?
Dialogue: 0,0:42:37.72,0:42:40.97,EN,,0,0,0,,We're going to manufacture a new environment.
Dialogue: 0,0:42:43.55,0:42:45.64,EN,,0,0,0,,And we're going to manufacture a new environment that,
Dialogue: 0,0:42:46.76,0:42:48.11,EN,,0,0,0,,let's see, that we'll call E1.
Dialogue: 0,0:42:52.90,0:42:55.63,EN,,0,0,0,,E1 is going to be some environment where the
Dialogue: 0,0:42:57.31,0:42:59.15,EN,,0,0,0,,where the parameters of the procedure,
Dialogue: 0,0:42:59.21,0:43:03.26,EN,,0,0,0,,Nwhere A is bound to 3, and B is bound to 4,
Dialogue: 0,0:43:04.27,0:43:05.76,EN,,0,0,0,,and it's linked to E0
Dialogue: 0,0:43:05.76,0:43:08.08,EN,,0,0,0,,because that's where f is defined.
Dialogue: 0,0:43:09.27,0:43:10.27,EN,,0,0,0,,And, in this environment,
Dialogue: 0,0:43:10.27,0:43:11.96,EN,,0,0,0,,we're going to evaluate the body of the procedure.
Dialogue: 0,0:43:12.05,0:43:14.48,EN,,0,0,0,,So let's look at that, we're going
Dialogue: 0,0:43:16.52,0:43:18.32,EN,,0,0,0,,Here we are at compound-apply,
Dialogue: 0,0:43:20.30,0:43:23.47,EN,,0,0,0,,which says assign to the expression register
Dialogue: 0,0:43:24.50,0:43:25.98,EN,,0,0,0,,the body of the procedure
Dialogue: 0,0:43:25.98,0:43:27.26,EN,,0,0,0,,that's in the function register.
Dialogue: 0,0:43:28.38,0:43:30.64,EN,,0,0,0,,So I assign to the expression register
Dialogue: 0,0:43:31.29,0:43:32.33,EN,,0,0,0,,the procedure body,
Dialogue: 0,0:43:40.75,0:43:41.10,EN,,0,0,0,,OK?
Dialogue: 0,0:43:42.64,0:43:44.97,EN,,0,0,0,,That's going to be evaluated in an environment
Dialogue: 0,0:43:45.82,0:43:48.32,EN,,0,0,0,,which is formed by making some bindings
Dialogue: 0,0:43:51.30,0:43:53.67,EN,,0,0,0,,using information determined by the procedure--
Dialogue: 0,0:43:53.67,0:43:56.25,EN,,0,0,0,,that's what's in FUN-- and the argument list.
Dialogue: 0,0:43:57.80,0:44:00.00,EN,,0,0,0,,And let's not worry about exactly what that does,
Dialogue: 0,0:44:00.08,0:44:01.63,EN,,0,0,0,,but you can see the information's there.
Dialogue: 0,0:44:01.93,0:44:03.32,EN,,0,0,0,,So make bindings will say oh,
Dialogue: 0,0:44:04.04,0:44:07.90,EN,,0,0,0,,the procedure, itself, had an environment attached to it.
Dialogue: 0,0:44:07.96,0:44:09.32,EN,,0,0,0,,I didn't write that quite here.
Dialogue: 0,0:44:09.36,0:44:10.56,EN,,0,0,0,,I should've said in environment
Dialogue: 0,0:44:11.30,0:44:12.73,EN,,0,0,0,,because every procedure gets built
Dialogue: 0,0:44:12.76,0:44:13.44,EN,,0,0,0,,with an environment.
Dialogue: 0,0:44:13.66,0:44:14.83,EN,,0,0,0,,So, from that environment,
Dialogue: 0,0:44:15.68,0:44:16.35,EN,,0,0,0,,it knows
Dialogue: 0,0:44:16.60,0:44:18.65,EN,,0,0,0,,what the procedure's definition environment is.
Dialogue: 0,0:44:19.29,0:44:20.75,EN,,0,0,0,,It knows what the arguments are.
Dialogue: 0,0:44:21.83,0:44:22.49,EN,,0,0,0,,It looks at argl,
Dialogue: 0,0:44:22.49,0:44:24.28,EN,,0,0,0,,and then you see a reversal convention here.
Dialogue: 0,0:44:24.28,0:44:26.62,EN,,0,0,0,,It just has to know that argl is reversed,
Dialogue: 0,0:44:27.06,0:44:28.81,EN,,0,0,0,,and it builds this frame, E,1.
Dialogue: 0,0:44:29.99,0:44:31.08,EN,,0,0,0,,All right, so, let's assume that
Dialogue: 0,0:44:31.10,0:44:32.92,EN,,0,0,0,,that's what make bindings returns,
Dialogue: 0,0:44:33.36,0:44:36.22,EN,,0,0,0,,so it assigns to ENV this thing, E,1.
Dialogue: 0,0:44:41.34,0:44:42.54,EN,,0,0,0,,The next thing it says
Dialogue: 0,0:44:43.95,0:44:45.84,EN,,0,0,0,,is restore continue.
Dialogue: 0,0:44:46.89,0:44:48.19,EN,,0,0,0,,Remember what continue was here?
Dialogue: 0,0:44:48.76,0:44:50.43,EN,,0,0,0,,It got put up in the last segment.
Dialogue: 0,0:44:52.24,0:44:54.02,EN,,0,0,0,,Continue got stored.
Dialogue: 0,0:44:54.02,0:44:55.18,EN,,0,0,0,,That was the original done,
Dialogue: 0,0:44:55.32,0:44:56.56,EN,,0,0,0,,which said what are you going to do
Dialogue: 0,0:44:56.73,0:44:59.44,EN,,0,0,0,,after you're done with this particular application?
Dialogue: 0,0:45:00.14,0:45:01.72,EN,,0,0,0,,It was one of the very first things that happened
Dialogue: 0,0:45:01.76,0:45:03.18,EN,,0,0,0,,when we evaluated the application.
Dialogue: 0,0:45:03.88,0:45:05.87,EN,,0,0,0,,And now, finally, we're going to restore continue.
Dialogue: 0,0:45:06.86,0:45:09.55,EN,,0,0,0,,Remember apply-dispatch's contract.
Dialogue: 0,0:45:09.58,0:45:11.20,EN,,0,0,0,,It assumes that where it should go to next
Dialogue: 0,0:45:11.23,0:45:11.98,EN,,0,0,0,,was on the stack,
Dialogue: 0,0:45:12.03,0:45:13.12,EN,,0,0,0,,and there it was on the stack.
Dialogue: 0,0:45:13.59,0:45:14.76,EN,,0,0,0,,Continue has done,
Dialogue: 0,0:45:17.82,0:45:19.90,EN,,0,0,0,,and now we're going to go back to eval-dispatch.
Dialogue: 0,0:45:19.94,0:45:20.84,EN,,0,0,0,,We're set up again.
Dialogue: 0,0:45:20.97,0:45:24.41,EN,,0,0,0,,We have an expression, an environment, and a place to go to.
Dialogue: 0,0:45:25.80,0:45:26.89,EN,,0,0,0,,We're not going to go through that
Dialogue: 0,0:45:27.88,0:45:29.55,EN,,0,0,0,,because it's sort of the same expression.
Dialogue: 0,0:45:35.40,0:45:37.79,EN,,0,0,0,,OK, but the thing, again, to notice
Dialogue: 0,0:45:37.82,0:45:38.73,EN,,0,0,0,,is, at this point,
Dialogue: 0,0:45:39.34,0:45:43.72,EN,,0,0,0,,we have reduced the original expression, F,X,Y,
Dialogue: 0,0:45:44.64,0:45:47.92,EN,,0,0,0,,We've reduced evaluating F,X,Y in environment E,0
Dialogue: 0,0:45:48.89,0:45:52.67,EN,,0,0,0,,to evaluate plus A, B in E,1.
Dialogue: 0,0:45:52.78,0:45:55.92,EN,,0,0,0,,And notice, nothing's on the stack, right?
Dialogue: 0,0:45:56.11,0:45:56.83,EN,,0,0,0,,It's a reduction.
Dialogue: 0,0:45:56.84,0:45:59.80,EN,,0,0,0,,At this point, the machine does not contain,
Dialogue: 0,0:45:59.84,0:46:01.20,EN,,0,0,0,,as part of its state,
Dialogue: 0,0:46:01.76,0:46:03.71,EN,,0,0,0,,the fact that it's in the middle of evaluating
Dialogue: 0,0:46:03.72,0:46:04.88,EN,,0,0,0,,some procedure called f,
Dialogue: 0,0:46:05.49,0:46:06.28,EN,,0,0,0,,that's gone,
Dialogue: 0,0:46:07.66,0:46:09.55,EN,,0,0,0,,Right? There's no accumulated state?
Dialogue: 0,0:46:13.07,0:46:14.37,EN,,0,0,0,,Again, that's a very important idea.
Dialogue: 0,0:46:14.37,0:46:16.33,EN,,0,0,0,,That's the meaning of,
Dialogue: 0,0:46:16.76,0:46:18.39,EN,,0,0,0,,when we used to write in the substitution model,
Dialogue: 0,0:46:18.39,0:46:20.86,EN,,0,0,0,,this expression reduces to that expression.
Dialogue: 0,0:46:21.35,0:46:22.66,EN,,0,0,0,,And you don't have to remember anything.
Dialogue: 0,0:46:22.66,0:46:24.50,EN,,0,0,0,,And here, you see the meaning of reduction.
Dialogue: 0,0:46:24.56,0:46:26.16,EN,,0,0,0,,At this point, there is nothing on the stack.
Dialogue: 0,0:46:31.59,0:46:33.63,EN,,0,0,0,,See, that has very important consequences.
Dialogue: 0,0:46:35.24,0:46:37.90,EN,,0,0,0,,Let's go back and look at iterative factorial,
Dialogue: 0,0:46:40.42,0:46:42.76,EN,,0,0,0,,all right? Remember, this was some sort of loop
Dialogue: 0,0:46:44.01,0:46:44.88,EN,,0,0,0,,and doing iter.
Dialogue: 0,0:46:45.13,0:46:47.36,EN,,0,0,0,,And we kept saying that's an iterative procedure,
Dialogue: 0,0:46:49.26,0:46:53.84,EN,,0,0,0,,And what we wrote, remember,
Dialogue: 0,0:46:58.44,0:47:03.13,EN,,0,0,0,,are things like, we said,
Dialogue: 0,0:47:04.35,0:47:11.07,EN,,0,0,0,,fact-iter of 5.
Dialogue: 0,0:47:12.36,0:47:18.67,EN,,0,0,0,,We wrote things like reduces to iter of 1, and 1, and 5,
Dialogue: 0,0:47:19.03,0:47:25.15,EN,,0,0,0,,which reduces to iter of 1, and 2, and 5,
Dialogue: 0,0:47:25.32,0:47:27.07,EN,,0,0,0,,and so on, and so on, and so on.
Dialogue: 0,0:47:27.07,0:47:28.17,EN,,0,0,0,,And we kept saying well, look,
Dialogue: 0,0:47:28.17,0:47:30.35,EN,,0,0,0,,you don't have to build up any storage to do that.
Dialogue: 0,0:47:31.72,0:47:32.73,EN,,0,0,0,,And we waved our hands,
Dialogue: 0,0:47:32.75,0:47:34.59,EN,,0,0,0,,and said in principle, there's no storage needed.
Dialogue: 0,0:47:35.04,0:47:36.17,EN,,0,0,0,,Now, you see no storage needed.
Dialogue: 0,0:47:36.17,0:47:39.09,EN,,0,0,0,,Each of these is a real reduction, right?
Dialogue: 0,0:47:39.09,0:47:42.60,EN,,0,0,0,,As you walk through these expressions,
Dialogue: 0,0:47:47.30,0:47:50.51,EN,,0,0,0,,As you walk through these expressions,
Dialogue: 0,0:47:50.83,0:47:51.37,EN,,0,0,0,,what you'll see
Dialogue: 0,0:47:51.37,0:47:52.81,EN,,0,0,0,,are these expressions on the stack
Dialogue: 0,0:47:53.75,0:47:55.64,EN,,0,0,0,,in some particular environment,
Dialogue: 0,0:47:56.42,0:48:00.02,EN,,0,0,0,,and then these expressions, sorry, in the EXP register
Dialogue: 0,0:48:00.02,0:48:01.50,EN,,0,0,0,,in some particular environment.
Dialogue: 0,0:48:01.57,0:48:02.19,EN,,0,0,0,,And, at each point,
Dialogue: 0,0:48:02.19,0:48:04.00,EN,,0,0,0,,there'll be no accumulated stuff on the stack
Dialogue: 0,0:48:04.36,0:48:05.68,EN,,0,0,0,,because each one's a real reduction.
Dialogue: 0,0:48:09.28,0:48:10.51,EN,,0,0,0,,All right, so, for example,
Dialogue: 0,0:48:10.58,0:48:12.51,EN,,0,0,0,,just to go through it in a little bit more care,
Dialogue: 0,0:48:13.46,0:48:16.88,EN,,0,0,0,,if I start out with an expression that says something like,
Dialogue: 0,0:48:22.44,0:48:34.25,EN,,0,0,0,,oh, say, fact-iter of 5 in some environment
Dialogue: 0,0:48:42.11,0:48:46.30,EN,,0,0,0,,that will, at some point, create an environment
Dialogue: 0,0:48:46.81,0:48:48.38,EN,,0,0,0,,in which n is down to 5.
Dialogue: 0,0:48:51.47,0:48:52.01,EN,,0,0,0,,Let's call that--
Dialogue: 0,0:48:55.68,0:48:56.59,EN,,0,0,0,,And, at some point,
Dialogue: 0,0:48:56.89,0:49:02.56,EN,,0,0,0,,the machine will reduce this whole thing
Dialogue: 0,0:49:02.91,0:49:04.35,EN,,0,0,0,,to a thing that says that's really
Dialogue: 0,0:49:04.76,0:49:09.85,EN,,0,0,0,,iter of 1, and 1, and n,
Dialogue: 0,0:49:10.68,0:49:13.72,EN,,0,0,0,,evaluated in this environment, E,1
Dialogue: 0,0:49:15.87,0:49:17.16,EN,,0,0,0,,with nothing on the stack.
Dialogue: 0,0:49:17.16,0:49:19.55,EN,,0,0,0,,See, at this moment, the machine is not remembering
Dialogue: 0,0:49:20.71,0:49:22.50,EN,,0,0,0,,that evaluating this expression, iter--
Dialogue: 0,0:49:25.00,0:49:25.63,EN,,0,0,0,,which is the loop--
Dialogue: 0,0:49:25.79,0:49:28.57,EN,,0,0,0,,is part of this thing called iterative factorial.
Dialogue: 0,0:49:29.68,0:49:30.59,EN,,0,0,0,,It's not remembering that.
Dialogue: 0,0:49:30.59,0:49:33.17,EN,,0,0,0,,It's just reducing the expression to that, right?
Dialogue: 0,0:49:33.17,0:49:36.56,EN,,0,0,0,,If we look again at the body of iterative factorial,
Dialogue: 0,0:49:38.05,0:49:41.08,EN,,0,0,0,,this expression has reduced to that expression.
Dialogue: 0,0:49:42.81,0:49:43.87,EN,,0,0,0,,Oh, I shouldn't have the n there.
Dialogue: 0,0:49:46.59,0:49:47.74,EN,,0,0,0,,It's a slightly different convention
Dialogue: 0,0:49:47.74,0:49:49.13,EN,,0,0,0,,from the slide to the program.
Dialogue: 0,0:49:53.34,0:49:56.25,EN,,0,0,0,,And, then, what's the body of iter?
Dialogue: 0,0:49:56.28,0:49:57.40,EN,,0,0,0,,Well, iter's going to be an if,
Dialogue: 0,0:49:58.75,0:50:00.19,EN,,0,0,0,,and I won't go through the details of if.
Dialogue: 0,0:50:00.24,0:50:01.63,EN,,0,0,0,,It'll evaluate the predicate.
Dialogue: 0,0:50:02.40,0:50:03.71,EN,,0,0,0,,In this case, it'll be false.
Dialogue: 0,0:50:03.81,0:50:08.64,EN,,0,0,0,,And this iter will now reduce to the expression
Dialogue: 0,0:50:09.85,0:50:20.20,EN,,0,0,0,,iter of whatever it says, star, counter product, and--
Dialogue: 0,0:50:21.62,0:50:22.24,EN,,0,0,0,,what does it say--
Dialogue: 0,0:50:22.68,0:50:24.56,EN,,0,0,0,,plus counter 1
Dialogue: 0,0:50:28.72,0:50:31.42,EN,,0,0,0,,in some other environment, by this time, E,2,
Dialogue: 0,0:50:32.97,0:50:35.98,EN,,0,0,0,,where E,2 will be set up having bindings
Dialogue: 0,0:50:36.49,0:50:39.39,EN,,0,0,0,,for product and counter.
Dialogue: 0,0:50:42.92,0:50:44.33,EN,,0,0,0,,And it'll reduce to that.
Dialogue: 0,0:50:44.94,0:50:46.04,EN,,0,0,0,,Right? It won't be remembering
Dialogue: 0,0:50:46.06,0:50:48.75,EN,,0,0,0,,that it's part of something that it has to return to.
Dialogue: 0,0:50:49.34,0:50:50.43,EN,,0,0,0,,And when iter calls iter again,
Dialogue: 0,0:50:50.44,0:50:52.56,EN,,0,0,0,,it'll reduce to another thing that looks like this
Dialogue: 0,0:50:53.05,0:50:54.68,EN,,0,0,0,,in some environment, E,3,
Dialogue: 0,0:50:54.83,0:50:56.67,EN,,0,0,0,,which has new bindings for product and counter.
Dialogue: 0,0:50:58.80,0:51:05.29,EN,,0,0,0,,OK? So, if you're wondering,
Dialogue: 0,0:51:06.09,0:51:07.53,EN,,0,0,0,,if you've always been queasy about
Dialogue: 0,0:51:08.25,0:51:10.67,EN,,0,0,0,,about how it is we've been saying those procedures
Dialogue: 0,0:51:10.67,0:51:12.45,EN,,0,0,0,,that look syntactically recursive,
Dialogue: 0,0:51:13.20,0:51:15.69,EN,,0,0,0,,are, in fact, iterative,
Dialogue: 0,0:51:15.87,0:51:17.24,EN,,0,0,0,,run in constant space,
Dialogue: 0,0:51:18.40,0:51:19.75,EN,,0,0,0,,well, I don't know if this makes you less queasy,
Dialogue: 0,0:51:19.75,0:51:21.23,EN,,0,0,0,,but at least it shows you what's happening.
Dialogue: 0,0:51:21.23,0:51:22.81,EN,,0,0,0,,There really isn't any buildup there.
Dialogue: 0,0:51:25.91,0:51:27.58,EN,,0,0,0,,Now, you might ask well, is there buildup
Dialogue: 0,0:51:27.98,0:51:30.08,EN,,0,0,0,,in principle in these environment frames?
Dialogue: 0,0:51:31.71,0:51:32.37,EN,,0,0,0,,And the answer is yeah,
Dialogue: 0,0:51:32.40,0:51:33.84,EN,,0,0,0,,you have to make these new environment frames,
Dialogue: 0,0:51:33.84,0:51:35.26,EN,,0,0,0,,but you don't have to hang onto them
Dialogue: 0,0:51:35.42,0:51:36.19,EN,,0,0,0,,when you're done.
Dialogue: 0,0:51:36.44,0:51:37.61,EN,,0,0,0,,They can be garbage collected,
Dialogue: 0,0:51:37.92,0:51:39.47,EN,,0,0,0,,or the space can be reused automatically.
Dialogue: 0,0:51:40.72,0:51:42.99,EN,,0,0,0,,But you see the control structure of the evaluator
Dialogue: 0,0:51:43.25,0:51:46.12,EN,,0,0,0,,is really using this idea that you actually have a reduction,
Dialogue: 0,0:51:47.02,0:51:49.29,EN,,0,0,0,,so these procedures really are iterative procedures.
Dialogue: 0,0:51:50.13,0:51:51.38,EN,,0,0,0,,All right, let's stop for questions.
Dialogue: 0,0:52:02.68,0:52:03.23,EN,,0,0,0,,All right, let's break.
Dialogue: 0,0:52:04.12,0:52:24.56,EN,,0,0,0,,[JESU, JOY OF MAN'S DESIRING]
Dialogue: 0,0:52:24.60,0:52:29.69,EN,,0,0,0,,The Structure And Interpretation of Computer Programs
Dialogue: 0,0:52:35.20,0:52:38.36,EN,,0,0,0,,By: Prof. Harold Abelson && Sussman Jay Sussman
Dialogue: 0,0:52:38.36,0:52:42.14,EN,,0,0,0,,The Structure And Interpretation of Computer Programs
Dialogue: 0,0:52:48.77,0:52:51.55,EN,,0,0,0,,PROFESSOR: Let me contrast the iterative procedure
Dialogue: 0,0:52:52.77,0:52:54.89,EN,,0,0,0,,just so you'll see where space does build up
Dialogue: 0,0:52:55.12,0:52:56.14,EN,,0,0,0,,with a recursive procedure,
Dialogue: 0,0:52:56.17,0:52:57.29,EN,,0,0,0,,so you can see the difference.
Dialogue: 0,0:52:58.03,0:53:01.20,EN,,0,0,0,,Let's look at the evaluation of recursive factorial.
Dialogue: 0,0:53:02.65,0:53:05.53,EN,,0,0,0,,So, here's fact-recursive,
Dialogue: 0,0:53:05.55,0:53:07.22,EN,,0,0,0,,or standard factorial definition.
Dialogue: 0,0:53:07.22,0:53:10.01,EN,,0,0,0,,We said this one is still a recursive procedure,
Dialogue: 0,0:53:10.01,0:53:12.57,EN,,0,0,0,,but this is actually a recursive process.
Dialogue: 0,0:53:13.75,0:53:16.56,EN,,0,0,0,,And then, just to link it back to the way we started,
Dialogue: 0,0:53:16.83,0:53:20.53,EN,,0,0,0,,we said oh, you can see that it's going to be recursive process
Dialogue: 0,0:53:20.53,0:53:21.82,EN,,0,0,0,,by the substitution model
Dialogue: 0,0:53:22.36,0:53:28.00,EN,,0,0,0,,because, if I say recursive factorial of 5,
Dialogue: 0,0:53:30.45,0:53:34.94,EN,,0,0,0,,that turns into 5 times--
Dialogue: 0,0:53:36.28,0:53:37.82,EN,,0,0,0,,what is it, fact-rec, or record fact--
Dialogue: 0,0:53:42.62,0:53:47.93,EN,,0,0,0,,5 times recursive factorial of 4,
Dialogue: 0,0:53:49.66,0:53:58.22,EN,,0,0,0,,which turns into 5 times 4 times fact-rec of 3,
Dialogue: 0,0:54:00.22,0:54:08.60,EN,,0,0,0,,which returns into 5 times 4 times 3 times
Dialogue: 0,0:54:13.45,0:54:15.31,EN,,0,0,0,,and so on, right?
Dialogue: 0,0:54:15.39,0:54:17.39,EN,,0,0,0,,The idea is there was this chain of stuff building up,
Dialogue: 0,0:54:18.10,0:54:20.06,EN,,0,0,0,,which justified, in the substitution model,
Dialogue: 0,0:54:20.08,0:54:21.28,EN,,0,0,0,,the fact that it's recursive.
Dialogue: 0,0:54:21.52,0:54:24.18,EN,,0,0,0,,And now, let's actually see that chain of stuff build up
Dialogue: 0,0:54:24.18,0:54:25.29,EN,,0,0,0,,and where it is in the machine, OK?
Dialogue: 0,0:54:27.68,0:54:29.95,EN,,0,0,0,,All right, well, let's imagine we're going to start out again.
Dialogue: 0,0:54:30.44,0:54:40.01,EN,,0,0,0,,We'll tell it to evaluate recursive factorial of 5
Dialogue: 0,0:54:41.45,0:54:43.39,EN,,0,0,0,,in some environment, again, E0, where
Dialogue: 0,0:54:45.08,0:54:48.97,EN,,0,0,0,,where recursive factorial is defined, OK?
Dialogue: 0,0:54:49.55,0:54:51.23,EN,,0,0,0,,Well, now we know what's eventually going to happen.
Dialogue: 0,0:54:52.25,0:54:53.64,EN,,0,0,0,,This is going to come along,
Dialogue: 0,0:54:53.92,0:54:55.64,EN,,0,0,0,,it'll evaluate those things,
Dialogue: 0,0:54:55.68,0:54:56.99,EN,,0,0,0,,figure out it's a procedure,
Dialogue: 0,0:54:57.18,0:55:00.16,EN,,0,0,0,,build somewhere over here an environment, E1,
Dialogue: 0,0:55:00.88,0:55:03.69,EN,,0,0,0,,which has n bound to 5,
Dialogue: 0,0:55:04.33,0:55:06.54,EN,,0,0,0,,which hangs off of E0,
Dialogue: 0,0:55:07.80,0:55:08.97,EN,,0,0,0,,which would be, presumably,
Dialogue: 0,0:55:08.99,0:55:12.30,EN,,0,0,0,,the definition environment of recursive factorial.
Dialogue: 0,0:55:14.11,0:55:15.74,EN,,0,0,0,,OK? And, in this environment,
Dialogue: 0,0:55:15.76,0:55:17.48,EN,,0,0,0,,it's going to go off and evaluate the body.
Dialogue: 0,0:55:19.67,0:55:25.92,EN,,0,0,0,,So, again, the evaluation here will reduce to
Dialogue: 0,0:55:27.00,0:55:28.92,EN,,0,0,0,,evaluating the body in E1.
Dialogue: 0,0:55:30.16,0:55:31.34,EN,,0,0,0,,That's going to look at an if,
Dialogue: 0,0:55:32.17,0:55:33.53,EN,,0,0,0,,and I won't go through the details of if.
Dialogue: 0,0:55:33.53,0:55:34.88,EN,,0,0,0,,It'll look at the predicate.
Dialogue: 0,0:55:34.88,0:55:37.53,EN,,0,0,0,,It'll decide it eventually has to evaluate the alternative.
Dialogue: 0,0:55:37.84,0:55:40.41,EN,,0,0,0,,So this whole thing, again, will reduce to
Dialogue: 0,0:55:41.30,0:55:45.53,EN,,0,0,0,,the alternative of recursive factorial,
Dialogue: 0,0:55:45.82,0:55:46.97,EN,,0,0,0,,the alternative clause,
Dialogue: 0,0:55:47.23,0:55:51.16,EN,,0,0,0,,which says that this whole thing reduces to times n
Dialogue: 0,0:55:53.07,0:55:59.96,EN,,0,0,0,,of recursive factorial of n minus 1
Dialogue: 0,0:56:03.48,0:56:05.55,EN,,0,0,0,,in the environment E1
Dialogue: 0,0:56:08.38,0:56:10.91,EN,,0,0,0,,OK? So the original expression, now, is going to reduce
Dialogue: 0,0:56:11.04,0:56:12.52,EN,,0,0,0,,to evaluating that expression, all right?
Dialogue: 0,0:56:13.75,0:56:16.28,EN,,0,0,0,,OK? Now we have an application.
Dialogue: 0,0:56:16.28,0:56:17.63,EN,,0,0,0,,We did an application before.
Dialogue: 0,0:56:18.22,0:56:20.25,EN,,0,0,0,,Remember what happens in an application?
Dialogue: 0,0:56:20.36,0:56:21.69,EN,,0,0,0,,The first thing you do is you go off and you
Dialogue: 0,0:56:21.74,0:56:24.81,EN,,0,0,0,,you save the value of the continue register on the stack.
Dialogue: 0,0:56:25.35,0:56:27.18,EN,,0,0,0,,So the stack here is going to have done in it.
Dialogue: 0,0:56:29.98,0:56:32.88,EN,,0,0,0,,And then you're going to set up to evaluate the sub-parts.
Dialogue: 0,0:56:35.00,0:56:37.20,EN,,0,0,0,,OK? So here we go off to evaluate the sub-parts.
Dialogue: 0,0:56:39.47,0:56:41.45,EN,,0,0,0,,First thing we're going to do is evaluate the operator.
Dialogue: 0,0:56:44.60,0:56:46.32,EN,,0,0,0,,What happens when we evaluate an operator?
Dialogue: 0,0:56:47.25,0:56:48.99,EN,,0,0,0,,Well, we arrange things so that
Dialogue: 0,0:56:49.00,0:56:51.04,EN,,0,0,0,,the operator ends up in the expression register.
Dialogue: 0,0:56:51.48,0:56:53.15,EN,,0,0,0,,The environments in the ENV register
Dialogue: 0,0:56:53.66,0:56:54.60,EN,,0,0,0,,continue someplace
Dialogue: 0,0:56:54.62,0:56:56.22,EN,,0,0,0,,where we're going to go evaluate the arguments.
Dialogue: 0,0:56:56.59,0:56:57.37,EN,,0,0,0,,And, on the stack,
Dialogue: 0,0:56:57.40,0:56:59.29,EN,,0,0,0,,we've saved the original continue,
Dialogue: 0,0:56:59.52,0:57:01.02,EN,,0,0,0,,which is where we wanted to be when we're all done.
Dialogue: 0,0:57:01.72,0:57:02.86,EN,,0,0,0,,And then the things we needed
Dialogue: 0,0:57:03.58,0:57:05.80,EN,,0,0,0,,when we're going to get done evaluating the operator,
Dialogue: 0,0:57:05.90,0:57:07.66,EN,,0,0,0,,the things we'll need to evaluate the arguments,
Dialogue: 0,0:57:07.69,0:57:12.01,EN,,0,0,0,,namely the environment and those arguments,
Dialogue: 0,0:57:12.14,0:57:13.44,EN,,0,0,0,,those unevaluated arguments,
Dialogue: 0,0:57:14.20,0:57:15.62,EN,,0,0,0,,so there they are sitting on the stack.
Dialogue: 0,0:57:15.62,0:57:18.59,EN,,0,0,0,,And we're about to go off to evaluate the operator.
Dialogue: 0,0:57:23.26,0:57:26.73,EN,,0,0,0,,Well, when we return from this particular call--
Dialogue: 0,0:57:26.92,0:57:28.64,EN,,0,0,0,,so we're about to call eval-dispatch here--
Dialogue: 0,0:57:29.38,0:57:30.83,EN,,0,0,0,,when we return from this call,
Dialogue: 0,0:57:31.45,0:57:32.70,EN,,0,0,0,,the value of that operator,
Dialogue: 0,0:57:32.73,0:57:33.52,EN,,0,0,0,,which, in this case,
Dialogue: 0,0:57:33.55,0:57:35.44,EN,,0,0,0,,is going to be the primitive multiplier procedure,
Dialogue: 0,0:57:36.44,0:57:37.93,EN,,0,0,0,,will end up in the FUN register.
Dialogue: 0,0:57:43.02,0:57:44.53,EN,,0,0,0,,We're going to evaluate some arguments.
Dialogue: 0,0:57:44.53,0:57:45.85,EN,,0,0,0,,They will evaluate n here.
Dialogue: 0,0:57:47.73,0:57:49.87,EN,,0,0,0,,That'll give us 5, in this case.
Dialogue: 0,0:57:50.25,0:57:52.04,EN,,0,0,0,,We're going to put that in the argl register,
Dialogue: 0,0:57:53.00,0:57:55.88,EN,,0,0,0,,and then we'll go off to evaluate the second operand.
Dialogue: 0,0:57:57.46,0:58:00.48,EN,,0,0,0,,So, at the point where we go off to evaluate the second operand--
Dialogue: 0,0:58:00.52,0:58:02.19,EN,,0,0,0,,and I'll skip details like computing,
Dialogue: 0,0:58:02.20,0:58:03.58,EN,,0,0,0,,N minus 1, and all of that--
Dialogue: 0,0:58:03.71,0:58:05.88,EN,,0,0,0,,but, when we go off to evaluate the second operand,
Dialogue: 0,0:58:06.62,0:58:10.44,EN,,0,0,0,,that will eventually reduce to another call to fact-recursive.
Dialogue: 0,0:58:12.00,0:58:14.20,EN,,0,0,0,,And, what we've got on the stack here is
Dialogue: 0,0:58:16.52,0:58:19.94,EN,,0,0,0,,the operator from that combination that we're going to use it in
Dialogue: 0,0:58:20.12,0:58:21.07,EN,,0,0,0,,and the other argument.
Dialogue: 0,0:58:23.40,0:58:27.61,EN,,0,0,0,,OK? So, now, we're set up for another call
Dialogue: 0,0:58:28.49,0:58:29.69,EN,,0,0,0,,to recursive factorial.
Dialogue: 0,0:58:30.20,0:58:31.43,EN,,0,0,0,,And, when we're done with this one,
Dialogue: 0,0:58:31.56,0:58:33.64,EN,,0,0,0,,we're going to go to accumulate the last arg.
Dialogue: 0,0:58:34.12,0:58:35.20,EN,,0,0,0,,and remember what that'll do?
Dialogue: 0,0:58:35.20,0:58:35.93,EN,,0,0,0,,That'll say oh,
Dialogue: 0,0:58:36.45,0:58:39.28,EN,,0,0,0,,whatever the result of this has to get combined with that,
Dialogue: 0,0:58:39.28,0:58:40.40,EN,,0,0,0,,and we're going to multiply them.
Dialogue: 0,0:58:41.69,0:58:42.38,EN,,0,0,0,,But, notice now,
Dialogue: 0,0:58:42.73,0:58:44.81,EN,,0,0,0,,we're at another recursive factorial.
Dialogue: 0,0:58:45.72,0:58:48.92,EN,,0,0,0,,We're about to call eval-dispatch again,
Dialogue: 0,0:58:49.32,0:58:50.60,EN,,0,0,0,,except we haven't really reduced it
Dialogue: 0,0:58:50.64,0:58:52.08,EN,,0,0,0,,because there's stuff on the stack now.
Dialogue: 0,0:58:53.70,0:58:55.39,EN,,0,0,0,,The stuff on the stack says oh, when you get back,
Dialogue: 0,0:58:55.40,0:58:57.52,EN,,0,0,0,,you'd better multiply it by the 5 you had hanging there.
Dialogue: 0,0:58:58.43,0:59:05.77,EN,,0,0,0,,So, when we go off to make another call,
Dialogue: 0,0:59:07.12,0:59:08.84,EN,,0,0,0,,we evaluate the n minus 1.
Dialogue: 0,0:59:09.30,0:59:11.05,EN,,0,0,0,,That gives us another environment which
Dialogue: 0,0:59:11.25,0:59:13.84,EN,,0,0,0,,in which the new n's going to be down to 4.
Dialogue: 0,0:59:14.60,0:59:16.22,EN,,0,0,0,,And we're about to call eval-dispatch again.
Dialogue: 0,0:59:19.20,0:59:20.22,EN,,0,0,0,,We get another call.
Dialogue: 0,0:59:21.35,0:59:24.44,EN,,0,0,0,,That 4 is going to end up in the same situation.
Dialogue: 0,0:59:26.04,0:59:28.62,EN,,0,0,0,,We'll end up with another call to fact-recursive n.
Dialogue: 0,0:59:30.02,0:59:32.68,EN,,0,0,0,,And sitting on the stack will be the stuff from the original one
Dialogue: 0,0:59:32.88,0:59:34.51,EN,,0,0,0,,and, now, the subsidiary one we're doing.
Dialogue: 0,0:59:35.36,0:59:36.91,EN,,0,0,0,,And both of them are waiting for the same thing.
Dialogue: 0,0:59:36.91,0:59:39.16,EN,,0,0,0,,They're going to go to accumulate a last argument.
Dialogue: 0,0:59:40.51,0:59:42.94,EN,,0,0,0,,And then, of course, when we go to the fourth call,
Dialogue: 0,0:59:43.25,0:59:44.38,EN,,0,0,0,,the same thing happens.
Dialogue: 0,0:59:45.64,0:59:47.07,EN,,0,0,0,,And this goes on, and on, and on.
Dialogue: 0,0:59:47.30,0:59:48.60,EN,,0,0,0,,And what you see here on the stack,
Dialogue: 0,0:59:50.30,0:59:52.22,EN,,0,0,0,,exactly what's sitting here on the stack,
Dialogue: 0,0:59:52.22,0:59:54.59,EN,,0,0,0,,the thing that says times and 5.
Dialogue: 0,0:59:54.96,0:59:56.40,EN,,0,0,0,,And what you're going to do with that
Dialogue: 0,0:59:56.59,0:59:58.54,EN,,0,0,0,,accumulate that into a last argument.
Dialogue: 0,1:00:00.47,1:00:02.01,EN,,0,0,0,,That's exactly this, right?
Dialogue: 0,1:00:02.01,1:00:04.75,EN,,0,0,0,,This is exactly where that stuff is hanging.
Dialogue: 0,1:00:05.65,1:00:10.65,EN,,0,0,0,,Effectively, the operator you're going to apply,
Dialogue: 0,1:00:11.72,1:00:14.30,EN,,0,0,0,,the other argument that it's got
Dialogue: 0,1:00:14.32,1:00:15.79,EN,,0,0,0,,to be multiplied by when you get back
Dialogue: 0,1:00:15.80,1:00:16.91,EN,,0,0,0,,and sort of the parentheses,
Dialogue: 0,1:00:16.94,1:00:18.96,EN,,0,0,0,,which says yeah, what you wanted to do was accumulate them.
Dialogue: 0,1:00:19.62,1:00:21.88,EN,,0,0,0,,So, you see, the substitution model is not such a lie.
Dialogue: 0,1:00:22.56,1:00:23.63,EN,,0,0,0,,That really is, in some sense,
Dialogue: 0,1:00:23.64,1:00:25.31,EN,,0,0,0,,what's sitting right on the stack.
Dialogue: 0,1:00:29.37,1:00:30.40,EN,,0,0,0,,All right, so that,
Dialogue: 0,1:00:30.81,1:00:32.48,EN,,0,0,0,,in some sense, should explain for you,
Dialogue: 0,1:00:33.26,1:00:34.52,EN,,0,0,0,,or at least convince you,
Dialogue: 0,1:00:35.93,1:00:38.72,EN,,0,0,0,,that somehow, this evaluator is managing
Dialogue: 0,1:00:40.06,1:00:42.86,EN,,0,0,0,,to take these procedures and execute some of them iteratively
Dialogue: 0,1:00:42.95,1:00:44.25,EN,,0,0,0,,and some of them recursively,
Dialogue: 0,1:00:45.26,1:00:47.45,EN,,0,0,0,,even though, as syntactically,
Dialogue: 0,1:00:47.45,1:00:49.05,EN,,0,0,0,,they look like recursive procedures.
Dialogue: 0,1:00:49.40,1:00:50.64,EN,,0,0,0,,How's it managing to do that?
Dialogue: 0,1:00:50.66,1:00:53.72,EN,,0,0,0,,Well, the basic reason it's managing to do that
Dialogue: 0,1:00:53.80,1:00:55.68,EN,,0,0,0,,is the evaluator is set up
Dialogue: 0,1:00:56.04,1:00:59.26,EN,,0,0,0,,to save only what it needs later.
Dialogue: 0,1:01:01.09,1:01:04.25,EN,,0,0,0,,So, for example, at the point where you've reduced
Dialogue: 0,1:01:04.67,1:01:07.39,EN,,0,0,0,,evaluating an expression and an environment
Dialogue: 0,1:01:07.87,1:01:09.87,EN,,0,0,0,,to applying a procedure to some arguments,
Dialogue: 0,1:01:10.52,1:01:12.49,EN,,0,0,0,,it doesn't need that original environment anymore
Dialogue: 0,1:01:13.37,1:01:16.65,EN,,0,0,0,,because any environment stuff will be packaged inside the procedures
Dialogue: 0,1:01:17.88,1:01:19.36,EN,,0,0,0,,where the application's going to happen.
Dialogue: 0,1:01:20.75,1:01:21.61,EN,,0,0,0,,All right, similarly,
Dialogue: 0,1:01:21.63,1:01:23.65,EN,,0,0,0,,when you're going along evaluating an argument list,
Dialogue: 0,1:01:23.65,1:01:25.20,EN,,0,0,0,,when you've finished evaluating the list,
Dialogue: 0,1:01:25.91,1:01:28.03,EN,,0,0,0,,when you're finished evaluating the last argument,
Dialogue: 0,1:01:28.20,1:01:31.61,EN,,0,0,0,,you don't need that argument list any more, right?
Dialogue: 0,1:01:31.63,1:01:32.94,EN,,0,0,0,,And you don't need the environment where
Dialogue: 0,1:01:33.04,1:01:34.64,EN,,0,0,0,,those arguments would be evaluated.
Dialogue: 0,1:01:36.69,1:01:40.89,EN,,0,0,0,,So the basic reason that this interpreter is being so smart
Dialogue: 0,1:01:40.89,1:01:42.88,EN,,0,0,0,,is that it's not being smart at all, it's being stupid.
Dialogue: 0,1:01:43.05,1:01:45.74,EN,,0,0,0,,It's just saying I'm only going to save what I really need.
Dialogue: 0,1:01:48.70,1:01:51.00,EN,,0,0,0,,Well, let me show you here.
Dialogue: 0,1:01:53.07,1:01:57.20,EN,,0,0,0,,Here's the actual thing that's making a tail recursive.
Dialogue: 0,1:01:58.31,1:02:00.20,EN,,0,0,0,,Remember, it's the restore of continue.
Dialogue: 0,1:02:00.22,1:02:06.94,EN,,0,0,0,,It's saying when I go off to evaluate the procedure body,
Dialogue: 0,1:02:08.96,1:02:11.00,EN,,0,0,0,,I should tell eval to come back to
Dialogue: 0,1:02:11.25,1:02:12.54,EN,,0,0,0,,the place where that original
Dialogue: 0,1:02:12.54,1:02:14.25,EN,,0,0,0,,evaluation was supposed to come back to.
Dialogue: 0,1:02:15.17,1:02:15.95,EN,,0,0,0,,So, in some sense,
Dialogue: 0,1:02:16.17,1:02:18.84,EN,,0,0,0,,you want to say what's the actual line that makes tail recursive
Dialogue: 0,1:02:18.89,1:02:19.44,EN,,0,0,0,,It's that one.
Dialogue: 0,1:02:19.92,1:02:21.53,EN,,0,0,0,,If I wanted to build a non-
Dialogue: 0,1:02:21.77,1:02:24.80,EN,,0,0,0,,tail recursive evaluator, for some strange reason,
Dialogue: 0,1:02:25.69,1:02:26.86,EN,,0,0,0,,all I would need to do
Dialogue: 0,1:02:27.12,1:02:29.29,EN,,0,0,0,,is, instead of restoring continue at this point,
Dialogue: 0,1:02:30.06,1:02:31.66,EN,,0,0,0,,I'd set up a label down here
Dialogue: 0,1:02:32.75,1:02:36.25,EN,,0,0,0,,called, "Where to come back after you've finished applying the procedure."
Dialogue: 0,1:02:37.64,1:02:39.71,EN,,0,0,0,,Instead, I'd set continue to that.
Dialogue: 0,1:02:39.92,1:02:41.21,EN,,0,0,0,,I'd go to eval-dispatch,
Dialogue: 0,1:02:41.40,1:02:43.21,EN,,0,0,0,,and then eval-dispatch would come back here.
Dialogue: 0,1:02:43.79,1:02:44.30,EN,,0,0,0,,At that point,
Dialogue: 0,1:02:44.32,1:02:45.28,EN,,0,0,0,,I would restore continue
Dialogue: 0,1:02:45.29,1:02:46.52,EN,,0,0,0,,and go to the original one.
Dialogue: 0,1:02:47.92,1:02:51.00,EN,,0,0,0,,So here, the only consequence of that
Dialogue: 0,1:02:51.15,1:02:52.68,EN,,0,0,0,,would be to make it non-tail recursive.
Dialogue: 0,1:02:52.84,1:02:54.62,EN,,0,0,0,,It would give you exactly the same answers,
Dialogue: 0,1:02:54.72,1:02:57.02,EN,,0,0,0,,except if you did that iterative factorial
Dialogue: 0,1:02:57.05,1:02:58.36,EN,,0,0,0,,and all those iterative procedures,
Dialogue: 0,1:02:58.60,1:02:59.80,EN,,0,0,0,,it would execute recursively.
Dialogue: 0,1:03:03.04,1:03:05.40,EN,,0,0,0,,Well, I lied to you a little bit, but just a little bit,
Dialogue: 0,1:03:05.76,1:03:06.99,EN,,0,0,0,,because I showed you a slightly
Dialogue: 0,1:03:07.02,1:03:08.33,EN,,0,0,0,,over-simplified evaluator
Dialogue: 0,1:03:08.72,1:03:10.38,EN,,0,0,0,,where it assumes that each procedure --
Dialogue: 0,1:03:11.36,1:03:13.66,EN,,0,0,0,,each procedure body has only one expression.
Dialogue: 0,1:03:13.89,1:03:14.54,EN,,0,0,0,,Remember, in general,
Dialogue: 0,1:03:14.56,1:03:16.57,EN,,0,0,0,,a procedure has a sequence of expressions in it.
Dialogue: 0,1:03:17.87,1:03:20.49,EN,,0,0,0,,So there's nothing really conceptually new.
Dialogue: 0,1:03:20.49,1:03:22.28,EN,,0,0,0,,Let me just show you the actual evaluator
Dialogue: 0,1:03:22.89,1:03:24.73,EN,,0,0,0,,that handles sequences of expressions.
Dialogue: 0,1:03:28.47,1:03:29.74,EN,,0,0,0,,This is compound-apply now,
Dialogue: 0,1:03:29.74,1:03:31.31,EN,,0,0,0,,and the only difference from the old one
Dialogue: 0,1:03:32.07,1:03:34.33,EN,,0,0,0,,is that, instead of going off to eval directly,
Dialogue: 0,1:03:35.98,1:03:38.03,EN,,0,0,0,,it takes the whole body of the procedure,
Dialogue: 0,1:03:38.03,1:03:40.15,EN,,0,0,0,,which, in this case, is a sequence of expressions,
Dialogue: 0,1:03:40.28,1:03:41.71,EN,,0,0,0,,and goes off to eval-sequence.
Dialogue: 0,1:03:42.60,1:03:45.32,EN,,0,0,0,,And eval-sequence is a little loop
Dialogue: 0,1:03:46.83,1:03:49.98,EN,,0,0,0,,that, basically, does these evaluations one at a time.
Dialogue: 0,1:03:52.63,1:03:53.85,EN,,0,0,0,,So it does an evaluation.
Dialogue: 0,1:03:53.90,1:03:54.94,EN,,0,0,0,,Says oh, when I come back,
Dialogue: 0,1:03:54.97,1:03:56.86,EN,,0,0,0,,I'd better come back here to do the next one.
Dialogue: 0,1:03:58.44,1:03:59.29,EN,,0,0,0,,And, when I'm all done,
Dialogue: 0,1:03:59.29,1:04:01.02,EN,,0,0,0,,when I want to get the last expression,
Dialogue: 0,1:04:01.31,1:04:03.28,EN,,0,0,0,,I just restore my continue
Dialogue: 0,1:04:03.92,1:04:05.28,EN,,0,0,0,,and go off to eval-dispatch.
Dialogue: 0,1:04:06.41,1:04:08.20,EN,,0,0,0,,And, again, if you wanted for some reason
Dialogue: 0,1:04:08.20,1:04:10.35,EN,,0,0,0,,to break tail recursion in this evaluator,
Dialogue: 0,1:04:10.64,1:04:13.71,EN,,0,0,0,,all you need to do is not handle the last expression, especially.
Dialogue: 0,1:04:14.90,1:04:17.34,EN,,0,0,0,,Just say, after you've done the last expression,
Dialogue: 0,1:04:17.36,1:04:18.65,EN,,0,0,0,,come back to some other place
Dialogue: 0,1:04:19.15,1:04:20.68,EN,,0,0,0,,after which you restore continue.
Dialogue: 0,1:04:21.90,1:04:23.26,EN,,0,0,0,,And, for some reason,
Dialogue: 0,1:04:23.26,1:04:25.74,EN,,0,0,0,,a lot of LISP evaluators tended to work that way.
Dialogue: 0,1:04:26.55,1:04:28.44,EN,,0,0,0,,And the only consequence of that is that
Dialogue: 0,1:04:28.86,1:04:30.72,EN,,0,0,0,,iterative procedures built up stack.
Dialogue: 0,1:04:31.88,1:04:33.61,EN,,0,0,0,,And it's not clear why that happened.
Dialogue: 0,1:04:35.92,1:04:37.98,EN,,0,0,0,,All right. Well, let me just sort of summarize,
Dialogue: 0,1:04:38.09,1:04:39.60,EN,,0,0,0,,since this is a lot of details
Dialogue: 0,1:04:39.98,1:04:41.04,EN,,0,0,0,,in a big program.
Dialogue: 0,1:04:41.12,1:04:42.25,EN,,0,0,0,,But the main point is that
Dialogue: 0,1:04:43.04,1:04:43.87,EN,,0,0,0,,it's no different,
Dialogue: 0,1:04:44.04,1:04:46.08,EN,,0,0,0,,conceptually, from translating any other program.
Dialogue: 0,1:04:47.06,1:04:48.06,EN,,0,0,0,,And the main idea is that
Dialogue: 0,1:04:48.06,1:04:50.28,EN,,0,0,0,,we have this universal evaluator program,
Dialogue: 0,1:04:50.33,1:04:51.71,EN,,0,0,0,,the meta-circular evaluator.
Dialogue: 0,1:04:51.87,1:04:53.07,EN,,0,0,0,,If we translate that into LISP,
Dialogue: 0,1:04:53.10,1:04:53.95,EN,,0,0,0,,then we have all of LISP.
Dialogue: 0,1:04:54.33,1:04:55.15,EN,,0,0,0,,And that's all we did.
Dialogue: 0,1:04:57.98,1:04:59.68,EN,,0,0,0,,The second point is that the magic's gone away.
Dialogue: 0,1:04:59.68,1:05:01.97,EN,,0,0,0,,There should be no more magic in this whole system, right?
Dialogue: 0,1:05:01.97,1:05:07.79,EN,,0,0,0,,In principle, it should all be very clear
Dialogue: 0,1:05:07.82,1:05:10.08,EN,,0,0,0,,except, maybe, for how list structured memory works,
Dialogue: 0,1:05:10.80,1:05:11.80,EN,,0,0,0,,and we'll see that later.
Dialogue: 0,1:05:12.64,1:05:14.20,EN,,0,0,0,,But that's not very hard.
Dialogue: 0,1:05:15.45,1:05:16.35,EN,,0,0,0,,The third point is that
Dialogue: 0,1:05:16.35,1:05:17.52,EN,,0,0,0,,all this tail recursion
Dialogue: 0,1:05:18.24,1:05:21.96,EN,,0,0,0,,came from the discipline of eval being very careful
Dialogue: 0,1:05:22.55,1:05:24.51,EN,,0,0,0,,to save only what it needs next time.
Dialogue: 0,1:05:25.87,1:05:27.72,EN,,0,0,0,,It's not some arbitrary thing
Dialogue: 0,1:05:27.76,1:05:29.86,EN,,0,0,0,,where we're saying well, whenever we call a sub-routine,
Dialogue: 0,1:05:29.86,1:05:32.16,EN,,0,0,0,,we'll save all the registers in the world and come back?
Dialogue: 0,1:05:33.94,1:05:36.49,EN,,0,0,0,,See, sometimes it pays to really worry about efficiency.
Dialogue: 0,1:05:37.15,1:05:39.96,EN,,0,0,0,,And, when you're down in the guts of your evaluator machine,
Dialogue: 0,1:05:40.45,1:05:42.56,EN,,0,0,0,,it really pays to think about things like that
Dialogue: 0,1:05:42.56,1:05:43.96,EN,,0,0,0,,because it makes big consequences.
Dialogue: 0,1:05:45.23,1:05:47.69,EN,,0,0,0,,Well, I hope what this has done
Dialogue: 0,1:05:47.90,1:05:52.30,EN,,0,0,0,,is really made the evaluator seem concrete.
Dialogue: 0,1:05:52.56,1:05:53.90,EN,,0,0,0,,I hope you really believe
Dialogue: 0,1:05:54.32,1:05:56.27,EN,,0,0,0,,that somebody could hold a LISP
Dialogue: 0,1:05:56.84,1:05:58.56,EN,,0,0,0,,LISP evaluator in the palm of their hand.
Dialogue: 0,1:05:59.07,1:06:00.49,EN,,0,0,0,,Maybe to help you believe that, here's a
Dialogue: 0,1:06:00.80,1:06:01.96,EN,,0,0,0,,here's a LISP evaluator
Dialogue: 0,1:06:02.54,1:06:04.06,EN,,0,0,0,,that I'm holding the palm of my hand.
Dialogue: 0,1:06:06.16,1:06:10.56,EN,,0,0,0,,And this is a chip which is actually
Dialogue: 0,1:06:10.89,1:06:13.70,EN,,0,0,0,,quite a bit more complicated than the evaluator I showed you.
Dialogue: 0,1:06:16.86,1:06:19.20,EN,,0,0,0,,Uh.. maybe, here's a better picture of it.
Dialogue: 0,1:06:22.07,1:06:22.57,EN,,0,0,0,,What there is,
Dialogue: 0,1:06:22.60,1:06:24.38,EN,,0,0,0,,is you can see the same overall structure.
Dialogue: 0,1:06:24.73,1:06:25.93,EN,,0,0,0,,This is a register array.
Dialogue: 0,1:06:26.80,1:06:27.71,EN,,0,0,0,,These are the data paths.
Dialogue: 0,1:06:27.72,1:06:29.07,EN,,0,0,0,,Here's a finite state controller.
Dialogue: 0,1:06:29.80,1:06:31.04,EN,,0,0,0,,And again, finite state,
Dialogue: 0,1:06:31.96,1:06:32.80,EN,,0,0,0,,that's all there is.
Dialogue: 0,1:06:32.81,1:06:34.16,EN,,0,0,0,,And somewhere there's external memory
Dialogue: 0,1:06:34.16,1:06:35.23,EN,,0,0,0,,that'll worry about things.
Dialogue: 0,1:06:35.75,1:06:37.63,EN,,0,0,0,,And this particular one is very complicated
Dialogue: 0,1:06:37.64,1:06:39.16,EN,,0,0,0,,because it's trying to run LISP fast.
Dialogue: 0,1:06:39.66,1:06:42.97,EN,,0,0,0,,And it has some very, very fast parallel operations in there
Dialogue: 0,1:06:43.07,1:06:46.32,EN,,0,0,0,,like, if you want to index into an array,
Dialogue: 0,1:06:46.70,1:06:50.40,EN,,0,0,0,,simultaneously check that the index is an integer,
Dialogue: 0,1:06:50.43,1:06:52.86,EN,,0,0,0,,check that it doesn't exceed the array bands,
Dialogue: 0,1:06:53.04,1:06:55.02,EN,,0,0,0,,and go off and do the memory access,
Dialogue: 0,1:06:55.05,1:06:56.70,EN,,0,0,0,,and do all those things simultaneously.
Dialogue: 0,1:06:57.12,1:06:58.40,EN,,0,0,0,,And then, later, if they're all OK,
Dialogue: 0,1:06:58.44,1:06:59.96,EN,,0,0,0,,actually get the value there.
Dialogue: 0,1:07:00.42,1:07:02.46,EN,,0,0,0,,So there are a lot of complicated operations
Dialogue: 0,1:07:02.48,1:07:04.65,EN,,0,0,0,,in these data paths for making LISP run in parallel.
Dialogue: 0,1:07:05.26,1:07:08.41,EN,,0,0,0,,It's a completely non-risk
Dialogue: 0,1:07:08.76,1:07:10.36,EN,,0,0,0,,philosophy of evaluating LISP.
Dialogue: 0,1:07:10.64,1:07:13.20,EN,,0,0,0,,And then, this microcode is pretty complicated.
Dialogue: 0,1:07:13.45,1:07:17.56,EN,,0,0,0,,Let's see, there's what?
Dialogue: 0,1:07:17.60,1:07:21.10,EN,,0,0,0,,There's about 389 instructions of
Dialogue: 0,1:07:21.68,1:07:23.85,EN,,0,0,0,,of 220-bit microcode sitting here
Dialogue: 0,1:07:24.07,1:07:27.94,EN,,0,0,0,,because these are very complicated data paths.
Dialogue: 0,1:07:27.94,1:07:32.25,EN,,0,0,0,,And the whole thing has about 89,000 transistors, OK?
Dialogue: 0,1:07:33.56,1:07:36.86,EN,,0,0,0,,OK. Well, I hope that that takes away a lot of the mystery.
Dialogue: 0,1:07:37.97,1:07:39.24,EN,,0,0,0,,Maybe somebody wants to look at this.
Dialogue: 0,1:07:46.14,1:07:46.89,EN,,0,0,0,,OK. Let's stop.
Dialogue: 0,1:07:56.46,1:07:56.75,EN,,0,0,0,,Questions?
Dialogue: 0,1:07:59.00,1:08:00.42,EN,,0,0,0,,AUDIENCE: OK, now, it sounds like what you're saying is that,
Dialogue: 0,1:08:00.42,1:08:03.48,EN,,0,0,0,,with the restore continue put in the proper place,
Dialogue: 0,1:08:03.58,1:08:09.42,EN,,0,0,0,,that procedures that would invoke a recursive process
Dialogue: 0,1:08:09.42,1:08:11.95,EN,,0,0,0,,now invoke an iterative process
Dialogue: 0,1:08:12.67,1:08:15.36,EN,,0,0,0,,just by the way that the eval-sequence source?
Dialogue: 0,1:08:15.60,1:08:17.54,EN,,0,0,0,,PROFESSOR: I think the way I'd prefer to put it is that,
Dialogue: 0,1:08:17.54,1:08:19.82,EN,,0,0,0,,with restore continue put in the wrong place,
Dialogue: 0,1:08:20.55,1:08:25.48,EN,,0,0,0,,you can cause any syntactically-looking recursive procedure,
Dialogue: 0,1:08:25.52,1:08:27.28,EN,,0,0,0,,in fact, to build up stack as it runs.
Dialogue: 0,1:08:28.64,1:08:30.52,EN,,0,0,0,,But there's no reason for that,
Dialogue: 0,1:08:33.15,1:08:35.12,EN,,0,0,0,,so you might want to play around with it.
Dialogue: 0,1:08:35.15,1:08:38.09,EN,,0,0,0,,You can just switch around two or three instructions
Dialogue: 0,1:08:38.18,1:08:40.78,EN,,0,0,0,,in the way compound-apply comes back,
Dialogue: 0,1:08:41.31,1:08:43.26,EN,,0,0,0,,and you'll get something which isn't tail recursive.
Dialogue: 0,1:08:45.06,1:08:46.14,EN,,0,0,0,,But the thing I wanted to emphasize
Dialogue: 0,1:08:46.16,1:08:47.40,EN,,0,0,0,,is there's no magic. there's no
Dialogue: 0,1:08:47.67,1:08:48.57,EN,,0,0,0,,It's not as if
Dialogue: 0,1:08:49.31,1:08:52.17,EN,,0,0,0,,there's some very clever pre-processing program
Dialogue: 0,1:08:52.65,1:08:55.45,EN,,0,0,0,,that's looking at this procedure, factorial iter,
Dialogue: 0,1:08:55.47,1:08:56.73,EN,,0,0,0,,and say oh, gee, um
Dialogue: 0,1:08:57.42,1:08:58.86,EN,,0,0,0,,I really notice that
Dialogue: 0,1:08:58.88,1:09:01.13,EN,,0,0,0,,I don't have to push stack in order to do this.
Dialogue: 0,1:09:01.13,1:09:02.88,EN,,0,0,0,,Some people think that that's what's going on.
Dialogue: 0,1:09:03.76,1:09:05.38,EN,,0,0,0,,It's something much, much more dumb than that,
Dialogue: 0,1:09:05.38,1:09:07.50,EN,,0,0,0,,it's this one place you're putting the restore instruction.
Dialogue: 0,1:09:08.56,1:09:09.79,EN,,0,0,0,,It's just automatic.
Dialogue: 0,1:09:14.72,1:09:17.55,EN,,0,0,0,,AUDIENCE: But that's not affecting the time complexity is it?
Dialogue: 0,1:09:17.58,1:09:17.87,EN,,0,0,0,,PROFESSOR: No.
Dialogue: 0,1:09:18.60,1:09:21.77,EN,,0,0,0,,AUDIENCE: It's just that it's handling it recursively
Dialogue: 0,1:09:21.80,1:09:23.02,EN,,0,0,0,,instead of iteratively.
Dialogue: 0,1:09:23.02,1:09:27.34,EN,,0,0,0,,But, in terms of the order of time it takes to finish the operation,
Dialogue: 0,1:09:27.37,1:09:29.22,EN,,0,0,0,,it's the same one way or the other, right?
Dialogue: 0,1:09:29.47,1:09:29.76,EN,,0,0,0,,PROFESSOR: Yes.
Dialogue: 0,1:09:29.79,1:09:32.68,EN,,0,0,0,,Tail recursion is not going to change the time complexity of anything
Dialogue: 0,1:09:32.72,1:09:33.29,EN,,0,0,0,,because, in some sense,
Dialogue: 0,1:09:33.34,1:09:35.15,EN,,0,0,0,,it's the same algorithm that's going on.
Dialogue: 0,1:09:36.02,1:09:39.37,EN,,0,0,0,,What it's doing is really making this thing run as an iteration.
Dialogue: 0,1:09:41.00,1:09:42.64,EN,,0,0,0,,Right? Not going to run out of memory
Dialogue: 0,1:09:42.68,1:09:44.22,EN,,0,0,0,,you know counting up to a giant number
Dialogue: 0,1:09:44.75,1:09:46.40,EN,,0,0,0,,simply because the stack would get pushed.
Dialogue: 0,1:09:48.35,1:09:50.24,EN,,0,0,0,,See, the thing you really have to believe is that,
Dialogue: 0,1:09:50.56,1:09:51.13,EN,,0,0,0,,when we write--
Dialogue: 0,1:09:51.64,1:09:53.78,EN,,0,0,0,,see, we've been writing all these things called iterations,
Dialogue: 0,1:09:53.93,1:09:57.99,EN,,0,0,0,,infinite loops, define loop to be called loop.
Dialogue: 0,1:10:00.32,1:10:03.36,EN,,0,0,0,,That's is as much an iteration
Dialogue: 0,1:10:03.65,1:10:05.66,EN,,0,0,0,,you know as if we wrote do forever loop.
Dialogue: 0,1:10:07.63,1:10:09.28,EN,,0,0,0,,It's just syntactic sugar as the difference.
Dialogue: 0,1:10:09.28,1:10:11.32,EN,,0,0,0,,These things are real, honest to god, iterations?
Dialogue: 0,1:10:14.73,1:10:16.08,EN,,0,0,0,,They don't change the time complexity,
Dialogue: 0,1:10:16.11,1:10:18.53,EN,,0,0,0,,but they turn them into real iterations.
Dialogue: 0,1:10:21.68,1:10:23.80,EN,,0,0,0,,All right, thank you.
Dialogue: 0,0:00:00.03,0:00:00.97,Declare,,0,0,0,,{\an2\fad(500,500)}Learning-SICP 学习小组\N倾情制作
Dialogue: 0,0:00:01.05,0:00:09.09,title,,0,0,0,,{\fad(600,800)\pos(324,32)}《计算机程序的构造和解释》
Dialogue: 0,0:00:01.05,0:00:09.09,staff,,0,0,0,,{\fad(600,800)\pos(110.666,403.334)}翻译&&时间轴\N邓雄飞\N刘殊君
Dialogue: 0,0:00:01.05,0:00:09.09,staff,,0,0,0,,{\fad(600,800)\pos(534.666,404)}压制&&特效\N邓雄飞\N（Dysprosium）
Dialogue: 0,0:00:01.05,0:00:09.09,staff,,0,0,0,,{\fad(600,800)\pos(574.667,277.333)}校对\N邓雄飞
Dialogue: 0,0:00:01.05,0:00:09.09,staff,,0,0,0,,{\fad(600,800)\pos(89.334,273.333)}特别感谢\N裘宗燕教授
Dialogue: 0,0:00:09.21,0:00:13.12,Declare,,0,0,0,,{\an2\fad(500,500)}显示控制求值器
Dialogue: 0,0:00:16.30,0:00:18.08,Default,,0,0,0,,教授：我想大家已经意识到
Dialogue: 0,0:00:20.01,0:00:22.73,Default,,0,0,0,,我们介绍了一些真正的魔法
Dialogue: 0,0:00:24.20,0:00:27.24,Default,,0,0,0,,创造新语言的魔法
Dialogue: 0,0:00:27.42,0:00:28.72,Default,,0,0,0,,用来创造全新的语言
Dialogue: 0,0:00:29.69,0:00:30.40,Default,,0,0,0,,我们学了些什么？
Dialogue: 0,0:00:30.43,0:00:32.78,Default,,0,0,0,,我们学习了一门用来操作图片的Escher的语言
Dialogue: 0,0:00:38.92,0:00:41.15,Default,,0,0,0,,这门语言由Peter Henderson发明
Dialogue: 0,0:00:42.01,0:00:46.49,Default,,0,0,0,,我们还学习了数字逻辑语言
Dialogue: 0,0:00:53.16,0:00:55.55,Default,,0,0,0,,以及 我们还学习了查询语言
Dialogue: 0,0:00:59.70,0:01:00.78,Default,,0,0,0,,然而你需要明白的是
Dialogue: 0,0:01:00.81,0:01:03.10,Default,,0,0,0,,尽管它们都是“玩具级”的语言示例
Dialogue: 0,0:01:04.70,0:01:07.61,Default,,0,0,0,,但也确实是实用工具的核心
Dialogue: 0,0:01:08.25,0:01:09.48,Default,,0,0,0,,比如说
Dialogue: 0,0:01:10.12,0:01:11.18,Default,,0,0,0,,Escher图片语言
Dialogue: 0,0:01:11.20,0:01:14.33,Default,,0,0,0,,就被MIT的学生Henry Wu拿去
Dialogue: 0,0:01:14.88,0:01:16.43,Default,,0,0,0,,开发成了一门用于
Dialogue: 0,0:01:16.97,0:01:19.45,Default,,0,0,0,,为电路板布局的语言
Dialogue: 0,0:01:20.35,0:01:22.56,Default,,0,0,0,,它就是在这些结构上扩展而来
Dialogue: 0,0:01:23.24,0:01:24.65,Default,,0,0,0,,至于数字逻辑语言
Dialogue: 0,0:01:24.68,0:01:26.08,Default,,0,0,0,,Gerry教授在上课的时候也提到过
Dialogue: 0,0:01:26.43,0:01:29.92,Default,,0,0,0,,它被扩展为了一个仿真器的基础
Dialogue: 0,0:01:30.85,0:01:32.96,Default,,0,0,0,,用来设计真实的计算机
Dialogue: 0,0:01:33.46,0:01:34.32,Default,,0,0,0,,至于查询语言
Dialogue: 0,0:01:34.35,0:01:36.44,Default,,0,0,0,,当然就是Prolog语言的一种核心
Dialogue: 0,0:01:37.51,0:01:39.07,Default,,0,0,0,,我们构造的这些语言
Dialogue: 0,0:01:39.55,0:01:40.65,Default,,0,0,0,,全都是用Lisp编写
Dialogue: 0,0:01:43.63,0:01:44.59,Default,,0,0,0,,很多人问
Dialogue: 0,0:01:45.27,0:01:48.73,Default,,0,0,0,,Lisp适合用来解决哪一类问题？
Dialogue: 0,0:01:48.75,0:01:49.93,Default,,0,0,0,,答案就是
Dialogue: 0,0:01:50.33,0:01:52.65,Default,,0,0,0,,Lisp不适合解决任何一类问题
Dialogue: 0,0:01:53.53,0:01:54.60,Default,,0,0,0,,Lisp擅长的是
Dialogue: 0,0:01:54.73,0:01:57.15,Default,,0,0,0,,用它来构造一门合适的语言
Dialogue: 0,0:01:57.18,0:01:58.57,Default,,0,0,0,,来解决你的问题
Dialogue: 0,0:01:59.17,0:02:00.44,Default,,0,0,0,,你应该像这样看待Lisp
Dialogue: 0,0:02:01.47,0:02:03.39,Default,,0,0,0,,那么既然这些语言都基于Lisp
Dialogue: 0,0:02:04.57,0:02:05.72,Default,,0,0,0,,那Lisp又基于什么？
Dialogue: 0,0:02:06.97,0:02:07.88,Default,,0,0,0,,它又从何而来？
Dialogue: 0,0:02:07.90,0:02:09.40,Default,,0,0,0,,这个我们也学过
Dialogue: 0,0:02:09.58,0:02:16.09,Default,,0,0,0,,我们学过元循环求值器
Dialogue: 0,0:02:21.53,0:02:23.40,Default,,0,0,0,,学习了元循环求值器后 我们说
Dialogue: 0,0:02:23.42,0:02:25.76,Default,,0,0,0,,Lisp就是基于Lisp的
Dialogue: 0,0:02:25.80,0:02:27.48,Default,,0,0,0,,而当我们研究它的时候
Dialogue: 0,0:02:28.27,0:02:29.95,Default,,0,0,0,,我们必须得施展一些真正的魔法 对吧？
Dialogue: 0,0:02:29.95,0:02:31.74,Default,,0,0,0,,这又是什么意思呢？
Dialogue: 0,0:02:31.74,0:02:34.96,Default,,0,0,0,,Y算子、不动点
Dialogue: 0,0:02:35.76,0:02:38.33,Default,,0,0,0,,以及这样的一个观念--
Dialogue: 0,0:02:38.36,0:02:41.44,Default,,0,0,0,,Lisp实际上是一个方程的不动点
Dialogue: 0,0:02:42.20,0:02:45.42,Default,,0,0,0,,一个通过自身来定义的有趣方程
Dialogue: 0,0:02:47.40,0:02:48.56,Default,,0,0,0,,这确实是神奇的魔法
Dialogue: 0,0:02:49.07,0:02:52.35,Default,,0,0,0,,那么今天 作为魔法的最后一步
Dialogue: 0,0:02:52.62,0:02:54.03,Default,,0,0,0,,我们要把它们通通消除掉
Dialogue: 0,0:03:06.80,0:03:07.98,Default,,0,0,0,,我们已经知道怎么做了
Dialogue: 0,0:03:09.77,0:03:10.76,Default,,0,0,0,,核心要思想是
Dialogue: 0,0:03:11.13,0:03:12.73,Default,,0,0,0,,将Lisp语言
Dialogue: 0,0:03:13.36,0:03:15.50,Default,,0,0,0,,实现在使用寄存器架构的机器上
Dialogue: 0,0:03:15.50,0:03:17.93,Default,,0,0,0,,回想一下 寄存器机器的关键之处在于
Dialogue: 0,0:03:19.60,0:03:24.68,Default,,0,0,0,,机器的一部分是确定且有穷的
Dialogue: 0,0:03:24.72,0:03:26.12,Default,,0,0,0,,它有一个有穷状态控制器
Dialogue: 0,0:03:26.12,0:03:27.87,Default,,0,0,0,,它用特定的硬件
Dialogue: 0,0:03:27.88,0:03:29.31,Default,,0,0,0,,去完成特定的事情
Dialogue: 0,0:03:30.51,0:03:31.74,Default,,0,0,0,,其中还有一些运算所需的
Dialogue: 0,0:03:31.76,0:03:33.24,Default,,0,0,0,,特殊数据通路
Dialogue: 0,0:03:33.55,0:03:35.29,Default,,0,0,0,,然后 为了实现递归
Dialogue: 0,0:03:35.53,0:03:37.60,Default,,0,0,0,,并且维持无穷的假象
Dialogue: 0,0:03:37.82,0:03:39.77,Default,,0,0,0,,还使用了一种称作“栈”的大内存
Dialogue: 0,0:03:42.06,0:03:43.72,Default,,0,0,0,,所以如果我们在
Dialogue: 0,0:03:43.92,0:03:45.50,Default,,0,0,0,,寄存器机器上实现了Lisp
Dialogue: 0,0:03:47.02,0:03:48.35,Default,,0,0,0,,那么这个时候
Dialogue: 0,0:03:48.40,0:03:49.85,Default,,0,0,0,,所有的东西都会完全具体化
Dialogue: 0,0:03:49.85,0:03:51.23,Default,,0,0,0,,所有的魔法都会消除
Dialogue: 0,0:03:51.65,0:03:53.52,Default,,0,0,0,,这堂课结束时
Dialogue: 0,0:03:53.53,0:03:54.78,Default,,0,0,0,,我想让你感觉到
Dialogue: 0,0:03:55.14,0:03:59.05,Default,,0,0,0,,相对于神秘的元循环求值器
Dialogue: 0,0:03:59.67,0:04:02.60,Default,,0,0,0,,Lisp求值器是非常具体的东西
Dialogue: 0,0:04:02.85,0:04:04.57,Default,,0,0,0,,你甚至可以把它放在手心中
Dialogue: 0,0:04:04.76,0:04:06.24,Default,,0,0,0,,你可以想象一下
Dialogue: 0,0:04:06.57,0:04:07.90,Default,,0,0,0,,手里拿着一个Lisp解释器的情景
Dialogue: 0,0:04:09.63,0:04:10.94,Default,,0,0,0,,好 那我们怎么做呢？
Dialogue: 0,0:04:10.95,0:04:12.76,Default,,0,0,0,,所有的原料都已经齐全
Dialogue: 0,0:04:13.96,0:04:17.45,Default,,0,0,0,,上节课Gerry教了你们
Dialogue: 0,0:04:17.60,0:04:21.47,Default,,0,0,0,,对一个任意的Lisp过程
Dialogue: 0,0:04:22.60,0:04:24.28,Default,,0,0,0,,如何手动地把它们
Dialogue: 0,0:04:24.75,0:04:26.67,Default,,0,0,0,,翻译成在寄存器机器上运行的代码
Dialogue: 0,0:04:28.20,0:04:30.52,Default,,0,0,0,,那么 要在寄存器机器上实现Lisp本身
Dialogue: 0,0:04:30.57,0:04:31.44,Default,,0,0,0,,我们只需要
Dialogue: 0,0:04:31.69,0:04:33.45,Default,,0,0,0,,把最关键的过程
Dialogue: 0,0:04:33.68,0:04:35.42,Default,,0,0,0,,也就是元循环求值器
Dialogue: 0,0:04:36.17,0:04:38.11,Default,,0,0,0,,手工翻译成寄存器机器的代码
Dialogue: 0,0:04:39.04,0:04:40.25,Default,,0,0,0,,这就实现了整个Lisp
Dialogue: 0,0:04:42.14,0:04:43.00,Default,,0,0,0,,因此 我们已经知道了
Dialogue: 0,0:04:43.02,0:04:44.43,Default,,0,0,0,,实现的原理
Dialogue: 0,0:04:45.38,0:04:46.54,Default,,0,0,0,,而且实际上
Dialogue: 0,0:04:46.68,0:04:48.86,Default,,0,0,0,,这跟翻译
Dialogue: 0,0:04:50.00,0:04:53.40,Default,,0,0,0,,递归版的阶乘或斐波那契数列
Dialogue: 0,0:04:53.42,0:04:54.67,Default,,0,0,0,,没什么区别
Dialogue: 0,0:04:54.67,0:04:56.00,Default,,0,0,0,,只是它规模更大 代码更多
Dialogue: 0,0:04:56.84,0:04:58.03,Default,,0,0,0,,只是包含了更多细节
Dialogue: 0,0:04:58.04,0:04:59.66,Default,,0,0,0,,但是没有任何新的概念
Dialogue: 0,0:05:01.48,0:05:03.02,Default,,0,0,0,,当我们完成这个以后
Dialogue: 0,0:05:03.08,0:05:04.76,Default,,0,0,0,,所有的东西都变得明确了
Dialogue: 0,0:05:04.87,0:05:06.91,Default,,0,0,0,,当我们看到如何用一系列的
Dialogue: 0,0:05:06.94,0:05:10.08,Default,,0,0,0,,寄存器操作来实现Lisp之后
Dialogue: 0,0:05:10.16,0:05:11.63,Default,,0,0,0,,它就成为了我们整个课程中
Dialogue: 0,0:05:11.95,0:05:14.16,Default,,0,0,0,,最明确的Lisp模型
Dialogue: 0,0:05:14.81,0:05:16.95,Default,,0,0,0,,回忆一下 这个过程贯穿了整个课程
Dialogue: 0,0:05:16.95,0:05:18.25,Default,,0,0,0,,我们先从代换模型开始
Dialogue: 0,0:05:18.28,0:05:19.58,Default,,0,0,0,,它和代数有点相似
Dialogue: 0,0:05:20.24,0:05:21.87,Default,,0,0,0,,然后学习了环境模型
Dialogue: 0,0:05:21.88,0:05:24.00,Default,,0,0,0,,它引入了“框架”的概念
Dialogue: 0,0:05:24.03,0:05:25.31,Default,,0,0,0,,以及框架之间的关联
Dialogue: 0,0:05:26.32,0:05:27.88,Default,,0,0,0,,然后我们在元循环求值器中
Dialogue: 0,0:05:27.90,0:05:29.36,Default,,0,0,0,,把它变得更具体了
Dialogue: 0,0:05:31.05,0:05:31.64,Default,,0,0,0,,但是有的事情
Dialogue: 0,0:05:31.87,0:05:33.98,Default,,0,0,0,,元循环求值器没有告诉我们
Dialogue: 0,0:05:34.36,0:05:35.34,Default,,0,0,0,,你应该认识到这点
Dialogue: 0,0:05:36.09,0:05:38.64,Default,,0,0,0,,比如说 我们还不知道
Dialogue: 0,0:05:38.73,0:05:42.67,Default,,0,0,0,,像这里的递归阶乘过程
Dialogue: 0,0:05:45.17,0:05:47.13,Default,,0,0,0,,为何不断地申请新的空间
Dialogue: 0,0:05:47.21,0:05:47.98,Default,,0,0,0,,另一方面
Dialogue: 0,0:05:48.16,0:05:51.94,Default,,0,0,0,,一个语法上看起来像是递归的过程
Dialogue: 0,0:05:52.11,0:05:55.07,Default,,0,0,0,,比如FACT-ITER 并不占用栈空间
Dialogue: 0,0:05:55.10,0:05:59.16,Default,,0,0,0,,我们通过代换模型来证明
Dialogue: 0,0:06:00.50,0:06:01.96,Default,,0,0,0,,它不占用空间
Dialogue: 0,0:06:01.96,0:06:02.94,Default,,0,0,0,,但我们并没有说清楚
Dialogue: 0,0:06:03.42,0:06:06.76,Default,,0,0,0,,机器是如何做到这一点的
Dialogue: 0,0:06:07.31,0:06:08.91,Default,,0,0,0,,这涉及到一些细节
Dialogue: 0,0:06:09.02,0:06:11.12,Default,,0,0,0,,比如参数是如何传递给过程的
Dialogue: 0,0:06:12.48,0:06:13.69,Default,,0,0,0,,这是我们在元循环求值器中
Dialogue: 0,0:06:13.71,0:06:15.34,Default,,0,0,0,,没有看到的
Dialogue: 0,0:06:15.36,0:06:17.40,Default,,0,0,0,,完全是因为在所实现的Lisp中
Dialogue: 0,0:06:17.42,0:06:19.20,Default,,0,0,0,,把参数传递给过程的方式
Dialogue: 0,0:06:19.70,0:06:20.59,Default,,0,0,0,,取决于
Dialogue: 0,0:06:21.02,0:06:23.50,Default,,0,0,0,,外部Lisp的传参方式
Dialogue: 0,0:06:25.87,0:06:29.02,Default,,0,0,0,,但现在 这一点将变得非常明确
Dialogue: 0,0:06:30.74,0:06:31.12,Default,,0,0,0,,好
Dialogue: 0,0:06:31.23,0:06:34.30,Default,,0,0,0,,在开始研究求值器之前
Dialogue: 0,0:06:34.36,0:06:35.53,Default,,0,0,0,,我先让你们感受一下
Dialogue: 0,0:06:35.55,0:06:37.00,Default,,0,0,0,,一个完整Lisp系统是怎么样的
Dialogue: 0,0:06:37.60,0:06:39.36,Default,,0,0,0,,这样你就可以知道 我们要讨论哪部分
Dialogue: 0,0:06:39.40,0:06:40.81,Default,,0,0,0,,不讨论哪些部分
Dialogue: 0,0:06:43.18,0:06:47.42,Default,,0,0,0,,首先 这里有一个快乐的Lisp用户
Dialogue: 0,0:06:48.67,0:06:52.65,Default,,0,0,0,,他正在和一个叫做读取器的东西交流
Dialogue: 0,0:07:00.36,0:07:01.53,Default,,0,0,0,,读取器的工作是
Dialogue: 0,0:07:01.95,0:07:13.23,Default,,0,0,0,,读取用户输入的字符串
Dialogue: 0,0:07:14.17,0:07:16.62,Default,,0,0,0,,把它们转化成一种称作
Dialogue: 0,0:07:17.20,0:07:19.37,Default,,0,0,0,,表结构内存的数据结构
Dialogue: 0,0:07:30.00,0:07:31.72,Default,,0,0,0,,读取器会读取--
Dialogue: 0,0:07:32.65,0:07:33.95,Default,,0,0,0,,你敲出来的符号、括号
Dialogue: 0,0:07:34.48,0:07:37.12,Default,,0,0,0,,A和B、1和3这些东西
Dialogue: 0,0:07:37.18,0:07:39.04,Default,,0,0,0,,并把它们变成表结构
Dialogue: 0,0:07:39.15,0:07:40.54,Default,,0,0,0,,变成序对、指针等等
Dialogue: 0,0:07:42.35,0:07:43.92,Default,,0,0,0,,所以当求值器运行的时候
Dialogue: 0,0:07:43.93,0:07:45.10,Default,,0,0,0,,环境里已经不存在原始字符了
Dialogue: 0,0:07:45.85,0:07:48.16,Default,,0,0,0,,当然 在更现代的Lisp系统中
Dialogue: 0,0:07:49.00,0:07:50.44,Default,,0,0,0,,可能还有一大团东西
Dialogue: 0,0:07:50.44,0:07:52.17,Default,,0,0,0,,存在于在读取器和用户之间
Dialogue: 0,0:07:52.41,0:07:54.52,Default,,0,0,0,,最顶层首先是视窗系统
Dialogue: 0,0:07:54.77,0:07:56.03,Default,,0,0,0,,以及鼠标之类的东西
Dialogue: 0,0:07:56.28,0:07:58.20,Default,,0,0,0,,但从概念上来说 都是在输入字符
Dialogue: 0,0:07:59.93,0:08:04.32,Default,,0,0,0,,总之 读取器把它们都变成指针
Dialogue: 0,0:08:05.56,0:08:07.28,Default,,0,0,0,,指向内存中的对象
Dialogue: 0,0:08:08.27,0:08:10.94,Default,,0,0,0,,这是求值器的所能看到的东西
Dialogue: 0,0:08:15.55,0:08:16.04,Default,,0,0,0,,明白吗？
Dialogue: 0,0:08:17.02,0:08:18.88,Default,,0,0,0,,求值器有一些辅助函数
Dialogue: 0,0:08:19.78,0:08:23.16,Default,,0,0,0,,包括你需要的所有基本运算
Dialogue: 0,0:08:23.16,0:08:24.91,Default,,0,0,0,,也就是说这里另有一盒子东西
Dialogue: 0,0:08:28.40,0:08:30.25,Default,,0,0,0,,比如浮点单元
Dialogue: 0,0:08:32.22,0:08:34.40,Default,,0,0,0,,或者其它类似的东西来执行这些运算
Dialogue: 0,0:08:35.39,0:08:37.68,Default,,0,0,0,,如果你需要支持更多的基本运算
Dialogue: 0,0:08:37.71,0:08:39.02,Default,,0,0,0,,你就实现更多的运算符执行器
Dialogue: 0,0:08:39.05,0:08:40.48,Default,,0,0,0,,但它们和求值器都是分离的
Dialogue: 0,0:08:42.08,0:08:43.77,Default,,0,0,0,,求值器最终算出结果
Dialogue: 0,0:08:45.16,0:08:46.76,Default,,0,0,0,,并且把它们告诉打印程序
Dialogue: 0,0:08:50.62,0:08:52.01,Default,,0,0,0,,现在 打印程序的任务就是
Dialogue: 0,0:08:52.01,0:08:54.54,Default,,0,0,0,,从求值器取得这个表结构
Dialogue: 0,0:08:55.39,0:08:56.99,Default,,0,0,0,,再把它们变回字符
Dialogue: 0,0:09:01.85,0:09:04.07,Default,,0,0,0,,然后通过某种界面
Dialogue: 0,0:09:04.28,0:09:05.66,Default,,0,0,0,,展示给用户
Dialogue: 0,0:09:08.05,0:09:11.23,Default,,0,0,0,,那么 今天我们要讨论的是这个求值器
Dialogue: 0,0:09:12.67,0:09:15.20,Default,,0,0,0,,基本运算和Lisp没有什么特别的关系
Dialogue: 0,0:09:15.20,0:09:18.14,Default,,0,0,0,,它们只取决于你怎么实现基本运算
Dialogue: 0,0:09:19.36,0:09:22.18,Default,,0,0,0,,读取器和打印程序实际上很复杂
Dialogue: 0,0:09:22.18,0:09:23.55,Default,,0,0,0,,但是我们不去讨论它们
Dialogue: 0,0:09:24.68,0:09:27.10,Default,,0,0,0,,从字符构建表的过程中
Dialogue: 0,0:09:27.10,0:09:28.92,Default,,0,0,0,,它们需要处理很多细节
Dialogue: 0,0:09:29.90,0:09:31.18,Default,,0,0,0,,说来话长
Dialogue: 0,0:09:31.18,0:09:32.32,Default,,0,0,0,,我们就不讨论它了
Dialogue: 0,0:09:32.49,0:09:33.69,Default,,0,0,0,,关于表结构内存
Dialogue: 0,0:09:34.36,0:09:35.63,Default,,0,0,0,,我们下次再来讨论
Dialogue: 0,0:09:36.93,0:09:39.72,Default,,0,0,0,,那么去除了读取和打印的细节
Dialogue: 0,0:09:40.12,0:09:41.71,Default,,0,0,0,,关于这个求值器
Dialogue: 0,0:09:41.72,0:09:43.05,Default,,0,0,0,,所剩下的唯一谜团
Dialogue: 0,0:09:43.25,0:09:45.85,Default,,0,0,0,,几乎就只有怎么在传统内存上构建表结构了
Dialogue: 0,0:09:46.65,0:09:48.20,Default,,0,0,0,,不过我们把那也放到下次来讨论
Dialogue: 0,0:09:50.58,0:09:51.04,Default,,0,0,0,,好
Dialogue: 0,0:09:53.34,0:09:56.11,Default,,0,0,0,,那么 我们先来看看这个求值器
Dialogue: 0,0:09:56.20,0:09:58.32,Default,,0,0,0,,我将要展示的这个求值器
Dialogue: 0,0:09:58.49,0:10:01.12,Default,,0,0,0,,我想 它并没有什么特别的
Dialogue: 0,0:10:01.15,0:10:04.56,Default,,0,0,0,,它只是一台专门运行Lisp的寄存器机器
Dialogue: 0,0:10:04.81,0:10:06.09,Default,,0,0,0,,它有七个寄存器
Dialogue: 0,0:10:07.88,0:10:09.26,Default,,0,0,0,,这是它的七个寄存器
Dialogue: 0,0:10:09.89,0:10:12.38,Default,,0,0,0,,这个寄存器叫EXP
Dialogue: 0,0:10:14.12,0:10:15.53,Default,,0,0,0,,它的任务是存放
Dialogue: 0,0:10:16.36,0:10:18.03,Default,,0,0,0,,将要被求值的表达式
Dialogue: 0,0:10:18.37,0:10:19.80,Default,,0,0,0,,具体来说
Dialogue: 0,0:10:20.38,0:10:21.64,Default,,0,0,0,,它存放的是一个指针
Dialogue: 0,0:10:22.03,0:10:23.55,Default,,0,0,0,,指针指向存放着求值的表达式
Dialogue: 0,0:10:23.56,0:10:25.32,Default,,0,0,0,,的一处表结构内存
Dialogue: 0,0:10:26.55,0:10:27.82,Default,,0,0,0,,还有一个叫做ENV的寄存器
Dialogue: 0,0:10:28.88,0:10:30.28,Default,,0,0,0,,它存放着环境
Dialogue: 0,0:10:31.00,0:10:33.05,Default,,0,0,0,,也就是表达式的求值环境
Dialogue: 0,0:10:34.07,0:10:35.02,Default,,0,0,0,,同样的 这也是一个指针
Dialogue: 0,0:10:35.02,0:10:36.75,Default,,0,0,0,,环境是一种数据结构
Dialogue: 0,0:10:38.24,0:10:40.14,Default,,0,0,0,,这个叫做FUN的寄存器--
Dialogue: 0,0:10:40.75,0:10:42.54,Default,,0,0,0,,当你在应用一个过程时
Dialogue: 0,0:10:42.57,0:10:43.96,Default,,0,0,0,,它会存放这个过程
Dialogue: 0,0:10:44.56,0:10:46.24,Default,,0,0,0,,还有寄存器ARGL
Dialogue: 0,0:10:47.36,0:10:49.34,Default,,0,0,0,,它存放的是已求值的参数
Dialogue: 0,0:10:50.54,0:10:51.60,Default,,0,0,0,,从这里开始你能看到
Dialogue: 0,0:10:51.63,0:10:53.14,Default,,0,0,0,,求值器的基本构造
Dialogue: 0,0:10:53.14,0:10:54.49,Default,,0,0,0,,回忆一下它是怎么工作的
Dialogue: 0,0:10:54.49,0:10:56.62,Default,,0,0,0,,对这一块输入表达式和环境
Dialogue: 0,0:10:57.67,0:10:59.71,Default,,0,0,0,,而这一块接收函数
Dialogue: 0,0:10:59.74,0:11:02.14,Default,,0,0,0,,或者说 过程以及参数
Dialogue: 0,0:11:03.48,0:11:06.30,Default,,0,0,0,,EVAL-APPLY循环使用这些寄存器工作
Dialogue: 0,0:11:07.40,0:11:09.69,Default,,0,0,0,,所以这些是EVAL-APPLY的基本组成部分
Dialogue: 0,0:11:10.20,0:11:10.99,Default,,0,0,0,,还有一些别的东西
Dialogue: 0,0:11:11.00,0:11:11.61,Default,,0,0,0,,比如CONTINUE寄存器
Dialogue: 0,0:11:11.61,0:11:15.34,Default,,0,0,0,,你之前已经见过CONTINUE寄存器
Dialogue: 0,0:11:15.34,0:11:18.04,Default,,0,0,0,,是如何实现递归以及栈操作的
Dialogue: 0,0:11:18.94,0:11:20.68,Default,,0,0,0,,还有个寄存器用来存放
Dialogue: 0,0:11:20.94,0:11:22.52,Default,,0,0,0,,某个求值的结果
Dialogue: 0,0:11:24.14,0:11:24.89,Default,,0,0,0,,然后 除了这些以外
Dialogue: 0,0:11:24.89,0:11:26.43,Default,,0,0,0,,还有一个临时寄存器
Dialogue: 0,0:11:26.70,0:11:27.29,Default,,0,0,0,,它就是UNEV
Dialogue: 0,0:11:27.29,0:11:29.04,Default,,0,0,0,,一般来讲 在求值器中
Dialogue: 0,0:11:29.28,0:11:32.72,Default,,0,0,0,,它是用来存放正在求值的表达式
Dialogue: 0,0:11:32.89,0:11:33.95,Default,,0,0,0,,的临时部分
Dialogue: 0,0:11:33.95,0:11:35.72,Default,,0,0,0,,就是那些尚未求值的部分
Dialogue: 0,0:11:36.97,0:11:39.82,Default,,0,0,0,,那么 这就是我的七寄存器机器
Dialogue: 0,0:11:40.96,0:11:42.98,Default,,0,0,0,,当然 你可能想造一台
Dialogue: 0,0:11:42.98,0:11:44.96,Default,,0,0,0,,有更多寄存器的机器 来取得更好性能
Dialogue: 0,0:11:44.97,0:11:47.05,Default,,0,0,0,,但我们这个只是一台小型机器
Dialogue: 0,0:11:48.48,0:11:49.58,Default,,0,0,0,,那么数据通路呢？
Dialogue: 0,0:11:49.78,0:11:53.66,Default,,0,0,0,,这台机器有很多专为Lisp设计的运算
Dialogue: 0,0:11:55.10,0:11:58.08,Default,,0,0,0,,这里有几条典型的数据通路
Dialogue: 0,0:12:00.12,0:12:01.04,Default,,0,0,0,,其中一条可能是
Dialogue: 0,0:12:01.37,0:12:03.40,Default,,0,0,0,,将EXP寄存器的值
Dialogue: 0,0:12:03.40,0:12:04.80,Default,,0,0,0,,赋给VAL寄存器
Dialogue: 0,0:12:05.71,0:12:08.01,Default,,0,0,0,,用我们之前的数据通路图来说
Dialogue: 0,0:12:08.03,0:12:10.81,Default,,0,0,0,,就是一条箭头上的小按钮
Dialogue: 0,0:12:11.90,0:12:13.13,Default,,0,0,0,,这还有一个更复杂的
Dialogue: 0,0:12:13.69,0:12:14.80,Default,,0,0,0,,它判断
Dialogue: 0,0:12:15.23,0:12:19.58,Default,,0,0,0,,如果EXP寄存器的内容是COND语句
Dialogue: 0,0:12:20.49,0:12:22.72,Default,,0,0,0,,那么这里就会跳转到EV-COND标号处
Dialogue: 0,0:12:23.80,0:12:26.23,Default,,0,0,0,,你可以想象出很多种实现它的方法
Dialogue: 0,0:12:26.23,0:12:28.36,Default,,0,0,0,,你可以把这个判断看作是
Dialogue: 0,0:12:28.36,0:12:29.98,Default,,0,0,0,,一个特殊意图的子过程
Dialogue: 0,0:12:30.60,0:12:33.95,Default,,0,0,0,,而条件被表示成某种数据抽象
Dialogue: 0,0:12:33.96,0:12:36.00,Default,,0,0,0,,你在这个层面上不用考虑它
Dialogue: 0,0:12:36.61,0:12:37.98,Default,,0,0,0,,那么它可以用子过程实现
Dialogue: 0,0:12:37.98,0:12:40.67,Default,,0,0,0,,如果机器通过硬件来判断表达式类型
Dialogue: 0,0:12:40.90,0:12:44.04,Default,,0,0,0,,那么某些特定比特就代表了COND语句
Dialogue: 0,0:12:45.35,0:12:46.41,Default,,0,0,0,,有很多种实现办法
Dialogue: 0,0:12:46.41,0:12:48.48,Default,,0,0,0,,它们都低于我们关注的这一层抽象
Dialogue: 0,0:12:50.19,0:12:51.71,Default,,0,0,0,,然后还有另一种操作
Dialogue: 0,0:12:51.71,0:12:53.24,Default,,0,0,0,,以及其它很多操作
Dialogue: 0,0:12:53.24,0:12:56.65,Default,,0,0,0,,把EXP的第一个子句赋值给EXP
Dialogue: 0,0:12:56.84,0:12:58.89,Default,,0,0,0,,这可能是处理COND语句的一部分
Dialogue: 0,0:12:59.26,0:13:01.80,Default,,0,0,0,,同样 FIRST-SELECTOR这个选择子
Dialogue: 0,0:13:03.07,0:13:04.48,Default,,0,0,0,,我们也不需要关心它的细节
Dialogue: 0,0:13:04.49,0:13:06.46,Default,,0,0,0,,同样可以把那也看成一个子过程
Dialogue: 0,0:13:06.46,0:13:07.90,Default,,0,0,0,,用来进行一些表操作
Dialogue: 0,0:13:08.22,0:13:09.18,Default,,0,0,0,,或者你也可以想象成
Dialogue: 0,0:13:09.18,0:13:10.73,Default,,0,0,0,,一个直接构建在硬件中的东西
Dialogue: 0,0:13:12.17,0:13:13.71,Default,,0,0,0,,我之所以强调
Dialogue: 0,0:13:14.03,0:13:15.22,Default,,0,0,0,,你可以把它想象成硬件直接实现
Dialogue: 0,0:13:15.22,0:13:17.80,Default,,0,0,0,,是因为尽管有很多的运算
Dialogue: 0,0:13:18.36,0:13:19.74,Default,,0,0,0,,但也它们的数量也是固定的
Dialogue: 0,0:13:20.12,0:13:21.80,Default,,0,0,0,,我记不清有多少 大概有150个
Dialogue: 0,0:13:22.37,0:13:25.39,Default,,0,0,0,,所以假设用硬件实现它们是合理的
Dialogue: 0,0:13:26.41,0:13:27.68,Default,,0,0,0,,而这一条更加复杂
Dialogue: 0,0:13:28.27,0:13:29.47,Default,,0,0,0,,你会发现 这条涉及到
Dialogue: 0,0:13:29.47,0:13:31.10,Default,,0,0,0,,查找变量的值
Dialogue: 0,0:13:31.50,0:13:33.28,Default,,0,0,0,,它会查找某条表达式中
Dialogue: 0,0:13:33.45,0:13:36.91,Default,,0,0,0,,某个变量的值
Dialogue: 0,0:13:36.99,0:13:38.52,Default,,0,0,0,,并赋值给VAL寄存器
Dialogue: 0,0:13:39.18,0:13:40.30,Default,,0,0,0,,在本例中 也就是
Dialogue: 0,0:13:40.33,0:13:42.00,Default,,0,0,0,,在某个环境中查找变量
Dialogue: 0,0:13:42.80,0:13:44.68,Default,,0,0,0,,然后这个操作
Dialogue: 0,0:13:45.21,0:13:47.50,Default,,0,0,0,,会搜索整个环境结构
Dialogue: 0,0:13:47.52,0:13:48.97,Default,,0,0,0,,无论环境是如何表示的
Dialogue: 0,0:13:49.37,0:13:50.91,Default,,0,0,0,,并查找该变量
Dialogue: 0,0:13:52.17,0:13:53.95,Default,,0,0,0,,同样 它也不在我们思考的
Dialogue: 0,0:13:53.96,0:13:54.86,Default,,0,0,0,,的抽象层面上
Dialogue: 0,0:13:54.89,0:13:57.30,Default,,0,0,0,,它需要处理的细节是
Dialogue: 0,0:13:57.55,0:13:59.44,Default,,0,0,0,,用来表示环境的数据结构
Dialogue: 0,0:14:00.07,0:14:01.21,Default,,0,0,0,,但是不管怎么说
Dialogue: 0,0:14:01.31,0:14:03.47,Default,,0,0,0,,这就是这台寄存器机器的
Dialogue: 0,0:14:04.11,0:14:06.08,Default,,0,0,0,,有穷数量的固定操作
Dialogue: 0,0:14:08.50,0:14:11.60,Default,,0,0,0,,那么 它的整体结构是什么样子的？
Dialogue: 0,0:14:11.72,0:14:13.23,Default,,0,0,0,,这有几个典型的运算
Dialogue: 0,0:14:14.76,0:14:16.33,Default,,0,0,0,,想一想 我们要做什么
Dialogue: 0,0:14:16.44,0:14:18.40,Default,,0,0,0,,我们需要把元循环求值器
Dialogue: 0,0:14:20.43,0:14:22.76,Default,,0,0,0,,这就是元循环求值器的一部分
Dialogue: 0,0:14:22.76,0:14:26.89,Default,,0,0,0,,这是书中使用抽象代码的版本
Dialogue: 0,0:14:28.22,0:14:31.53,Default,,0,0,0,,它和Gerry教授给你们展示的有些不同
Dialogue: 0,0:14:33.50,0:14:35.10,Default,,0,0,0,,关于求值器
Dialogue: 0,0:14:35.13,0:14:37.87,Default,,0,0,0,,主要需要记住的是
Dialogue: 0,0:14:37.87,0:14:40.96,Default,,0,0,0,,它是某种针对表达式类型的分情况分析
Dialogue: 0,0:14:43.76,0:14:45.90,Default,,0,0,0,,看它是否为自求值的 或被引用的
Dialogue: 0,0:14:45.92,0:14:46.86,Default,,0,0,0,,或是别的什么
Dialogue: 0,0:14:48.56,0:14:50.57,Default,,0,0,0,,而在大部分情况下
Dialogue: 0,0:14:50.86,0:14:52.96,Default,,0,0,0,,它处理的是一个过程应用
Dialogue: 0,0:14:53.55,0:14:55.36,Default,,0,0,0,,那么里面有一些技巧性的递归过程
Dialogue: 0,0:14:55.75,0:14:59.36,Default,,0,0,0,,首先 EVAL要调用它自己
Dialogue: 0,0:14:59.79,0:15:01.45,Default,,0,0,0,,来求值运算符以及
Dialogue: 0,0:15:02.14,0:15:04.04,Default,,0,0,0,,所有的运算对象
Dialogue: 0,0:15:05.88,0:15:07.40,Default,,0,0,0,,因此这些标红线的地方
Dialogue: 0,0:15:07.63,0:15:09.28,Default,,0,0,0,,就是某种在语法树上的递归
Dialogue: 0,0:15:10.94,0:15:12.27,Default,,0,0,0,,这是很简单的递归
Dialogue: 0,0:15:12.27,0:15:14.44,Default,,0,0,0,,只是EVAL在递归地遍历语法树
Dialogue: 0,0:15:14.75,0:15:15.53,Default,,0,0,0,,然后在求值器中
Dialogue: 0,0:15:15.53,0:15:16.46,Default,,0,0,0,,有一个复杂的递归
Dialogue: 0,0:15:16.49,0:15:17.92,Default,,0,0,0,,由绿线到红线的递归
Dialogue: 0,0:15:18.00,0:15:19.66,Default,,0,0,0,,由EVAL调用APPLY
Dialogue: 0,0:15:22.47,0:15:26.45,Default,,0,0,0,,也就是把过程调用
Dialogue: 0,0:15:26.45,0:15:28.72,Default,,0,0,0,,归约为了 将过程应用在
Dialogue: 0,0:15:28.94,0:15:29.93,Default,,0,0,0,,实参表上
Dialogue: 0,0:15:30.37,0:15:31.76,Default,,0,0,0,,然后请看APPLY
Dialogue: 0,0:15:34.77,0:15:36.67,Default,,0,0,0,,APPLY需要过程PROC和参数ARGS
Dialogue: 0,0:15:37.65,0:15:39.45,Default,,0,0,0,,一般情况下
Dialogue: 0,0:15:39.48,0:15:40.81,Default,,0,0,0,,PROC都是一个复合过程
Dialogue: 0,0:15:41.05,0:15:42.19,Default,,0,0,0,,随着APPLY不断被调用
Dialogue: 0,0:15:42.25,0:15:43.15,Default,,0,0,0,,绿线处会调用红线处
Dialogue: 0,0:15:43.34,0:15:46.44,Default,,0,0,0,,APPLY被调用并再次调用EVAL
Dialogue: 0,0:15:48.17,0:15:49.79,Default,,0,0,0,,EVAL会求值过程体
Dialogue: 0,0:15:50.24,0:15:52.59,Default,,0,0,0,,基于一个扩展了的环境
Dialogue: 0,0:15:53.69,0:15:55.28,Default,,0,0,0,,这个环境通过将过程的形式参数
Dialogue: 0,0:15:55.48,0:15:56.92,Default,,0,0,0,,与实际参数绑定起来而得
Dialogue: 0,0:15:59.62,0:16:00.62,Default,,0,0,0,,而对于最基本的情况
Dialogue: 0,0:16:00.64,0:16:02.52,Default,,0,0,0,,它会调用PRIMITIVE-APPLY过程
Dialogue: 0,0:16:02.73,0:16:04.70,Default,,0,0,0,,而那又不是求值器的工作了
Dialogue: 0,0:16:05.98,0:16:07.47,Default,,0,0,0,,那么像这样从红到绿
Dialogue: 0,0:16:07.47,0:16:08.40,Default,,0,0,0,,又到红又到绿
Dialogue: 0,0:16:09.79,0:16:12.72,Default,,0,0,0,,这就是EVAL-APPLY循环
Dialogue: 0,0:16:14.06,0:16:15.74,Default,,0,0,0,,这就是我们在求值器中
Dialogue: 0,0:16:16.19,0:16:17.72,Default,,0,0,0,,想要看到的东西
Dialogue: 0,0:16:19.69,0:16:21.07,Default,,0,0,0,,这样 你不会惊异于
Dialogue: 0,0:16:21.07,0:16:23.52,Default,,0,0,0,,这个求值器的两大部分
Dialogue: 0,0:16:25.34,0:16:27.04,Default,,0,0,0,,对应于EVAL-APPLY
Dialogue: 0,0:16:27.47,0:16:29.44,Default,,0,0,0,,一个部分叫EVAL-DISPATCH
Dialogue: 0,0:16:29.60,0:16:31.20,Default,,0,0,0,,另一部分叫做APPLY-DISPATCH
Dialogue: 0,0:16:32.00,0:16:34.09,Default,,0,0,0,,在我们关注代码细节之前
Dialogue: 0,0:16:34.20,0:16:35.76,Default,,0,0,0,,理解它们的方法就是
Dialogue: 0,0:16:36.09,0:16:39.02,Default,,0,0,0,,假设这些求值器的各个部分
Dialogue: 0,0:16:39.02,0:16:40.97,Default,,0,0,0,,和这个世界中其它的部分有一些约定
Dialogue: 0,0:16:41.87,0:16:43.18,Default,,0,0,0,,在进入这些肮脏的细节前
Dialogue: 0,0:16:43.20,0:16:45.50,Default,,0,0,0,,它们在外部做了什么？
Dialogue: 0,0:16:45.78,0:16:49.32,Default,,0,0,0,,针对EVAL-DISPATCH的约定
Dialogue: 0,0:16:50.01,0:16:51.40,Default,,0,0,0,,还记得吗 它对应的是EVAL
Dialogue: 0,0:16:51.55,0:16:54.10,Default,,0,0,0,,它要在环境中求值一个表达式
Dialogue: 0,0:16:54.10,0:16:55.88,Default,,0,0,0,,那么 这部分要做的就是
Dialogue: 0,0:16:56.52,0:16:58.68,Default,,0,0,0,,EVAL-DISPATCH会假设当你调用它的时候
Dialogue: 0,0:16:59.68,0:17:01.48,Default,,0,0,0,,你想要求值的表达式
Dialogue: 0,0:17:01.48,0:17:02.52,Default,,0,0,0,,就存放在EXP寄存器中
Dialogue: 0,0:17:03.64,0:17:07.39,Default,,0,0,0,,而求值所基于的环境
Dialogue: 0,0:17:07.45,0:17:09.05,Default,,0,0,0,,则存放在ENV环境中
Dialogue: 0,0:17:09.56,0:17:10.67,Default,,0,0,0,,而CONTINUE寄存器用来指示
Dialogue: 0,0:17:10.84,0:17:12.46,Default,,0,0,0,,当求值完成后
Dialogue: 0,0:17:12.52,0:17:13.92,Default,,0,0,0,,机器需要去向何方
Dialogue: 0,0:17:17.28,0:17:19.18,Default,,0,0,0,,EVAL-DISPATCH的约定实际上就是
Dialogue: 0,0:17:19.28,0:17:21.26,Default,,0,0,0,,它会执行实际的求值
Dialogue: 0,0:17:21.40,0:17:22.46,Default,,0,0,0,,并且在求值结束后
Dialogue: 0,0:17:23.28,0:17:25.63,Default,,0,0,0,,它会转到由CONTINUE寄存器指定的位置
Dialogue: 0,0:17:26.61,0:17:29.16,Default,,0,0,0,,求值的结果会存放在VAL寄存器中
Dialogue: 0,0:17:29.82,0:17:30.96,Default,,0,0,0,,需要提醒的是
Dialogue: 0,0:17:30.99,0:17:32.91,Default,,0,0,0,,它对其余的寄存器
Dialogue: 0,0:17:32.96,0:17:34.60,Default,,0,0,0,,不做任何承诺
Dialogue: 0,0:17:35.23,0:17:36.81,Default,,0,0,0,,其它所有的寄存器都可能被修改
Dialogue: 0,0:17:37.49,0:17:40.14,Default,,0,0,0,,那么这是一部分
Dialogue: 0,0:17:41.55,0:17:43.48,Default,,0,0,0,,这些部分一块构成了APPLY-DISPATCH
Dialogue: 0,0:17:43.52,0:17:44.92,Default,,0,0,0,,它们对应了APPLY
Dialogue: 0,0:17:46.09,0:17:48.43,Default,,0,0,0,,用来把一个过程应用在一些参数上
Dialogue: 0,0:17:48.73,0:17:51.43,Default,,0,0,0,,因此它假设ARGL寄存器
Dialogue: 0,0:17:51.68,0:17:53.77,Default,,0,0,0,,存放着求值后的参数列表
Dialogue: 0,0:17:54.54,0:17:55.96,Default,,0,0,0,,FUN寄存器存放着那个过程
Dialogue: 0,0:17:57.22,0:17:58.83,Default,,0,0,0,,它们对应于元循环求值器中的
Dialogue: 0,0:17:58.94,0:18:01.36,Default,,0,0,0,,参数应用部分
Dialogue: 0,0:18:03.97,0:18:06.04,Default,,0,0,0,,在我们的这个求值器中
Dialogue: 0,0:18:06.06,0:18:07.58,Default,,0,0,0,,我们APPLY时采用的约定是
Dialogue: 0,0:18:07.72,0:18:08.97,Default,,0,0,0,,当APPLY完成后--
Dialogue: 0,0:18:09.47,0:18:11.20,Default,,0,0,0,,机器应该跳转到
Dialogue: 0,0:18:11.79,0:18:13.45,Default,,0,0,0,,的下一个地方应该是
Dialogue: 0,0:18:13.55,0:18:15.92,Default,,0,0,0,,APPLY-DISPATCH被调用时的栈顶元素
Dialogue: 0,0:18:17.07,0:18:21.24,Default,,0,0,0,,这只是针对这台机器的约定
Dialogue: 0,0:18:21.84,0:18:23.70,Default,,0,0,0,,现在已经给出了APPLY的所有约定
Dialogue: 0,0:18:23.93,0:18:25.37,Default,,0,0,0,,它会去执行应用
Dialogue: 0,0:18:25.54,0:18:27.85,Default,,0,0,0,,这个应用的结果将会保存在VAL寄存器中
Dialogue: 0,0:18:28.89,0:18:29.95,Default,,0,0,0,,栈会被弹出
Dialogue: 0,0:18:31.12,0:18:31.66,Default,,0,0,0,,同样的
Dialogue: 0,0:18:31.71,0:18:34.03,Default,,0,0,0,,其它所有寄存器的内容都可能被修改
Dialogue: 0,0:18:34.84,0:18:37.82,Default,,0,0,0,,那么 这就是这台机器的基本结构
Dialogue: 0,0:18:38.99,0:18:41.50,Default,,0,0,0,,我们先课间休息一下
Dialogue: 0,0:18:41.52,0:18:42.70,Default,,0,0,0,,然后再来研究一个真实的例子
Dialogue: 0,0:18:43.53,0:19:08.11,Default,,0,0,0,,[音乐]
Dialogue: 0,0:19:08.14,0:19:13.47,Declare,,0,0,0,,{\an2\fad(500,500)}《计算机程序的构造和解释》
Dialogue: 0,0:19:33.10,0:19:35.87,Declare,,0,0,0,,{\an2\fad(500,500)}讲师： 哈罗德·艾伯森教授 及 格兰德·杰·萨斯曼教授
Dialogue: 0,0:19:35.87,0:19:40.38,Declare,,0,0,0,,{\an2\fad(500,500)}《计算机程序的构造和解释》
Dialogue: 0,0:19:40.38,0:19:45.29,Declare,,0,0,0,,{\an2\fad(500,500)}显式控制求值器
Dialogue: 0,0:19:47.85,0:19:49.95,Default,,0,0,0,,现在 我们来研究一下这台寄存器机器
Dialogue: 0,0:19:50.41,0:19:51.77,Default,,0,0,0,,我们一步一步地跟进
Dialogue: 0,0:19:52.27,0:19:56.94,Default,,0,0,0,,具体到每一处细节
Dialogue: 0,0:19:57.07,0:19:58.52,Default,,0,0,0,,这样你就能完全具体地看到
Dialogue: 0,0:19:58.86,0:20:01.24,Default,,0,0,0,,表达式是如何求值的
Dialogue: 0,0:20:03.15,0:20:06.86,Default,,0,0,0,,那么我们从一个非常简单的表达式开始
Dialogue: 0,0:20:07.45,0:20:13.52,Default,,0,0,0,,我们要求值的表达式只有一个1
Dialogue: 0,0:20:18.77,0:20:20.40,Default,,0,0,0,,我们需要一个环境
Dialogue: 0,0:20:20.43,0:20:22.35,Default,,0,0,0,,因此我们假设某处有一个环境
Dialogue: 0,0:20:22.38,0:20:23.39,Default,,0,0,0,,我们把它记作E0
Dialogue: 0,0:20:30.06,0:20:34.56,Default,,0,0,0,,由于我们之后也要用到它
Dialogue: 0,0:20:35.62,0:20:37.04,Default,,0,0,0,,而且显然不需要任何东西
Dialogue: 0,0:20:37.07,0:20:37.93,Default,,0,0,0,,就可以求值1
Dialogue: 0,0:20:38.36,0:20:39.45,Default,,0,0,0,,但是为了方便以后引用
Dialogue: 0,0:20:39.45,0:20:40.94,Default,,0,0,0,,我们假设环境E0中有
Dialogue: 0,0:20:41.44,0:20:43.15,Default,,0,0,0,,X=3
Dialogue: 0,0:20:43.72,0:20:45.37,Default,,0,0,0,,Y=4
Dialogue: 0,0:20:48.27,0:20:48.78,Default,,0,0,0,,好吗？
Dialogue: 0,0:20:49.14,0:20:50.12,Default,,0,0,0,,现在 我们要做的就是
Dialogue: 0,0:20:50.51,0:20:54.59,Default,,0,0,0,,在这个环境中求值表达式1
Dialogue: 0,0:20:55.74,0:20:58.54,Default,,0,0,0,,这样 ENV寄存器就存放了一个指针
Dialogue: 0,0:20:59.65,0:21:01.04,Default,,0,0,0,,指向这个环境E0
Dialogue: 0,0:21:03.31,0:21:05.65,Default,,0,0,0,,那么我们来看它是怎么进行的
Dialogue: 0,0:21:05.65,0:21:07.26,Default,,0,0,0,,我要步步跟进代码
Dialogue: 0,0:21:08.26,0:21:10.00,Default,,0,0,0,,这样的话 我会充当控制器
Dialogue: 0,0:21:10.04,0:21:10.80,Default,,0,0,0,,现在我需要的是--
Dialogue: 0,0:21:11.02,0:21:12.49,Default,,0,0,0,,由于这台机器已经变得相当复杂
Dialogue: 0,0:21:12.98,0:21:16.83,Default,,0,0,0,,我需要一个小小的执行单元
Dialogue: 0,0:21:16.83,0:21:18.16,Default,,0,0,0,,那么请上我们的执行单元
Dialogue: 0,0:21:22.62,0:21:23.12,Default,,0,0,0,,好的
Dialogue: 0,0:21:28.59,0:21:29.96,Default,,0,0,0,,好 现在我们要开始了
Dialogue: 0,0:21:30.53,0:21:32.48,Default,,0,0,0,,我们要从EVAL-DISPATCH启动机器
Dialogue: 0,0:21:33.26,0:21:34.62,Default,,0,0,0,,这是整个过程的开始
Dialogue: 0,0:21:35.87,0:21:38.75,Default,,0,0,0,,EVAL-DISPATCH会查看表达式并进行分派
Dialogue: 0,0:21:39.32,0:21:40.06,Default,,0,0,0,,就像EVAL
Dialogue: 0,0:21:40.87,0:21:42.00,Default,,0,0,0,,先从第一句看起
Dialogue: 0,0:21:42.04,0:21:47.95,Default,,0,0,0,,先判断表达式是不是自求值的
Dialogue: 0,0:21:47.95,0:21:49.96,Default,,0,0,0,,SELF-EVALUATING?是我们放入机器的
Dialogue: 0,0:21:49.96,0:21:51.10,Default,,0,0,0,,一个抽象过程
Dialogue: 0,0:21:52.22,0:21:53.51,Default,,0,0,0,,它对于数字1来说为真
Dialogue: 0,0:21:53.64,0:21:55.52,Default,,0,0,0,,因此跳转的目的是EV-SELF-EVAL
Dialogue: 0,0:21:56.77,0:21:58.20,Default,,0,0,0,,那么我作为控制器
Dialogue: 0,0:21:58.22,0:21:59.55,Default,,0,0,0,,会去查看EV-SELF-EVAL
Dialogue: 0,0:22:00.06,0:22:01.07,Default,,0,0,0,,所以我们要跳到那里
Dialogue: 0,0:22:02.60,0:22:04.76,Default,,0,0,0,,EV-SELF-EAVL的代码是--
Dialogue: 0,0:22:06.54,0:22:09.90,Default,,0,0,0,,把EXP寄存器的值赋值给VAL寄存器
Dialogue: 0,0:22:15.24,0:22:16.51,Default,,0,0,0,,我遇到一个BUG
Dialogue: 0,0:22:17.93,0:22:20.59,Default,,0,0,0,,因为我初始化机器的时候没有做一件事情
Dialogue: 0,0:22:21.62,0:22:22.89,Default,,0,0,0,,也就是指定当它执行完毕后
Dialogue: 0,0:22:22.91,0:22:24.19,Default,,0,0,0,,应该做什么
Dialogue: 0,0:22:24.65,0:22:26.83,Default,,0,0,0,,所以在启动机器的时候
Dialogue: 0,0:22:27.37,0:22:29.85,Default,,0,0,0,,应该将CONTINUE寄存器设置为DONE
Dialogue: 0,0:22:31.18,0:22:33.26,Default,,0,0,0,,所以我们给VAL赋值
Dialogue: 0,0:22:33.37,0:22:35.56,Default,,0,0,0,,然后执行(GOTO (FETCH CONTINUE))
Dialogue: 0,0:22:35.63,0:22:36.56,Default,,0,0,0,,并且修改--
Dialogue: 0,0:22:38.09,0:22:38.60,Default,,0,0,0,,好
Dialogue: 0,0:22:40.00,0:22:41.16,Default,,0,0,0,,好 我们来看一个更复杂的
Dialogue: 0,0:22:42.16,0:22:43.45,Default,,0,0,0,,我们先重置机器
Dialogue: 0,0:22:44.86,0:22:50.88,Default,,0,0,0,,然后把X放入EXP寄存器中
Dialogue: 0,0:22:56.71,0:22:58.20,Default,,0,0,0,,重新从EVAL-DISPATCH开始
Dialogue: 0,0:22:59.61,0:23:01.69,Default,,0,0,0,,先检查它是自求值的么？
Dialogue: 0,0:23:01.69,0:23:02.03,Default,,0,0,0,,不是
Dialogue: 0,0:23:02.65,0:23:03.61,Default,,0,0,0,,它是变量吗
Dialogue: 0,0:23:04.63,0:23:05.02,Default,,0,0,0,,是的
Dialogue: 0,0:23:05.56,0:23:07.07,Default,,0,0,0,,我们跳转到EV-VARIABLE
Dialogue: 0,0:23:08.38,0:23:10.97,Default,,0,0,0,,它说：查找EXP寄存器中变量的值
Dialogue: 0,0:23:12.13,0:23:15.69,Default,,0,0,0,,并把它赋值给VAL寄存器
Dialogue: 0,0:23:21.23,0:23:22.91,Default,,0,0,0,,(GOTO (FETCH CONTINUE))
Dialogue: 0,0:23:23.96,0:23:24.48,Default,,0,0,0,,Sussman教授：DONE
Dialogue: 0,0:23:27.61,0:23:28.09,Default,,0,0,0,,Abelson教授：好
Dialogue: 0,0:23:29.31,0:23:30.76,Default,,0,0,0,,这些都是最基本的理念
Dialogue: 0,0:23:31.33,0:23:32.65,Default,,0,0,0,,这是这台机器上的简单运算
Dialogue: 0,0:23:32.68,0:23:35.07,Default,,0,0,0,,现在 我们来做些有意义的事情
Dialogue: 0,0:23:36.07,0:23:38.64,Default,,0,0,0,,我们看这条表达式
Dialogue: 0,0:23:43.58,0:23:47.93,Default,,0,0,0,,(+ X Y)
Dialogue: 0,0:23:49.69,0:23:51.28,Default,,0,0,0,,现在我们会看到
Dialogue: 0,0:23:52.41,0:23:54.01,Default,,0,0,0,,如何展开这些表达式树
Dialogue: 0,0:23:57.13,0:23:58.68,Default,,0,0,0,,我们再次从EVAL-DISPATCH开始
Dialogue: 0,0:24:04.61,0:24:05.80,Default,,0,0,0,,是自求值的吗？
Dialogue: 0,0:24:05.95,0:24:06.52,Default,,0,0,0,,不是
Dialogue: 0,0:24:06.70,0:24:07.71,Default,,0,0,0,,是变量吗？不是
Dialogue: 0,0:24:07.82,0:24:08.99,Default,,0,0,0,,它也不是我在这里
Dialogue: 0,0:24:08.99,0:24:10.12,Default,,0,0,0,,没有列出的特殊形式
Dialogue: 0,0:24:10.27,0:24:12.48,Default,,0,0,0,,比如引用、LAMBDA、SET! 等等
Dialogue: 0,0:24:12.48,0:24:13.08,Default,,0,0,0,,它都不是
Dialogue: 0,0:24:13.26,0:24:14.73,Default,,0,0,0,,它是一个过程应用
Dialogue: 0,0:24:15.88,0:24:17.42,Default,,0,0,0,,所以我们要跳转到EV-APPLICATION
Dialogue: 0,0:24:19.97,0:24:24.94,Default,,0,0,0,,回忆一下EV-APPLICATION要做什么
Dialogue: 0,0:24:25.58,0:24:28.19,Default,,0,0,0,,它先要求值运算符
Dialogue: 0,0:24:28.27,0:24:31.40,Default,,0,0,0,,然后求值运算对象
Dialogue: 0,0:24:32.36,0:24:34.30,Default,,0,0,0,,然后再进行应用
Dialogue: 0,0:24:35.06,0:24:36.09,Default,,0,0,0,,所以在我们开始之前
Dialogue: 0,0:24:36.94,0:24:37.88,Default,,0,0,0,,由于我们是严格按照代码来执行的
Dialogue: 0,0:24:37.88,0:24:38.88,Default,,0,0,0,,我们最好记住
Dialogue: 0,0:24:39.07,0:24:40.54,Default,,0,0,0,,在这个环境中的某处
Dialogue: 0,0:24:40.57,0:24:42.36,Default,,0,0,0,,连接到了另一个环境
Dialogue: 0,0:24:43.98,0:24:44.94,Default,,0,0,0,,其中符号'+
Dialogue: 0,0:24:45.72,0:24:49.16,Default,,0,0,0,,跟基本的加法过程绑定在了一起
Dialogue: 0,0:24:51.63,0:24:54.03,Default,,0,0,0,,这样 求值+时就不会导致“变量未定义”
Dialogue: 0,0:24:55.34,0:24:56.84,Default,,0,0,0,,现在我们来到了EV-APPLICATION
Dialogue: 0,0:24:59.85,0:25:04.32,Default,,0,0,0,,把EXP寄存器对应的运算对象
Dialogue: 0,0:25:04.92,0:25:06.89,Default,,0,0,0,,赋值给UNEV寄存器
Dialogue: 0,0:25:07.61,0:25:08.83,Default,,0,0,0,,这些是运算对象
Dialogue: 0,0:25:09.23,0:25:11.66,Default,,0,0,0,,UNEV这个临时寄存器
Dialogue: 0,0:25:11.68,0:25:12.59,Default,,0,0,0,,就是用来暂存它们的
Dialogue: 0,0:25:13.22,0:25:13.86,Default,,0,0,0,,Sussman教授：我正在赋值
Dialogue: 0,0:25:14.28,0:25:16.62,Default,,0,0,0,,Abelson教授：把运算符赋值给EXP寄存器
Dialogue: 0,0:25:18.07,0:25:20.09,Default,,0,0,0,,注意 现在我们已经修改了EXP中的表达式
Dialogue: 0,0:25:21.84,0:25:23.61,Default,,0,0,0,,但是我们需要的部分在UNEV中
Dialogue: 0,0:25:25.82,0:25:26.81,Default,,0,0,0,,现在 我们要准备好
Dialogue: 0,0:25:26.81,0:25:28.59,Default,,0,0,0,,去递归地求值运算符
Dialogue: 0,0:25:28.75,0:25:31.69,Default,,0,0,0,,把CONTINUE寄存器保存在栈上
Dialogue: 0,0:25:34.86,0:25:36.09,Default,,0,0,0,,保存ENV
Dialogue: 0,0:25:40.48,0:25:41.69,Default,,0,0,0,,保存UNEV
Dialogue: 0,0:25:49.53,0:25:54.64,Default,,0,0,0,,把标号EVAL-ARGS赋值给CONTINUE寄存器
Dialogue: 0,0:26:01.40,0:26:01.95,Default,,0,0,0,,我们做了什么
Dialogue: 0,0:26:01.95,0:26:04.38,Default,,0,0,0,,我们为递归调用做了必要的准备
Dialogue: 0,0:26:04.38,0:26:05.88,Default,,0,0,0,,我们要开始执行EVAL-DISPATCH
Dialogue: 0,0:26:06.28,0:26:08.83,Default,,0,0,0,,我们为递归调用EVAL-DISPATCH做好了准备
Dialogue: 0,0:26:10.23,0:26:10.86,Default,,0,0,0,,我们做了哪些事情
Dialogue: 0,0:26:11.02,0:26:13.64,Default,,0,0,0,,我们把之后要用到的东西
Dialogue: 0,0:26:14.48,0:26:15.98,Default,,0,0,0,,也就是UNEV中的运算对象
Dialogue: 0,0:26:16.36,0:26:18.99,Default,,0,0,0,,以及我们最终求值运算对象时
Dialogue: 0,0:26:19.16,0:26:20.72,Default,,0,0,0,,会用到的环境
Dialogue: 0,0:26:22.28,0:26:23.93,Default,,0,0,0,,以及我们最终想要去的位置
Dialogue: 0,0:26:23.95,0:26:25.07,Default,,0,0,0,,本例中 也就是DONE
Dialogue: 0,0:26:25.34,0:26:26.70,Default,,0,0,0,,我们把它们保存在栈上
Dialogue: 0,0:26:27.10,0:26:28.41,Default,,0,0,0,,我们之所以把它们保存在栈上
Dialogue: 0,0:26:28.43,0:26:30.67,Default,,0,0,0,,是因为EVAL-DISPATCH并不会保证
Dialogue: 0,0:26:30.94,0:26:32.54,Default,,0,0,0,,不会去修改这些寄存器
Dialogue: 0,0:26:33.55,0:26:35.02,Default,,0,0,0,,那么所有这些东西都存在了栈上
Dialogue: 0,0:26:35.02,0:26:36.91,Default,,0,0,0,,现在我们满足了EVAL-DISPATCH的约定
Dialogue: 0,0:26:37.38,0:26:38.75,Default,,0,0,0,,这是一条新的表达式
Dialogue: 0,0:26:38.78,0:26:40.04,Default,,0,0,0,,也就是+运算符
Dialogue: 0,0:26:41.07,0:26:41.95,Default,,0,0,0,,以及一个新的环境
Dialogue: 0,0:26:41.98,0:26:43.60,Default,,0,0,0,,尽管在本例中是同一个环境
Dialogue: 0,0:26:44.25,0:26:45.87,Default,,0,0,0,,以及在完成后要返回的位置
Dialogue: 0,0:26:45.87,0:26:46.91,Default,,0,0,0,,也就是EVAL-ARGS
Dialogue: 0,0:26:47.60,0:26:48.13,Default,,0,0,0,,这样就满足了
Dialogue: 0,0:26:48.13,0:26:49.68,Default,,0,0,0,,现在我们来执行EVAL-DISPATCH
Dialogue: 0,0:26:50.89,0:26:52.36,Default,,0,0,0,,我们回到了EVAL-DISPATCH
Dialogue: 0,0:26:53.05,0:26:54.40,Default,,0,0,0,,它不是自求值的
Dialogue: 0,0:26:54.44,0:26:55.47,Default,,0,0,0,,但它是一个变量
Dialogue: 0,0:26:56.32,0:26:58.06,Default,,0,0,0,,因此我们最好跳转到EV-VARIABLE
Dialogue: 0,0:26:59.79,0:27:02.65,Default,,0,0,0,,EV-VARIABLE首先要给VAL赋值
Dialogue: 0,0:27:02.70,0:27:06.33,Default,,0,0,0,,查找表达式中变量的值
Dialogue: 0,0:27:08.49,0:27:10.75,Default,,0,0,0,,那么VAL寄存器中应该是基本的加法运算
Dialogue: 0,0:27:13.37,0:27:15.16,Default,,0,0,0,,然后(GOTO (FETCH CONTINUE))
Dialogue: 0,0:27:15.23,0:27:16.11,Default,,0,0,0,,Sussman教授：它是EVAL-ARGS
Dialogue: 0,0:27:16.20,0:27:18.73,Default,,0,0,0,,Abelson教授：现在它是EVAL-ARGS而不是DONE了
Dialogue: 0,0:27:19.42,0:27:21.26,Default,,0,0,0,,然后我们来到EVAL-ARGS
Dialogue: 0,0:27:22.16,0:27:23.02,Default,,0,0,0,,看看它要做什么
Dialogue: 0,0:27:23.07,0:27:24.84,Default,,0,0,0,,我们要恢复之前保存的东西
Dialogue: 0,0:27:25.20,0:27:26.57,Default,,0,0,0,,因此调用(RESTORE UNEV)
Dialogue: 0,0:27:29.21,0:27:31.69,Default,,0,0,0,,注意 这里并不是必要的
Dialogue: 0,0:27:31.74,0:27:32.90,Default,,0,0,0,,但通常来说都会有这么一步
Dialogue: 0,0:27:32.90,0:27:35.16,Default,,0,0,0,,它可以是任意的求值过程
Dialogue: 0,0:27:35.43,0:27:36.70,Default,,0,0,0,,恢复ENV寄存器
Dialogue: 0,0:27:47.87,0:27:52.04,Default,,0,0,0,,然后把(FETCH VAL)赋值给FUN
Dialogue: 0,0:27:59.95,0:28:02.81,Default,,0,0,0,,现在我们要开始求值参数了
Dialogue: 0,0:28:04.34,0:28:06.48,Default,,0,0,0,,首先 我们最好把FUN寄存器保存起来
Dialogue: 0,0:28:07.42,0:28:10.62,Default,,0,0,0,,因为求值过程中可能发生任何事情
Dialogue: 0,0:28:15.33,0:28:16.88,Default,,0,0,0,,我们初始化参数列表
Dialogue: 0,0:28:16.91,0:28:19.29,Default,,0,0,0,,给ARGL赋值一个空的参数列表
Dialogue: 0,0:28:20.88,0:28:22.17,Default,,0,0,0,,然后跳转到EVAL-ARG-LOOP
Dialogue: 0,0:28:24.86,0:28:26.27,Default,,0,0,0,,在EVAL-ARG-LOOP中
Dialogue: 0,0:28:27.77,0:28:31.53,Default,,0,0,0,,我们想要去一条一条的求值
Dialogue: 0,0:28:31.61,0:28:33.37,Default,,0,0,0,,UNEV中的表达式
Dialogue: 0,0:28:33.54,0:28:35.68,Default,,0,0,0,,然后把它们从UNEV中的待求值表
Dialogue: 0,0:28:35.90,0:28:37.26,Default,,0,0,0,,移动到ARGL中的已求值表中
Dialogue: 0,0:28:37.84,0:28:39.18,Default,,0,0,0,,然后我们保存ARGL
Dialogue: 0,0:28:43.95,0:28:47.26,Default,,0,0,0,,然后我们把UNEV中的第一个运算对象
Dialogue: 0,0:28:47.37,0:28:48.38,Default,,0,0,0,,赋值给EXP
Dialogue: 0,0:28:53.77,0:28:55.89,Default,,0,0,0,,然后我们检查它是否为最后一个运算对象
Dialogue: 0,0:28:55.89,0:28:56.91,Default,,0,0,0,,在这里 它还不是
Dialogue: 0,0:28:58.99,0:29:01.55,Default,,0,0,0,,然后我们保存环境
Dialogue: 0,0:29:08.00,0:29:10.06,Default,,0,0,0,,我们之所以保存UNEV
Dialogue: 0,0:29:11.61,0:29:13.50,Default,,0,0,0,,是因为稍后我们可能会需要它们
Dialogue: 0,0:29:13.50,0:29:14.40,Default,,0,0,0,,我们需要环境
Dialogue: 0,0:29:14.44,0:29:15.64,Default,,0,0,0,,来进行一些求值
Dialogue: 0,0:29:15.80,0:29:16.60,Default,,0,0,0,,我们需要UNEV寄存器来指示
Dialogue: 0,0:29:16.62,0:29:19.20,Default,,0,0,0,,其余的待求值参数
Dialogue: 0,0:29:20.34,0:29:21.55,Default,,0,0,0,,我们要把CONTINUE寄存器赋值为
Dialogue: 0,0:29:21.56,0:29:24.44,Default,,0,0,0,,ACCUMULATE-ARG这个标号
Dialogue: 0,0:29:31.13,0:29:34.01,Default,,0,0,0,,现在 我们已经准备好再次调用EVAL-DISPATCH了
Dialogue: 0,0:29:37.07,0:29:38.54,Default,,0,0,0,,现在让我把这个短路掉
Dialogue: 0,0:29:39.12,0:29:41.09,Default,,0,0,0,,这里我们不跟进EVAL-DISPATCH的细节
Dialogue: 0,0:29:41.09,0:29:42.64,Default,,0,0,0,,EVAL-DISPATCH的约定说：
Dialogue: 0,0:29:42.97,0:29:45.00,Default,,0,0,0,,我的调用完成后
Dialogue: 0,0:29:45.13,0:29:45.96,Default,,0,0,0,,整个机器的状态会变为
Dialogue: 0,0:29:46.03,0:29:48.20,Default,,0,0,0,,也就是在ENV环境中求值EXP表达式
Dialogue: 0,0:29:48.24,0:29:50.27,Default,,0,0,0,,求值结果会保存在VAL寄存器中
Dialogue: 0,0:29:50.27,0:29:51.07,Default,,0,0,0,,结束状态就是这样
Dialogue: 0,0:29:51.32,0:29:52.62,Default,,0,0,0,,那么我们把这些全都省略掉
Dialogue: 0,0:29:54.43,0:29:56.36,Default,,0,0,0,,最后VAL的内容是3
Dialogue: 0,0:29:58.01,0:29:59.76,Default,,0,0,0,,并且当我们从EVAL-DISPATCH返回的时候
Dialogue: 0,0:29:59.76,0:30:01.76,Default,,0,0,0,,我们会返回到ACCUMULAT-ARG这里
Dialogue: 0,0:30:02.30,0:30:03.23,Default,,0,0,0,,Sussman教授：跳转到ACCUMULATE-ARG
Dialogue: 0,0:30:06.22,0:30:08.20,Default,,0,0,0,,Abelson教授：VAL寄存器里是3 对吧？
Dialogue: 0,0:30:08.72,0:30:10.59,Default,,0,0,0,,我们跳过了求值的细节
Dialogue: 0,0:30:10.65,0:30:11.32,Default,,0,0,0,,现在我们要做什么？
Dialogue: 0,0:30:11.32,0:30:13.68,Default,,0,0,0,,我们返回继续看剩下的参数
Dialogue: 0,0:30:13.68,0:30:14.83,Default,,0,0,0,,我们恢复UNEV
Dialogue: 0,0:30:17.51,0:30:19.00,Default,,0,0,0,,恢复ENV
Dialogue: 0,0:30:25.79,0:30:27.05,Default,,0,0,0,,然后恢复ARGL
Dialogue: 0,0:30:28.65,0:30:29.17,Default,,0,0,0,,这件事
Dialogue: 0,0:30:30.06,0:30:31.45,Default,,0,0,0,,Sussman教授：糟糕 奇偶错误
Dialogue: 0,0:30:33.76,0:30:34.83,Default,,0,0,0,,Abelson教授：恢复ARGL
Dialogue: 0,0:30:45.57,0:30:49.76,Default,,0,0,0,,然后 我们把VAL寄存器和ARGL给CONS起来
Dialogue: 0,0:30:50.65,0:30:52.64,Default,,0,0,0,,然后赋值给ARGL寄存器
Dialogue: 0,0:30:59.36,0:31:02.96,Default,,0,0,0,,我们把UNEV中剩余的运算对象
Dialogue: 0,0:31:03.34,0:31:04.52,Default,,0,0,0,,赋值给UNEV
Dialogue: 0,0:31:08.91,0:31:10.76,Default,,0,0,0,,然后我们返回到EVAL-ARG-LOOP
Dialogue: 0,0:31:11.51,0:31:12.28,Default,,0,0,0,,Sussman教授：EVAL-ARG-LOOP
Dialogue: 0,0:31:12.28,0:31:12.86,Default,,0,0,0,,Abelson教授：好
Dialogue: 0,0:31:15.88,0:31:17.08,Default,,0,0,0,,现在我们处理下一个参数
Dialogue: 0,0:31:17.58,0:31:19.31,Default,,0,0,0,,所以首先我们要保存ARGL
Dialogue: 0,0:31:25.40,0:31:28.27,Default,,0,0,0,,然后我们把UNEV中的第一个运算对象
Dialogue: 0,0:31:29.15,0:31:30.81,Default,,0,0,0,,赋给EXP
Dialogue: 0,0:31:34.72,0:31:37.02,Default,,0,0,0,,然后我们检查它是否为最后一个运算对象
Dialogue: 0,0:31:37.02,0:31:38.00,Default,,0,0,0,,这里它是最后一个
Dialogue: 0,0:31:39.08,0:31:40.27,Default,,0,0,0,,所以我们跳到一个特殊的地方
Dialogue: 0,0:31:40.28,0:31:42.06,Default,,0,0,0,,来求值最后一个参数
Dialogue: 0,0:31:43.37,0:31:45.07,Default,,0,0,0,,因为请注意 在求值这个参数之后
Dialogue: 0,0:31:45.10,0:31:46.62,Default,,0,0,0,,我们就不再需要这个环境了
Dialogue: 0,0:31:47.64,0:31:48.78,Default,,0,0,0,,这就是区别
Dialogue: 0,0:31:50.25,0:31:51.85,Default,,0,0,0,,在这里 在EVAL-LAST-ARG这里
Dialogue: 0,0:31:52.24,0:31:54.92,Default,,0,0,0,,CONTINUE被赋值为了ACCUMULATE-LAST-ARG
Dialogue: 0,0:32:04.27,0:32:06.90,Default,,0,0,0,,现在我们再次为EVAL-DISPATCH做准备
Dialogue: 0,0:32:06.90,0:32:08.51,Default,,0,0,0,,我们有一个完成时要跳转的目的地
Dialogue: 0,0:32:08.62,0:32:09.84,Default,,0,0,0,,我们有一条表达式
Dialogue: 0,0:32:09.84,0:32:10.80,Default,,0,0,0,,还有一个环境
Dialogue: 0,0:32:11.33,0:32:13.64,Default,,0,0,0,,好 那么我们略过对EVAL-DISPATCH的调用
Dialogue: 0,0:32:14.37,0:32:16.41,Default,,0,0,0,,现在情况是这里有一个Y
Dialogue: 0,0:32:16.70,0:32:18.56,Default,,0,0,0,,在这个环境中 它的值是4
Dialogue: 0,0:32:18.60,0:32:20.09,Default,,0,0,0,,所以最终VAL寄存器将会是4
Dialogue: 0,0:32:21.06,0:32:22.86,Default,,0,0,0,,然后我们就要以ACCUMULATE-LAST-ARG结束了
Dialogue: 0,0:32:25.45,0:32:26.91,Default,,0,0,0,,因此 在ACCUMULATE-LAST-ARG中
Dialogue: 0,0:32:29.28,0:32:30.52,Default,,0,0,0,,我们恢复ARGL寄存器
Dialogue: 0,0:32:37.69,0:32:42.76,Default,,0,0,0,,我们把ARGL赋值为
Dialogue: 0,0:32:43.60,0:32:45.83,Default,,0,0,0,,将一个新值CONS在它上面的结果
Dialogue: 0,0:32:45.93,0:32:47.39,Default,,0,0,0,,所以我们在它的旧值前CONS一个4
Dialogue: 0,0:32:49.85,0:32:52.52,Default,,0,0,0,,我们恢复FUN寄存器中的内容
Dialogue: 0,0:32:53.77,0:32:54.99,Default,,0,0,0,,需要注意的是 在则个例子中
Dialogue: 0,0:32:55.00,0:32:56.27,Default,,0,0,0,,FUN寄存器还没有被修改过
Dialogue: 0,0:32:56.38,0:32:57.72,Default,,0,0,0,,但是通常来说 它会的
Dialogue: 0,0:32:59.13,0:33:01.50,Default,,0,0,0,,现在 我们将要调用APPLY-DISPATCH
Dialogue: 0,0:33:02.65,0:33:04.40,Default,,0,0,0,,所以我们刚刚步步跟进了EVAL过程
Dialogue: 0,0:33:04.51,0:33:05.85,Default,,0,0,0,,我们求值了运算符
Dialogue: 0,0:33:06.46,0:33:07.98,Default,,0,0,0,,以及实际参数
Dialogue: 0,0:33:07.98,0:33:09.24,Default,,0,0,0,,现在我们要应用它们了
Dialogue: 0,0:33:09.58,0:33:11.37,Default,,0,0,0,,因此 我们来到APPLY-DISPATCH这里
Dialogue: 0,0:33:18.03,0:33:19.29,Default,,0,0,0,,这是APPLY-DISPATCH的代码
Dialogue: 0,0:33:21.05,0:33:22.41,Default,,0,0,0,,我们要检查它是一个基本过程
Dialogue: 0,0:33:22.41,0:33:23.45,Default,,0,0,0,,还是一个复合过程
Dialogue: 0,0:33:23.64,0:33:24.20,Default,,0,0,0,,Sussman教授：基本过程
Dialogue: 0,0:33:24.54,0:33:24.83,Default,,0,0,0,,Abelson教授：好的
Dialogue: 0,0:33:24.89,0:33:26.52,Default,,0,0,0,,这里 它是一个基本过程
Dialogue: 0,0:33:27.45,0:33:28.91,Default,,0,0,0,,因此 我们跳转到PRIMITIVE-APPLY
Dialogue: 0,0:33:29.79,0:33:31.36,Default,,0,0,0,,我们来到PRIMITIVE-APPLY
Dialogue: 0,0:33:33.71,0:33:35.37,Default,,0,0,0,,它说：把VAL赋值为
Dialogue: 0,0:33:35.69,0:33:38.25,Default,,0,0,0,,把基本过程
Dialogue: 0,0:33:38.36,0:33:40.30,Default,,0,0,0,,应用在参数表的结果
Dialogue: 0,0:33:41.31,0:33:42.43,Default,,0,0,0,,Sussman教授：我不知道怎么做加法
Dialogue: 0,0:33:42.54,0:33:43.80,Default,,0,0,0,,我只是一个执行单元
Dialogue: 0,0:33:44.14,0:33:45.35,Default,,0,0,0,,Abelson教授：我也不知道
Dialogue: 0,0:33:45.35,0:33:46.51,Default,,0,0,0,,我只是一个求值器
Dialogue: 0,0:33:47.08,0:33:48.36,Default,,0,0,0,,因此 我们需要一个基本运算执行器
Dialogue: 0,0:33:48.36,0:33:49.72,Default,,0,0,0,,那么 请问基本运算执行器
Dialogue: 0,0:33:49.76,0:33:52.36,Default,,0,0,0,,3+4等于多少？
Dialogue: 0,0:33:52.86,0:33:53.32,Default,,0,0,0,,学生：7
Dialogue: 0,0:33:53.71,0:33:54.65,Default,,0,0,0,,Abelson教授：好 是7
Dialogue: 0,0:33:55.32,0:33:55.99,Default,,0,0,0,,Sussman教授：谢谢
Dialogue: 0,0:33:59.20,0:34:00.60,Default,,0,0,0,,Abelson教授：现在 我们恢复CONTINUE
Dialogue: 0,0:34:11.58,0:34:12.90,Default,,0,0,0,,执行(GOTO (FETCH CONTINUE))
Dialogue: 0,0:34:13.07,0:34:13.47,Default,,0,0,0,,Sussman教授：'DONE
Dialogue: 0,0:34:14.20,0:34:14.67,Default,,0,0,0,,Abelson教授：好
Dialogue: 0,0:34:14.92,0:34:18.41,Default,,0,0,0,,这些是你能看到的最细致的过程了
Dialogue: 0,0:34:18.41,0:34:20.19,Default,,0,0,0,,我们再也不会讲得这么细了
Dialogue: 0,0:34:21.59,0:34:23.92,Default,,0,0,0,,有一件重要的事需要注意
Dialogue: 0,0:34:24.91,0:34:27.55,Default,,0,0,0,,我们刚刚执行了一个递归过程
Dialogue: 0,0:34:29.56,0:34:31.17,Default,,0,0,0,,我们在整个过程中使用了栈
Dialogue: 0,0:34:31.17,0:34:32.75,Default,,0,0,0,,而且求值器是递归的
Dialogue: 0,0:34:33.07,0:34:35.88,Default,,0,0,0,,有很多人以为在求值器中
Dialogue: 0,0:34:36.48,0:34:37.85,Default,,0,0,0,,会用到栈和递归
Dialogue: 0,0:34:37.87,0:34:38.97,Default,,0,0,0,,或许是因为
Dialogue: 0,0:34:39.09,0:34:42.15,Default,,0,0,0,,回去求值像阶乘或者FIB那样的递归过程
Dialogue: 0,0:34:42.15,0:34:42.92,Default,,0,0,0,,这并不正确
Dialogue: 0,0:34:43.67,0:34:44.99,Default,,0,0,0,,注意 我们在这里进行了递归
Dialogue: 0,0:34:45.00,0:34:46.86,Default,,0,0,0,,而仅仅是去求值(+ X Y)
Dialogue: 0,0:34:47.77,0:34:50.65,Default,,0,0,0,,在求值器中需要递归 实际上是因为
Dialogue: 0,0:34:50.96,0:34:52.97,Default,,0,0,0,,是因为求值过程本身
Dialogue: 0,0:34:52.99,0:34:54.06,Default,,0,0,0,,就是递归的
Dialogue: 0,0:34:54.45,0:34:56.17,Default,,0,0,0,,并不是因为你在Lisp中
Dialogue: 0,0:34:56.32,0:34:58.09,Default,,0,0,0,,要求值的那个过程
Dialogue: 0,0:34:58.12,0:34:59.27,Default,,0,0,0,,是一个递归过程
Dialogue: 0,0:34:59.27,0:35:00.52,Default,,0,0,0,,这一点很重要
Dialogue: 0,0:35:00.52,0:35:02.14,Default,,0,0,0,,人们经常在这里被弄糊涂
Dialogue: 0,0:35:03.01,0:35:04.27,Default,,0,0,0,,另一点要注意的是
Dialogue: 0,0:35:04.27,0:35:05.64,Default,,0,0,0,,我们在这里完成之后
Dialogue: 0,0:35:06.28,0:35:07.12,Default,,0,0,0,,真正完成以后
Dialogue: 0,0:35:07.12,0:35:08.49,Default,,0,0,0,,不仅仅是指我们在'DONE这个标号
Dialogue: 0,0:35:09.45,0:35:13.23,Default,,0,0,0,,栈上也没有累积的东西了
Dialogue: 0,0:35:13.60,0:35:15.71,Default,,0,0,0,,对吧？机器又回到了它的初始状态
Dialogue: 0,0:35:17.00,0:35:18.75,Default,,0,0,0,,那就是“完成”的其中一部分意义
Dialogue: 0,0:35:19.71,0:35:21.04,Default,,0,0,0,,换句话说就是
Dialogue: 0,0:35:22.72,0:35:26.04,Default,,0,0,0,,整个求值过程是把
Dialogue: 0,0:35:26.41,0:35:28.32,Default,,0,0,0,,(+ X Y)这条表达式
Dialogue: 0,0:35:30.54,0:35:32.78,Default,,0,0,0,,归约为这里的7
Dialogue: 0,0:35:33.24,0:35:35.45,Default,,0,0,0,,我所指的“归约”有特殊的意义
Dialogue: 0,0:35:36.01,0:35:38.18,Default,,0,0,0,,也就是栈上没剩下任何东西了
Dialogue: 0,0:35:38.18,0:35:40.36,Default,,0,0,0,,机器现在与初始状态相同
Dialogue: 0,0:35:40.92,0:35:42.65,Default,,0,0,0,,只是VAL寄存器里有一些东西
Dialogue: 0,0:35:42.72,0:35:44.52,Default,,0,0,0,,它不是任何问题的子问题
Dialogue: 0,0:35:44.52,0:35:45.63,Default,,0,0,0,,不需要返回到其它地方
Dialogue: 0,0:35:46.12,0:35:46.96,Default,,0,0,0,,好 这节课就讲到这里
Dialogue: 0,0:35:50.16,0:35:50.76,Default,,0,0,0,,有问题吗
Dialogue: 0,0:35:51.08,0:35:54.02,Default,,0,0,0,,学生：关于栈有一个问题
Dialogue: 0,0:35:54.02,0:35:55.82,Default,,0,0,0,,由于数据有可能是递归的
Dialogue: 0,0:35:56.20,0:35:58.75,Default,,0,0,0,,例如 嵌套的表达式
Dialogue: 0,0:35:59.31,0:36:02.08,Default,,0,0,0,,教授：是的 因为你可能遇到嵌套的表达式
Dialogue: 0,0:36:02.08,0:36:04.77,Default,,0,0,0,,但是再说一遍 不要搞混
Dialogue: 0,0:36:04.77,0:36:07.98,Default,,0,0,0,,有时候人们说数据是递归的
Dialogue: 0,0:36:08.00,0:36:10.35,Default,,0,0,0,,他们说的是对于这些表结构的
Dialogue: 0,0:36:11.04,0:36:12.93,Default,,0,0,0,,一些递归运算
Dialogue: 0,0:36:12.93,0:36:13.96,Default,,0,0,0,,那和这没有关系
Dialogue: 0,0:36:13.98,0:36:16.16,Default,,0,0,0,,这只是包含子表达式的表达式而已
Dialogue: 0,0:36:20.04,0:36:23.52,Default,,0,0,0,,学生：为什么ARGL中参数的顺序是反过来的
Dialogue: 0,0:36:23.55,0:36:25.29,Default,,0,0,0,,教授：对 我应该提一嘴这个
Dialogue: 0,0:36:27.26,0:36:29.07,Default,,0,0,0,,之所以在这里把顺序反过来
Dialogue: 0,0:36:32.78,0:36:35.37,Default,,0,0,0,,你首先定义怎么算“逆序”
Dialogue: 0,0:36:36.05,0:36:39.90,Default,,0,0,0,,我记得应该是牛顿
Dialogue: 0,0:36:40.91,0:36:42.41,Default,,0,0,0,,在光学发展的很早期
Dialogue: 0,0:36:42.43,0:36:43.26,Default,,0,0,0,,人们意识到
Dialogue: 0,0:36:43.61,0:36:45.36,Default,,0,0,0,,当你用眼睛通过透镜看东西的时候
Dialogue: 0,0:36:45.50,0:36:46.73,Default,,0,0,0,,图像是上下颠倒的
Dialogue: 0,0:36:46.73,0:36:48.04,Default,,0,0,0,,当时有很多的争论说
Dialogue: 0,0:36:48.04,0:36:50.48,Default,,0,0,0,,为什么不能是你眼睛平时看见的都是上下颠倒的
Dialogue: 0,0:36:51.28,0:36:52.65,Default,,0,0,0,,这实际上是一样的道理
Dialogue: 0,0:36:52.86,0:36:53.90,Default,,0,0,0,,和什么相比反过来了
Dialogue: 0,0:36:54.81,0:36:56.24,Default,,0,0,0,,我们只是需要一个约定
Dialogue: 0,0:36:56.59,0:37:00.35,Default,,0,0,0,,它们作为(4 3)出现的原因是
Dialogue: 0,0:37:00.80,0:37:02.49,Default,,0,0,0,,是因为我们从UNEV中取出东西
Dialogue: 0,0:37:02.52,0:37:04.03,Default,,0,0,0,,并且把它CONS到了ARGL上面
Dialogue: 0,0:37:04.52,0:37:06.68,Default,,0,0,0,,那么你要意识到你已经做了这个约定
Dialogue: 0,0:37:06.86,0:37:09.37,Default,,0,0,0,,你需要意识到这点的地方有
Dialogue: 0,0:37:09.98,0:37:11.23,Default,,0,0,0,,实际上有两个地方
Dialogue: 0,0:37:11.23,0:37:12.91,Default,,0,0,0,,首先是在APPLY-PRIMITIVE-OPERATOR
Dialogue: 0,0:37:12.91,0:37:14.06,Default,,0,0,0,,你要意识到
Dialogue: 0,0:37:15.12,0:37:16.75,Default,,0,0,0,,参数传入基本运算的顺序
Dialogue: 0,0:37:16.78,0:37:18.72,Default,,0,0,0,,是和你的书写顺序相反的
Dialogue: 0,0:37:19.49,0:37:21.00,Default,,0,0,0,,我们之后会在另外一处看到
Dialogue: 0,0:37:21.07,0:37:23.80,Default,,0,0,0,,当你实际绑定绑定函数的形式参数时
Dialogue: 0,0:37:24.01,0:37:25.74,Default,,0,0,0,,你要意识到参数进入的顺序
Dialogue: 0,0:37:25.74,0:37:28.54,Default,,0,0,0,,和你要绑定这些变量时的顺序相反
Dialogue: 0,0:37:28.87,0:37:30.17,Default,,0,0,0,,所以如果你注意这些
Dialogue: 0,0:37:31.08,0:37:31.83,Default,,0,0,0,,就没有问题了
Dialogue: 0,0:37:31.83,0:37:33.69,Default,,0,0,0,,同样 这完全是随意的
Dialogue: 0,0:37:33.90,0:37:34.96,Default,,0,0,0,,因为如果我们做了一个
Dialogue: 0,0:37:35.10,0:37:37.15,Default,,0,0,0,,比如 给向量的各个维度赋值的迭代
Dialogue: 0,0:37:37.42,0:37:38.73,Default,,0,0,0,,它们可能会以其它顺序输出
Dialogue: 0,0:37:40.41,0:37:42.04,Default,,0,0,0,,那么这只是这个求值器
Dialogue: 0,0:37:42.06,0:37:43.53,Default,,0,0,0,,工作时的一个约定
Dialogue: 0,0:37:45.39,0:37:46.24,Default,,0,0,0,,好 我们休息一下
Dialogue: 0,0:37:46.33,0:38:02.44,Default,,0,0,0,,[音乐]
Dialogue: 0,0:38:02.44,0:38:07.64,Declare,,0,0,0,,{\an2\fad(500,500)}《计算机程序的构造和解释》
Dialogue: 0,0:38:28.62,0:38:32.51,Declare,,0,0,0,,{\an2\fad(500,500)}讲师： 哈罗德·艾伯森教授 及 格兰德·杰·萨斯曼教授
Dialogue: 0,0:38:32.51,0:38:35.68,Declare,,0,0,0,,{\an2\fad(500,500)}《计算机程序的构造和解释》
Dialogue: 0,0:38:35.68,0:38:39.61,Declare,,0,0,0,,{\an2\fad(500,500)}显式控制求值器
Dialogue: 0,0:38:41.84,0:38:45.31,Default,,0,0,0,,教授：我们已经学习了表达式的求值
Dialogue: 0,0:38:45.60,0:38:47.08,Default,,0,0,0,,虽然这只是一个非常简单的例子
Dialogue: 0,0:38:48.81,0:38:50.24,Default,,0,0,0,,但从本质上来说
Dialogue: 0,0:38:50.24,0:38:52.03,Default,,0,0,0,,它跟那些大型嵌套表达式没什么不同
Dialogue: 0,0:38:52.03,0:38:54.57,Default,,0,0,0,,后者只是在栈上递归得更深而已
Dialogue: 0,0:38:55.13,0:38:56.03,Default,,0,0,0,,我现在要为你们
Dialogue: 0,0:38:56.04,0:38:56.91,Default,,0,0,0,,讲解最后一部分
Dialogue: 0,0:38:56.92,0:38:59.82,Default,,0,0,0,,我要带着你们观察EVAL-APPLY循环
Dialogue: 0,0:39:01.01,0:39:02.81,Default,,0,0,0,,我们还没有仔细研究过它
Dialogue: 0,0:39:03.00,0:39:04.75,Default,,0,0,0,,我们还没有见过一个复合程序
Dialogue: 0,0:39:05.20,0:39:07.79,Default,,0,0,0,,对它的求值会归约为
Dialogue: 0,0:39:07.92,0:39:10.11,Default,,0,0,0,,对一个过程的应用
Dialogue: 0,0:39:10.12,0:39:11.64,Default,,0,0,0,,进而是对过程体的求值
Dialogue: 0,0:39:12.44,0:39:15.88,Default,,0,0,0,,因此 假设我们有这个
Dialogue: 0,0:39:15.93,0:39:17.44,Default,,0,0,0,,假设我们正在考察
Dialogue: 0,0:39:18.07,0:39:31.60,Default,,0,0,0,,(DEFINE (F A B) (+ A B)
Dialogue: 0,0:39:33.99,0:39:37.32,Default,,0,0,0,,假设我们预先定义好了这个过程
Dialogue: 0,0:39:37.69,0:39:41.64,Default,,0,0,0,,现在 我们将要求值(F X Y)
Dialogue: 0,0:39:42.27,0:39:44.20,Default,,0,0,0,,基于的环境是E0
Dialogue: 0,0:39:44.35,0:39:47.02,Default,,0,0,0,,其中X=3 Y=4
Dialogue: 0,0:39:50.78,0:39:52.11,Default,,0,0,0,,当执行DEFINE的时候
Dialogue: 0,0:39:52.12,0:39:53.69,Default,,0,0,0,,还记得么 这里是一个LAMBDA
Dialogue: 0,0:39:53.82,0:39:55.53,Default,,0,0,0,,LAMBDA会创建一个过程
Dialogue: 0,0:39:55.95,0:39:58.49,Default,,0,0,0,,基本上 会发生的事情是
Dialogue: 0,0:39:59.63,0:40:00.68,Default,,0,0,0,,在环境E0中
Dialogue: 0,0:40:01.00,0:40:02.65,Default,,0,0,0,,我们会得到F的绑定
Dialogue: 0,0:40:03.56,0:40:05.61,Default,,0,0,0,,它指出F是一个过程
Dialogue: 0,0:40:07.15,0:40:11.28,Default,,0,0,0,,这个过程的参数是A和B
Dialogue: 0,0:40:12.57,0:40:16.19,Default,,0,0,0,,而过程体是(+ A B)
Dialogue: 0,0:40:18.11,0:40:20.99,Default,,0,0,0,,这就是环境大概的样子
Dialogue: 0,0:40:21.21,0:40:22.52,Default,,0,0,0,,我们之前就定义过了
Dialogue: 0,0:40:24.22,0:40:27.28,Default,,0,0,0,,然后 我们去求值(F X Y)
Dialogue: 0,0:40:28.80,0:40:30.89,Default,,0,0,0,,我们会仔细地解释每一步
Dialogue: 0,0:40:31.02,0:40:31.85,Default,,0,0,0,,就像之前那样
Dialogue: 0,0:40:31.88,0:40:33.09,Default,,0,0,0,,不会跳过重复的表达式
Dialogue: 0,0:40:33.28,0:40:34.38,Default,,0,0,0,,唯一的不同是
Dialogue: 0,0:40:34.40,0:40:36.64,Default,,0,0,0,,它的内部不再是基本的“+”过程
Dialogue: 0,0:40:37.24,0:40:38.99,Default,,0,0,0,,它还有这个东西
Dialogue: 0,0:40:41.04,0:40:43.60,Default,,0,0,0,,因此我们要进行相同的过程
Dialogue: 0,0:40:43.60,0:40:44.92,Default,,0,0,0,,只不过这次
Dialogue: 0,0:40:45.26,0:40:47.42,Default,,0,0,0,,当我们停在APPLY-DISPATCH时
Dialogue: 0,0:40:47.86,0:40:50.28,Default,,0,0,0,,FUN寄存器中不再是基本的“+”过程
Dialogue: 0,0:40:50.44,0:40:53.58,Default,,0,0,0,,而是一个代表过程的东西
Dialogue: 0,0:40:54.30,0:40:59.00,Default,,0,0,0,,其中参数为A和B
Dialogue: 0,0:41:00.64,0:41:06.27,Default,,0,0,0,,过程体是(+ A B)
Dialogue: 0,0:41:07.87,0:41:09.92,Default,,0,0,0,,再强调一下 我所谓的ENV
Dialogue: 0,0:41:09.96,0:41:11.12,Default,,0,0,0,,是一个指向环境的指针
Dialogue: 0,0:41:11.24,0:41:13.07,Default,,0,0,0,,所以不用担心我在这里写了很多东西
Dialogue: 0,0:41:13.28,0:41:15.63,Default,,0,0,0,,这是一个指向代表过程的数据结构的指针
Dialogue: 0,0:41:17.17,0:41:19.77,Default,,0,0,0,,因此 我们现在面临着相同的情况
Dialogue: 0,0:41:20.27,0:41:22.43,Default,,0,0,0,,我们来到了APPLY-DISPATCH
Dialogue: 0,0:41:23.98,0:41:26.48,Default,,0,0,0,,这是APPLY-DISPATCH的代码
Dialogue: 0,0:41:26.48,0:41:28.73,Default,,0,0,0,,上一次 我们分支跳转到了一个基本过程
Dialogue: 0,0:41:30.01,0:41:30.70,Default,,0,0,0,,然而这一次
Dialogue: 0,0:41:30.84,0:41:32.80,Default,,0,0,0,,我们遇到的是一个复合过程
Dialogue: 0,0:41:34.55,0:41:36.60,Default,,0,0,0,,因此我们要跳转到COMPOUND-APPLY
Dialogue: 0,0:41:38.47,0:41:39.92,Default,,0,0,0,,COMPOUND-APPLY又是怎样定义的呢？
Dialogue: 0,0:41:41.92,0:41:44.54,Default,,0,0,0,,还记得元循环求值器是怎么做的么？
Dialogue: 0,0:41:45.09,0:41:47.40,Default,,0,0,0,,COMPOUND-APPLY的执行步骤则是
Dialogue: 0,0:41:49.90,0:41:51.60,Default,,0,0,0,,在一个新的环境中
Dialogue: 0,0:41:52.94,0:41:54.12,Default,,0,0,0,,求值一个过程的体
Dialogue: 0,0:41:54.12,0:41:55.87,Default,,0,0,0,,这个新的环境来自于哪里呢？
Dialogue: 0,0:41:56.73,0:42:01.36,Default,,0,0,0,,我们把跟过程一同打包的环境
Dialogue: 0,0:42:03.02,0:42:05.79,Default,,0,0,0,,我们把过程的形式参数
Dialogue: 0,0:42:06.00,0:42:07.63,Default,,0,0,0,,同传递进来的实际参数给绑定起来
Dialogue: 0,0:42:09.75,0:42:11.95,Default,,0,0,0,,把这个作为新的框架
Dialogue: 0,0:42:12.59,0:42:13.79,Default,,0,0,0,,来扩展过程附带的环境
Dialogue: 0,0:42:14.99,0:42:16.08,Default,,0,0,0,,我们就是在这个环境中
Dialogue: 0,0:42:16.30,0:42:18.88,Default,,0,0,0,,求值过程的体
Dialogue: 0,0:42:20.12,0:42:24.47,Default,,0,0,0,,对吧？这就是APPLY-EVAL循环做的事
Dialogue: 0,0:42:24.47,0:42:26.25,Default,,0,0,0,,这就是APPLY回过头来调用EVAL
Dialogue: 0,0:42:32.86,0:42:34.92,Default,,0,0,0,,因此 这就是我们要在COMPOUND-APPLY中要做的所有事
Dialogue: 0,0:42:36.78,0:42:37.72,Default,,0,0,0,,要怎么来实现呢？
Dialogue: 0,0:42:37.72,0:42:40.97,Default,,0,0,0,,我们要构造一个新的环境
Dialogue: 0,0:42:43.55,0:42:45.64,Default,,0,0,0,,而我们构造的这个新环境呢
Dialogue: 0,0:42:46.76,0:42:48.11,Default,,0,0,0,,我们把它记作E1
Dialogue: 0,0:42:52.90,0:42:55.63,Default,,0,0,0,,E1这个环境呢
Dialogue: 0,0:42:57.31,0:42:59.15,Default,,0,0,0,,存储了过程的参数绑定
Dialogue: 0,0:42:59.21,0:43:03.26,Default,,0,0,0,,其中A=3 B=4
Dialogue: 0,0:43:04.27,0:43:05.76,Default,,0,0,0,,并且它跟E0相连
Dialogue: 0,0:43:05.76,0:43:08.08,Default,,0,0,0,,这是因为 F就是在E0中定义的
Dialogue: 0,0:43:09.27,0:43:10.27,Default,,0,0,0,,因此 在这个环境中
Dialogue: 0,0:43:10.27,0:43:11.96,Default,,0,0,0,,我们要来求值过程的体
Dialogue: 0,0:43:12.05,0:43:14.48,Default,,0,0,0,,让我们来看一看
Dialogue: 0,0:43:16.52,0:43:18.32,Default,,0,0,0,,我们来看COMPOUND-APPLY的代码
Dialogue: 0,0:43:20.30,0:43:23.47,Default,,0,0,0,,首先是给EXP寄存器赋值
Dialogue: 0,0:43:24.50,0:43:25.98,Default,,0,0,0,,所赋的值是FUN寄存器
Dialogue: 0,0:43:25.98,0:43:27.26,Default,,0,0,0,,所指向过程的体
Dialogue: 0,0:43:28.38,0:43:30.64,Default,,0,0,0,,这样 我就将过程的体
Dialogue: 0,0:43:31.29,0:43:32.33,Default,,0,0,0,,赋值给了EXP寄存器
Dialogue: 0,0:43:40.75,0:43:41.10,Default,,0,0,0,,对吧？
Dialogue: 0,0:43:42.64,0:43:44.97,Default,,0,0,0,,而这将在某个环境中求值
Dialogue: 0,0:43:45.82,0:43:48.32,Default,,0,0,0,,这个环境是通过将FUN寄存器
Dialogue: 0,0:43:51.30,0:43:53.67,Default,,0,0,0,,所指向的过程中的形式参数
Dialogue: 0,0:43:53.67,0:43:56.25,Default,,0,0,0,,与实际参数绑定起来 得到的
Dialogue: 0,0:43:57.80,0:44:00.00,Default,,0,0,0,,我们先不要关系它的具体细节
Dialogue: 0,0:44:00.08,0:44:01.63,Default,,0,0,0,,你可以知道它的最后结果
Dialogue: 0,0:44:01.93,0:44:03.32,Default,,0,0,0,,因此MAKE-BINDINGS会说
Dialogue: 0,0:44:04.04,0:44:07.90,Default,,0,0,0,,过程本身就附带有一个环境
Dialogue: 0,0:44:07.96,0:44:09.32,Default,,0,0,0,,在这里 我没有写出来
Dialogue: 0,0:44:09.36,0:44:10.56,Default,,0,0,0,,但我应该说过它有一个环境
Dialogue: 0,0:44:11.30,0:44:12.73,Default,,0,0,0,,因为每个过程在构造时
Dialogue: 0,0:44:12.76,0:44:13.44,Default,,0,0,0,,都有一个环境
Dialogue: 0,0:44:13.66,0:44:14.83,Default,,0,0,0,,因此 通过这个环境
Dialogue: 0,0:44:15.68,0:44:16.35,Default,,0,0,0,,它能够知道
Dialogue: 0,0:44:16.60,0:44:18.65,Default,,0,0,0,,定义该过程时的环境是怎样的
Dialogue: 0,0:44:19.29,0:44:20.75,Default,,0,0,0,,它知道实际参数是什么
Dialogue: 0,0:44:21.83,0:44:22.49,Default,,0,0,0,,它查看ARGL
Dialogue: 0,0:44:22.49,0:44:24.28,Default,,0,0,0,,然后你会在这里看到逆序的约定
Dialogue: 0,0:44:24.28,0:44:26.62,Default,,0,0,0,,它需要知道ARGL是逆序的
Dialogue: 0,0:44:27.06,0:44:28.81,Default,,0,0,0,,然后它构造了这个框架 E1
Dialogue: 0,0:44:29.99,0:44:31.08,Default,,0,0,0,,因此我们假设
Dialogue: 0,0:44:31.10,0:44:32.92,Default,,0,0,0,,MAKE-BINDINGS返回的就是这些东西
Dialogue: 0,0:44:33.36,0:44:36.22,Default,,0,0,0,,然后 它把E1赋值给ENV
Dialogue: 0,0:44:41.34,0:44:42.54,Default,,0,0,0,,下一步就是
Dialogue: 0,0:44:43.95,0:44:45.84,Default,,0,0,0,,恢复CONTINUE
Dialogue: 0,0:44:46.89,0:44:48.19,Default,,0,0,0,,还记得CONTINUE之前是什么吗？
Dialogue: 0,0:44:48.76,0:44:50.43,Default,,0,0,0,,在最后一段中
Dialogue: 0,0:44:52.24,0:44:54.02,Default,,0,0,0,,CONTINUE被保存了
Dialogue: 0,0:44:54.02,0:44:55.18,Default,,0,0,0,,它的值是最初的'DONE
Dialogue: 0,0:44:55.32,0:44:56.56,Default,,0,0,0,,这代表了
Dialogue: 0,0:44:56.73,0:44:59.44,Default,,0,0,0,,在完成这项特定应用后要做的事
Dialogue: 0,0:45:00.14,0:45:01.72,Default,,0,0,0,,这是在求值整个应用时
Dialogue: 0,0:45:01.76,0:45:03.18,Default,,0,0,0,,最先发生的事儿
Dialogue: 0,0:45:03.88,0:45:05.87,Default,,0,0,0,,现在 我们要恢复CONTINUE了
Dialogue: 0,0:45:06.86,0:45:09.55,Default,,0,0,0,,还记得APPLY-DISPATCH的约定么？
Dialogue: 0,0:45:09.58,0:45:11.20,Default,,0,0,0,,它假设下一步的跳转目标
Dialogue: 0,0:45:11.23,0:45:11.98,Default,,0,0,0,,已经存放在栈上了
Dialogue: 0,0:45:12.03,0:45:13.12,Default,,0,0,0,,并且 这里确实存放在栈上了
Dialogue: 0,0:45:13.59,0:45:14.76,Default,,0,0,0,,CONTINUE被赋值成了DONE
Dialogue: 0,0:45:17.82,0:45:19.90,Default,,0,0,0,,现在我们要回到EVAL-DISPATCH了
Dialogue: 0,0:45:19.94,0:45:20.84,Default,,0,0,0,,我们要再次进行寄存器设置
Dialogue: 0,0:45:20.97,0:45:24.41,Default,,0,0,0,,我们有表达式、环境、下一步
Dialogue: 0,0:45:25.80,0:45:26.89,Default,,0,0,0,,我不会再细讲了
Dialogue: 0,0:45:27.88,0:45:29.55,Default,,0,0,0,,因为它基本上就是相同的表达式
Dialogue: 0,0:45:35.40,0:45:37.79,Default,,0,0,0,,但是需要注意的是
Dialogue: 0,0:45:37.82,0:45:38.73,Default,,0,0,0,,在这个时候
Dialogue: 0,0:45:39.34,0:45:43.72,Default,,0,0,0,,我们已经归约了原始表达式(F X Y)
Dialogue: 0,0:45:44.64,0:45:47.92,Default,,0,0,0,,通过在E0中求值(F X Y)
Dialogue: 0,0:45:48.89,0:45:52.67,Default,,0,0,0,,将其归约为在E1中求值(+ A B)
Dialogue: 0,0:45:52.78,0:45:55.92,Default,,0,0,0,,要注意 栈上并没有什么东西 对吧？
Dialogue: 0,0:45:56.11,0:45:56.83,Default,,0,0,0,,这是一个归约
Dialogue: 0,0:45:56.84,0:45:59.80,Default,,0,0,0,,这个时候 机器的状态中
Dialogue: 0,0:45:59.84,0:46:01.20,Default,,0,0,0,,并没有包含
Dialogue: 0,0:46:01.76,0:46:03.71,Default,,0,0,0,,它是求值过程F的
Dialogue: 0,0:46:03.72,0:46:04.88,Default,,0,0,0,,中间状态的事实
Dialogue: 0,0:46:05.49,0:46:06.28,Default,,0,0,0,,它消失了
Dialogue: 0,0:46:07.66,0:46:09.55,Default,,0,0,0,,这里面没有积累的状态
Dialogue: 0,0:46:13.07,0:46:14.37,Default,,0,0,0,,注意 这个思想非常重要
Dialogue: 0,0:46:14.37,0:46:16.33,Default,,0,0,0,,这意味着
Dialogue: 0,0:46:16.76,0:46:18.39,Default,,0,0,0,,当我们使用代换模型时
Dialogue: 0,0:46:18.39,0:46:20.86,Default,,0,0,0,,一条表达式会归约到另一条表达式
Dialogue: 0,0:46:21.35,0:46:22.66,Default,,0,0,0,,而你不需要记住任何东西
Dialogue: 0,0:46:22.66,0:46:24.50,Default,,0,0,0,,这里 你就见到了归约的真谛
Dialogue: 0,0:46:24.56,0:46:26.16,Default,,0,0,0,,这个时候 栈上没有任何东西
Dialogue: 0,0:46:31.59,0:46:33.63,Default,,0,0,0,,这样就有一个非常重要的结果
Dialogue: 0,0:46:35.24,0:46:37.90,Default,,0,0,0,,让我们回过头来看看迭代式阶乘
Dialogue: 0,0:46:40.42,0:46:42.76,Default,,0,0,0,,还记得吗？这是某种循环
Dialogue: 0,0:46:44.01,0:46:44.88,Default,,0,0,0,,用来进行迭代
Dialogue: 0,0:46:45.13,0:46:47.36,Default,,0,0,0,,我们不断强调 它是一个迭代过程
Dialogue: 0,0:46:49.26,0:46:53.84,Default,,0,0,0,,还记得吗
Dialogue: 0,0:46:58.44,0:47:03.13,Default,,0,0,0,,我们使用它的时候
Dialogue: 0,0:47:04.35,0:47:11.07,Default,,0,0,0,,是像(FACT-ITER 5)这样调用它的
Dialogue: 0,0:47:12.36,0:47:18.67,Default,,0,0,0,,然后我们把它归约成(ITER 1 1 5)
Dialogue: 0,0:47:19.03,0:47:25.15,Default,,0,0,0,,然后它归约成(ITER 1 2 5)
Dialogue: 0,0:47:25.32,0:47:27.07,Default,,0,0,0,,等等等等
Dialogue: 0,0:47:27.07,0:47:28.17,Default,,0,0,0,,然后我们又说 看
Dialogue: 0,0:47:28.17,0:47:30.35,Default,,0,0,0,,为了实现这个效果 不需要存储任何东西
Dialogue: 0,0:47:31.72,0:47:32.73,Default,,0,0,0,,我们摆了摆手 说
Dialogue: 0,0:47:32.75,0:47:34.59,Default,,0,0,0,,“原则上 这不需要任何存储”
Dialogue: 0,0:47:35.04,0:47:36.17,Default,,0,0,0,,现在你们发现 确实不需要
Dialogue: 0,0:47:36.17,0:47:39.09,Default,,0,0,0,,这里的每一步都是真正的归约 对吧？
Dialogue: 0,0:47:39.09,0:47:42.60,Default,,0,0,0,,随着你求值这些表达式
Dialogue: 0,0:47:47.30,0:47:50.51,Default,,0,0,0,,在求值这些表达式的过程中
Dialogue: 0,0:47:50.83,0:47:51.37,Default,,0,0,0,,你会发现
Dialogue: 0,0:47:51.37,0:47:52.81,Default,,0,0,0,,栈上的这些表达式
Dialogue: 0,0:47:53.75,0:47:55.64,Default,,0,0,0,,都在一个特定的环境中
Dialogue: 0,0:47:56.42,0:48:00.02,Default,,0,0,0,,抱歉 是EXP寄存器中的表达式
Dialogue: 0,0:48:00.02,0:48:01.50,Default,,0,0,0,,是在某个特定的环境中
Dialogue: 0,0:48:01.57,0:48:02.19,Default,,0,0,0,,并且 在每一步
Dialogue: 0,0:48:02.19,0:48:04.00,Default,,0,0,0,,栈上不会积累任何东西
Dialogue: 0,0:48:04.36,0:48:05.68,Default,,0,0,0,,因为每一步都是真正的归约
Dialogue: 0,0:48:09.28,0:48:10.51,Default,,0,0,0,,因此 举例来说
Dialogue: 0,0:48:10.58,0:48:12.51,Default,,0,0,0,,说得更仔细一点
Dialogue: 0,0:48:13.46,0:48:16.88,Default,,0,0,0,,如果我从这样的一条表达式开始
Dialogue: 0,0:48:22.44,0:48:34.25,Default,,0,0,0,,比如说 在某个环境中计算(FACT-ITER 5)
Dialogue: 0,0:48:42.11,0:48:46.30,Default,,0,0,0,,它将在某个时刻创建一个环境
Dialogue: 0,0:48:46.81,0:48:48.38,Default,,0,0,0,,其中N=5
Dialogue: 0,0:48:51.47,0:48:52.01,Default,,0,0,0,,我们把它写下来
Dialogue: 0,0:48:55.68,0:48:56.59,Default,,0,0,0,,然后 在某个时候
Dialogue: 0,0:48:56.89,0:49:02.56,Default,,0,0,0,,机器会归约这整个东西
Dialogue: 0,0:49:02.91,0:49:04.35,Default,,0,0,0,,将它归约为
Dialogue: 0,0:49:04.76,0:49:09.85,Default,,0,0,0,,(ITER 1 1 N)
Dialogue: 0,0:49:10.68,0:49:13.72,Default,,0,0,0,,然后在环境E1中求值这条表达式
Dialogue: 0,0:49:15.87,0:49:17.16,Default,,0,0,0,,而不在栈上存放任何东西
Dialogue: 0,0:49:17.16,0:49:19.55,Default,,0,0,0,,看到了么 这时机器并不会记住
Dialogue: 0,0:49:20.71,0:49:22.50,Default,,0,0,0,,求值这条ITER表达式--
Dialogue: 0,0:49:25.00,0:49:25.63,Default,,0,0,0,,也就是某种循环--
Dialogue: 0,0:49:25.79,0:49:28.57,Default,,0,0,0,,并不是FACT-ITER的一部分
Dialogue: 0,0:49:29.68,0:49:30.59,Default,,0,0,0,,它不会记住这个事实
Dialogue: 0,0:49:30.59,0:49:33.17,Default,,0,0,0,,它只是归约了该表达式
Dialogue: 0,0:49:33.17,0:49:36.56,Default,,0,0,0,,如果我们再来看迭代式阶乘的体
Dialogue: 0,0:49:38.05,0:49:41.08,Default,,0,0,0,,这条表达式归约为了这条表达式
Dialogue: 0,0:49:42.81,0:49:43.87,Default,,0,0,0,,哦 这里漏了一个N
Dialogue: 0,0:49:46.59,0:49:47.74,Default,,0,0,0,,幻灯片中的约定
Dialogue: 0,0:49:47.74,0:49:49.13,Default,,0,0,0,,和实际程序中稍有不同
Dialogue: 0,0:49:53.34,0:49:56.25,Default,,0,0,0,,那么 ITER的体又是什么？
Dialogue: 0,0:49:56.28,0:49:57.40,Default,,0,0,0,,ITER的体首先是一个IF--
Dialogue: 0,0:49:58.75,0:50:00.19,Default,,0,0,0,,我不会再深入IF语句的细节了
Dialogue: 0,0:50:00.24,0:50:01.63,Default,,0,0,0,,它会对谓词求值
Dialogue: 0,0:50:02.40,0:50:03.71,Default,,0,0,0,,本例中 会返回FALSE
Dialogue: 0,0:50:03.81,0:50:08.64,Default,,0,0,0,,然后这里的ITER会归约为表达式--
Dialogue: 0,0:50:09.85,0:50:20.20,Default,,0,0,0,,(ITER (* COUNTER PRODUCT)
Dialogue: 0,0:50:21.62,0:50:22.24,Default,,0,0,0,,按照它代码写的--
Dialogue: 0,0:50:22.68,0:50:24.56,Default,,0,0,0,,(+ COUNTER 1))
Dialogue: 0,0:50:28.72,0:50:31.42,Default,,0,0,0,,在另外的一个环境E2中求值
Dialogue: 0,0:50:32.97,0:50:35.98,Default,,0,0,0,,其中 E2会记录着
Dialogue: 0,0:50:36.49,0:50:39.39,Default,,0,0,0,,PRODUCT和COUNTER的值
Dialogue: 0,0:50:42.92,0:50:44.33,Default,,0,0,0,,它会被归约为这条语句
Dialogue: 0,0:50:44.94,0:50:46.04,Default,,0,0,0,,它不会记得
Dialogue: 0,0:50:46.06,0:50:48.75,Default,,0,0,0,,它是一个需要返回到某处的一部分
Dialogue: 0,0:50:49.34,0:50:50.43,Default,,0,0,0,,当ITER再次调用ITER时
Dialogue: 0,0:50:50.44,0:50:52.56,Default,,0,0,0,,它会归约为另一个像这样的东西
Dialogue: 0,0:50:53.05,0:50:54.68,Default,,0,0,0,,只是会在新环境E3中
Dialogue: 0,0:50:54.83,0:50:56.67,Default,,0,0,0,,里面有关于PRODUCT和COUNTER新的绑定
Dialogue: 0,0:50:58.80,0:51:05.29,Default,,0,0,0,,因此 如果你想知道
Dialogue: 0,0:51:06.09,0:51:07.53,Default,,0,0,0,,如果你一直感到不安
Dialogue: 0,0:51:08.25,0:51:10.67,Default,,0,0,0,,不知道为什么我们说这些过程
Dialogue: 0,0:51:10.67,0:51:12.45,Default,,0,0,0,,虽然从语法上看起来是递归的
Dialogue: 0,0:51:13.20,0:51:15.69,Default,,0,0,0,,但实际上是迭代的
Dialogue: 0,0:51:15.87,0:51:17.24,Default,,0,0,0,,可以在常量空间中运行
Dialogue: 0,0:51:18.40,0:51:19.75,Default,,0,0,0,,我不知道这么说是否打消了你们的疑虑
Dialogue: 0,0:51:19.75,0:51:21.23,Default,,0,0,0,,但至少让你们知道发生了什么
Dialogue: 0,0:51:21.23,0:51:22.81,Default,,0,0,0,,这其中没有任何构造
Dialogue: 0,0:51:25.91,0:51:27.58,Default,,0,0,0,,但你也会说 这里面还是有一些构造
Dialogue: 0,0:51:27.98,0:51:30.08,Default,,0,0,0,,从原则上来说 我们也构造了环境框架
Dialogue: 0,0:51:31.71,0:51:32.37,Default,,0,0,0,,答案则是
Dialogue: 0,0:51:32.40,0:51:33.84,Default,,0,0,0,,你确实需要构建这些环境框架
Dialogue: 0,0:51:33.84,0:51:35.26,Default,,0,0,0,,但是 等你求值完毕后
Dialogue: 0,0:51:35.42,0:51:36.19,Default,,0,0,0,,不必保留它们
Dialogue: 0,0:51:36.44,0:51:37.61,Default,,0,0,0,,它们可以被废料收集
Dialogue: 0,0:51:37.92,0:51:39.47,Default,,0,0,0,,这些空间也可以被自动地重用
Dialogue: 0,0:51:40.72,0:51:42.99,Default,,0,0,0,,但你们可以看到求值器控制流
Dialogue: 0,0:51:43.25,0:51:46.12,Default,,0,0,0,,的中心思想就是进行归约
Dialogue: 0,0:51:47.02,0:51:49.29,Default,,0,0,0,,因此这些过程实际上是迭代过程
Dialogue: 0,0:51:50.13,0:51:51.38,Default,,0,0,0,,好吧 有什么问题么？
Dialogue: 0,0:52:02.68,0:52:03.23,Default,,0,0,0,,好吧 课件休息吧
Dialogue: 0,0:52:04.12,0:52:24.56,Default,,0,0,0,,[音乐]
Dialogue: 0,0:52:24.60,0:52:29.69,Declare,,0,0,0,,{\an2\fad(500,500)}《计算机程序的构造和解释》
Dialogue: 0,0:52:35.20,0:52:38.36,Declare,,0,0,0,,{\an2\fad(500,500)}讲师： 哈罗德·艾伯森教授 及 格兰德·杰·萨斯曼教授
Dialogue: 0,0:52:38.36,0:52:42.14,Declare,,0,0,0,,{\an2\fad(500,500)}《计算机程序的构造和解释》
Dialogue: 0,0:52:42.14,0:52:46.44,Declare,,0,0,0,,{\an2\fad(500,500)}显示控制求值器
Dialogue: 0,0:52:48.77,0:52:51.55,Default,,0,0,0,,教授：跟迭代过程形成对比的是
Dialogue: 0,0:52:52.77,0:52:54.89,Default,,0,0,0,,确实会占用空间的
Dialogue: 0,0:52:55.12,0:52:56.14,Default,,0,0,0,,递归过程
Dialogue: 0,0:52:56.17,0:52:57.29,Default,,0,0,0,,你们可以看到其中的区别
Dialogue: 0,0:52:58.03,0:53:01.20,Default,,0,0,0,,让我们来看看递归式阶乘的求值
Dialogue: 0,0:53:02.65,0:53:05.53,Default,,0,0,0,,这里的FACT-REC
Dialogue: 0,0:53:05.55,0:53:07.22,Default,,0,0,0,,就是阶乘的标准定义
Dialogue: 0,0:53:07.22,0:53:10.01,Default,,0,0,0,,这个当然是一个递归过程
Dialogue: 0,0:53:10.01,0:53:12.57,Default,,0,0,0,,它的计算过程也是递归的
Dialogue: 0,0:53:13.75,0:53:16.56,Default,,0,0,0,,然后 只要把它和我们开始的方式联系起来
Dialogue: 0,0:53:16.83,0:53:20.53,Default,,0,0,0,,我们会通过代换模型发现
Dialogue: 0,0:53:20.53,0:53:21.82,Default,,0,0,0,,这是一个递归过程
Dialogue: 0,0:53:22.36,0:53:28.00,Default,,0,0,0,,因为 如果我调用(REC-FACT 5)
Dialogue: 0,0:53:30.45,0:53:34.94,Default,,0,0,0,,会变成(* 5
Dialogue: 0,0:53:36.28,0:53:37.82,Default,,0,0,0,,哦 这里是FACT-REC
Dialogue: 0,0:53:42.62,0:53:47.93,Default,,0,0,0,,(* 5 (FACT-REC 4))
Dialogue: 0,0:53:49.66,0:53:58.22,Default,,0,0,0,,又会变成(* 5 (* 4 (FACT-REC 3)))
Dialogue: 0,0:54:00.22,0:54:08.60,Default,,0,0,0,,又会变成(* 5 (* 4 (* 3 (* ...
Dialogue: 0,0:54:13.45,0:54:15.31,Default,,0,0,0,,以此类推
Dialogue: 0,0:54:15.39,0:54:17.39,Default,,0,0,0,,关键点就是 有一条链条被不断构造出来
Dialogue: 0,0:54:18.10,0:54:20.06,Default,,0,0,0,,这就在代换模型中证明了
Dialogue: 0,0:54:20.08,0:54:21.28,Default,,0,0,0,,FACT-REC是递归的
Dialogue: 0,0:54:21.52,0:54:24.18,Default,,0,0,0,,现在 让我们来看看这条构造起来的链条
Dialogue: 0,0:54:24.18,0:54:25.29,Default,,0,0,0,,它又是在机器中的什么地方？
Dialogue: 0,0:54:27.68,0:54:29.95,Default,,0,0,0,,好吧 让我们想象一下要从哪里开始
Dialogue: 0,0:54:30.44,0:54:40.01,Default,,0,0,0,,我们告诉机器 求值(FACT-REC 5)
Dialogue: 0,0:54:41.45,0:54:43.39,Default,,0,0,0,,基于的环境是E0
Dialogue: 0,0:54:45.08,0:54:48.97,Default,,0,0,0,,也就是定义FACT-REC时的环境
Dialogue: 0,0:54:49.55,0:54:51.23,Default,,0,0,0,,现在 我们知道最终要发生什么
Dialogue: 0,0:54:52.25,0:54:53.64,Default,,0,0,0,,首先
Dialogue: 0,0:54:53.92,0:54:55.64,Default,,0,0,0,,它会对这些东西求值
Dialogue: 0,0:54:55.68,0:54:56.99,Default,,0,0,0,,发现它是一个过程
Dialogue: 0,0:54:57.18,0:55:00.16,Default,,0,0,0,,在这里创建一个新环境E1
Dialogue: 0,0:55:00.88,0:55:03.69,Default,,0,0,0,,其中N=5
Dialogue: 0,0:55:04.33,0:55:06.54,Default,,0,0,0,,并且与E0相连
Dialogue: 0,0:55:07.80,0:55:08.97,Default,,0,0,0,,这个E0也就是
Dialogue: 0,0:55:08.99,0:55:12.30,Default,,0,0,0,,定义FACT-REC的那个环境
Dialogue: 0,0:55:14.11,0:55:15.74,Default,,0,0,0,,然后 在E1这个环境中
Dialogue: 0,0:55:15.76,0:55:17.48,Default,,0,0,0,,求值过程的体
Dialogue: 0,0:55:19.67,0:55:25.92,Default,,0,0,0,,因此 在这里求值会归约为
Dialogue: 0,0:55:27.00,0:55:28.92,Default,,0,0,0,,在E1中求值过程的体
Dialogue: 0,0:55:30.16,0:55:31.34,Default,,0,0,0,,这就需要求值IF语句
Dialogue: 0,0:55:32.17,0:55:33.53,Default,,0,0,0,,而我不会讲解IF语句的细节
Dialogue: 0,0:55:33.53,0:55:34.88,Default,,0,0,0,,IF语句会求值谓词
Dialogue: 0,0:55:34.88,0:55:37.53,Default,,0,0,0,,最后发现需要求值ELSE子句
Dialogue: 0,0:55:37.84,0:55:40.41,Default,,0,0,0,,因此 这里的整个部分 会归约为
Dialogue: 0,0:55:41.30,0:55:45.53,Default,,0,0,0,,FACT-REC的ELSE子句
Dialogue: 0,0:55:45.82,0:55:46.97,Default,,0,0,0,,也就是谓词为假的部分
Dialogue: 0,0:55:47.23,0:55:51.16,Default,,0,0,0,,整个表达式就归约为了(* N
Dialogue: 0,0:55:53.07,0:55:59.96,Default,,0,0,0,,(FACT-REC (- N 1))
Dialogue: 0,0:56:03.48,0:56:05.55,Default,,0,0,0,,求值的环境是E1
Dialogue: 0,0:56:08.38,0:56:10.91,Default,,0,0,0,,因此 最初的表达式现在就会归约为
Dialogue: 0,0:56:11.04,0:56:12.52,Default,,0,0,0,,求值这样的一个表达式
Dialogue: 0,0:56:13.75,0:56:16.28,Default,,0,0,0,,而现在 我们面对的是一个应用
Dialogue: 0,0:56:16.28,0:56:17.63,Default,,0,0,0,,我们之前求值过应用
Dialogue: 0,0:56:18.22,0:56:20.25,Default,,0,0,0,,还记得要怎么求值应用么？
Dialogue: 0,0:56:20.36,0:56:21.69,Default,,0,0,0,,正式求值一个应用之前
Dialogue: 0,0:56:21.74,0:56:24.81,Default,,0,0,0,,你需要把CONTINUE寄存器的值保存在栈上
Dialogue: 0,0:56:25.35,0:56:27.18,Default,,0,0,0,,此时 栈上会有一个值'DONE
Dialogue: 0,0:56:29.98,0:56:32.88,Default,,0,0,0,,接下来 你要为求值子部分做准备
Dialogue: 0,0:56:35.00,0:56:37.20,Default,,0,0,0,,因此 我们在这里开始求值子部分
Dialogue: 0,0:56:39.47,0:56:41.45,Default,,0,0,0,,首先要做的是求值运算符
Dialogue: 0,0:56:44.60,0:56:46.32,Default,,0,0,0,,运算符是怎样求值的呢？
Dialogue: 0,0:56:47.25,0:56:48.99,Default,,0,0,0,,我们通过一些手段
Dialogue: 0,0:56:49.00,0:56:51.04,Default,,0,0,0,,将EXP寄存器指向运算符对应的过程
Dialogue: 0,0:56:51.48,0:56:53.15,Default,,0,0,0,,并且让ENV寄存器指向求值的环境
Dialogue: 0,0:56:53.66,0:56:54.60,Default,,0,0,0,,而把CONTINUE寄存器赋值为
Dialogue: 0,0:56:54.62,0:56:56.22,Default,,0,0,0,,用于求值参数的EVAL-ARGS
Dialogue: 0,0:56:56.59,0:56:57.37,Default,,0,0,0,,并且 我们把
Dialogue: 0,0:56:57.40,0:56:59.29,Default,,0,0,0,,CONTINUE的原始值保存在栈上
Dialogue: 0,0:56:59.52,0:57:01.02,Default,,0,0,0,,我们完成所有工作后 就会跳转到这个地方
Dialogue: 0,0:57:01.72,0:57:02.86,Default,,0,0,0,,在我们求值完运算符后
Dialogue: 0,0:57:03.58,0:57:05.80,Default,,0,0,0,,需要做的则是
Dialogue: 0,0:57:05.90,0:57:07.66,Default,,0,0,0,,求值对实际参数进行求值
Dialogue: 0,0:57:07.69,0:57:12.01,Default,,0,0,0,,也就是这个环境和这些参数
Dialogue: 0,0:57:12.14,0:57:13.44,Default,,0,0,0,,这些尚未求值的实际参数
Dialogue: 0,0:57:14.20,0:57:15.62,Default,,0,0,0,,它们现在都还在栈上
Dialogue: 0,0:57:15.62,0:57:18.59,Default,,0,0,0,,我们现在就要先来求值运算符
Dialogue: 0,0:57:23.26,0:57:26.73,Default,,0,0,0,,当我们从这个调用返回时
Dialogue: 0,0:57:26.92,0:57:28.64,Default,,0,0,0,,在这里 我们将要去调用EVAL-DISPATCH
Dialogue: 0,0:57:29.38,0:57:30.83,Default,,0,0,0,,当我们从这个调用返回时
Dialogue: 0,0:57:31.45,0:57:32.70,Default,,0,0,0,,这个运算符所对应的值
Dialogue: 0,0:57:32.73,0:57:33.52,Default,,0,0,0,,在本例中
Dialogue: 0,0:57:33.55,0:57:35.44,Default,,0,0,0,,也就是基本的乘法过程
Dialogue: 0,0:57:36.44,0:57:37.93,Default,,0,0,0,,会存放在FUN寄存器中
Dialogue: 0,0:57:43.02,0:57:44.53,Default,,0,0,0,,我们要去求值实际参数
Dialogue: 0,0:57:44.53,0:57:45.85,Default,,0,0,0,,现在这里求值N
Dialogue: 0,0:57:47.73,0:57:49.87,Default,,0,0,0,,本例中 会返回5
Dialogue: 0,0:57:50.25,0:57:52.04,Default,,0,0,0,,然后我们会把它放入ARGL寄存器
Dialogue: 0,0:57:53.00,0:57:55.88,Default,,0,0,0,,然后我们会去求值第二个运算对象
Dialogue: 0,0:57:57.46,0:58:00.48,Default,,0,0,0,,就在我们准备求值第二个运算对象之时
Dialogue: 0,0:58:00.52,0:58:02.19,Default,,0,0,0,,我会省略计算
Dialogue: 0,0:58:02.20,0:58:03.58,Default,,0,0,0,,(- N 1)之类的细节
Dialogue: 0,0:58:03.71,0:58:05.88,Default,,0,0,0,,但是 当我们去求值第二个运算对象时
Dialogue: 0,0:58:06.62,0:58:10.44,Default,,0,0,0,,会最终归约为对FACT-REC的另一个调用
Dialogue: 0,0:58:12.00,0:58:14.20,Default,,0,0,0,,现在 我们在栈上有
Dialogue: 0,0:58:16.52,0:58:19.94,Default,,0,0,0,,来自于这个组合式的运算符
Dialogue: 0,0:58:20.12,0:58:21.07,Default,,0,0,0,,以及其它的参数
Dialogue: 0,0:58:23.40,0:58:27.61,Default,,0,0,0,,现在 我们已经准备好
Dialogue: 0,0:58:28.49,0:58:29.69,Default,,0,0,0,,去调用另外的FACT-REC了
Dialogue: 0,0:58:30.20,0:58:31.43,Default,,0,0,0,,而让我们完成了这个调用以后
Dialogue: 0,0:58:31.56,0:58:33.64,Default,,0,0,0,,我们就要跳转到ACCUMULATE-LAST-ARG
Dialogue: 0,0:58:34.12,0:58:35.20,Default,,0,0,0,,还记得这是做什么的么？
Dialogue: 0,0:58:35.20,0:58:35.93,Default,,0,0,0,,它会说
Dialogue: 0,0:58:36.45,0:58:39.28,Default,,0,0,0,,我们会把这个调用的结果
Dialogue: 0,0:58:39.28,0:58:40.40,Default,,0,0,0,,和这个5相乘
Dialogue: 0,0:58:41.69,0:58:42.38,Default,,0,0,0,,但是请注意
Dialogue: 0,0:58:42.73,0:58:44.81,Default,,0,0,0,,我们现在处于另一个递归阶乘中
Dialogue: 0,0:58:45.72,0:58:48.92,Default,,0,0,0,,我们又要再次调用EVAL-DISPATCH
Dialogue: 0,0:58:49.32,0:58:50.60,Default,,0,0,0,,然而我们并没有真正地“归约”它
Dialogue: 0,0:58:50.64,0:58:52.08,Default,,0,0,0,,因为现在栈上还有东西
Dialogue: 0,0:58:53.70,0:58:55.39,Default,,0,0,0,,栈上的这些东西说：“当你返回时”
Dialogue: 0,0:58:55.40,0:58:57.52,Default,,0,0,0,,你最好把结果和放在这里的5相乘
Dialogue: 0,0:58:58.43,0:59:05.77,Default,,0,0,0,,所以当我们进行另外的调用
Dialogue: 0,0:59:07.12,0:59:08.84,Default,,0,0,0,,求值(- N 1)
Dialogue: 0,0:59:09.30,0:59:11.05,Default,,0,0,0,,这会返回给我们另一个环境
Dialogue: 0,0:59:11.25,0:59:13.84,Default,,0,0,0,,其中N的新值为4
Dialogue: 0,0:59:14.60,0:59:16.22,Default,,0,0,0,,然后又将调用EVAL-DISPATCH
Dialogue: 0,0:59:19.20,0:59:20.22,Default,,0,0,0,,我们又创建了另一个调用
Dialogue: 0,0:59:21.35,0:59:24.44,Default,,0,0,0,,这个4又会遇到相同的情况
Dialogue: 0,0:59:26.04,0:59:28.62,Default,,0,0,0,,我们最后会遇到对(FACT-REC N)的又一次调用
Dialogue: 0,0:59:30.02,0:59:32.68,Default,,0,0,0,,而这时候 栈上会有从最初的调用
Dialogue: 0,0:59:32.88,0:59:34.51,Default,,0,0,0,,到最近一次调用的东西
Dialogue: 0,0:59:35.36,0:59:36.91,Default,,0,0,0,,它们都在等待同一个东西
Dialogue: 0,0:59:36.91,0:59:39.16,Default,,0,0,0,,它们都要跳转到ACCUMULATE-LAST-ARG
Dialogue: 0,0:59:40.51,0:59:42.94,Default,,0,0,0,,当然 当我们进行第四次调用时
Dialogue: 0,0:59:43.25,0:59:44.38,Default,,0,0,0,,会发生同样的事
Dialogue: 0,0:59:45.64,0:59:47.07,Default,,0,0,0,,如此往复
Dialogue: 0,0:59:47.30,0:59:48.60,Default,,0,0,0,,在这里 你在栈上看到的
Dialogue: 0,0:59:50.30,0:59:52.22,Default,,0,0,0,,栈上面实际存放的是
Dialogue: 0,0:59:52.22,0:59:54.59,Default,,0,0,0,,基本过程*以及5
Dialogue: 0,0:59:54.96,0:59:56.40,Default,,0,0,0,,而你要把它用来
Dialogue: 0,0:59:56.59,0:59:58.54,Default,,0,0,0,,调用ACCUMULATE-LAST-ARG
Dialogue: 0,1:00:00.47,1:00:02.01,Default,,0,0,0,,就是这样 对吧？
Dialogue: 0,1:00:02.01,1:00:04.75,Default,,0,0,0,,这跟它们在表达式中的顺序是一致的
Dialogue: 0,1:00:05.65,1:00:10.65,Default,,0,0,0,,实际上 你将要应用的运算符
Dialogue: 0,1:00:11.72,1:00:14.30,Default,,0,0,0,,以及当你返回时
Dialogue: 0,1:00:14.32,1:00:15.79,Default,,0,0,0,,需要去求积的参数
Dialogue: 0,1:00:15.80,1:00:16.91,Default,,0,0,0,,以及这里的括号
Dialogue: 0,1:00:16.94,1:00:18.96,Default,,0,0,0,,都在告诉你 在对它们进行积累
Dialogue: 0,1:00:19.62,1:00:21.88,Default,,0,0,0,,因此 你可以看到代换模型并不是这样的谎言
Dialogue: 0,1:00:22.56,1:00:23.63,Default,,0,0,0,,从某种意义上来说 它实际上是
Dialogue: 0,1:00:23.64,1:00:25.31,Default,,0,0,0,,存在于栈上的那些东西
Dialogue: 0,1:00:29.37,1:00:30.40,Default,,0,0,0,,好吧 从某种意义上来说
Dialogue: 0,1:00:30.81,1:00:32.48,Default,,0,0,0,,应该给你们解释了
Dialogue: 0,1:00:33.26,1:00:34.52,Default,,0,0,0,,或者 至少让你们相信
Dialogue: 0,1:00:35.93,1:00:38.72,Default,,0,0,0,,求值器会通过某些方式
Dialogue: 0,1:00:40.06,1:00:42.86,Default,,0,0,0,,迭代地去求值某些过程
Dialogue: 0,1:00:42.95,1:00:44.25,Default,,0,0,0,,而递归地去求值另外的过程
Dialogue: 0,1:00:45.26,1:00:47.45,Default,,0,0,0,,尽管从语法上看
Dialogue: 0,1:00:47.45,1:00:49.05,Default,,0,0,0,,它们都是递归过程
Dialogue: 0,1:00:49.40,1:00:50.64,Default,,0,0,0,,它又是如何做到的呢？
Dialogue: 0,1:00:50.66,1:00:53.72,Default,,0,0,0,,其中的基本原因就是
Dialogue: 0,1:00:53.80,1:00:55.68,Default,,0,0,0,,求值器被设置为
Dialogue: 0,1:00:56.04,1:00:59.26,Default,,0,0,0,,只保存那些稍后会用到的东西
Dialogue: 0,1:01:01.09,1:01:04.25,Default,,0,0,0,,比如说 当你在把
Dialogue: 0,1:01:04.67,1:01:07.39,Default,,0,0,0,,在一个环境中求值表达式归约为
Dialogue: 0,1:01:07.87,1:01:09.87,Default,,0,0,0,,将某个过程应用在参数上时
Dialogue: 0,1:01:10.52,1:01:12.49,Default,,0,0,0,,它就不再需要最初的环境了
Dialogue: 0,1:01:13.37,1:01:16.65,Default,,0,0,0,,因为所需要的环境信息都被打包到
Dialogue: 0,1:01:17.88,1:01:19.36,Default,,0,0,0,,需要应用的那个过程中了
Dialogue: 0,1:01:20.75,1:01:21.61,Default,,0,0,0,,同样 类似地
Dialogue: 0,1:01:21.63,1:01:23.65,Default,,0,0,0,,当你求值一个参数表时
Dialogue: 0,1:01:23.65,1:01:25.20,Default,,0,0,0,,当你完成对表的求值时
Dialogue: 0,1:01:25.91,1:01:28.03,Default,,0,0,0,,当你求值完最后一个参数时
Dialogue: 0,1:01:28.20,1:01:31.61,Default,,0,0,0,,你就不再需要这个参数表了 对吧？
Dialogue: 0,1:01:31.63,1:01:32.94,Default,,0,0,0,,你也就不再需要
Dialogue: 0,1:01:33.04,1:01:34.64,Default,,0,0,0,,求值这些参数所需的环境了
Dialogue: 0,1:01:36.69,1:01:40.89,Default,,0,0,0,,所以这个解释器如此“智能”的根本原因
Dialogue: 0,1:01:40.89,1:01:42.88,Default,,0,0,0,,根本不是因为它“智能” 只是因为它老实
Dialogue: 0,1:01:43.05,1:01:45.74,Default,,0,0,0,,它的原则就是：“只保存那些需要的”
Dialogue: 0,1:01:48.70,1:01:51.00,Default,,0,0,0,,这里 让我来给你们展示
Dialogue: 0,1:01:53.07,1:01:57.20,Default,,0,0,0,,这是致使尾递归的根本原因
Dialogue: 0,1:01:58.31,1:02:00.20,Default,,0,0,0,,要记住 (RESOTRE CONTINUE)这条代码
Dialogue: 0,1:02:00.22,1:02:06.94,Default,,0,0,0,,它指的是 当我去求值过程体的时候
Dialogue: 0,1:02:08.96,1:02:11.00,Default,,0,0,0,,我应该告诉EVAL返回到
Dialogue: 0,1:02:11.25,1:02:12.54,Default,,0,0,0,,最初的求值
Dialogue: 0,1:02:12.54,1:02:14.25,Default,,0,0,0,,应该返回的地方
Dialogue: 0,1:02:15.17,1:02:15.95,Default,,0,0,0,,因此 从某种角度来说
Dialogue: 0,1:02:16.17,1:02:18.84,Default,,0,0,0,,你想知道是哪一行代码致使了尾递归
Dialogue: 0,1:02:18.89,1:02:19.44,Default,,0,0,0,,那么就是这一行
Dialogue: 0,1:02:19.92,1:02:21.53,Default,,0,0,0,,出于某些奇怪的原因
Dialogue: 0,1:02:21.77,1:02:24.80,Default,,0,0,0,,如果我想构建一个没有尾递归的求值器
Dialogue: 0,1:02:25.69,1:02:26.86,Default,,0,0,0,,我需要做的就是
Dialogue: 0,1:02:27.12,1:02:29.29,Default,,0,0,0,,在这里先不要去恢复CONTINUE
Dialogue: 0,1:02:30.06,1:02:31.66,Default,,0,0,0,,而是在这里建立一个标号
Dialogue: 0,1:02:32.75,1:02:36.25,Default,,0,0,0,,用来标识完成过程应用后的返回位置
Dialogue: 0,1:02:37.64,1:02:39.71,Default,,0,0,0,,而我会把CONTINUE设置为这个标号
Dialogue: 0,1:02:39.92,1:02:41.21,Default,,0,0,0,,然后跳转到EVAL-DISPATCH
Dialogue: 0,1:02:41.40,1:02:43.21,Default,,0,0,0,,然后EVAL-DISPATCH会回到这里
Dialogue: 0,1:02:43.79,1:02:44.30,Default,,0,0,0,,而这时
Dialogue: 0,1:02:44.32,1:02:45.28,Default,,0,0,0,,我会恢复CONTINUE
Dialogue: 0,1:02:45.29,1:02:46.52,Default,,0,0,0,,并回到最初的返回位置
Dialogue: 0,1:02:47.92,1:02:51.00,Default,,0,0,0,,因此 这里唯一的后果就是
Dialogue: 0,1:02:51.15,1:02:52.68,Default,,0,0,0,,解释器不再是尾递归的了
Dialogue: 0,1:02:52.84,1:02:54.62,Default,,0,0,0,,它会给你完全相同的答案
Dialogue: 0,1:02:54.72,1:02:57.02,Default,,0,0,0,,只是当你执行迭代式阶乘
Dialogue: 0,1:02:57.05,1:02:58.36,Default,,0,0,0,,或者其它迭代过程时
Dialogue: 0,1:02:58.60,1:02:59.80,Default,,0,0,0,,它都会递归地去执行
Dialogue: 0,1:03:03.04,1:03:05.40,Default,,0,0,0,,然而 我对你们撒了一个小谎
Dialogue: 0,1:03:05.76,1:03:06.99,Default,,0,0,0,,因为我演示的
Dialogue: 0,1:03:07.02,1:03:08.33,Default,,0,0,0,,一个有些过于简化的解释器
Dialogue: 0,1:03:08.72,1:03:10.38,Default,,0,0,0,,这个解释器假设每个过程
Dialogue: 0,1:03:11.36,1:03:13.66,Default,,0,0,0,,只含有一条表达式
Dialogue: 0,1:03:13.89,1:03:14.54,Default,,0,0,0,,还记得吗 通常来说
Dialogue: 0,1:03:14.56,1:03:16.57,Default,,0,0,0,,过程的体是多条表达式组成的序列
Dialogue: 0,1:03:17.87,1:03:20.49,Default,,0,0,0,,所以没有什么新概念
Dialogue: 0,1:03:20.49,1:03:22.28,Default,,0,0,0,,让我来展示一下实际的求值器
Dialogue: 0,1:03:22.89,1:03:24.73,Default,,0,0,0,,是怎么来处理表达式序列的
Dialogue: 0,1:03:28.47,1:03:29.74,Default,,0,0,0,,这是现在的COMPOUND-APPLY
Dialogue: 0,1:03:29.74,1:03:31.31,Default,,0,0,0,,和之前的唯一不同是
Dialogue: 0,1:03:32.07,1:03:34.33,Default,,0,0,0,,它不再直接地跳转到EVAL
Dialogue: 0,1:03:35.98,1:03:38.03,Default,,0,0,0,,它先获取整个过程的体
Dialogue: 0,1:03:38.03,1:03:40.15,Default,,0,0,0,,在本例中 也就是表达式序列
Dialogue: 0,1:03:40.28,1:03:41.71,Default,,0,0,0,,然后跳转到EVAL-SEQUENCE
Dialogue: 0,1:03:42.60,1:03:45.32,Default,,0,0,0,,EVAL-SEQUENCE是一个小型的循环
Dialogue: 0,1:03:46.83,1:03:49.98,Default,,0,0,0,,然后每次求值一条表达式
Dialogue: 0,1:03:52.63,1:03:53.85,Default,,0,0,0,,就是这样来求值的--
Dialogue: 0,1:03:53.90,1:03:54.94,Default,,0,0,0,,当它求值完一条表达式后
Dialogue: 0,1:03:54.97,1:03:56.86,Default,,0,0,0,,会跳转到这里 去求值下一条
Dialogue: 0,1:03:58.44,1:03:59.29,Default,,0,0,0,,当我完成了所有的求值后
Dialogue: 0,1:03:59.29,1:04:01.02,Default,,0,0,0,,我想要跳转到LAST-EXP
Dialogue: 0,1:04:01.31,1:04:03.28,Default,,0,0,0,,我就只需要恢复CONTINUE寄存器
Dialogue: 0,1:04:03.92,1:04:05.28,Default,,0,0,0,,然后跳转到EVAL-DISPATCH
Dialogue: 0,1:04:06.41,1:04:08.20,Default,,0,0,0,,同样的 如果你想要在这种求值器中
Dialogue: 0,1:04:08.20,1:04:10.35,Default,,0,0,0,,破坏尾递归机制
Dialogue: 0,1:04:10.64,1:04:13.71,Default,,0,0,0,,你只需要在LAST-EXP中不做特殊处理即可
Dialogue: 0,1:04:14.90,1:04:17.34,Default,,0,0,0,,也就是说 当你处理完最后一条表达式
Dialogue: 0,1:04:17.36,1:04:18.65,Default,,0,0,0,,你跳转到另外一个地方
Dialogue: 0,1:04:19.15,1:04:20.68,Default,,0,0,0,,在那个地方去恢复CONTINUE
Dialogue: 0,1:04:21.90,1:04:23.26,Default,,0,0,0,,出于某些原因
Dialogue: 0,1:04:23.26,1:04:25.74,Default,,0,0,0,,很多Lisp求值器倾向于这么做
Dialogue: 0,1:04:26.55,1:04:28.44,Default,,0,0,0,,这样做的后果就是
Dialogue: 0,1:04:28.86,1:04:30.72,Default,,0,0,0,,迭代式过程也会使栈增长
Dialogue: 0,1:04:31.88,1:04:33.61,Default,,0,0,0,,还不清楚为什么会这样
Dialogue: 0,1:04:35.92,1:04:37.98,Default,,0,0,0,,好吧 我稍微来总结一下
Dialogue: 0,1:04:38.09,1:04:39.60,Default,,0,0,0,,毕竟这是一个大程序
Dialogue: 0,1:04:39.98,1:04:41.04,Default,,0,0,0,,又有很多细节
Dialogue: 0,1:04:41.12,1:04:42.25,Default,,0,0,0,,但关键点就是
Dialogue: 0,1:04:43.04,1:04:43.87,Default,,0,0,0,,从概念上来说
Dialogue: 0,1:04:44.04,1:04:46.08,Default,,0,0,0,,这跟翻译其它程序没什么不同
Dialogue: 0,1:04:47.06,1:04:48.06,Default,,0,0,0,,核心思想就是
Dialogue: 0,1:04:48.06,1:04:50.28,Default,,0,0,0,,我们已经有了通用求值器程序
Dialogue: 0,1:04:50.33,1:04:51.71,Default,,0,0,0,,一个元循环求值器
Dialogue: 0,1:04:51.87,1:04:53.07,Default,,0,0,0,,如果我们把它翻译为了Lisp
Dialogue: 0,1:04:53.10,1:04:53.95,Default,,0,0,0,,那么我们就有了Lisp的所有东西
Dialogue: 0,1:04:54.33,1:04:55.15,Default,,0,0,0,,我们就是这么来做的
Dialogue: 0,1:04:57.98,1:04:59.68,Default,,0,0,0,,第二点则是 魔法消失了
Dialogue: 0,1:04:59.68,1:05:01.97,Default,,0,0,0,,这整个系统不再神秘了 对吧？
Dialogue: 0,1:05:01.97,1:05:07.79,Default,,0,0,0,,原则上来说 这应该相当清楚了
Dialogue: 0,1:05:07.82,1:05:10.08,Default,,0,0,0,,只是还不太了解表结构的内存管理
Dialogue: 0,1:05:10.80,1:05:11.80,Default,,0,0,0,,我们后面会讲
Dialogue: 0,1:05:12.64,1:05:14.20,Default,,0,0,0,,这也并不困难
Dialogue: 0,1:05:15.45,1:05:16.35,Default,,0,0,0,,第三点就是
Dialogue: 0,1:05:16.35,1:05:17.52,Default,,0,0,0,,所有的这些尾递归
Dialogue: 0,1:05:18.24,1:05:21.96,Default,,0,0,0,,来自于严格的求值纪律
Dialogue: 0,1:05:22.55,1:05:24.51,Default,,0,0,0,,也就是只保存那些后面会用到的东西
Dialogue: 0,1:05:25.87,1:05:27.72,Default,,0,0,0,,而不是一些比较随意的原则
Dialogue: 0,1:05:27.76,1:05:29.86,Default,,0,0,0,,比如 无论什么时候我们调用一个子过程
Dialogue: 0,1:05:29.86,1:05:32.16,Default,,0,0,0,,我们会保存所有的寄存器并且返回
Dialogue: 0,1:05:33.94,1:05:36.49,Default,,0,0,0,,有些时候为了提效 这样做很值得
Dialogue: 0,1:05:37.15,1:05:39.96,Default,,0,0,0,,当你研究求值机器的内部原理时
Dialogue: 0,1:05:40.45,1:05:42.56,Default,,0,0,0,,这类东西就很值得去研究
Dialogue: 0,1:05:42.56,1:05:43.96,Default,,0,0,0,,因为它会带来显著的不同
Dialogue: 0,1:05:45.23,1:05:47.69,Default,,0,0,0,,我想现在基本上已经
Dialogue: 0,1:05:47.90,1:05:52.30,Default,,0,0,0,,把这个求值器讲得很清楚了
Dialogue: 0,1:05:52.56,1:05:53.90,Default,,0,0,0,,我希望你们能相信
Dialogue: 0,1:05:54.32,1:05:56.27,Default,,0,0,0,,真的有人能够
Dialogue: 0,1:05:56.84,1:05:58.56,Default,,0,0,0,,将一个Lisp求值器放在掌心之中
Dialogue: 0,1:05:59.07,1:06:00.49,Default,,0,0,0,,为了让你们死心塌地
Dialogue: 0,1:06:00.80,1:06:01.96,Default,,0,0,0,,我给你们看一个Lisp求值器
Dialogue: 0,1:06:02.54,1:06:04.06,Default,,0,0,0,,它就在我的手掌中
Dialogue: 0,1:06:06.16,1:06:10.56,Default,,0,0,0,,这块求值器芯片实际上
Dialogue: 0,1:06:10.89,1:06:13.70,Default,,0,0,0,,比我给你们展示的求值器还要复杂
Dialogue: 0,1:06:16.86,1:06:19.20,Default,,0,0,0,,这张图片效果更好
Dialogue: 0,1:06:22.07,1:06:22.57,Default,,0,0,0,,在这上面
Dialogue: 0,1:06:22.60,1:06:24.38,Default,,0,0,0,,你可以看到相同的宏观结构
Dialogue: 0,1:06:24.73,1:06:25.93,Default,,0,0,0,,这是寄存器阵列
Dialogue: 0,1:06:26.80,1:06:27.71,Default,,0,0,0,,这些是数据通路
Dialogue: 0,1:06:27.72,1:06:29.07,Default,,0,0,0,,这里有是有穷状态控制器
Dialogue: 0,1:06:29.80,1:06:31.04,Default,,0,0,0,,再强调一下 是有穷状态
Dialogue: 0,1:06:31.96,1:06:32.80,Default,,0,0,0,,全都在这里了
Dialogue: 0,1:06:32.81,1:06:34.16,Default,,0,0,0,,在另外的地方还有外部存储
Dialogue: 0,1:06:34.16,1:06:35.23,Default,,0,0,0,,用来存储数据
Dialogue: 0,1:06:35.75,1:06:37.63,Default,,0,0,0,,而这块芯片非常复杂
Dialogue: 0,1:06:37.64,1:06:39.16,Default,,0,0,0,,是因为它尝试更快地运行Lisp
Dialogue: 0,1:06:39.66,1:06:42.97,Default,,0,0,0,,它具有非常非常之快的并行运算
Dialogue: 0,1:06:43.07,1:06:46.32,Default,,0,0,0,,比如说 如果你想要索引一个数组
Dialogue: 0,1:06:46.70,1:06:50.40,Default,,0,0,0,,同时又要检查该索引是否为一个整数
Dialogue: 0,1:06:50.43,1:06:52.86,Default,,0,0,0,,以及该索引没有越界
Dialogue: 0,1:06:53.04,1:06:55.02,Default,,0,0,0,,同时还要进行内存存取
Dialogue: 0,1:06:55.05,1:06:56.70,Default,,0,0,0,,它会同时进行这些事
Dialogue: 0,1:06:57.12,1:06:58.40,Default,,0,0,0,,如果这些操作都没有问题的话
Dialogue: 0,1:06:58.44,1:06:59.96,Default,,0,0,0,,最终就会在这里得到结果
Dialogue: 0,1:07:00.42,1:07:02.46,Default,,0,0,0,,因此 数据通路中大量的
Dialogue: 0,1:07:02.48,1:07:04.65,Default,,0,0,0,,复杂运算使得Lisp能够并行运行
Dialogue: 0,1:07:05.26,1:07:08.41,Default,,0,0,0,,这完全是求值Lisp的
Dialogue: 0,1:07:08.76,1:07:10.36,Default,,0,0,0,,一种无冒险的哲学
Dialogue: 0,1:07:10.64,1:07:13.20,Default,,0,0,0,,并且 这个的微指令也相当复杂
Dialogue: 0,1:07:13.45,1:07:17.56,Default,,0,0,0,,让我先看一看
Dialogue: 0,1:07:17.60,1:07:21.10,Default,,0,0,0,,这其中有大概389条
Dialogue: 0,1:07:21.68,1:07:23.85,Default,,0,0,0,,220比特的微指令
Dialogue: 0,1:07:24.07,1:07:27.94,Default,,0,0,0,,只因为这些数据通路非常复杂
Dialogue: 0,1:07:27.94,1:07:32.25,Default,,0,0,0,,整个芯片大概有89,000支晶体管
Dialogue: 0,1:07:33.56,1:07:36.86,Default,,0,0,0,,好吧 我希望通过这节课解答了大部分疑惑
Dialogue: 0,1:07:37.97,1:07:39.24,Default,,0,0,0,,也许你们想看一看这块芯片
Dialogue: 0,1:07:46.14,1:07:46.89,Default,,0,0,0,,好吧 先讲到这里
Dialogue: 0,1:07:56.46,1:07:56.75,Default,,0,0,0,,有问题吗？
Dialogue: 0,1:07:59.00,1:08:00.42,Default,,0,0,0,,学生：您所讲的 听起来像是
Dialogue: 0,1:08:00.42,1:08:03.48,Default,,0,0,0,,如果把(RESTORE CONTINUE)放在合适的地方
Dialogue: 0,1:08:03.58,1:08:09.42,Default,,0,0,0,,这样之前递归求值的过程
Dialogue: 0,1:08:09.42,1:08:11.95,Default,,0,0,0,,现在就会变成迭代求值的
Dialogue: 0,1:08:12.67,1:08:15.36,Default,,0,0,0,,（意义不明）
Dialogue: 0,1:08:15.60,1:08:17.54,Default,,0,0,0,,教授：我想我应该这么来说
Dialogue: 0,1:08:17.54,1:08:19.82,Default,,0,0,0,,如果把(RESTORE CONTINUE)放在了错误的位置
Dialogue: 0,1:08:20.55,1:08:25.48,Default,,0,0,0,,你就会让那些语法上看起来像递归的过程
Dialogue: 0,1:08:25.52,1:08:27.28,Default,,0,0,0,,在运行的时候不断地扩张栈
Dialogue: 0,1:08:28.64,1:08:30.52,Default,,0,0,0,,但这样是没有原因的
Dialogue: 0,1:08:33.15,1:08:35.12,Default,,0,0,0,,你可以自己去试一试
Dialogue: 0,1:08:35.15,1:08:38.09,Default,,0,0,0,,你可以在COMPOND-APPLY返回后
Dialogue: 0,1:08:38.18,1:08:40.78,Default,,0,0,0,,交换两、三条语句的顺序
Dialogue: 0,1:08:41.31,1:08:43.26,Default,,0,0,0,,那么你得到的就不再是尾递归了
Dialogue: 0,1:08:45.06,1:08:46.14,Default,,0,0,0,,我只是想强调
Dialogue: 0,1:08:46.16,1:08:47.40,Default,,0,0,0,,这其中没有什么魔法
Dialogue: 0,1:08:47.67,1:08:48.57,Default,,0,0,0,,这并不是
Dialogue: 0,1:08:49.31,1:08:52.17,Default,,0,0,0,,有什么智能的预处理程序
Dialogue: 0,1:08:52.65,1:08:55.45,Default,,0,0,0,,它会分析FACT-ITER这个程序
Dialogue: 0,1:08:55.47,1:08:56.73,Default,,0,0,0,,然后说
Dialogue: 0,1:08:57.42,1:08:58.86,Default,,0,0,0,,我注意到
Dialogue: 0,1:08:58.88,1:09:01.13,Default,,0,0,0,,完成这个调用 不需要我进行压栈
Dialogue: 0,1:09:01.13,1:09:02.88,Default,,0,0,0,,但是有些人是这么认为的
Dialogue: 0,1:09:03.76,1:09:05.38,Default,,0,0,0,,而是一种比这个还要蠢的机制
Dialogue: 0,1:09:05.38,1:09:07.50,Default,,0,0,0,,就是在合适的地方插入RESTORE指令
Dialogue: 0,1:09:08.56,1:09:09.79,Default,,0,0,0,,就可以自动地实现
Dialogue: 0,1:09:14.72,1:09:17.55,Default,,0,0,0,,学生：但这不会影响到时间复杂度 对吧？
Dialogue: 0,1:09:17.58,1:09:17.87,Default,,0,0,0,,教授：不会
Dialogue: 0,1:09:18.60,1:09:21.77,Default,,0,0,0,,学生：它不会迭代地处理
Dialogue: 0,1:09:21.80,1:09:23.02,Default,,0,0,0,,而是会递归地处理
Dialogue: 0,1:09:23.02,1:09:27.34,Default,,0,0,0,,但就从完成这两个运算的时间来说
Dialogue: 0,1:09:27.37,1:09:29.22,Default,,0,0,0,,它们都是相同的 对吧？
Dialogue: 0,1:09:29.47,1:09:29.76,Default,,0,0,0,,教授 ：是的
Dialogue: 0,1:09:29.79,1:09:32.68,Default,,0,0,0,,尾递归不会改变任何东西的时间复杂度
Dialogue: 0,1:09:32.72,1:09:33.29,Default,,0,0,0,,因为 从某种意义上来说
Dialogue: 0,1:09:33.34,1:09:35.15,Default,,0,0,0,,两者都是相同的算法
Dialogue: 0,1:09:36.02,1:09:39.37,Default,,0,0,0,,它只是让这个过程迭代地运行
Dialogue: 0,1:09:41.00,1:09:42.64,Default,,0,0,0,,这样 当参数很大时
Dialogue: 0,1:09:42.68,1:09:44.22,Default,,0,0,0,,它不会耗尽所有的内存
Dialogue: 0,1:09:44.75,1:09:46.40,Default,,0,0,0,,因为这其中没有压栈
Dialogue: 0,1:09:48.35,1:09:50.24,Default,,0,0,0,,事实上 你们需要相信
Dialogue: 0,1:09:50.56,1:09:51.13,Default,,0,0,0,,当我们编写--
Dialogue: 0,1:09:51.64,1:09:53.78,Default,,0,0,0,,我们一直把这些代码称作“迭代”
Dialogue: 0,1:09:53.93,1:09:57.99,Default,,0,0,0,,把(DEFINE (LOOP) (LOOP))称作无穷循环
Dialogue: 0,1:10:00.32,1:10:03.36,Default,,0,0,0,,这就是一个迭代
Dialogue: 0,1:10:03.65,1:10:05.66,Default,,0,0,0,,跟我们用DO语句来写无穷循环是一样的
Dialogue: 0,1:10:07.63,1:10:09.28,Default,,0,0,0,,它们只是语法上不同而已
Dialogue: 0,1:10:09.28,1:10:11.32,Default,,0,0,0,,它们实际上都是迭代
Dialogue: 0,1:10:14.73,1:10:16.08,Default,,0,0,0,,它们并不改变时间复杂度
Dialogue: 0,1:10:16.11,1:10:18.53,Default,,0,0,0,,但是它会把它们变成真正的迭代
Dialogue: 0,1:10:21.68,1:10:23.80,Default,,0,0,0,,好吧 下课
Dialogue: 0,1:10:24.25,1:10:40.73,Declare,,0,0,0,,{\fad(500,500)}MIT OpenCourseWare\Nhttp://ocw.mit.edu
Dialogue: 0,1:10:24.25,1:10:40.73,Declare,,0,0,0,,{\an2\fad(500,500)}本项目主页\Nhttps://github.com/DeathKing/Learning-SICP
