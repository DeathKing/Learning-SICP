[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 640
PlayResY: 480

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: EN,Calisto MT,21,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,1,0,2,10,10,30,1
Style: Declare,微软雅黑,30,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,2,0,8,10,10,10,1
Style: staff,微软雅黑,30,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,0,2,5,10,10,10,1
Style: title,微软雅黑,35,&H001D64D9,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,0,1,5,10,10,10,1
Style: Default,雅黑宋体,20,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,1,0,2,10,10,30,1


[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:16.30,0:00:18.08,EN,,0,0,0,,PROFESSOR: Well, I hope you appreciate that we have
Dialogue: 0,0:00:20.01,0:00:22.73,EN,,0,0,0,,we have inducted you into some real magic,
Dialogue: 0,0:00:24.20,0:00:27.24,EN,,0,0,0,,the magic of building languages
Dialogue: 0,0:00:27.42,0:00:28.72,EN,,0,0,0,,really building new languages.
Dialogue: 0,0:00:29.69,0:00:30.40,EN,,0,0,0,,What have we looked at?
Dialogue: 0,0:00:30.43,0:00:32.78,EN,,0,0,0,,We've looked at an Escher picture language.
Dialogue: 0,0:00:38.92,0:00:41.15,EN,,0,0,0,,OK? this language invented by Peter Henderson.
Dialogue: 0,0:00:42.01,0:00:46.49,EN,,0,0,0,,We looked at digital logic language.
Dialogue: 0,0:00:53.16,0:00:55.55,EN,,0,0,0,,Let's see.We've looked at the query language.
Dialogue: 0,0:00:59.70,0:01:00.78,EN,,0,0,0,,And the thing you should realize is,
Dialogue: 0,0:01:00.81,0:01:03.10,EN,,0,0,0,,even though these were toy examples,
Dialogue: 0,0:01:04.70,0:01:07.61,EN,,0,0,0,,they really are the kernels of really useful things.
Dialogue: 0,0:01:08.25,0:01:09.48,EN,,0,0,0,,So, for instance,
Dialogue: 0,0:01:10.12,0:01:11.18,EN,,0,0,0,,the Escher picture language
Dialogue: 0,0:01:11.20,0:01:14.33,EN,,0,0,0,,was taken byHenry Wu, who's a student at MIT,
Dialogue: 0,0:01:14.88,0:01:16.43,EN,,0,0,0,,and developed into a real
Dialogue: 0,0:01:16.97,0:01:19.45,EN,,0,0,0,,language for laying out PC boards,
Dialogue: 0,0:01:20.35,0:01:22.56,EN,,0,0,0,,based just on extending those structures.
Dialogue: 0,0:01:23.24,0:01:24.65,EN,,0,0,0,,And the digital logic language,
Dialogue: 0,0:01:24.68,0:01:26.08,EN,,0,0,0,,Gerry mentioned when he showed it to you,
Dialogue: 0,0:01:26.43,0:01:29.92,EN,,0,0,0,,was really extended to be used as the basis for a simulator
Dialogue: 0,0:01:30.85,0:01:32.96,EN,,0,0,0,,that was used to design a real computer.
Dialogue: 0,0:01:33.46,0:01:34.32,EN,,0,0,0,,And the query language,
Dialogue: 0,0:01:34.35,0:01:36.44,EN,,0,0,0,,of course, is kind of the germ of prolog.
Dialogue: 0,0:01:37.51,0:01:39.07,EN,,0,0,0,,So we built all of these languages,
Dialogue: 0,0:01:39.55,0:01:40.65,EN,,0,0,0,,they're all based on LISP.
Dialogue: 0,0:01:43.63,0:01:44.59,EN,,0,0,0,,A lot of people ask
Dialogue: 0,0:01:45.27,0:01:48.73,EN,,0,0,0,,what particular problems is LISP good for solving for?
Dialogue: 0,0:01:48.75,0:01:49.93,EN,,0,0,0,,The answer is LISP is not...
Dialogue: 0,0:01:50.33,0:01:52.65,EN,,0,0,0,,LISP is not good for solving any particular problems.
Dialogue: 0,0:01:53.53,0:01:54.60,EN,,0,0,0,,What LISP is good for
Dialogue: 0,0:01:54.73,0:01:57.15,EN,,0,0,0,,is constructing within it the right language
Dialogue: 0,0:01:57.18,0:01:58.57,EN,,0,0,0,,to solve the problems you want to solve,
Dialogue: 0,0:01:59.17,0:02:00.44,EN,,0,0,0,,and that's how you should think about it.
Dialogue: 0,0:02:01.47,0:02:03.39,EN,,0,0,0,,So all of these languages were based on LISP.
Dialogue: 0,0:02:04.57,0:02:05.72,EN,,0,0,0,,Now, what's LISP based on?
Dialogue: 0,0:02:06.97,0:02:07.88,EN,,0,0,0,,Where's that come from?
Dialogue: 0,0:02:07.90,0:02:09.40,EN,,0,0,0,,Well, we looked at that too.
Dialogue: 0,0:02:09.58,0:02:16.09,EN,,0,0,0,,We looked at the meta-circular evaluator
Dialogue: 0,0:02:21.53,0:02:23.40,EN,,0,0,0,,the meta-circular evaluator and sort of said
Dialogue: 0,0:02:23.42,0:02:25.76,EN,,0,0,0,,well, LISP is based on LISP.
Dialogue: 0,0:02:25.80,0:02:27.48,EN,,0,0,0,,And when we start looking at that,
Dialogue: 0,0:02:28.27,0:02:29.95,EN,,0,0,0,,we've got to do some real magic, right?
Dialogue: 0,0:02:29.95,0:02:31.74,EN,,0,0,0,,So what does that mean, right?
Dialogue: 0,0:02:31.74,0:02:34.96,EN,,0,0,0,,Y operators, and fixed points,
Dialogue: 0,0:02:35.76,0:02:38.33,EN,,0,0,0,,and the idea that what this means is
Dialogue: 0,0:02:38.36,0:02:41.44,EN,,0,0,0,,that LISP is somehow the fixed-point equation for the
Dialogue: 0,0:02:42.20,0:02:45.42,EN,,0,0,0,,for this funny set of things which are defined in terms of themselves.
Dialogue: 0,0:02:47.40,0:02:48.56,EN,,0,0,0,,Now, it's real magic.
Dialogue: 0,0:02:49.07,0:02:52.35,EN,,0,0,0,,Well, today, for a final piece of magic,
Dialogue: 0,0:02:52.62,0:02:54.03,EN,,0,0,0,,we're going to make all the magic go away.
Dialogue: 0,0:03:06.80,0:03:07.98,EN,,0,0,0,,We already know how to do that.
Dialogue: 0,0:03:09.77,0:03:10.76,EN,,0,0,0,,The idea is, we're going to take
Dialogue: 0,0:03:11.13,0:03:12.73,EN,,0,0,0,,the register machine architecture
Dialogue: 0,0:03:13.36,0:03:15.50,EN,,0,0,0,,and show how to implement LISP on terms of that.
Dialogue: 0,0:03:15.50,0:03:17.93,EN,,0,0,0,,And, remember, the idea of the register machine
Dialogue: 0,0:03:19.60,0:03:24.68,EN,,0,0,0,,is that there's a fixed and finite part of the machine.
Dialogue: 0,0:03:24.72,0:03:26.12,EN,,0,0,0,,There's a finite-state controller,
Dialogue: 0,0:03:26.12,0:03:27.87,EN,,0,0,0,,which dose particular thing
Dialogue: 0,0:03:27.88,0:03:29.31,EN,,0,0,0,,with a particular amount of hardware.
Dialogue: 0,0:03:30.51,0:03:31.74,EN,,0,0,0,,There are particular data paths,
Dialogue: 0,0:03:31.76,0:03:33.24,EN,,0,0,0,,the operation the machine does
Dialogue: 0,0:03:33.55,0:03:35.29,EN,,0,0,0,,And then, in order to implement recursion
Dialogue: 0,0:03:35.53,0:03:37.60,EN,,0,0,0,,and sustain the illusion of infinity,
Dialogue: 0,0:03:37.82,0:03:39.77,EN,,0,0,0,,there's some large amount of memory, which is the stack.
Dialogue: 0,0:03:42.06,0:03:43.72,EN,,0,0,0,,So, if we implement LISP
Dialogue: 0,0:03:43.92,0:03:45.50,EN,,0,0,0,,in terms of a register machine,
Dialogue: 0,0:03:47.02,0:03:48.35,EN,,0,0,0,,then everything ought to become,
Dialogue: 0,0:03:48.40,0:03:49.85,EN,,0,0,0,,at this point,completely concrete.
Dialogue: 0,0:03:49.85,0:03:51.23,EN,,0,0,0,,All the magic should go away.
Dialogue: 0,0:03:51.65,0:03:53.52,EN,,0,0,0,,And, by the end of this talk,
Dialogue: 0,0:03:53.53,0:03:54.78,EN,,0,0,0,,I want you get the feeling
Dialogue: 0,0:03:55.14,0:03:59.05,EN,,0,0,0,,that, as opposed to this very mysterious meta-circular evaluator
Dialogue: 0,0:03:59.67,0:04:02.60,EN,,0,0,0,,that a LISP evaluator really is something that's concrete enough
Dialogue: 0,0:04:02.85,0:04:04.57,EN,,0,0,0,,that you can hold in the palm of your hand.
Dialogue: 0,0:04:04.76,0:04:06.24,EN,,0,0,0,,You should be able to imagine holding
Dialogue: 0,0:04:06.57,0:04:07.90,EN,,0,0,0,,holding a LISP interpreter there.
Dialogue: 0,0:04:09.63,0:04:10.94,EN,,0,0,0,,All right, how are we going to do this?
Dialogue: 0,0:04:10.95,0:04:12.76,EN,,0,0,0,,We already have all the ingredients.
Dialogue: 0,0:04:13.96,0:04:17.45,EN,,0,0,0,,See, what you learned last time from Gerry
Dialogue: 0,0:04:17.60,0:04:21.47,EN,,0,0,0,,is how to take any particular couple of LISP procedures.
Dialogue: 0,0:04:22.60,0:04:24.28,EN,,0,0,0,,and hand-translate them
Dialogue: 0,0:04:24.75,0:04:26.67,EN,,0,0,0,,into something that runs on a register machine.
Dialogue: 0,0:04:28.20,0:04:30.52,EN,,0,0,0,,So, to implement all of LISP on a register machine,
Dialogue: 0,0:04:30.57,0:04:31.44,EN,,0,0,0,,all we have to do
Dialogue: 0,0:04:31.69,0:04:33.45,EN,,0,0,0,,is take the particular procedures
Dialogue: 0,0:04:33.68,0:04:35.42,EN,,0,0,0,,that are the meta-circular evaluator
Dialogue: 0,0:04:36.17,0:04:38.11,EN,,0,0,0,,and hand-translate them for a register machine.
Dialogue: 0,0:04:39.04,0:04:40.25,EN,,0,0,0,,And that does all of LISP
Dialogue: 0,0:04:42.14,0:04:43.00,EN,,0,0,0,,Right? So, in principle,
Dialogue: 0,0:04:43.02,0:04:44.43,EN,,0,0,0,,we already know how to do this.
Dialogue: 0,0:04:45.38,0:04:46.54,EN,,0,0,0,,And, indeed, it's going to be no
Dialogue: 0,0:04:46.68,0:04:48.86,EN,,0,0,0,,no different, in kind,
Dialogue: 0,0:04:50.00,0:04:53.40,EN,,0,0,0,,from in say recursive factorial
Dialogue: 0,0:04:53.42,0:04:54.67,EN,,0,0,0,,or recursive Fibonacci.
Dialogue: 0,0:04:54.67,0:04:56.00,EN,,0,0,0,,It's just bigger and there's more of it.
Dialogue: 0,0:04:56.84,0:04:58.03,EN,,0,0,0,,So it'd just be more details,
Dialogue: 0,0:04:58.04,0:04:59.66,EN,,0,0,0,,but nothing really conceptually new.
Dialogue: 0,0:05:01.48,0:05:03.02,EN,,0,0,0,,And also, when we've done that,
Dialogue: 0,0:05:03.08,0:05:04.76,EN,,0,0,0,,and the thing is completely explicit,
Dialogue: 0,0:05:04.87,0:05:06.91,EN,,0,0,0,,and we see how to implement LISP
Dialogue: 0,0:05:06.94,0:05:10.08,EN,,0,0,0,,in terms of the actual sequential register operations,
Dialogue: 0,0:05:10.16,0:05:11.63,EN,,0,0,0,,that's going to be our final
Dialogue: 0,0:05:11.95,0:05:14.16,EN,,0,0,0,,most explicit model of LISP in this course.
Dialogue: 0,0:05:14.81,0:05:16.95,EN,,0,0,0,,And, remember, that's a progression through this course.
Dialogue: 0,0:05:16.95,0:05:18.25,EN,,0,0,0,,We started out with substitution,
Dialogue: 0,0:05:18.28,0:05:19.58,EN,,0,0,0,,which is sort of like algebra.
Dialogue: 0,0:05:20.24,0:05:21.87,EN,,0,0,0,,And then we went to the environment model,
Dialogue: 0,0:05:21.88,0:05:24.00,EN,,0,0,0,,which talked about the actual frames
Dialogue: 0,0:05:24.03,0:05:25.31,EN,,0,0,0,,and how they got linked together.
Dialogue: 0,0:05:26.32,0:05:27.88,EN,,0,0,0,,And then we made that more concrete
Dialogue: 0,0:05:27.90,0:05:29.36,EN,,0,0,0,,in the meta-circular evaluator.
Dialogue: 0,0:05:31.05,0:05:31.64,EN,,0,0,0,,There are things
Dialogue: 0,0:05:31.87,0:05:33.98,EN,,0,0,0,,the meta-circular evaluator doesn't tell us.
Dialogue: 0,0:05:34.36,0:05:35.34,EN,,0,0,0,,You should realize that.
Dialogue: 0,0:05:36.09,0:05:38.64,EN,,0,0,0,,For instance, it left unanswered the question
Dialogue: 0,0:05:38.73,0:05:42.67,EN,,0,0,0,,of how a procedure, like recursive factorial here,
Dialogue: 0,0:05:45.17,0:05:47.13,EN,,0,0,0,,somehow takes space that grows.
Dialogue: 0,0:05:47.21,0:05:47.98,EN,,0,0,0,,On the other hand,
Dialogue: 0,0:05:48.16,0:05:51.94,EN,,0,0,0,,a procedure which also looks syntactically recursive,
Dialogue: 0,0:05:52.11,0:05:55.07,EN,,0,0,0,,called fact-iter, somehow doesn't take space.
Dialogue: 0,0:05:55.10,0:05:59.16,EN,,0,0,0,,We justify that it doesn't need to take space
Dialogue: 0,0:06:00.50,0:06:01.96,EN,,0,0,0,,by showing the substitution model.
Dialogue: 0,0:06:01.96,0:06:02.94,EN,,0,0,0,,But we didn't really say
Dialogue: 0,0:06:03.42,0:06:06.76,EN,,0,0,0,,how it happens that the machine manages to do that,
Dialogue: 0,0:06:07.31,0:06:08.91,EN,,0,0,0,,that that has to do with the details
Dialogue: 0,0:06:09.02,0:06:11.12,EN,,0,0,0,,of how arguments are passed to procedures
Dialogue: 0,0:06:12.48,0:06:13.69,EN,,0,0,0,,And that's the thing we didn't see
Dialogue: 0,0:06:13.71,0:06:15.34,EN,,0,0,0,,in the meta-circular evaluator
Dialogue: 0,0:06:15.36,0:06:17.40,EN,,0,0,0,,precisely because the way arguments
Dialogue: 0,0:06:17.42,0:06:19.20,EN,,0,0,0,,got passed to procedures in this LISP
Dialogue: 0,0:06:19.70,0:06:20.59,EN,,0,0,0,,depended on
Dialogue: 0,0:06:21.02,0:06:23.50,EN,,0,0,0,,the way arguments got passed to procedures in this LISP.
Dialogue: 0,0:06:25.87,0:06:29.02,EN,,0,0,0,,But, now, that's going to become extremely explicit.
Dialogue: 0,0:06:30.74,0:06:31.12,EN,,0,0,0,,OK.
Dialogue: 0,0:06:31.23,0:06:34.30,EN,,0,0,0,,Well, before going on to the evaluator,
Dialogue: 0,0:06:34.36,0:06:35.53,EN,,0,0,0,,let me just give you a sense of
Dialogue: 0,0:06:35.55,0:06:37.00,EN,,0,0,0,,what a whole LISP system looks like
Dialogue: 0,0:06:37.60,0:06:39.36,EN,,0,0,0,,so you can see the parts we're going to talk about
Dialogue: 0,0:06:39.40,0:06:40.81,EN,,0,0,0,,and the parts we're not going to talk about.
Dialogue: 0,0:06:43.18,0:06:47.42,EN,,0,0,0,,Let's see, over here is a happy LISP user,
Dialogue: 0,0:06:48.67,0:06:52.65,EN,,0,0,0,,and the LISP user is talking to something called the reader.
Dialogue: 0,0:07:00.36,0:07:01.53,EN,,0,0,0,,The reader's job in life
Dialogue: 0,0:07:01.95,0:07:13.23,EN,,0,0,0,,is to take characters from the user
Dialogue: 0,0:07:14.17,0:07:16.62,EN,,0,0,0,,and turn them into data structures
Dialogue: 0,0:07:17.20,0:07:19.37,EN,,0,0,0,,in something called a list structure memory.
Dialogue: 0,0:07:30.00,0:07:31.72,EN,,0,0,0,,All right, so the reader is going to take
Dialogue: 0,0:07:32.65,0:07:33.95,EN,,0,0,0,,symbols, parentheses,
Dialogue: 0,0:07:34.48,0:07:37.12,EN,,0,0,0,,and A's and B's, and 1s and 3s that you type in,
Dialogue: 0,0:07:37.18,0:07:39.04,EN,,0,0,0,,and turn these into actual list structure:
Dialogue: 0,0:07:39.15,0:07:40.54,EN,,0,0,0,,pairs, and pointers, and things.
Dialogue: 0,0:07:42.35,0:07:43.92,EN,,0,0,0,,And so, by the time evaluator is going,
Dialogue: 0,0:07:43.93,0:07:45.10,EN,,0,0,0,,there are no characters in the world.
Dialogue: 0,0:07:45.85,0:07:48.16,EN,,0,0,0,,And, of course, in more modern Lisp systems, there's
Dialogue: 0,0:07:49.00,0:07:50.44,EN,,0,0,0,,there's sort a big morass here
Dialogue: 0,0:07:50.44,0:07:52.17,EN,,0,0,0,,that might sit between the user and the reader:
Dialogue: 0,0:07:52.41,0:07:54.52,EN,,0,0,0,,you know, Windows systems, in top levels,
Dialogue: 0,0:07:54.77,0:07:56.03,EN,,0,0,0,,and mice, and all kinds of things.
Dialogue: 0,0:07:56.28,0:07:58.20,EN,,0,0,0,,But conceptually, characters are coming in.
Dialogue: 0,0:07:59.93,0:08:04.32,EN,,0,0,0,,All right, the reader transforms these into pointers
Dialogue: 0,0:08:05.56,0:08:07.28,EN,,0,0,0,,pointers to stuff in this memory,
Dialogue: 0,0:08:08.27,0:08:10.94,EN,,0,0,0,,and that's what the evaluator sees
Dialogue: 0,0:08:15.55,0:08:16.04,EN,,0,0,0,,OK?
Dialogue: 0,0:08:17.02,0:08:18.88,EN,,0,0,0,,The evaluator has a bunch of helpers.
Dialogue: 0,0:08:19.78,0:08:23.16,EN,,0,0,0,,It has all possible primitive operators you might want.
Dialogue: 0,0:08:23.16,0:08:24.91,EN,,0,0,0,,So there's a completely separate box,
Dialogue: 0,0:08:28.40,0:08:30.25,EN,,0,0,0,,a floating point unit,
Dialogue: 0,0:08:32.22,0:08:34.40,EN,,0,0,0,,or all sorts of things, which do the primitive operators.
Dialogue: 0,0:08:35.39,0:08:37.68,EN,,0,0,0,,there's and, if you want more special primitives,
Dialogue: 0,0:08:37.71,0:08:39.02,EN,,0,0,0,,you build more primitive operators,
Dialogue: 0,0:08:39.05,0:08:40.48,EN,,0,0,0,,but they're separate from the evaluator.
Dialogue: 0,0:08:42.08,0:08:43.77,EN,,0,0,0,,The evaluator finally gets an answer
Dialogue: 0,0:08:45.16,0:08:46.76,EN,,0,0,0,,and communicates that to the printer.
Dialogue: 0,0:08:50.62,0:08:52.01,EN,,0,0,0,,And now, the printer's job in life
Dialogue: 0,0:08:52.01,0:08:54.54,EN,,0,0,0,,is this list structure coming from the evaluator,
Dialogue: 0,0:08:55.39,0:08:56.99,EN,,0,0,0,,and turn it back into characters,
Dialogue: 0,0:09:01.85,0:09:04.07,EN,,0,0,0,,and communicate them to the user through
Dialogue: 0,0:09:04.28,0:09:05.66,EN,,0,0,0,,whatever interface there is.
Dialogue: 0,0:09:08.05,0:09:11.23,EN,,0,0,0,,OK. Well, today, what we're going to talk about is this evaluator.
Dialogue: 0,0:09:12.67,0:09:15.20,EN,,0,0,0,,The primitive operators have nothing particular to do with LISP,
Dialogue: 0,0:09:15.20,0:09:18.14,EN,,0,0,0,,they're however you like to implement primitive operations.
Dialogue: 0,0:09:19.36,0:09:22.18,EN,,0,0,0,,The reader and printer are actually complicated,
Dialogue: 0,0:09:22.18,0:09:23.55,EN,,0,0,0,,but we're not going to talk about them.
Dialogue: 0,0:09:24.68,0:09:27.10,EN,,0,0,0,,They sort of have to do with details of how you might build
Dialogue: 0,0:09:27.10,0:09:28.92,EN,,0,0,0,,build up list structure from characters.
Dialogue: 0,0:09:29.90,0:09:31.18,EN,,0,0,0,,So that is a long story,
Dialogue: 0,0:09:31.18,0:09:32.32,EN,,0,0,0,,but we're not going to talk about it,
Dialogue: 0,0:09:32.49,0:09:33.69,EN,,0,0,0,,the list structure memory,
Dialogue: 0,0:09:34.36,0:09:35.63,EN,,0,0,0,,we'll talk about next time.
Dialogue: 0,0:09:36.93,0:09:39.72,EN,,0,0,0,,So, pretty much, except for the details of reading and printing,
Dialogue: 0,0:09:40.12,0:09:41.71,EN,,0,0,0,,the only mystery that's going to be left
Dialogue: 0,0:09:41.72,0:09:43.05,EN,,0,0,0,,after you see the evaluator
Dialogue: 0,0:09:43.25,0:09:45.85,EN,,0,0,0,,is how you build list structure on conventional memories.
Dialogue: 0,0:09:46.65,0:09:48.20,EN,,0,0,0,,But we'll worry about that next time too.
Dialogue: 0,0:09:50.58,0:09:51.04,EN,,0,0,0,,OK.
Dialogue: 0,0:09:53.34,0:09:56.11,EN,,0,0,0,,Well, let's start talking about the evaluator.
Dialogue: 0,0:09:56.20,0:09:58.32,EN,,0,0,0,,The one that we're going to show you,
Dialogue: 0,0:09:58.49,0:10:01.12,EN,,0,0,0,,of course, is not, I think, nothing special about it.
Dialogue: 0,0:10:01.15,0:10:04.56,EN,,0,0,0,,It's just a particular register machine that runs LISP.
Dialogue: 0,0:10:04.81,0:10:06.09,EN,,0,0,0,,And it has seven registers,
Dialogue: 0,0:10:07.88,0:10:09.26,EN,,0,0,0,,and here are the seven registers.
Dialogue: 0,0:10:09.89,0:10:12.38,EN,,0,0,0,,There's a register, called EXP
Dialogue: 0,0:10:14.12,0:10:15.53,EN,,0,0,0,,and its job is to hold
Dialogue: 0,0:10:16.36,0:10:18.03,EN,,0,0,0,,the expression to be evaluated.
Dialogue: 0,0:10:18.37,0:10:19.80,EN,,0,0,0,,And by that, I mean
Dialogue: 0,0:10:20.38,0:10:21.64,EN,,0,0,0,,it's going to hold a pointer
Dialogue: 0,0:10:22.03,0:10:23.55,EN,,0,0,0,,to someplace in list structure memory
Dialogue: 0,0:10:23.56,0:10:25.32,EN,,0,0,0,,the expression to be evaluated.
Dialogue: 0,0:10:26.55,0:10:27.82,EN,,0,0,0,,There's a register, called ENV,
Dialogue: 0,0:10:28.88,0:10:30.28,EN,,0,0,0,,which holds the environment
Dialogue: 0,0:10:31.00,0:10:33.05,EN,,0,0,0,,in which this expression is to be evaluated.
Dialogue: 0,0:10:34.07,0:10:35.02,EN,,0,0,0,,And, again, I made a pointer.
Dialogue: 0,0:10:35.02,0:10:36.75,EN,,0,0,0,,The environment is some data structure.
Dialogue: 0,0:10:38.24,0:10:40.14,EN,,0,0,0,,There's a register, called FUN, which will
Dialogue: 0,0:10:40.75,0:10:42.54,EN,,0,0,0,,which will hold the procedure to be applied
Dialogue: 0,0:10:42.57,0:10:43.96,EN,,0,0,0,,when you go to apply a procedure.
Dialogue: 0,0:10:44.56,0:10:46.24,EN,,0,0,0,,A register, called ARGL,
Dialogue: 0,0:10:47.36,0:10:49.34,EN,,0,0,0,,which holds the list of evaluated arguments.
Dialogue: 0,0:10:50.54,0:10:51.60,EN,,0,0,0,,What you can start seeing here is
Dialogue: 0,0:10:51.63,0:10:53.14,EN,,0,0,0,,the basic structure of the evaluator.
Dialogue: 0,0:10:53.14,0:10:54.49,EN,,0,0,0,,Remember how evaluators work.
Dialogue: 0,0:10:54.49,0:10:56.62,EN,,0,0,0,,There's a piece that takes expressions and environments,
Dialogue: 0,0:10:57.67,0:10:59.71,EN,,0,0,0,,and there's a piece that takes functions
Dialogue: 0,0:10:59.74,0:11:02.14,EN,,0,0,0,,or procedures and arguments.
Dialogue: 0,0:11:03.48,0:11:06.30,EN,,0,0,0,,And going back and forth around here is the eval/apply loop.
Dialogue: 0,0:11:07.40,0:11:09.69,EN,,0,0,0,,So those are the basic pieces of the eval and apply.
Dialogue: 0,0:11:10.20,0:11:10.99,EN,,0,0,0,,Then there's some other things,
Dialogue: 0,0:11:11.00,0:11:11.61,EN,,0,0,0,,there's continue.
Dialogue: 0,0:11:11.61,0:11:15.34,EN,,0,0,0,,You just saw before how the continue register is used to
Dialogue: 0,0:11:15.34,0:11:18.04,EN,,0,0,0,,implement recursion and stack discipline.
Dialogue: 0,0:11:18.94,0:11:20.68,EN,,0,0,0,,There's a register that's going to hold the
Dialogue: 0,0:11:20.94,0:11:22.52,EN,,0,0,0,,result of some evaluation.
Dialogue: 0,0:11:24.14,0:11:24.89,EN,,0,0,0,,And then, besides that,
Dialogue: 0,0:11:24.89,0:11:26.43,EN,,0,0,0,,there's one temporary register,
Dialogue: 0,0:11:26.70,0:11:27.29,EN,,0,0,0,,called UNEV,
Dialogue: 0,0:11:27.29,0:11:29.04,EN,,0,0,0,,which typically, in the evaluator,
Dialogue: 0,0:11:29.28,0:11:32.72,EN,,0,0,0,,is going to be used to hold temporary pieces of the
Dialogue: 0,0:11:32.89,0:11:33.95,EN,,0,0,0,,expression you're working on,
Dialogue: 0,0:11:33.95,0:11:35.72,EN,,0,0,0,,which you haven't gotten around to evaluate yet
Dialogue: 0,0:11:36.97,0:11:39.82,EN,,0,0,0,,Right? So there's my machine: a seven-register machine.
Dialogue: 0,0:11:40.96,0:11:42.98,EN,,0,0,0,,And, of course, you might want to make a machine with
Dialogue: 0,0:11:42.98,0:11:44.96,EN,,0,0,0,,a lot more registers to get better performance,
Dialogue: 0,0:11:44.97,0:11:47.05,EN,,0,0,0,,but this is just a tiny, minimal one.
Dialogue: 0,0:11:48.48,0:11:49.58,EN,,0,0,0,,Well, how about the data paths?
Dialogue: 0,0:11:49.78,0:11:53.66,EN,,0,0,0,,This machine has a lot of special operations for LISP.
Dialogue: 0,0:11:55.10,0:11:58.08,EN,,0,0,0,,So, here are some typical data paths.
Dialogue: 0,0:12:00.12,0:12:01.04,EN,,0,0,0,,A typical one might be,
Dialogue: 0,0:12:01.37,0:12:03.40,EN,,0,0,0,,oh, assign to the VAL register
Dialogue: 0,0:12:03.40,0:12:04.80,EN,,0,0,0,,the contents of the EXP register.
Dialogue: 0,0:12:05.71,0:12:08.01,EN,,0,0,0,,That's in terms of those diagrams you saw,
Dialogue: 0,0:12:08.03,0:12:10.81,EN,,0,0,0,,that's a little button on some arrow.
Dialogue: 0,0:12:11.90,0:12:13.13,EN,,0,0,0,,Here's a more complicated one.
Dialogue: 0,0:12:13.69,0:12:14.80,EN,,0,0,0,,It says branch,
Dialogue: 0,0:12:15.23,0:12:19.58,EN,,0,0,0,,if the thing in the expression register is a conditional
Dialogue: 0,0:12:20.49,0:12:22.72,EN,,0,0,0,,to some label here, called the ev-conditional.
Dialogue: 0,0:12:23.80,0:12:26.23,EN,,0,0,0,,And you can imagine this implemented in a lot of different ways.
Dialogue: 0,0:12:26.23,0:12:28.36,EN,,0,0,0,,You might imagine this conditional test
Dialogue: 0,0:12:28.36,0:12:29.98,EN,,0,0,0,,as a special purpose sub-routine,
Dialogue: 0,0:12:30.60,0:12:33.95,EN,,0,0,0,,and conditional might be represented as some data abstraction
Dialogue: 0,0:12:33.96,0:12:36.00,EN,,0,0,0,,that you don't care about at this level of detail.
Dialogue: 0,0:12:36.61,0:12:37.98,EN,,0,0,0,,So that might be done as a sub-routine.
Dialogue: 0,0:12:37.98,0:12:40.67,EN,,0,0,0,,This might be a machine with hardware-types,
Dialogue: 0,0:12:40.90,0:12:44.04,EN,,0,0,0,,and conditional might be testing some bits for a particular code.
Dialogue: 0,0:12:45.35,0:12:46.41,EN,,0,0,0,,There are all sorts of ways that's
Dialogue: 0,0:12:46.41,0:12:48.48,EN,,0,0,0,,beneath the level of abstraction we're looking at.
Dialogue: 0,0:12:50.19,0:12:51.71,EN,,0,0,0,,Another kind of operation,
Dialogue: 0,0:12:51.71,0:12:53.24,EN,,0,0,0,,and there are a lot of different operations
Dialogue: 0,0:12:53.24,0:12:56.65,EN,,0,0,0,,assigned to EXP, the first clause of what's in EXP.
Dialogue: 0,0:12:56.84,0:12:58.89,EN,,0,0,0,,This might be part of processing a conditional.
Dialogue: 0,0:12:59.26,0:13:01.80,EN,,0,0,0,,And, again, first clause is some selector
Dialogue: 0,0:13:03.07,0:13:04.48,EN,,0,0,0,,whose details we don't care about.
Dialogue: 0,0:13:04.49,0:13:06.46,EN,,0,0,0,,And you can, again, imagine that as a sub-routine
Dialogue: 0,0:13:06.46,0:13:07.90,EN,,0,0,0,,which'll do some list operations,
Dialogue: 0,0:13:08.22,0:13:09.18,EN,,0,0,0,,or you can imagine that as
Dialogue: 0,0:13:09.18,0:13:10.73,EN,,0,0,0,,something that's built directly into hardware.
Dialogue: 0,0:13:12.17,0:13:13.71,EN,,0,0,0,,The reason I keep saying you can imagine it
Dialogue: 0,0:13:14.03,0:13:15.22,EN,,0,0,0,,built directly into hardware
Dialogue: 0,0:13:15.22,0:13:17.80,EN,,0,0,0,,is even though there are a lot of operations,
Dialogue: 0,0:13:18.36,0:13:19.74,EN,,0,0,0,,there are still a fixed number of them.
Dialogue: 0,0:13:20.12,0:13:21.80,EN,,0,0,0,,I forget how many, maybe 150.
Dialogue: 0,0:13:22.37,0:13:25.39,EN,,0,0,0,,So, it's plausible to think of building these directly into hardware.
Dialogue: 0,0:13:26.41,0:13:27.68,EN,,0,0,0,,Here's a more complicated one.
Dialogue: 0,0:13:28.27,0:13:29.47,EN,,0,0,0,,You can see this has to do with
Dialogue: 0,0:13:29.47,0:13:31.10,EN,,0,0,0,,looking up the values of variables.
Dialogue: 0,0:13:31.50,0:13:33.28,EN,,0,0,0,,It says assign to the VAL register
Dialogue: 0,0:13:33.45,0:13:36.91,EN,,0,0,0,,the result of looking up the variable value
Dialogue: 0,0:13:36.99,0:13:38.52,EN,,0,0,0,,of some particular expression,
Dialogue: 0,0:13:39.18,0:13:40.30,EN,,0,0,0,,which, in this case, is supposed to be
Dialogue: 0,0:13:40.33,0:13:42.00,EN,,0,0,0,,a variable in some environment.
Dialogue: 0,0:13:42.80,0:13:44.68,EN,,0,0,0,,And this'll be some operation
Dialogue: 0,0:13:45.21,0:13:47.50,EN,,0,0,0,,that search through the environment structure,
Dialogue: 0,0:13:47.52,0:13:48.97,EN,,0,0,0,,however it is represented,
Dialogue: 0,0:13:49.37,0:13:50.91,EN,,0,0,0,,and goes and looks up that variable.
Dialogue: 0,0:13:52.17,0:13:53.95,EN,,0,0,0,,And, again, that's below the level of detail
Dialogue: 0,0:13:53.96,0:13:54.86,EN,,0,0,0,,that we're thinking about.
Dialogue: 0,0:13:54.89,0:13:57.30,EN,,0,0,0,,This is... this has to do with the details of
Dialogue: 0,0:13:57.55,0:13:59.44,EN,,0,0,0,,the data structures for representing environments.
Dialogue: 0,0:14:00.07,0:14:01.21,EN,,0,0,0,,But, anyway, there is this
Dialogue: 0,0:14:01.31,0:14:03.47,EN,,0,0,0,,there is this fixed and finite number
Dialogue: 0,0:14:04.11,0:14:06.08,EN,,0,0,0,,of operations in the register machine.
Dialogue: 0,0:14:08.50,0:14:11.60,EN,,0,0,0,,Well, what's its overall structure?
Dialogue: 0,0:14:11.72,0:14:13.23,EN,,0,0,0,,Those are some typical operations.
Dialogue: 0,0:14:14.76,0:14:16.33,EN,,0,0,0,,Remember what we have to do,
Dialogue: 0,0:14:16.44,0:14:18.40,EN,,0,0,0,,we have to take the meta-circular evaluator--
Dialogue: 0,0:14:20.43,0:14:22.76,EN,,0,0,0,,and here's a piece of the meta-circular evaluator.
Dialogue: 0,0:14:22.76,0:14:26.89,EN,,0,0,0,,This is the one using abstract syntax that's in the book.
Dialogue: 0,0:14:28.22,0:14:31.53,EN,,0,0,0,,It's a little bit different from the one that Gerry shows you.
Dialogue: 0,0:14:33.50,0:14:35.10,EN,,0,0,0,,And the main thing
Dialogue: 0,0:14:35.13,0:14:37.87,EN,,0,0,0,,to remember about the evaluator is that
Dialogue: 0,0:14:37.87,0:14:40.96,EN,,0,0,0,,it's doing some sort of case analysis on the kinds of expressions:
Dialogue: 0,0:14:43.76,0:14:45.90,EN,,0,0,0,,so if it's either self-evaluated, or quoted,
Dialogue: 0,0:14:45.92,0:14:46.86,EN,,0,0,0,,or whatever else.
Dialogue: 0,0:14:48.56,0:14:50.57,EN,,0,0,0,,And then, in the general case where
Dialogue: 0,0:14:50.86,0:14:52.96,EN,,0,0,0,,the expression it's looking at is an application,
Dialogue: 0,0:14:53.55,0:14:55.36,EN,,0,0,0,,there's some tricky recursions going on.
Dialogue: 0,0:14:55.75,0:14:59.36,EN,,0,0,0,,First of all, eval has to call itself
Dialogue: 0,0:14:59.79,0:15:01.45,EN,,0,0,0,,both to evaluate the operator
Dialogue: 0,0:15:02.14,0:15:04.04,EN,,0,0,0,,and to evaluate all the operands.
Dialogue: 0,0:15:05.88,0:15:07.40,EN,,0,0,0,,So there's this sort of red recursion
Dialogue: 0,0:15:07.63,0:15:09.28,EN,,0,0,0,,of values walking down the tree
Dialogue: 0,0:15:10.94,0:15:12.27,EN,,0,0,0,,that's sort of the easy recursion.
Dialogue: 0,0:15:12.27,0:15:14.44,EN,,0,0,0,,That's just eval walking down this tree of expressions.
Dialogue: 0,0:15:14.75,0:15:15.53,EN,,0,0,0,,Then, in the evaluator,
Dialogue: 0,0:15:15.53,0:15:16.46,EN,,0,0,0,,there's a hard recursion.
Dialogue: 0,0:15:16.49,0:15:17.92,EN,,0,0,0,,There's the red to green.
Dialogue: 0,0:15:18.00,0:15:19.66,EN,,0,0,0,,Eval calls apply.
Dialogue: 0,0:15:22.47,0:15:26.45,EN,,0,0,0,,That's the case where evaluating a procedure argument
Dialogue: 0,0:15:26.45,0:15:28.72,EN,,0,0,0,,reduces to applying the procedure
Dialogue: 0,0:15:28.94,0:15:29.93,EN,,0,0,0,,to the list of arguments.
Dialogue: 0,0:15:30.37,0:15:31.76,EN,,0,0,0,,And then, apply comes over here.
Dialogue: 0,0:15:34.77,0:15:36.67,EN,,0,0,0,,Apply takes a procedure and arguments
Dialogue: 0,0:15:37.65,0:15:39.45,EN,,0,0,0,,and, in the general case
Dialogue: 0,0:15:39.48,0:15:40.81,EN,,0,0,0,,where there's a compound procedure,
Dialogue: 0,0:15:41.05,0:15:42.19,EN,,0,0,0,,apply goes around and
Dialogue: 0,0:15:42.25,0:15:43.15,EN,,0,0,0,,green calls red.
Dialogue: 0,0:15:43.34,0:15:46.44,EN,,0,0,0,,Eval-- Apply comes around and calls eval again.
Dialogue: 0,0:15:48.17,0:15:49.79,EN,,0,0,0,,Eval's the body of the procedure
Dialogue: 0,0:15:50.24,0:15:52.59,EN,,0,0,0,,in the result of extending the environment
Dialogue: 0,0:15:53.69,0:15:55.28,EN,,0,0,0,,with the parameters of the procedure
Dialogue: 0,0:15:55.48,0:15:56.92,EN,,0,0,0,,by binding the arguments.
Dialogue: 0,0:15:59.62,0:16:00.62,EN,,0,0,0,,Except in the primitive case,
Dialogue: 0,0:16:00.64,0:16:02.52,EN,,0,0,0,,where it just calls something else primitive-apply
Dialogue: 0,0:16:02.73,0:16:04.70,EN,,0,0,0,,which is not really the business of the evaluator.
Dialogue: 0,0:16:05.98,0:16:07.47,EN,,0,0,0,,So this sort of red to green,
Dialogue: 0,0:16:07.47,0:16:08.40,EN,,0,0,0,,to red to green,
Dialogue: 0,0:16:09.79,0:16:12.72,EN,,0,0,0,,Right? That's the that's the eval/apply loop,
Dialogue: 0,0:16:14.06,0:16:15.74,EN,,0,0,0,,and that's the thing that we're going to want to see
Dialogue: 0,0:16:16.19,0:16:17.72,EN,,0,0,0,,in the evaluator.
Dialogue: 0,0:16:19.69,0:16:21.07,EN,,0,0,0,,Well, it won't surprise you at all that
Dialogue: 0,0:16:21.07,0:16:23.52,EN,,0,0,0,,the two big pieces of this evaluator
Dialogue: 0,0:16:25.34,0:16:27.04,EN,,0,0,0,,are correspond to eval and apply.
Dialogue: 0,0:16:27.47,0:16:29.44,EN,,0,0,0,,There's a piece called eval-dispatch,
Dialogue: 0,0:16:29.60,0:16:31.20,EN,,0,0,0,,and a piece called apply-dispatch.
Dialogue: 0,0:16:32.00,0:16:34.09,EN,,0,0,0,,And, before we get into the details of the code,
Dialogue: 0,0:16:34.20,0:16:35.76,EN,,0,0,0,,the way to understand this is to think,
Dialogue: 0,0:16:36.09,0:16:39.02,EN,,0,0,0,,again, in terms of these pieces of evaluator
Dialogue: 0,0:16:39.02,0:16:40.97,EN,,0,0,0,,having contracts with the rest of the world.
Dialogue: 0,0:16:41.87,0:16:43.18,EN,,0,0,0,,What do they do from the outside
Dialogue: 0,0:16:43.20,0:16:45.50,EN,,0,0,0,,before getting into the grungy details?
Dialogue: 0,0:16:45.78,0:16:49.32,EN,,0,0,0,,Well, the contract for eval-dispatch--
Dialogue: 0,0:16:50.01,0:16:51.40,EN,,0,0,0,,remember, it corresponds to eval.
Dialogue: 0,0:16:51.55,0:16:54.10,EN,,0,0,0,,It's got to evaluate an expression in an environment.
Dialogue: 0,0:16:54.10,0:16:55.88,EN,,0,0,0,,So, in particular, what this one is going to do,
Dialogue: 0,0:16:56.52,0:16:58.68,EN,,0,0,0,,eval-dispatch will assume that, when you call it,
Dialogue: 0,0:16:59.68,0:17:01.48,EN,,0,0,0,,that the expression you want to evaluate
Dialogue: 0,0:17:01.48,0:17:02.52,EN,,0,0,0,,is in the EXP register.
Dialogue: 0,0:17:03.64,0:17:07.39,EN,,0,0,0,,The environment in which you want the evaluation
Dialogue: 0,0:17:07.45,0:17:09.05,EN,,0,0,0,,to take place is in the ENV register.
Dialogue: 0,0:17:09.56,0:17:10.67,EN,,0,0,0,,And continue tells you
Dialogue: 0,0:17:10.84,0:17:12.46,EN,,0,0,0,,the place where the machine should go next
Dialogue: 0,0:17:12.52,0:17:13.92,EN,,0,0,0,,when the evaluation is done.
Dialogue: 0,0:17:17.28,0:17:19.18,EN,,0,0,0,,Eval-dispatch's contract is that
Dialogue: 0,0:17:19.28,0:17:21.26,EN,,0,0,0,,it'll actually perform that evaluation,
Dialogue: 0,0:17:21.40,0:17:22.46,EN,,0,0,0,,and, at the end of which,
Dialogue: 0,0:17:23.28,0:17:25.63,EN,,0,0,0,,it'll end up at the place specified by continue.
Dialogue: 0,0:17:26.61,0:17:29.16,EN,,0,0,0,,The result of the evaluation will be in the VAL register.
Dialogue: 0,0:17:29.82,0:17:30.96,EN,,0,0,0,,And it just warns you,
Dialogue: 0,0:17:30.99,0:17:32.91,EN,,0,0,0,,it makes no promises about
Dialogue: 0,0:17:32.96,0:17:34.60,EN,,0,0,0,,what happens to rest the registers.
Dialogue: 0,0:17:35.23,0:17:36.81,EN,,0,0,0,,All other registers might be destroyed.
Dialogue: 0,0:17:37.49,0:17:40.14,EN,,0,0,0,,So, there's one piece, OK?
Dialogue: 0,0:17:41.55,0:17:43.48,EN,,0,0,0,,Together, the pieces, apply-dispatch
Dialogue: 0,0:17:43.52,0:17:44.92,EN,,0,0,0,,that corresponds to apply,
Dialogue: 0,0:17:46.09,0:17:48.43,EN,,0,0,0,,it's got to apply a procedure to some arguments,
Dialogue: 0,0:17:48.73,0:17:51.43,EN,,0,0,0,,so it assumes that this register, ARGL,
Dialogue: 0,0:17:51.68,0:17:53.77,EN,,0,0,0,,contains a list of the evaluated arguments.
Dialogue: 0,0:17:54.54,0:17:55.96,EN,,0,0,0,,FUN contains the procedure.
Dialogue: 0,0:17:57.22,0:17:58.83,EN,,0,0,0,,Those correspond to the arguments to
Dialogue: 0,0:17:58.94,0:18:01.36,EN,,0,0,0,,the apply procedure in the meta-circular evaluator.
Dialogue: 0,0:18:03.97,0:18:06.04,EN,,0,0,0,,And apply, in this particular evaluator,
Dialogue: 0,0:18:06.06,0:18:07.58,EN,,0,0,0,,we're going to use a discipline which says
Dialogue: 0,0:18:07.72,0:18:08.97,EN,,0,0,0,,the place that apply
Dialogue: 0,0:18:09.47,0:18:11.20,EN,,0,0,0,,the place the machine should go to next
Dialogue: 0,0:18:11.79,0:18:13.45,EN,,0,0,0,,when apply is done, is at the moment
Dialogue: 0,0:18:13.55,0:18:15.92,EN,,0,0,0,,apply-dispatch is called at the top of the stack
Dialogue: 0,0:18:17.07,0:18:21.24,EN,,0,0,0,,that's just discipline for the way this particular machine's organized.
Dialogue: 0,0:18:21.84,0:18:23.70,EN,,0,0,0,,And now apply's contract is given all that.
Dialogue: 0,0:18:23.93,0:18:25.37,EN,,0,0,0,,It'll perform the application.
Dialogue: 0,0:18:25.54,0:18:27.85,EN,,0,0,0,,The result of that application will end up in VAL.
Dialogue: 0,0:18:28.89,0:18:29.95,EN,,0,0,0,,The stack will be popped.
Dialogue: 0,0:18:31.12,0:18:31.66,EN,,0,0,0,,And, again,
Dialogue: 0,0:18:31.71,0:18:34.03,EN,,0,0,0,,the contents of all the other registers may be destroyed.
Dialogue: 0,0:18:34.84,0:18:37.82,EN,,0,0,0,,All right? So that's the basic organization of this machine.
Dialogue: 0,0:18:38.99,0:18:41.50,EN,,0,0,0,,Let's break for a little bit and see if there are any questions
Dialogue: 0,0:18:41.52,0:18:42.70,EN,,0,0,0,,and then we'll do a real example.
Dialogue: 0,0:18:43.53,0:19:08.11,EN,,0,0,0,,[JESU, JOY OF MAN'S DESIRING]
Dialogue: 0,0:19:08.14,0:19:13.47,EN,,0,0,0,,The Structure And Interpretation of Computer Programs
Dialogue: 0,0:19:33.10,0:19:35.87,EN,,0,0,0,,By: Prof. Harold Abelson && Sussman Jay Sussman
Dialogue: 0,0:19:35.87,0:19:40.38,EN,,0,0,0,,The Structure And Interpretation of Computer Programs
Dialogue: 0,0:19:47.85,0:19:49.95,EN,,0,0,0,,Well, let's take the register machine now,
Dialogue: 0,0:19:50.41,0:19:51.77,EN,,0,0,0,,and actually step through,
Dialogue: 0,0:19:52.27,0:19:56.94,EN,,0,0,0,,and really, in real detail,
Dialogue: 0,0:19:57.07,0:19:58.52,EN,,0,0,0,,so you see completely concrete
Dialogue: 0,0:19:58.86,0:20:01.24,EN,,0,0,0,,how some expressions are evaluated,
Dialogue: 0,0:20:03.15,0:20:06.86,EN,,0,0,0,,Alright? So, let's start with a very simple expression.
Dialogue: 0,0:20:07.45,0:20:13.52,EN,,0,0,0,,Let's evaluate the expression 1.
Dialogue: 0,0:20:18.77,0:20:20.40,EN,,0,0,0,,And we need an environment,
Dialogue: 0,0:20:20.43,0:20:22.35,EN,,0,0,0,,so let's imagine that somewhere there's an environment
Dialogue: 0,0:20:22.38,0:20:23.39,EN,,0,0,0,,we'll call it E0.
Dialogue: 0,0:20:30.06,0:20:34.56,EN,,0,0,0,,And just, since we'll use these later,
Dialogue: 0,0:20:35.62,0:20:37.04,EN,,0,0,0,,we obviously don't really need anything
Dialogue: 0,0:20:37.07,0:20:37.93,EN,,0,0,0,,to evaluate 1.
Dialogue: 0,0:20:38.36,0:20:39.45,EN,,0,0,0,,But, just for reference later,
Dialogue: 0,0:20:39.45,0:20:40.94,EN,,0,0,0,,let's assume that E0 has in it
Dialogue: 0,0:20:41.44,0:20:43.15,EN,,0,0,0,,an X that's bound to 3
Dialogue: 0,0:20:43.72,0:20:45.37,EN,,0,0,0,,and a Y that's bound to 4,
Dialogue: 0,0:20:48.27,0:20:48.78,EN,,0,0,0,,OK?
Dialogue: 0,0:20:49.14,0:20:50.12,EN,,0,0,0,,And now what we're going to do
Dialogue: 0,0:20:50.51,0:20:54.59,EN,,0,0,0,,is we're going to evaluate 1 in this environment
Dialogue: 0,0:20:55.74,0:20:58.54,EN,,0,0,0,,and so the ENV register has a pointer
Dialogue: 0,0:20:59.65,0:21:01.04,EN,,0,0,0,,to this environment, E0, all right?
Dialogue: 0,0:21:03.31,0:21:05.65,EN,,0,0,0,,Right? So let's watch that thing go.
Dialogue: 0,0:21:05.65,0:21:07.26,EN,,0,0,0,,What I'm going to do is step through the code.
Dialogue: 0,0:21:08.26,0:21:10.00,EN,,0,0,0,,And, let's see, I'll be the controller.
Dialogue: 0,0:21:10.04,0:21:10.80,EN,,0,0,0,,And now what I need,
Dialogue: 0,0:21:11.02,0:21:12.49,EN,,0,0,0,,since this gets rather complicated,
Dialogue: 0,0:21:12.98,0:21:16.83,EN,,0,0,0,,is a very little execution unit.
Dialogue: 0,0:21:16.83,0:21:18.16,EN,,0,0,0,,So here's the execution unit, OK?
Dialogue: 0,0:21:22.62,0:21:23.12,EN,,0,0,0,,OK.
Dialogue: 0,0:21:28.59,0:21:29.96,EN,,0,0,0,,All right, now we're going to start.
Dialogue: 0,0:21:30.53,0:21:32.48,EN,,0,0,0,,We're going to start the machine at eval-dispatch。
Dialogue: 0,0:21:33.26,0:21:34.62,EN,,0,0,0,,Right? That's the beginning of this.
Dialogue: 0,0:21:35.87,0:21:38.75,EN,,0,0,0,,Eval-dispatch is going to look at the expression and dispatch,
Dialogue: 0,0:21:39.32,0:21:40.06,EN,,0,0,0,,just like eval
Dialogue: 0,0:21:40.87,0:21:42.00,EN,,0,0,0,,where we look at the very first thing.
Dialogue: 0,0:21:42.04,0:21:47.95,EN,,0,0,0,,We branch on whether or not this expression is self-evaluating.
Dialogue: 0,0:21:47.95,0:21:49.96,EN,,0,0,0,,Self-evaluating is some abstraction
Dialogue: 0,0:21:49.96,0:21:51.10,EN,,0,0,0,,we put into the machine--
Dialogue: 0,0:21:52.22,0:21:53.51,EN,,0,0,0,,it's going to be true for numbers--
Dialogue: 0,0:21:53.64,0:21:55.52,EN,,0,0,0,,to a place called ev-self-eval,
Dialogue: 0,0:21:56.77,0:21:58.20,EN,,0,0,0,,So me, being the controller,
Dialogue: 0,0:21:58.22,0:21:59.55,EN,,0,0,0,,looks at ev-self-eval,
Dialogue: 0,0:22:00.06,0:22:01.07,EN,,0,0,0,,so we'll go over to there.
Dialogue: 0,0:22:02.60,0:22:04.76,EN,,0,0,0,,Ev-self-eval says fine,
Dialogue: 0,0:22:06.54,0:22:09.90,EN,,0,0,0,,assign to val whatever is in the expression unit.
Dialogue: 0,0:22:15.24,0:22:16.51,EN,,0,0,0,,And I have a bug
Dialogue: 0,0:22:17.93,0:22:20.59,EN,,0,0,0,,because what I didn't do when I initialized this machine
Dialogue: 0,0:22:21.62,0:22:22.89,EN,,0,0,0,,is also say what's supposed
Dialogue: 0,0:22:22.91,0:22:24.19,EN,,0,0,0,,to happen when it's done,
Dialogue: 0,0:22:24.65,0:22:26.83,EN,,0,0,0,,so I should have started out the machine
Dialogue: 0,0:22:27.37,0:22:29.85,EN,,0,0,0,,with done being in the continue register,
Dialogue: 0,0:22:31.18,0:22:33.26,EN,,0,0,0,,OK? So we assign to VAL.
Dialogue: 0,0:22:33.37,0:22:35.56,EN,,0,0,0,,And now go to fetch of continue,
Dialogue: 0,0:22:35.63,0:22:36.56,EN,,0,0,0,,and now change--
Dialogue: 0,0:22:38.09,0:22:38.60,EN,,0,0,0,,OK.
Dialogue: 0,0:22:40.00,0:22:41.16,EN,,0,0,0,,OK, let's try something harder.
Dialogue: 0,0:22:42.16,0:22:43.45,EN,,0,0,0,,Let's reset the machine here,
Dialogue: 0,0:22:44.86,0:22:50.88,EN,,0,0,0,,and we'll put in the expression register, X, OK?
Dialogue: 0,0:22:56.71,0:22:58.20,EN,,0,0,0,,Start again at eval-dispatch.
Dialogue: 0,0:22:59.61,0:23:01.69,EN,,0,0,0,,Check, is it self-evaluating?
Dialogue: 0,0:23:01.69,0:23:02.03,EN,,0,0,0,,No.
Dialogue: 0,0:23:02.65,0:23:03.61,EN,,0,0,0,,Is it a variable?
Dialogue: 0,0:23:04.63,0:23:05.02,EN,,0,0,0,,Yes.
Dialogue: 0,0:23:05.56,0:23:07.07,EN,,0,0,0,,We go off to ev-variable.
Dialogue: 0,0:23:08.38,0:23:10.97,EN,,0,0,0,,It says assign to VAL,
Dialogue: 0,0:23:12.13,0:23:15.69,EN,,0,0,0,,look up the variable value in the expression register
Dialogue: 0,0:23:21.23,0:23:22.91,EN,,0,0,0,,Go to fetch of continue.
Dialogue: 0,0:23:23.96,0:23:24.48,EN,,0,0,0,,PROFESSOR: Done.
Dialogue: 0,0:23:27.61,0:23:28.09,EN,,0,0,0,,PROFESSOR: OK.
Dialogue: 0,0:23:29.31,0:23:30.76,EN,,0,0,0,,Alright, Well, that's the basic idea. Those're
Dialogue: 0,0:23:31.33,0:23:32.65,EN,,0,0,0,,That's a simple operation of the machine.
Dialogue: 0,0:23:32.68,0:23:35.07,EN,,0,0,0,,Now, let's actually do something a little bit more interesting.
Dialogue: 0,0:23:36.07,0:23:38.64,EN,,0,0,0,,Let's look at the expression
Dialogue: 0,0:23:43.58,0:23:47.93,EN,,0,0,0,,the sum of x and y.
Dialogue: 0,0:23:49.69,0:23:51.28,EN,,0,0,0,,OK. And now we'll see how you start
Dialogue: 0,0:23:52.41,0:23:54.01,EN,,0,0,0,,unrolling these expression trees.
Dialogue: 0,0:23:57.13,0:23:58.68,EN,,0,0,0,,Well, start again at eval-dispatch.
Dialogue: 0,0:24:04.61,0:24:05.80,EN,,0,0,0,,Self-evaluating?
Dialogue: 0,0:24:05.95,0:24:06.52,EN,,0,0,0,,No.
Dialogue: 0,0:24:06.70,0:24:07.71,EN,,0,0,0,,Variable? No.
Dialogue: 0,0:24:07.82,0:24:08.99,EN,,0,0,0,,All the other special forms
Dialogue: 0,0:24:08.99,0:24:10.12,EN,,0,0,0,,which I didn't write down,
Dialogue: 0,0:24:10.27,0:24:12.48,EN,,0,0,0,,like quote, and lambda, and set, and whatever,
Dialogue: 0,0:24:12.48,0:24:13.08,EN,,0,0,0,,it's none of those.
Dialogue: 0,0:24:13.26,0:24:14.73,EN,,0,0,0,,It turns out to be an application,
Dialogue: 0,0:24:15.88,0:24:17.42,EN,,0,0,0,,so we go off to ev-application.
Dialogue: 0,0:24:19.97,0:24:24.94,EN,,0,0,0,,Ev-application, remember what it's going to do overall.
Dialogue: 0,0:24:25.58,0:24:28.19,EN,,0,0,0,,It is going to evaluate the operator.
Dialogue: 0,0:24:28.27,0:24:31.40,EN,,0,0,0,,It's going to evaluate the arguments,
Dialogue: 0,0:24:32.36,0:24:34.30,EN,,0,0,0,,and then it's going to go apply them.
Dialogue: 0,0:24:35.06,0:24:36.09,EN,,0,0,0,,So, before we start,
Dialogue: 0,0:24:36.94,0:24:37.88,EN,,0,0,0,,since we're being very literal,
Dialogue: 0,0:24:37.88,0:24:38.88,EN,,0,0,0,,we'd better remember that,
Dialogue: 0,0:24:39.07,0:24:40.54,EN,,0,0,0,,somewhere in this environment,
Dialogue: 0,0:24:40.57,0:24:42.36,EN,,0,0,0,,it's linked to another environment
Dialogue: 0,0:24:43.98,0:24:44.94,EN,,0,0,0,,in which plus
Dialogue: 0,0:24:45.72,0:24:49.16,EN,,0,0,0,,is bound to the primitive procedure plus
Dialogue: 0,0:24:51.63,0:24:54.03,EN,,0,0,0,,before we get an unknown variable in our machine.
Dialogue: 0,0:24:55.34,0:24:56.84,EN,,0,0,0,,OK, so we're at ev-application.
Dialogue: 0,0:24:59.85,0:25:04.32,EN,,0,0,0,,OK, assign to UNEV the operands
Dialogue: 0,0:25:04.92,0:25:06.89,EN,,0,0,0,,of what's in the expression register.
Dialogue: 0,0:25:07.61,0:25:08.83,EN,,0,0,0,,OK. Those are the operands.
Dialogue: 0,0:25:09.23,0:25:11.66,EN,,0,0,0,,UNEV's a temporary register
Dialogue: 0,0:25:11.68,0:25:12.59,EN,,0,0,0,,where we're going to save them.
Dialogue: 0,0:25:13.22,0:25:13.86,EN,,0,0,0,,PROFESSOR: I'm assigning.
Dialogue: 0,0:25:14.28,0:25:16.62,EN,,0,0,0,,PROFESSOR: Assign to EXP the operator.
Dialogue: 0,0:25:18.07,0:25:20.09,EN,,0,0,0,,Now, notice we've destroyed that expression in EXP,
Dialogue: 0,0:25:21.84,0:25:23.61,EN,,0,0,0,,but the piece that we need is now in UNEV.
Dialogue: 0,0:25:25.82,0:25:26.81,EN,,0,0,0,,Now, we're going to get set up to
Dialogue: 0,0:25:26.81,0:25:28.59,EN,,0,0,0,,to recursively evaluate the operator.
Dialogue: 0,0:25:28.75,0:25:31.69,EN,,0,0,0,,Save the continue register on the stack.
Dialogue: 0,0:25:34.86,0:25:36.09,EN,,0,0,0,,Save the environment.
Dialogue: 0,0:25:40.48,0:25:41.69,EN,,0,0,0,,Save UNEV.
Dialogue: 0,0:25:49.53,0:25:54.64,EN,,0,0,0,,OK, assign to continue a label called eval-args.
Dialogue: 0,0:26:01.40,0:26:01.95,EN,,0,0,0,,Now, what have we done?
Dialogue: 0,0:26:01.95,0:26:04.38,EN,,0,0,0,,We've set up for a recursive call.
Dialogue: 0,0:26:04.38,0:26:05.88,EN,,0,0,0,,We're about to go to eval-dispatch.
Dialogue: 0,0:26:06.28,0:26:08.83,EN,,0,0,0,,We've set up for a recursive call to eval-dispatch.
Dialogue: 0,0:26:10.23,0:26:10.86,EN,,0,0,0,,What did we do?
Dialogue: 0,0:26:11.02,0:26:13.64,EN,,0,0,0,,We took the things we're going to need later,
Dialogue: 0,0:26:14.48,0:26:15.98,EN,,0,0,0,,those operands that were in UNEV;
Dialogue: 0,0:26:16.36,0:26:18.99,EN,,0,0,0,,the environment in which we're going to eventually have to,
Dialogue: 0,0:26:19.16,0:26:20.72,EN,,0,0,0,,maybe, evaluate those operands;
Dialogue: 0,0:26:22.28,0:26:23.93,EN,,0,0,0,,the place we eventually want to go to,
Dialogue: 0,0:26:23.95,0:26:25.07,EN,,0,0,0,,which, in this case, was done;
Dialogue: 0,0:26:25.34,0:26:26.70,EN,,0,0,0,,we've saved them on the stack.
Dialogue: 0,0:26:27.10,0:26:28.41,EN,,0,0,0,,The reason we saved them on the stack
Dialogue: 0,0:26:28.43,0:26:30.67,EN,,0,0,0,,is because eval-dispatch makes no promises
Dialogue: 0,0:26:30.94,0:26:32.54,EN,,0,0,0,,about what registers it may destroy.
Dialogue: 0,0:26:33.55,0:26:35.02,EN,,0,0,0,,So all that stuff is saved on the stack.
Dialogue: 0,0:26:35.02,0:26:36.91,EN,,0,0,0,,Now, we've set up eval-dispatch's contract.
Dialogue: 0,0:26:37.38,0:26:38.75,EN,,0,0,0,,There's a new expression,
Dialogue: 0,0:26:38.78,0:26:40.04,EN,,0,0,0,,which is the operator plus;
Dialogue: 0,0:26:41.07,0:26:41.95,EN,,0,0,0,,a new environment,
Dialogue: 0,0:26:41.98,0:26:43.60,EN,,0,0,0,,although, in this case, it's the same one;
Dialogue: 0,0:26:44.25,0:26:45.87,EN,,0,0,0,,and a new place to go to when you're done,
Dialogue: 0,0:26:45.87,0:26:46.91,EN,,0,0,0,,which is eval-args.
Dialogue: 0,0:26:47.60,0:26:48.13,EN,,0,0,0,,So that's set up.
Dialogue: 0,0:26:48.13,0:26:49.68,EN,,0,0,0,,Now, we're going to go off to eval-dispatch.
Dialogue: 0,0:26:50.89,0:26:52.36,EN,,0,0,0,,Here we are back at eval-dispatch.
Dialogue: 0,0:26:53.05,0:26:54.40,EN,,0,0,0,,It's not self-evaluating.
Dialogue: 0,0:26:54.44,0:26:55.47,EN,,0,0,0,,Oh, it's a variable,
Dialogue: 0,0:26:56.32,0:26:58.06,EN,,0,0,0,,so we'd better go off to ev-variable,
Dialogue: 0,0:26:59.79,0:27:02.65,EN,,0,0,0,,Right? Ev-variable is assigned to VAL.
Dialogue: 0,0:27:02.70,0:27:06.33,EN,,0,0,0,,Look up the variable value of the expression,
Dialogue: 0,0:27:08.49,0:27:10.75,EN,,0,0,0,,OK? So VAL is the primitive procedure plus.
Dialogue: 0,0:27:13.37,0:27:15.16,EN,,0,0,0,,And go to fetch of continue.
Dialogue: 0,0:27:15.23,0:27:16.11,EN,,0,0,0,,PROFESSOR: Eval-args.
Dialogue: 0,0:27:16.20,0:27:18.73,EN,,0,0,0,,PROFESSOR: Right, which is now eval-args not done.
Dialogue: 0,0:27:19.42,0:27:21.26,EN,,0,0,0,,So we come back here at eval-args,
Dialogue: 0,0:27:22.16,0:27:23.02,EN,,0,0,0,,and what do we do?
Dialogue: 0,0:27:23.07,0:27:24.84,EN,,0,0,0,,We're going to restore the stuff that we saved,
Dialogue: 0,0:27:25.20,0:27:26.57,EN,,0,0,0,,so we restore UNEV.
Dialogue: 0,0:27:29.21,0:27:31.69,EN,,0,0,0,,And notice, there, it wasn't necessary,
Dialogue: 0,0:27:31.74,0:27:32.90,EN,,0,0,0,,although, in general, it would be.
Dialogue: 0,0:27:32.90,0:27:35.16,EN,,0,0,0,,It might be some arbitrary evaluation that happened.
Dialogue: 0,0:27:35.43,0:27:36.70,EN,,0,0,0,,We restore ENV.
Dialogue: 0,0:27:47.87,0:27:52.04,EN,,0,0,0,,OK, we assign to FUN fetch of VAL.
Dialogue: 0,0:27:59.95,0:28:02.81,EN,,0,0,0,,OK, now, we're going to go off and start evaluating some arguments.
Dialogue: 0,0:28:04.34,0:28:06.48,EN,,0,0,0,,Well, first thing we'd better do is save FUN
Dialogue: 0,0:28:07.42,0:28:10.62,EN,,0,0,0,,because some arbitrary stuff might happen in that evaluation.
Dialogue: 0,0:28:15.33,0:28:16.88,EN,,0,0,0,,We initialize the argument list.
Dialogue: 0,0:28:16.91,0:28:19.29,EN,,0,0,0,,Assign to argl an empty argument list,
Dialogue: 0,0:28:20.88,0:28:22.17,EN,,0,0,0,,and go to eval-arg-loop,
Dialogue: 0,0:28:24.86,0:28:26.27,EN,,0,0,0,,At eval-arg-loop,
Dialogue: 0,0:28:27.77,0:28:31.53,EN,,0,0,0,,the idea of this is we're going to evaluate the pieces of the
Dialogue: 0,0:28:31.61,0:28:33.37,EN,,0,0,0,,expressions that are in UNEV, one by one,
Dialogue: 0,0:28:33.54,0:28:35.68,EN,,0,0,0,,and move them from unevaluated in UNEV
Dialogue: 0,0:28:35.90,0:28:37.26,EN,,0,0,0,,to evaluated in the arg list.
Dialogue: 0,0:28:37.84,0:28:39.18,EN,,0,0,0,,OK. So we save argl.
Dialogue: 0,0:28:43.95,0:28:47.26,EN,,0,0,0,,We assign to EXP the first operand
Dialogue: 0,0:28:47.37,0:28:48.38,EN,,0,0,0,,of the stuff in UNEV.
Dialogue: 0,0:28:53.77,0:28:55.89,EN,,0,0,0,,Now, we check and see if that was the last operand.
Dialogue: 0,0:28:55.89,0:28:56.91,EN,,0,0,0,,In this case, it is not.
Dialogue: 0,0:28:58.99,0:29:01.55,EN,,0,0,0,,So we save the environment.
Dialogue: 0,0:29:08.00,0:29:10.06,EN,,0,0,0,,We save UNEV
Dialogue: 0,0:29:11.61,0:29:13.50,EN,,0,0,0,,because those are all things we might need later.
Dialogue: 0,0:29:13.50,0:29:14.40,EN,,0,0,0,,We're going to need the environment
Dialogue: 0,0:29:14.44,0:29:15.64,EN,,0,0,0,,to do some more evaluations.
Dialogue: 0,0:29:15.80,0:29:16.60,EN,,0,0,0,,We're going to need UNEV
Dialogue: 0,0:29:16.62,0:29:19.20,EN,,0,0,0,,to look at what the rest of those arguments were.
Dialogue: 0,0:29:20.34,0:29:21.55,EN,,0,0,0,,We're going to assign continue
Dialogue: 0,0:29:21.56,0:29:24.44,EN,,0,0,0,,a place called accumulate-args, or accumulate-arg.
Dialogue: 0,0:29:31.13,0:29:34.01,EN,,0,0,0,,OK, now, we've set up for another call to eval-dispatch,
Dialogue: 0,0:29:37.07,0:29:38.54,EN,,0,0,0,,All right, now, let me short-circuit this
Dialogue: 0,0:29:39.12,0:29:41.09,EN,,0,0,0,,so we don't go through the details of eval-dispatch.
Dialogue: 0,0:29:41.09,0:29:42.64,EN,,0,0,0,,Eval-dispatch's contract says
Dialogue: 0,0:29:42.97,0:29:45.00,EN,,0,0,0,,i'm going to end up,
Dialogue: 0,0:29:45.13,0:29:45.96,EN,,0,0,0,,the world will end up,
Dialogue: 0,0:29:46.03,0:29:48.20,EN,,0,0,0,,with the value of evaluating this expression
Dialogue: 0,0:29:48.24,0:29:50.27,EN,,0,0,0,,in this environment in the VAL register,
Dialogue: 0,0:29:50.27,0:29:51.07,EN,,0,0,0,,and I'll end up there.
Dialogue: 0,0:29:51.32,0:29:52.62,EN,,0,0,0,,So we short-circuit all of this,
Dialogue: 0,0:29:54.43,0:29:56.36,EN,,0,0,0,,and a 3 ends up in VAL.
Dialogue: 0,0:29:58.01,0:29:59.76,EN,,0,0,0,,And, when we return from eval-dispatch,
Dialogue: 0,0:29:59.76,0:30:01.76,EN,,0,0,0,,we're going to return to accumulate-arg.
Dialogue: 0,0:30:02.30,0:30:03.23,EN,,0,0,0,,PROFESSOR: Accumulate-arg.
Dialogue: 0,0:30:06.22,0:30:08.20,EN,,0,0,0,,PROFESSOR: With 3 in the VAL register, OK?
Dialogue: 0,0:30:08.72,0:30:10.59,EN,,0,0,0,,So that short-circuited that evaluation.
Dialogue: 0,0:30:10.65,0:30:11.32,EN,,0,0,0,,Now, what do we do?
Dialogue: 0,0:30:11.32,0:30:13.68,EN,,0,0,0,,We're going to go back and look at the rest of the arguments,
Dialogue: 0,0:30:13.68,0:30:14.83,EN,,0,0,0,,so we restore UNEV.
Dialogue: 0,0:30:17.51,0:30:19.00,EN,,0,0,0,,We restore ENV.
Dialogue: 0,0:30:25.79,0:30:27.05,EN,,0,0,0,,We restore argl.
Dialogue: 0,0:30:28.65,0:30:29.17,EN,,0,0,0,,One thing.
Dialogue: 0,0:30:30.06,0:30:31.45,EN,,0,0,0,,PROFESSOR: Oops! Parity error.
Dialogue: 0,0:30:33.76,0:30:34.83,EN,,0,0,0,,PROFESSOR: Restore argl.
Dialogue: 0,0:30:45.57,0:30:49.76,EN,,0,0,0,,OK, we assign to argl consing on
Dialogue: 0,0:30:50.65,0:30:52.64,EN,,0,0,0,,fetch of the value register to what's in argl.
Dialogue: 0,0:30:59.36,0:31:02.96,EN,,0,0,0,,OK, we assign to UNEV the rest of the operands
Dialogue: 0,0:31:03.34,0:31:04.52,EN,,0,0,0,,in fetch of UNEV,
Dialogue: 0,0:31:08.91,0:31:10.76,EN,,0,0,0,,and we go back to eval-arg-loop.
Dialogue: 0,0:31:11.51,0:31:12.28,EN,,0,0,0,,PROFESSOR: Eval-arg-loop.
Dialogue: 0,0:31:12.28,0:31:12.86,EN,,0,0,0,,PROFESSOR: OK.
Dialogue: 0,0:31:15.88,0:31:17.08,EN,,0,0,0,,Now, we're about to do the next argument,
Dialogue: 0,0:31:17.58,0:31:19.31,EN,,0,0,0,,so the first thing we do is save argl.
Dialogue: 0,0:31:25.40,0:31:28.27,EN,,0,0,0,,OK, we assign to EXP the first operand
Dialogue: 0,0:31:29.15,0:31:30.81,EN,,0,0,0,,of fetch of UNEV.
Dialogue: 0,0:31:34.72,0:31:37.02,EN,,0,0,0,,OK, we test and see if that's the last operand.
Dialogue: 0,0:31:37.02,0:31:38.00,EN,,0,0,0,,In this case, it is
Dialogue: 0,0:31:39.08,0:31:40.27,EN,,0,0,0,,so we're going to go to a special place
Dialogue: 0,0:31:40.28,0:31:42.06,EN,,0,0,0,,that says evaluate the last argument
Dialogue: 0,0:31:43.37,0:31:45.07,EN,,0,0,0,,because, notice,after evaluating the argument,
Dialogue: 0,0:31:45.10,0:31:46.62,EN,,0,0,0,,we don't need the environment any more.
Dialogue: 0,0:31:47.64,0:31:48.78,EN,,0,0,0,,That's going to be the difference.
Dialogue: 0,0:31:50.25,0:31:51.85,EN,,0,0,0,,So here, at eval-last-arg,
Dialogue: 0,0:31:52.24,0:31:54.92,EN,,0,0,0,,which is assigned to continue accumulate-last-arg,
Dialogue: 0,0:32:04.27,0:32:06.90,EN,,0,0,0,,now, we're set up again for eval-dispatch.
Dialogue: 0,0:32:06.90,0:32:08.51,EN,,0,0,0,,We've got a place to go to when we're done.
Dialogue: 0,0:32:08.62,0:32:09.84,EN,,0,0,0,,We've got an expression.
Dialogue: 0,0:32:09.84,0:32:10.80,EN,,0,0,0,,We've got an environment.
Dialogue: 0,0:32:11.33,0:32:13.64,EN,,0,0,0,,OK, so we'll short-circuit the call to eval-dispatch.
Dialogue: 0,0:32:14.37,0:32:16.41,EN,,0,0,0,,And what'll happen is there's a y there,
Dialogue: 0,0:32:16.70,0:32:18.56,EN,,0,0,0,,it's 4 in that environment,
Dialogue: 0,0:32:18.60,0:32:20.09,EN,,0,0,0,,so VAL will end up with 4 in it.
Dialogue: 0,0:32:21.06,0:32:22.86,EN,,0,0,0,,And, then, we're going to end up at accumulate-last-arg, OK?
Dialogue: 0,0:32:25.45,0:32:26.91,EN,,0,0,0,,So, at accumulate-last-arg,
Dialogue: 0,0:32:29.28,0:32:30.52,EN,,0,0,0,,we restore argl.
Dialogue: 0,0:32:37.69,0:32:42.76,EN,,0,0,0,,We assign to argl, we assign to argl cons,
Dialogue: 0,0:32:43.60,0:32:45.83,EN,,0,0,0,,of fetch of the new value onto it,
Dialogue: 0,0:32:45.93,0:32:47.39,EN,,0,0,0,,so we cons a 4 onto that.
Dialogue: 0,0:32:49.85,0:32:52.52,EN,,0,0,0,,We restore what was saved in the function register.
Dialogue: 0,0:32:53.77,0:32:54.99,EN,,0,0,0,,And notice, in this case,
Dialogue: 0,0:32:55.00,0:32:56.27,EN,,0,0,0,,it had not been destroyed,
Dialogue: 0,0:32:56.38,0:32:57.72,EN,,0,0,0,,but in general, it will be.
Dialogue: 0,0:32:59.13,0:33:01.50,EN,,0,0,0,,And now, we're ready to go off to apply-dispatch,
Dialogue: 0,0:33:02.65,0:33:04.40,EN,,0,0,0,,Alright? So we've just gone through the eval.
Dialogue: 0,0:33:04.51,0:33:05.85,EN,,0,0,0,,We evaluated the argument,
Dialogue: 0,0:33:06.46,0:33:07.98,EN,,0,0,0,,the operator, and the arguments,
Dialogue: 0,0:33:07.98,0:33:09.24,EN,,0,0,0,,and now, we're about to apply them.
Dialogue: 0,0:33:09.58,0:33:11.37,EN,,0,0,0,,So we come off to apply-dispatch here
Dialogue: 0,0:33:18.03,0:33:19.29,EN,,0,0,0,,We come off to apply-dispatch,
Dialogue: 0,0:33:21.05,0:33:22.41,EN,,0,0,0,,and we're going to check whether it's a primitive
Dialogue: 0,0:33:22.41,0:33:23.45,EN,,0,0,0,,or a compound procedure.
Dialogue: 0,0:33:23.64,0:33:24.20,EN,,0,0,0,,PROFESSOR: Yes.
Dialogue: 0,0:33:24.54,0:33:24.83,EN,,0,0,0,,PROFESSOR: All right.
Dialogue: 0,0:33:24.89,0:33:26.52,EN,,0,0,0,,So, in this case, it's a primitive procedure,
Dialogue: 0,0:33:27.45,0:33:28.91,EN,,0,0,0,,and we go off to primitive-apply.
Dialogue: 0,0:33:29.79,0:33:31.36,EN,,0,0,0,,So we go off to primitive-apply,
Dialogue: 0,0:33:33.71,0:33:35.37,EN,,0,0,0,,that says assign to VAL
Dialogue: 0,0:33:35.69,0:33:38.25,EN,,0,0,0,,result of applying primitive procedure
Dialogue: 0,0:33:38.36,0:33:40.30,EN,,0,0,0,,of the function to the argument list.
Dialogue: 0,0:33:41.31,0:33:42.43,EN,,0,0,0,,PROFESSOR: I don't know how to add.
Dialogue: 0,0:33:42.54,0:33:43.80,EN,,0,0,0,,I'm just an execution unit.
Dialogue: 0,0:33:44.14,0:33:45.35,EN,,0,0,0,,PROFESSOR: Well, I don't know how to add either.
Dialogue: 0,0:33:45.35,0:33:46.51,EN,,0,0,0,,I'm just the evaluator,
Dialogue: 0,0:33:47.08,0:33:48.36,EN,,0,0,0,,so we need a primitive operator.
Dialogue: 0,0:33:48.36,0:33:49.72,EN,,0,0,0,,Let's see, so the primitive operator,
Dialogue: 0,0:33:49.76,0:33:52.36,EN,,0,0,0,,What's the... what's the sum of 3 and 4?
Dialogue: 0,0:33:52.86,0:33:53.32,EN,,0,0,0,,AUDIENCE: 7.
Dialogue: 0,0:33:53.71,0:33:54.65,EN,,0,0,0,,PROFESSOR: OK, 7.
Dialogue: 0,0:33:55.32,0:33:55.99,EN,,0,0,0,,PROFESSOR: Thank you.
Dialogue: 0,0:33:59.20,0:34:00.60,EN,,0,0,0,,PROFESSOR: Now, we restore continue,
Dialogue: 0,0:34:11.58,0:34:12.90,EN,,0,0,0,,and we go to fetch of continue.
Dialogue: 0,0:34:13.07,0:34:13.47,EN,,0,0,0,,PROFESSOR: Done.
Dialogue: 0,0:34:14.20,0:34:14.67,EN,,0,0,0,,PROFESSOR: OK.
Dialogue: 0,0:34:14.92,0:34:18.41,EN,,0,0,0,,Well, that was in as much detail as you will ever see.
Dialogue: 0,0:34:18.41,0:34:20.19,EN,,0,0,0,,We'll never do it in as much detail again.
Dialogue: 0,0:34:21.59,0:34:23.92,EN,,0,0,0,,One very important thing to notice
Dialogue: 0,0:34:24.91,0:34:27.55,EN,,0,0,0,,is that we just executed a recursive procedure,
Dialogue: 0,0:34:29.56,0:34:31.17,EN,,0,0,0,,Right? This whole thing, we used a stack
Dialogue: 0,0:34:31.17,0:34:32.75,EN,,0,0,0,,and the evaluator was recursive.
Dialogue: 0,0:34:33.07,0:34:35.88,EN,,0,0,0,,A lot of people think the reason that you need a stack
Dialogue: 0,0:34:36.48,0:34:37.85,EN,,0,0,0,,and recursion in an evaluator
Dialogue: 0,0:34:37.87,0:34:38.97,EN,,0,0,0,,is because you might be
Dialogue: 0,0:34:39.09,0:34:42.15,EN,,0,0,0,,evaluating recursive procedures like factorial or Fibonacci.
Dialogue: 0,0:34:42.15,0:34:42.92,EN,,0,0,0,,It's not true.
Dialogue: 0,0:34:43.67,0:34:44.99,EN,,0,0,0,,So you notice we did recursion here,
Dialogue: 0,0:34:45.00,0:34:46.86,EN,,0,0,0,,and all we evaluated was (+ x y)
Dialogue: 0,0:34:47.77,0:34:50.65,EN,,0,0,0,,Right? The reason that you need recursion in the evaluator
Dialogue: 0,0:34:50.96,0:34:52.97,EN,,0,0,0,,is because the evaluation process,
Dialogue: 0,0:34:52.99,0:34:54.06,EN,,0,0,0,,itself, is recursive.
Dialogue: 0,0:34:54.45,0:34:56.17,EN,,0,0,0,,Right? It's not because the procedure
Dialogue: 0,0:34:56.32,0:34:58.09,EN,,0,0,0,,that you might be evaluating in LISP
Dialogue: 0,0:34:58.12,0:34:59.27,EN,,0,0,0,,is a recursive procedure.
Dialogue: 0,0:34:59.27,0:35:00.52,EN,,0,0,0,,So that's an important thing
Dialogue: 0,0:35:00.52,0:35:02.14,EN,,0,0,0,,that people get confused about a lot.
Dialogue: 0,0:35:03.01,0:35:04.27,EN,,0,0,0,,The other thing to notice is that,
Dialogue: 0,0:35:04.27,0:35:05.64,EN,,0,0,0,,when we're done here,
Dialogue: 0,0:35:06.28,0:35:07.12,EN,,0,0,0,,we're really done.
Dialogue: 0,0:35:07.12,0:35:08.49,EN,,0,0,0,,Not only are we at done,
Dialogue: 0,0:35:09.45,0:35:13.23,EN,,0,0,0,,but there's no accumulated stuff on the stack,
Dialogue: 0,0:35:13.60,0:35:15.71,EN,,0,0,0,,Right? The machine is back to its initial state.
Dialogue: 0,0:35:17.00,0:35:18.75,EN,,0,0,0,,So that's part of what it means to be done.
Dialogue: 0,0:35:19.71,0:35:21.04,EN,,0,0,0,,Another way to say that is
Dialogue: 0,0:35:22.72,0:35:26.04,EN,,0,0,0,,the evaluation process has reduced
Dialogue: 0,0:35:26.41,0:35:28.32,EN,,0,0,0,,the expression, plus X, Y,
Dialogue: 0,0:35:30.54,0:35:32.78,EN,,0,0,0,,to the value here, 7.
Dialogue: 0,0:35:33.24,0:35:35.45,EN,,0,0,0,,And by reduced, I mean a very particular thing.
Dialogue: 0,0:35:36.01,0:35:38.18,EN,,0,0,0,,It means that there's nothing left on the stack.
Dialogue: 0,0:35:38.18,0:35:40.36,EN,,0,0,0,,The machine is now in the same state,
Dialogue: 0,0:35:40.92,0:35:42.65,EN,,0,0,0,,except there's something in the value register.
Dialogue: 0,0:35:42.72,0:35:44.52,EN,,0,0,0,,It's not part of a sub-problem of anything.
Dialogue: 0,0:35:44.52,0:35:45.63,EN,,0,0,0,,There's nothing to go back to.
Dialogue: 0,0:35:46.12,0:35:46.96,EN,,0,0,0,,OK. Let's break.
Dialogue: 0,0:35:50.16,0:35:50.76,EN,,0,0,0,,Question?
Dialogue: 0,0:35:51.08,0:35:54.02,EN,,0,0,0,,AUDIENCE: The question here, in the stack,
Dialogue: 0,0:35:54.02,0:35:55.82,EN,,0,0,0,,is because the data may be recursive.
Dialogue: 0,0:35:56.20,0:35:58.75,EN,,0,0,0,,You may have embedded expressions, for instance.
Dialogue: 0,0:35:59.31,0:36:02.08,EN,,0,0,0,,PROFESSOR: Yes, because you might have embedded expressions.
Dialogue: 0,0:36:02.08,0:36:04.77,EN,,0,0,0,,But, again, don't confuse that
Dialogue: 0,0:36:04.77,0:36:07.98,EN,,0,0,0,,with what people sometimes mean by the data may be recursive,
Dialogue: 0,0:36:08.00,0:36:10.35,EN,,0,0,0,,which is to say you have these list-structured,
Dialogue: 0,0:36:11.04,0:36:12.93,EN,,0,0,0,,recursive data list operations.
Dialogue: 0,0:36:12.93,0:36:13.96,EN,,0,0,0,,That has nothing to do with it.
Dialogue: 0,0:36:13.98,0:36:16.16,EN,,0,0,0,,It's simply that the expressions contain sub-expressions.
Dialogue: 0,0:36:20.04,0:36:23.52,EN,,0,0,0,,AUDIENCE: Why is it that the order of the arguments in the arg list got reversed?
Dialogue: 0,0:36:23.55,0:36:25.29,EN,,0,0,0,,PROFESSOR: Ah! Yes, I should've mentioned that.
Dialogue: 0,0:36:27.26,0:36:29.07,EN,,0,0,0,,Here, the reason the order is reversed--
Dialogue: 0,0:36:32.78,0:36:35.37,EN,,0,0,0,,it's a question of what you mean by reversed.
Dialogue: 0,0:36:36.05,0:36:39.90,EN,,0,0,0,,I believe it was Newton.
Dialogue: 0,0:36:40.91,0:36:42.41,EN,,0,0,0,,In the very early part of optics,
Dialogue: 0,0:36:42.43,0:36:43.26,EN,,0,0,0,,people realized
Dialogue: 0,0:36:43.61,0:36:45.36,EN,,0,0,0,,that when you look through the lens of your eye,
Dialogue: 0,0:36:45.50,0:36:46.73,EN,,0,0,0,,the image was up-side down.
Dialogue: 0,0:36:46.73,0:36:48.04,EN,,0,0,0,,And there was a lot of argument about
Dialogue: 0,0:36:48.04,0:36:50.48,EN,,0,0,0,,why that didn't mean you saw things up-side down.
Dialogue: 0,0:36:51.28,0:36:52.65,EN,,0,0,0,,So it's sort of the same issue.
Dialogue: 0,0:36:52.86,0:36:53.90,EN,,0,0,0,,Reversed from what?
Dialogue: 0,0:36:54.81,0:36:56.24,EN,,0,0,0,,So we just need some convention.
Dialogue: 0,0:36:56.59,0:37:00.35,EN,,0,0,0,,So all we.. The reason that they're coming at 4, 3
Dialogue: 0,0:37:00.80,0:37:02.49,EN,,0,0,0,,is because taking UNEV
Dialogue: 0,0:37:02.52,0:37:04.03,EN,,0,0,0,,and consing the result onto argl.
Dialogue: 0,0:37:04.52,0:37:06.68,EN,,0,0,0,,So you have to realize you've made that convention.
Dialogue: 0,0:37:06.86,0:37:09.37,EN,,0,0,0,,The place that you have to realize that--
Dialogue: 0,0:37:09.98,0:37:11.23,EN,,0,0,0,,well, there's actually two places.
Dialogue: 0,0:37:11.23,0:37:12.91,EN,,0,0,0,,One is in apply-primitive-operator,
Dialogue: 0,0:37:12.91,0:37:14.06,EN,,0,0,0,,which has to realize that
Dialogue: 0,0:37:15.12,0:37:16.75,EN,,0,0,0,,the arguments to primitives go in,
Dialogue: 0,0:37:16.78,0:37:18.72,EN,,0,0,0,,the opposite order from the way you're writing them down.
Dialogue: 0,0:37:19.49,0:37:21.00,EN,,0,0,0,,And the other one is, we'll see later
Dialogue: 0,0:37:21.07,0:37:23.80,EN,,0,0,0,,when you actually go to bind a function's parameters,
Dialogue: 0,0:37:24.01,0:37:25.74,EN,,0,0,0,,you should realize the arguments are going to come in
Dialogue: 0,0:37:25.74,0:37:28.54,EN,,0,0,0,,from the opposite order of the variables to which you're binding them.
Dialogue: 0,0:37:28.87,0:37:30.17,EN,,0,0,0,,So, if you just keep track of that,
Dialogue: 0,0:37:31.08,0:37:31.83,EN,,0,0,0,,there's no problem.
Dialogue: 0,0:37:31.83,0:37:33.69,EN,,0,0,0,,Also, this is completely arbitrary
Dialogue: 0,0:37:33.90,0:37:34.96,EN,,0,0,0,,because, if we'd done,
Dialogue: 0,0:37:35.10,0:37:37.15,EN,,0,0,0,,say, an iteration through a vector assigning them,
Dialogue: 0,0:37:37.42,0:37:38.73,EN,,0,0,0,,they might come out in the other order.
Dialogue: 0,0:37:40.41,0:37:42.04,EN,,0,0,0,,OK. So it's just a convention of the way
Dialogue: 0,0:37:42.06,0:37:43.53,EN,,0,0,0,,this particular evaluator works.
Dialogue: 0,0:37:45.39,0:37:46.24,EN,,0,0,0,,All right, let's take a break.
Dialogue: 0,0:37:46.33,0:38:02.44,EN,,0,0,0,,[JESU, JOY OF MAN'S DESIRING]
Dialogue: 0,0:38:02.44,0:38:07.64,EN,,0,0,0,,The Structure And Interpretation of Computer Programs
Dialogue: 0,0:38:28.62,0:38:32.51,EN,,0,0,0,,By: Prof. Harold Abelson && Sussman Jay Sussman
Dialogue: 0,0:38:32.51,0:38:35.68,EN,,0,0,0,,The Structure And Interpretation of Computer Programs
Dialogue: 0,0:38:41.84,0:38:45.31,EN,,0,0,0,,Professor: We just saw evaluating an expression
Dialogue: 0,0:38:45.60,0:38:47.08,EN,,0,0,0,,and, of course, that was very simple one. But
Dialogue: 0,0:38:48.81,0:38:50.24,EN,,0,0,0,,in essence, it would be no different
Dialogue: 0,0:38:50.24,0:38:52.03,EN,,0,0,0,,if it was some big nested expression,
Dialogue: 0,0:38:52.03,0:38:54.57,EN,,0,0,0,,so there would just be deeper recursion on the stack.
Dialogue: 0,0:38:55.13,0:38:56.03,EN,,0,0,0,,But what I want to do now
Dialogue: 0,0:38:56.04,0:38:56.91,EN,,0,0,0,,is show you the last piece.
Dialogue: 0,0:38:56.92,0:38:59.82,EN,,0,0,0,,I want to walk you around this eval and apply loop,
Dialogue: 0,0:39:01.01,0:39:02.81,EN,,0,0,0,,That's the thing we haven't seen, really.
Dialogue: 0,0:39:03.00,0:39:04.75,EN,,0,0,0,,We haven't seen any compound procedures
Dialogue: 0,0:39:05.20,0:39:07.79,EN,,0,0,0,,where evalutation of procedure reduces to
Dialogue: 0,0:39:07.92,0:39:10.11,EN,,0,0,0,,where applying of procedure reduces to
Dialogue: 0,0:39:10.12,0:39:11.64,EN,,0,0,0,,evaluating the body of the procedure,
Dialogue: 0,0:39:12.44,0:39:15.88,EN,,0,0,0,,so let's just suppose we had this.
Dialogue: 0,0:39:15.93,0:39:17.44,EN,,0,0,0,,Suppose we were looking at the procedure
Dialogue: 0,0:39:18.07,0:39:31.60,EN,,0,0,0,,define F of A and B to be the sum of A and B.
Dialogue: 0,0:39:33.99,0:39:37.32,EN,,0,0,0,,So, as we typed in that procedure previously,
Dialogue: 0,0:39:37.69,0:39:41.64,EN,,0,0,0,,and now we're going to evaluate F of X and Y
Dialogue: 0,0:39:42.27,0:39:44.20,EN,,0,0,0,,again, in this environment, E,0,
Dialogue: 0,0:39:44.35,0:39:47.02,EN,,0,0,0,,where X is bound to 3 and Y is bound to 4.
Dialogue: 0,0:39:50.78,0:39:52.11,EN,,0,0,0,,When the defined is executed,
Dialogue: 0,0:39:52.12,0:39:53.69,EN,,0,0,0,,remember, there's a lambda here,
Dialogue: 0,0:39:53.82,0:39:55.53,EN,,0,0,0,,and lambdas create procedures.
Dialogue: 0,0:39:55.95,0:39:58.49,EN,,0,0,0,,And, basically, what will happen is,
Dialogue: 0,0:39:59.63,0:40:00.68,EN,,0,0,0,,in E0,
Dialogue: 0,0:40:01.00,0:40:02.65,EN,,0,0,0,,we'll end up with a binding for F,
Dialogue: 0,0:40:03.56,0:40:05.61,EN,,0,0,0,,which will say F is a procedure,
Dialogue: 0,0:40:07.15,0:40:11.28,EN,,0,0,0,,and its args are A and B,
Dialogue: 0,0:40:12.57,0:40:16.19,EN,,0,0,0,,and its body is plus a,b.
Dialogue: 0,0:40:18.11,0:40:20.99,EN,,0,0,0,,So that's what the environment would have looked like
Dialogue: 0,0:40:21.21,0:40:22.52,EN,,0,0,0,,had we made that definition.
Dialogue: 0,0:40:24.22,0:40:27.28,EN,,0,0,0,,Then, when we go to evaluate F of X and Y,
Dialogue: 0,0:40:28.80,0:40:30.89,EN,,0,0,0,,we'll go through exactly the same process
Dialogue: 0,0:40:31.02,0:40:31.85,EN,,0,0,0,,that we did before.
Dialogue: 0,0:40:31.88,0:40:33.09,EN,,0,0,0,,It's even the same expression.
Dialogue: 0,0:40:33.28,0:40:34.38,EN,,0,0,0,,The only difference is that
Dialogue: 0,0:40:34.40,0:40:36.64,EN,,0,0,0,,F, instead of having primitive "plus" in it
Dialogue: 0,0:40:37.24,0:40:38.99,EN,,0,0,0,,will have this thing.
Dialogue: 0,0:40:41.04,0:40:43.60,EN,,0,0,0,,And so we'll go through exactly the same process,
Dialogue: 0,0:40:43.60,0:40:44.92,EN,,0,0,0,,except this time, when we end up
Dialogue: 0,0:40:45.26,0:40:47.42,EN,,0,0,0,,at apply-dispatch,
Dialogue: 0,0:40:47.86,0:40:50.28,EN,,0,0,0,,the function register, instead of having primitive plus,
Dialogue: 0,0:40:50.44,0:40:53.58,EN,,0,0,0,,will have a thing that will represent it saying procedure,
Dialogue: 0,0:40:54.30,0:40:59.00,EN,,0,0,0,,where the args are A and B,
Dialogue: 0,0:41:00.64,0:41:06.27,EN,,0,0,0,,and the body is plus A, B.
Dialogue: 0,0:41:07.87,0:41:09.92,EN,,0,0,0,,And, again, what I mean, by its ENV,
Dialogue: 0,0:41:09.96,0:41:11.12,EN,,0,0,0,,I mean there's a pointer to it,
Dialogue: 0,0:41:11.24,0:41:13.07,EN,,0,0,0,,so don't worry that I'm writing a lot of stuff there.
Dialogue: 0,0:41:13.28,0:41:15.63,EN,,0,0,0,,There's a pointer to this procedure data structure.
Dialogue: 0,0:41:17.17,0:41:19.77,EN,,0,0,0,,OK, so, we're in exactly the same situation.
Dialogue: 0,0:41:20.27,0:41:22.43,EN,,0,0,0,,We get to apply-dispatch,
Dialogue: 0,0:41:23.98,0:41:26.48,EN,,0,0,0,,so, here, we come to apply-dispatch.
Dialogue: 0,0:41:26.48,0:41:28.73,EN,,0,0,0,,Last time, we branched off to a primitive procedure.
Dialogue: 0,0:41:30.01,0:41:30.70,EN,,0,0,0,,Here, it says oh,
Dialogue: 0,0:41:30.84,0:41:32.80,EN,,0,0,0,,we now have a compound procedure,
Dialogue: 0,0:41:34.55,0:41:36.60,EN,,0,0,0,,so we're going to go off to compound-apply.
Dialogue: 0,0:41:38.47,0:41:39.92,EN,,0,0,0,,Now, what's compound-apply?
Dialogue: 0,0:41:41.92,0:41:44.54,EN,,0,0,0,,Well, remember what the meta-circular evaluator did?
Dialogue: 0,0:41:45.09,0:41:47.40,EN,,0,0,0,,Compound-apply said we're going to evaluate
Dialogue: 0,0:41:49.90,0:41:51.60,EN,,0,0,0,,the body of the procedure
Dialogue: 0,0:41:52.94,0:41:54.12,EN,,0,0,0,,in some new environment.
Dialogue: 0,0:41:54.12,0:41:55.87,EN,,0,0,0,,Where does that new environment come from?
Dialogue: 0,0:41:56.73,0:42:01.36,EN,,0,0,0,,We take the environment that was packaged with the procedure,
Dialogue: 0,0:42:03.02,0:42:05.79,EN,,0,0,0,,we bind the parameters of the procedure
Dialogue: 0,0:42:06.00,0:42:07.63,EN,,0,0,0,,to the arguments that we're passing in,
Dialogue: 0,0:42:09.75,0:42:11.95,EN,,0,0,0,,and use that as a new frame to extend
Dialogue: 0,0:42:12.59,0:42:13.79,EN,,0,0,0,,the procedure environment.
Dialogue: 0,0:42:14.99,0:42:16.08,EN,,0,0,0,,And that's the environment
Dialogue: 0,0:42:16.30,0:42:18.88,EN,,0,0,0,,in which we evaluate the procedure body,
Dialogue: 0,0:42:20.12,0:42:24.47,EN,,0,0,0,,Right? That's going around the apply/eval loop.
Dialogue: 0,0:42:24.47,0:42:26.25,EN,,0,0,0,,That's apply coming back to call eval,
Dialogue: 0,0:42:32.86,0:42:34.92,EN,,0,0,0,,So, now, that's all we have to do in compound-apply.
Dialogue: 0,0:42:36.78,0:42:37.72,EN,,0,0,0,,What are we going to do?
Dialogue: 0,0:42:37.72,0:42:40.97,EN,,0,0,0,,We're going to manufacture a new environment.
Dialogue: 0,0:42:43.55,0:42:45.64,EN,,0,0,0,,And we're going to manufacture a new environment that,
Dialogue: 0,0:42:46.76,0:42:48.11,EN,,0,0,0,,let's see, that we'll call E1.
Dialogue: 0,0:42:52.90,0:42:55.63,EN,,0,0,0,,E1 is going to be some environment where the
Dialogue: 0,0:42:57.31,0:42:59.15,EN,,0,0,0,,where the parameters of the procedure,
Dialogue: 0,0:42:59.21,0:43:03.26,EN,,0,0,0,,Nwhere A is bound to 3, and B is bound to 4,
Dialogue: 0,0:43:04.27,0:43:05.76,EN,,0,0,0,,and it's linked to E0
Dialogue: 0,0:43:05.76,0:43:08.08,EN,,0,0,0,,because that's where f is defined.
Dialogue: 0,0:43:09.27,0:43:10.27,EN,,0,0,0,,And, in this environment,
Dialogue: 0,0:43:10.27,0:43:11.96,EN,,0,0,0,,we're going to evaluate the body of the procedure.
Dialogue: 0,0:43:12.05,0:43:14.48,EN,,0,0,0,,So let's look at that, we're going
Dialogue: 0,0:43:16.52,0:43:18.32,EN,,0,0,0,,Here we are at compound-apply,
Dialogue: 0,0:43:20.30,0:43:23.47,EN,,0,0,0,,which says assign to the expression register
Dialogue: 0,0:43:24.50,0:43:25.98,EN,,0,0,0,,the body of the procedure
Dialogue: 0,0:43:25.98,0:43:27.26,EN,,0,0,0,,that's in the function register.
Dialogue: 0,0:43:28.38,0:43:30.64,EN,,0,0,0,,So I assign to the expression register
Dialogue: 0,0:43:31.29,0:43:32.33,EN,,0,0,0,,the procedure body,
Dialogue: 0,0:43:40.75,0:43:41.10,EN,,0,0,0,,OK?
Dialogue: 0,0:43:42.64,0:43:44.97,EN,,0,0,0,,That's going to be evaluated in an environment
Dialogue: 0,0:43:45.82,0:43:48.32,EN,,0,0,0,,which is formed by making some bindings
Dialogue: 0,0:43:51.30,0:43:53.67,EN,,0,0,0,,using information determined by the procedure--
Dialogue: 0,0:43:53.67,0:43:56.25,EN,,0,0,0,,that's what's in FUN-- and the argument list.
Dialogue: 0,0:43:57.80,0:44:00.00,EN,,0,0,0,,And let's not worry about exactly what that does,
Dialogue: 0,0:44:00.08,0:44:01.63,EN,,0,0,0,,but you can see the information's there.
Dialogue: 0,0:44:01.93,0:44:03.32,EN,,0,0,0,,So make bindings will say oh,
Dialogue: 0,0:44:04.04,0:44:07.90,EN,,0,0,0,,the procedure, itself, had an environment attached to it.
Dialogue: 0,0:44:07.96,0:44:09.32,EN,,0,0,0,,I didn't write that quite here.
Dialogue: 0,0:44:09.36,0:44:10.56,EN,,0,0,0,,I should've said in environment
Dialogue: 0,0:44:11.30,0:44:12.73,EN,,0,0,0,,because every procedure gets built
Dialogue: 0,0:44:12.76,0:44:13.44,EN,,0,0,0,,with an environment.
Dialogue: 0,0:44:13.66,0:44:14.83,EN,,0,0,0,,So, from that environment,
Dialogue: 0,0:44:15.68,0:44:16.35,EN,,0,0,0,,it knows
Dialogue: 0,0:44:16.60,0:44:18.65,EN,,0,0,0,,what the procedure's definition environment is.
Dialogue: 0,0:44:19.29,0:44:20.75,EN,,0,0,0,,It knows what the arguments are.
Dialogue: 0,0:44:21.83,0:44:22.49,EN,,0,0,0,,It looks at argl,
Dialogue: 0,0:44:22.49,0:44:24.28,EN,,0,0,0,,and then you see a reversal convention here.
Dialogue: 0,0:44:24.28,0:44:26.62,EN,,0,0,0,,It just has to know that argl is reversed,
Dialogue: 0,0:44:27.06,0:44:28.81,EN,,0,0,0,,and it builds this frame, E,1.
Dialogue: 0,0:44:29.99,0:44:31.08,EN,,0,0,0,,All right, so, let's assume that
Dialogue: 0,0:44:31.10,0:44:32.92,EN,,0,0,0,,that's what make bindings returns,
Dialogue: 0,0:44:33.36,0:44:36.22,EN,,0,0,0,,so it assigns to ENV this thing, E,1.
Dialogue: 0,0:44:41.34,0:44:42.54,EN,,0,0,0,,The next thing it says
Dialogue: 0,0:44:43.95,0:44:45.84,EN,,0,0,0,,is restore continue.
Dialogue: 0,0:44:46.89,0:44:48.19,EN,,0,0,0,,Remember what continue was here?
Dialogue: 0,0:44:48.76,0:44:50.43,EN,,0,0,0,,It got put up in the last segment.
Dialogue: 0,0:44:52.24,0:44:54.02,EN,,0,0,0,,Continue got stored.
Dialogue: 0,0:44:54.02,0:44:55.18,EN,,0,0,0,,That was the original done,
Dialogue: 0,0:44:55.32,0:44:56.56,EN,,0,0,0,,which said what are you going to do
Dialogue: 0,0:44:56.73,0:44:59.44,EN,,0,0,0,,after you're done with this particular application?
Dialogue: 0,0:45:00.14,0:45:01.72,EN,,0,0,0,,It was one of the very first things that happened
Dialogue: 0,0:45:01.76,0:45:03.18,EN,,0,0,0,,when we evaluated the application.
Dialogue: 0,0:45:03.88,0:45:05.87,EN,,0,0,0,,And now, finally, we're going to restore continue.
Dialogue: 0,0:45:06.86,0:45:09.55,EN,,0,0,0,,Remember apply-dispatch's contract.
Dialogue: 0,0:45:09.58,0:45:11.20,EN,,0,0,0,,It assumes that where it should go to next
Dialogue: 0,0:45:11.23,0:45:11.98,EN,,0,0,0,,was on the stack,
Dialogue: 0,0:45:12.03,0:45:13.12,EN,,0,0,0,,and there it was on the stack.
Dialogue: 0,0:45:13.59,0:45:14.76,EN,,0,0,0,,Continue has done,
Dialogue: 0,0:45:17.82,0:45:19.90,EN,,0,0,0,,and now we're going to go back to eval-dispatch.
Dialogue: 0,0:45:19.94,0:45:20.84,EN,,0,0,0,,We're set up again.
Dialogue: 0,0:45:20.97,0:45:24.41,EN,,0,0,0,,We have an expression, an environment, and a place to go to.
Dialogue: 0,0:45:25.80,0:45:26.89,EN,,0,0,0,,We're not going to go through that
Dialogue: 0,0:45:27.88,0:45:29.55,EN,,0,0,0,,because it's sort of the same expression.
Dialogue: 0,0:45:35.40,0:45:37.79,EN,,0,0,0,,OK, but the thing, again, to notice
Dialogue: 0,0:45:37.82,0:45:38.73,EN,,0,0,0,,is, at this point,
Dialogue: 0,0:45:39.34,0:45:43.72,EN,,0,0,0,,we have reduced the original expression, F,X,Y,
Dialogue: 0,0:45:44.64,0:45:47.92,EN,,0,0,0,,We've reduced evaluating F,X,Y in environment E,0
Dialogue: 0,0:45:48.89,0:45:52.67,EN,,0,0,0,,to evaluate plus A, B in E,1.
Dialogue: 0,0:45:52.78,0:45:55.92,EN,,0,0,0,,And notice, nothing's on the stack, right?
Dialogue: 0,0:45:56.11,0:45:56.83,EN,,0,0,0,,It's a reduction.
Dialogue: 0,0:45:56.84,0:45:59.80,EN,,0,0,0,,At this point, the machine does not contain,
Dialogue: 0,0:45:59.84,0:46:01.20,EN,,0,0,0,,as part of its state,
Dialogue: 0,0:46:01.76,0:46:03.71,EN,,0,0,0,,the fact that it's in the middle of evaluating
Dialogue: 0,0:46:03.72,0:46:04.88,EN,,0,0,0,,some procedure called f,
Dialogue: 0,0:46:05.49,0:46:06.28,EN,,0,0,0,,that's gone,
Dialogue: 0,0:46:07.66,0:46:09.55,EN,,0,0,0,,Right? There's no accumulated state?
Dialogue: 0,0:46:13.07,0:46:14.37,EN,,0,0,0,,Again, that's a very important idea.
Dialogue: 0,0:46:14.37,0:46:16.33,EN,,0,0,0,,That's the meaning of,
Dialogue: 0,0:46:16.76,0:46:18.39,EN,,0,0,0,,when we used to write in the substitution model,
Dialogue: 0,0:46:18.39,0:46:20.86,EN,,0,0,0,,this expression reduces to that expression.
Dialogue: 0,0:46:21.35,0:46:22.66,EN,,0,0,0,,And you don't have to remember anything.
Dialogue: 0,0:46:22.66,0:46:24.50,EN,,0,0,0,,And here, you see the meaning of reduction.
Dialogue: 0,0:46:24.56,0:46:26.16,EN,,0,0,0,,At this point, there is nothing on the stack.
Dialogue: 0,0:46:31.59,0:46:33.63,EN,,0,0,0,,See, that has very important consequences.
Dialogue: 0,0:46:35.24,0:46:37.90,EN,,0,0,0,,Let's go back and look at iterative factorial,
Dialogue: 0,0:46:40.42,0:46:42.76,EN,,0,0,0,,all right? Remember, this was some sort of loop
Dialogue: 0,0:46:44.01,0:46:44.88,EN,,0,0,0,,and doing iter.
Dialogue: 0,0:46:45.13,0:46:47.36,EN,,0,0,0,,And we kept saying that's an iterative procedure,
Dialogue: 0,0:46:49.26,0:46:53.84,EN,,0,0,0,,And what we wrote, remember,
Dialogue: 0,0:46:58.44,0:47:03.13,EN,,0,0,0,,are things like, we said,
Dialogue: 0,0:47:04.35,0:47:11.07,EN,,0,0,0,,fact-iter of 5.
Dialogue: 0,0:47:12.36,0:47:18.67,EN,,0,0,0,,We wrote things like reduces to iter of 1, and 1, and 5,
Dialogue: 0,0:47:19.03,0:47:25.15,EN,,0,0,0,,which reduces to iter of 1, and 2, and 5,
Dialogue: 0,0:47:25.32,0:47:27.07,EN,,0,0,0,,and so on, and so on, and so on.
Dialogue: 0,0:47:27.07,0:47:28.17,EN,,0,0,0,,And we kept saying well, look,
Dialogue: 0,0:47:28.17,0:47:30.35,EN,,0,0,0,,you don't have to build up any storage to do that.
Dialogue: 0,0:47:31.72,0:47:32.73,EN,,0,0,0,,And we waved our hands,
Dialogue: 0,0:47:32.75,0:47:34.59,EN,,0,0,0,,and said in principle, there's no storage needed.
Dialogue: 0,0:47:35.04,0:47:36.17,EN,,0,0,0,,Now, you see no storage needed.
Dialogue: 0,0:47:36.17,0:47:39.09,EN,,0,0,0,,Each of these is a real reduction, right?
Dialogue: 0,0:47:39.09,0:47:42.60,EN,,0,0,0,,As you walk through these expressions,
Dialogue: 0,0:47:47.30,0:47:50.51,EN,,0,0,0,,As you walk through these expressions,
Dialogue: 0,0:47:50.83,0:47:51.37,EN,,0,0,0,,what you'll see
Dialogue: 0,0:47:51.37,0:47:52.81,EN,,0,0,0,,are these expressions on the stack
Dialogue: 0,0:47:53.75,0:47:55.64,EN,,0,0,0,,in some particular environment,
Dialogue: 0,0:47:56.42,0:48:00.02,EN,,0,0,0,,and then these expressions, sorry, in the EXP register
Dialogue: 0,0:48:00.02,0:48:01.50,EN,,0,0,0,,in some particular environment.
Dialogue: 0,0:48:01.57,0:48:02.19,EN,,0,0,0,,And, at each point,
Dialogue: 0,0:48:02.19,0:48:04.00,EN,,0,0,0,,there'll be no accumulated stuff on the stack
Dialogue: 0,0:48:04.36,0:48:05.68,EN,,0,0,0,,because each one's a real reduction.
Dialogue: 0,0:48:09.28,0:48:10.51,EN,,0,0,0,,All right, so, for example,
Dialogue: 0,0:48:10.58,0:48:12.51,EN,,0,0,0,,just to go through it in a little bit more care,
Dialogue: 0,0:48:13.46,0:48:16.88,EN,,0,0,0,,if I start out with an expression that says something like,
Dialogue: 0,0:48:22.44,0:48:34.25,EN,,0,0,0,,oh, say, fact-iter of 5 in some environment
Dialogue: 0,0:48:42.11,0:48:46.30,EN,,0,0,0,,that will, at some point, create an environment
Dialogue: 0,0:48:46.81,0:48:48.38,EN,,0,0,0,,in which n is down to 5.
Dialogue: 0,0:48:51.47,0:48:52.01,EN,,0,0,0,,Let's call that--
Dialogue: 0,0:48:55.68,0:48:56.59,EN,,0,0,0,,And, at some point,
Dialogue: 0,0:48:56.89,0:49:02.56,EN,,0,0,0,,the machine will reduce this whole thing
Dialogue: 0,0:49:02.91,0:49:04.35,EN,,0,0,0,,to a thing that says that's really
Dialogue: 0,0:49:04.76,0:49:09.85,EN,,0,0,0,,iter of 1, and 1, and n,
Dialogue: 0,0:49:10.68,0:49:13.72,EN,,0,0,0,,evaluated in this environment, E,1
Dialogue: 0,0:49:15.87,0:49:17.16,EN,,0,0,0,,with nothing on the stack.
Dialogue: 0,0:49:17.16,0:49:19.55,EN,,0,0,0,,See, at this moment, the machine is not remembering
Dialogue: 0,0:49:20.71,0:49:22.50,EN,,0,0,0,,that evaluating this expression, iter--
Dialogue: 0,0:49:25.00,0:49:25.63,EN,,0,0,0,,which is the loop--
Dialogue: 0,0:49:25.79,0:49:28.57,EN,,0,0,0,,is part of this thing called iterative factorial.
Dialogue: 0,0:49:29.68,0:49:30.59,EN,,0,0,0,,It's not remembering that.
Dialogue: 0,0:49:30.59,0:49:33.17,EN,,0,0,0,,It's just reducing the expression to that, right?
Dialogue: 0,0:49:33.17,0:49:36.56,EN,,0,0,0,,If we look again at the body of iterative factorial,
Dialogue: 0,0:49:38.05,0:49:41.08,EN,,0,0,0,,this expression has reduced to that expression.
Dialogue: 0,0:49:42.81,0:49:43.87,EN,,0,0,0,,Oh, I shouldn't have the n there.
Dialogue: 0,0:49:46.59,0:49:47.74,EN,,0,0,0,,It's a slightly different convention
Dialogue: 0,0:49:47.74,0:49:49.13,EN,,0,0,0,,from the slide to the program.
Dialogue: 0,0:49:53.34,0:49:56.25,EN,,0,0,0,,And, then, what's the body of iter?
Dialogue: 0,0:49:56.28,0:49:57.40,EN,,0,0,0,,Well, iter's going to be an if,
Dialogue: 0,0:49:58.75,0:50:00.19,EN,,0,0,0,,and I won't go through the details of if.
Dialogue: 0,0:50:00.24,0:50:01.63,EN,,0,0,0,,It'll evaluate the predicate.
Dialogue: 0,0:50:02.40,0:50:03.71,EN,,0,0,0,,In this case, it'll be false.
Dialogue: 0,0:50:03.81,0:50:08.64,EN,,0,0,0,,And this iter will now reduce to the expression
Dialogue: 0,0:50:09.85,0:50:20.20,EN,,0,0,0,,iter of whatever it says, star, counter product, and--
Dialogue: 0,0:50:21.62,0:50:22.24,EN,,0,0,0,,what does it say--
Dialogue: 0,0:50:22.68,0:50:24.56,EN,,0,0,0,,plus counter 1
Dialogue: 0,0:50:28.72,0:50:31.42,EN,,0,0,0,,in some other environment, by this time, E,2,
Dialogue: 0,0:50:32.97,0:50:35.98,EN,,0,0,0,,where E,2 will be set up having bindings
Dialogue: 0,0:50:36.49,0:50:39.39,EN,,0,0,0,,for product and counter.
Dialogue: 0,0:50:42.92,0:50:44.33,EN,,0,0,0,,And it'll reduce to that.
Dialogue: 0,0:50:44.94,0:50:46.04,EN,,0,0,0,,Right? It won't be remembering
Dialogue: 0,0:50:46.06,0:50:48.75,EN,,0,0,0,,that it's part of something that it has to return to.
Dialogue: 0,0:50:49.34,0:50:50.43,EN,,0,0,0,,And when iter calls iter again,
Dialogue: 0,0:50:50.44,0:50:52.56,EN,,0,0,0,,it'll reduce to another thing that looks like this
Dialogue: 0,0:50:53.05,0:50:54.68,EN,,0,0,0,,in some environment, E,3,
Dialogue: 0,0:50:54.83,0:50:56.67,EN,,0,0,0,,which has new bindings for product and counter.
Dialogue: 0,0:50:58.80,0:51:05.29,EN,,0,0,0,,OK? So, if you're wondering,
Dialogue: 0,0:51:06.09,0:51:07.53,EN,,0,0,0,,if you've always been queasy about
Dialogue: 0,0:51:08.25,0:51:10.67,EN,,0,0,0,,about how it is we've been saying those procedures
Dialogue: 0,0:51:10.67,0:51:12.45,EN,,0,0,0,,that look syntactically recursive,
Dialogue: 0,0:51:13.20,0:51:15.69,EN,,0,0,0,,are, in fact, iterative,
Dialogue: 0,0:51:15.87,0:51:17.24,EN,,0,0,0,,run in constant space,
Dialogue: 0,0:51:18.40,0:51:19.75,EN,,0,0,0,,well, I don't know if this makes you less queasy,
Dialogue: 0,0:51:19.75,0:51:21.23,EN,,0,0,0,,but at least it shows you what's happening.
Dialogue: 0,0:51:21.23,0:51:22.81,EN,,0,0,0,,There really isn't any buildup there.
Dialogue: 0,0:51:25.91,0:51:27.58,EN,,0,0,0,,Now, you might ask well, is there buildup
Dialogue: 0,0:51:27.98,0:51:30.08,EN,,0,0,0,,in principle in these environment frames?
Dialogue: 0,0:51:31.71,0:51:32.37,EN,,0,0,0,,And the answer is yeah,
Dialogue: 0,0:51:32.40,0:51:33.84,EN,,0,0,0,,you have to make these new environment frames,
Dialogue: 0,0:51:33.84,0:51:35.26,EN,,0,0,0,,but you don't have to hang onto them
Dialogue: 0,0:51:35.42,0:51:36.19,EN,,0,0,0,,when you're done.
Dialogue: 0,0:51:36.44,0:51:37.61,EN,,0,0,0,,They can be garbage collected,
Dialogue: 0,0:51:37.92,0:51:39.47,EN,,0,0,0,,or the space can be reused automatically.
Dialogue: 0,0:51:40.72,0:51:42.99,EN,,0,0,0,,But you see the control structure of the evaluator
Dialogue: 0,0:51:43.25,0:51:46.12,EN,,0,0,0,,is really using this idea that you actually have a reduction,
Dialogue: 0,0:51:47.02,0:51:49.29,EN,,0,0,0,,so these procedures really are iterative procedures.
Dialogue: 0,0:51:50.13,0:51:51.38,EN,,0,0,0,,All right, let's stop for questions.
Dialogue: 0,0:52:02.68,0:52:03.23,EN,,0,0,0,,All right, let's break.
Dialogue: 0,0:52:04.12,0:52:24.56,EN,,0,0,0,,[JESU, JOY OF MAN'S DESIRING]
Dialogue: 0,0:52:24.60,0:52:29.69,EN,,0,0,0,,The Structure And Interpretation of Computer Programs
Dialogue: 0,0:52:35.20,0:52:38.36,EN,,0,0,0,,By: Prof. Harold Abelson && Sussman Jay Sussman
Dialogue: 0,0:52:38.36,0:52:42.14,EN,,0,0,0,,The Structure And Interpretation of Computer Programs
Dialogue: 0,0:52:48.77,0:52:51.55,EN,,0,0,0,,PROFESSOR: Let me contrast the iterative procedure
Dialogue: 0,0:52:52.77,0:52:54.89,EN,,0,0,0,,just so you'll see where space does build up
Dialogue: 0,0:52:55.12,0:52:56.14,EN,,0,0,0,,with a recursive procedure,
Dialogue: 0,0:52:56.17,0:52:57.29,EN,,0,0,0,,so you can see the difference.
Dialogue: 0,0:52:58.03,0:53:01.20,EN,,0,0,0,,Let's look at the evaluation of recursive factorial.
Dialogue: 0,0:53:02.65,0:53:05.53,EN,,0,0,0,,So, here's fact-recursive,
Dialogue: 0,0:53:05.55,0:53:07.22,EN,,0,0,0,,or standard factorial definition.
Dialogue: 0,0:53:07.22,0:53:10.01,EN,,0,0,0,,We said this one is still a recursive procedure,
Dialogue: 0,0:53:10.01,0:53:12.57,EN,,0,0,0,,but this is actually a recursive process.
Dialogue: 0,0:53:13.75,0:53:16.56,EN,,0,0,0,,And then, just to link it back to the way we started,
Dialogue: 0,0:53:16.83,0:53:20.53,EN,,0,0,0,,we said oh, you can see that it's going to be recursive process
Dialogue: 0,0:53:20.53,0:53:21.82,EN,,0,0,0,,by the substitution model
Dialogue: 0,0:53:22.36,0:53:28.00,EN,,0,0,0,,because, if I say recursive factorial of 5,
Dialogue: 0,0:53:30.45,0:53:34.94,EN,,0,0,0,,that turns into 5 times--
Dialogue: 0,0:53:36.28,0:53:37.82,EN,,0,0,0,,what is it, fact-rec, or record fact--
Dialogue: 0,0:53:42.62,0:53:47.93,EN,,0,0,0,,5 times recursive factorial of 4,
Dialogue: 0,0:53:49.66,0:53:58.22,EN,,0,0,0,,which turns into 5 times 4 times fact-rec of 3,
Dialogue: 0,0:54:00.22,0:54:08.60,EN,,0,0,0,,which returns into 5 times 4 times 3 times
Dialogue: 0,0:54:13.45,0:54:15.31,EN,,0,0,0,,and so on, right?
Dialogue: 0,0:54:15.39,0:54:17.39,EN,,0,0,0,,The idea is there was this chain of stuff building up,
Dialogue: 0,0:54:18.10,0:54:20.06,EN,,0,0,0,,which justified, in the substitution model,
Dialogue: 0,0:54:20.08,0:54:21.28,EN,,0,0,0,,the fact that it's recursive.
Dialogue: 0,0:54:21.52,0:54:24.18,EN,,0,0,0,,And now, let's actually see that chain of stuff build up
Dialogue: 0,0:54:24.18,0:54:25.29,EN,,0,0,0,,and where it is in the machine, OK?
Dialogue: 0,0:54:27.68,0:54:29.95,EN,,0,0,0,,All right, well, let's imagine we're going to start out again.
Dialogue: 0,0:54:30.44,0:54:40.01,EN,,0,0,0,,We'll tell it to evaluate recursive factorial of 5
Dialogue: 0,0:54:41.45,0:54:43.39,EN,,0,0,0,,in some environment, again, E0, where
Dialogue: 0,0:54:45.08,0:54:48.97,EN,,0,0,0,,where recursive factorial is defined, OK?
Dialogue: 0,0:54:49.55,0:54:51.23,EN,,0,0,0,,Well, now we know what's eventually going to happen.
Dialogue: 0,0:54:52.25,0:54:53.64,EN,,0,0,0,,This is going to come along,
Dialogue: 0,0:54:53.92,0:54:55.64,EN,,0,0,0,,it'll evaluate those things,
Dialogue: 0,0:54:55.68,0:54:56.99,EN,,0,0,0,,figure out it's a procedure,
Dialogue: 0,0:54:57.18,0:55:00.16,EN,,0,0,0,,build somewhere over here an environment, E1,
Dialogue: 0,0:55:00.88,0:55:03.69,EN,,0,0,0,,which has n bound to 5,
Dialogue: 0,0:55:04.33,0:55:06.54,EN,,0,0,0,,which hangs off of E0,
Dialogue: 0,0:55:07.80,0:55:08.97,EN,,0,0,0,,which would be, presumably,
Dialogue: 0,0:55:08.99,0:55:12.30,EN,,0,0,0,,the definition environment of recursive factorial.
Dialogue: 0,0:55:14.11,0:55:15.74,EN,,0,0,0,,OK? And, in this environment,
Dialogue: 0,0:55:15.76,0:55:17.48,EN,,0,0,0,,it's going to go off and evaluate the body.
Dialogue: 0,0:55:19.67,0:55:25.92,EN,,0,0,0,,So, again, the evaluation here will reduce to
Dialogue: 0,0:55:27.00,0:55:28.92,EN,,0,0,0,,evaluating the body in E1.
Dialogue: 0,0:55:30.16,0:55:31.34,EN,,0,0,0,,That's going to look at an if,
Dialogue: 0,0:55:32.17,0:55:33.53,EN,,0,0,0,,and I won't go through the details of if.
Dialogue: 0,0:55:33.53,0:55:34.88,EN,,0,0,0,,It'll look at the predicate.
Dialogue: 0,0:55:34.88,0:55:37.53,EN,,0,0,0,,It'll decide it eventually has to evaluate the alternative.
Dialogue: 0,0:55:37.84,0:55:40.41,EN,,0,0,0,,So this whole thing, again, will reduce to
Dialogue: 0,0:55:41.30,0:55:45.53,EN,,0,0,0,,the alternative of recursive factorial,
Dialogue: 0,0:55:45.82,0:55:46.97,EN,,0,0,0,,the alternative clause,
Dialogue: 0,0:55:47.23,0:55:51.16,EN,,0,0,0,,which says that this whole thing reduces to times n
Dialogue: 0,0:55:53.07,0:55:59.96,EN,,0,0,0,,of recursive factorial of n minus 1
Dialogue: 0,0:56:03.48,0:56:05.55,EN,,0,0,0,,in the environment E1
Dialogue: 0,0:56:08.38,0:56:10.91,EN,,0,0,0,,OK? So the original expression, now, is going to reduce
Dialogue: 0,0:56:11.04,0:56:12.52,EN,,0,0,0,,to evaluating that expression, all right?
Dialogue: 0,0:56:13.75,0:56:16.28,EN,,0,0,0,,OK? Now we have an application.
Dialogue: 0,0:56:16.28,0:56:17.63,EN,,0,0,0,,We did an application before.
Dialogue: 0,0:56:18.22,0:56:20.25,EN,,0,0,0,,Remember what happens in an application?
Dialogue: 0,0:56:20.36,0:56:21.69,EN,,0,0,0,,The first thing you do is you go off and you
Dialogue: 0,0:56:21.74,0:56:24.81,EN,,0,0,0,,you save the value of the continue register on the stack.
Dialogue: 0,0:56:25.35,0:56:27.18,EN,,0,0,0,,So the stack here is going to have done in it.
Dialogue: 0,0:56:29.98,0:56:32.88,EN,,0,0,0,,And then you're going to set up to evaluate the sub-parts.
Dialogue: 0,0:56:35.00,0:56:37.20,EN,,0,0,0,,OK? So here we go off to evaluate the sub-parts.
Dialogue: 0,0:56:39.47,0:56:41.45,EN,,0,0,0,,First thing we're going to do is evaluate the operator.
Dialogue: 0,0:56:44.60,0:56:46.32,EN,,0,0,0,,What happens when we evaluate an operator?
Dialogue: 0,0:56:47.25,0:56:48.99,EN,,0,0,0,,Well, we arrange things so that
Dialogue: 0,0:56:49.00,0:56:51.04,EN,,0,0,0,,the operator ends up in the expression register.
Dialogue: 0,0:56:51.48,0:56:53.15,EN,,0,0,0,,The environments in the ENV register
Dialogue: 0,0:56:53.66,0:56:54.60,EN,,0,0,0,,continue someplace
Dialogue: 0,0:56:54.62,0:56:56.22,EN,,0,0,0,,where we're going to go evaluate the arguments.
Dialogue: 0,0:56:56.59,0:56:57.37,EN,,0,0,0,,And, on the stack,
Dialogue: 0,0:56:57.40,0:56:59.29,EN,,0,0,0,,we've saved the original continue,
Dialogue: 0,0:56:59.52,0:57:01.02,EN,,0,0,0,,which is where we wanted to be when we're all done.
Dialogue: 0,0:57:01.72,0:57:02.86,EN,,0,0,0,,And then the things we needed
Dialogue: 0,0:57:03.58,0:57:05.80,EN,,0,0,0,,when we're going to get done evaluating the operator,
Dialogue: 0,0:57:05.90,0:57:07.66,EN,,0,0,0,,the things we'll need to evaluate the arguments,
Dialogue: 0,0:57:07.69,0:57:12.01,EN,,0,0,0,,namely the environment and those arguments,
Dialogue: 0,0:57:12.14,0:57:13.44,EN,,0,0,0,,those unevaluated arguments,
Dialogue: 0,0:57:14.20,0:57:15.62,EN,,0,0,0,,so there they are sitting on the stack.
Dialogue: 0,0:57:15.62,0:57:18.59,EN,,0,0,0,,And we're about to go off to evaluate the operator.
Dialogue: 0,0:57:23.26,0:57:26.73,EN,,0,0,0,,Well, when we return from this particular call--
Dialogue: 0,0:57:26.92,0:57:28.64,EN,,0,0,0,,so we're about to call eval-dispatch here--
Dialogue: 0,0:57:29.38,0:57:30.83,EN,,0,0,0,,when we return from this call,
Dialogue: 0,0:57:31.45,0:57:32.70,EN,,0,0,0,,the value of that operator,
Dialogue: 0,0:57:32.73,0:57:33.52,EN,,0,0,0,,which, in this case,
Dialogue: 0,0:57:33.55,0:57:35.44,EN,,0,0,0,,is going to be the primitive multiplier procedure,
Dialogue: 0,0:57:36.44,0:57:37.93,EN,,0,0,0,,will end up in the FUN register.
Dialogue: 0,0:57:43.02,0:57:44.53,EN,,0,0,0,,We're going to evaluate some arguments.
Dialogue: 0,0:57:44.53,0:57:45.85,EN,,0,0,0,,They will evaluate n here.
Dialogue: 0,0:57:47.73,0:57:49.87,EN,,0,0,0,,That'll give us 5, in this case.
Dialogue: 0,0:57:50.25,0:57:52.04,EN,,0,0,0,,We're going to put that in the argl register,
Dialogue: 0,0:57:53.00,0:57:55.88,EN,,0,0,0,,and then we'll go off to evaluate the second operand.
Dialogue: 0,0:57:57.46,0:58:00.48,EN,,0,0,0,,So, at the point where we go off to evaluate the second operand--
Dialogue: 0,0:58:00.52,0:58:02.19,EN,,0,0,0,,and I'll skip details like computing,
Dialogue: 0,0:58:02.20,0:58:03.58,EN,,0,0,0,,N minus 1, and all of that--
Dialogue: 0,0:58:03.71,0:58:05.88,EN,,0,0,0,,but, when we go off to evaluate the second operand,
Dialogue: 0,0:58:06.62,0:58:10.44,EN,,0,0,0,,that will eventually reduce to another call to fact-recursive.
Dialogue: 0,0:58:12.00,0:58:14.20,EN,,0,0,0,,And, what we've got on the stack here is
Dialogue: 0,0:58:16.52,0:58:19.94,EN,,0,0,0,,the operator from that combination that we're going to use it in
Dialogue: 0,0:58:20.12,0:58:21.07,EN,,0,0,0,,and the other argument.
Dialogue: 0,0:58:23.40,0:58:27.61,EN,,0,0,0,,OK? So, now, we're set up for another call
Dialogue: 0,0:58:28.49,0:58:29.69,EN,,0,0,0,,to recursive factorial.
Dialogue: 0,0:58:30.20,0:58:31.43,EN,,0,0,0,,And, when we're done with this one,
Dialogue: 0,0:58:31.56,0:58:33.64,EN,,0,0,0,,we're going to go to accumulate the last arg.
Dialogue: 0,0:58:34.12,0:58:35.20,EN,,0,0,0,,and remember what that'll do?
Dialogue: 0,0:58:35.20,0:58:35.93,EN,,0,0,0,,That'll say oh,
Dialogue: 0,0:58:36.45,0:58:39.28,EN,,0,0,0,,whatever the result of this has to get combined with that,
Dialogue: 0,0:58:39.28,0:58:40.40,EN,,0,0,0,,and we're going to multiply them.
Dialogue: 0,0:58:41.69,0:58:42.38,EN,,0,0,0,,But, notice now,
Dialogue: 0,0:58:42.73,0:58:44.81,EN,,0,0,0,,we're at another recursive factorial.
Dialogue: 0,0:58:45.72,0:58:48.92,EN,,0,0,0,,We're about to call eval-dispatch again,
Dialogue: 0,0:58:49.32,0:58:50.60,EN,,0,0,0,,except we haven't really reduced it
Dialogue: 0,0:58:50.64,0:58:52.08,EN,,0,0,0,,because there's stuff on the stack now.
Dialogue: 0,0:58:53.70,0:58:55.39,EN,,0,0,0,,The stuff on the stack says oh, when you get back,
Dialogue: 0,0:58:55.40,0:58:57.52,EN,,0,0,0,,you'd better multiply it by the 5 you had hanging there.
Dialogue: 0,0:58:58.43,0:59:05.77,EN,,0,0,0,,So, when we go off to make another call,
Dialogue: 0,0:59:07.12,0:59:08.84,EN,,0,0,0,,we evaluate the n minus 1.
Dialogue: 0,0:59:09.30,0:59:11.05,EN,,0,0,0,,That gives us another environment which
Dialogue: 0,0:59:11.25,0:59:13.84,EN,,0,0,0,,in which the new n's going to be down to 4.
Dialogue: 0,0:59:14.60,0:59:16.22,EN,,0,0,0,,And we're about to call eval-dispatch again.
Dialogue: 0,0:59:19.20,0:59:20.22,EN,,0,0,0,,We get another call.
Dialogue: 0,0:59:21.35,0:59:24.44,EN,,0,0,0,,That 4 is going to end up in the same situation.
Dialogue: 0,0:59:26.04,0:59:28.62,EN,,0,0,0,,We'll end up with another call to fact-recursive n.
Dialogue: 0,0:59:30.02,0:59:32.68,EN,,0,0,0,,And sitting on the stack will be the stuff from the original one
Dialogue: 0,0:59:32.88,0:59:34.51,EN,,0,0,0,,and, now, the subsidiary one we're doing.
Dialogue: 0,0:59:35.36,0:59:36.91,EN,,0,0,0,,And both of them are waiting for the same thing.
Dialogue: 0,0:59:36.91,0:59:39.16,EN,,0,0,0,,They're going to go to accumulate a last argument.
Dialogue: 0,0:59:40.51,0:59:42.94,EN,,0,0,0,,And then, of course, when we go to the fourth call,
Dialogue: 0,0:59:43.25,0:59:44.38,EN,,0,0,0,,the same thing happens.
Dialogue: 0,0:59:45.64,0:59:47.07,EN,,0,0,0,,And this goes on, and on, and on.
Dialogue: 0,0:59:47.30,0:59:48.60,EN,,0,0,0,,And what you see here on the stack,
Dialogue: 0,0:59:50.30,0:59:52.22,EN,,0,0,0,,exactly what's sitting here on the stack,
Dialogue: 0,0:59:52.22,0:59:54.59,EN,,0,0,0,,the thing that says times and 5.
Dialogue: 0,0:59:54.96,0:59:56.40,EN,,0,0,0,,And what you're going to do with that
Dialogue: 0,0:59:56.59,0:59:58.54,EN,,0,0,0,,accumulate that into a last argument.
Dialogue: 0,1:00:00.47,1:00:02.01,EN,,0,0,0,,That's exactly this, right?
Dialogue: 0,1:00:02.01,1:00:04.75,EN,,0,0,0,,This is exactly where that stuff is hanging.
Dialogue: 0,1:00:05.65,1:00:10.65,EN,,0,0,0,,Effectively, the operator you're going to apply,
Dialogue: 0,1:00:11.72,1:00:14.30,EN,,0,0,0,,the other argument that it's got
Dialogue: 0,1:00:14.32,1:00:15.79,EN,,0,0,0,,to be multiplied by when you get back
Dialogue: 0,1:00:15.80,1:00:16.91,EN,,0,0,0,,and sort of the parentheses,
Dialogue: 0,1:00:16.94,1:00:18.96,EN,,0,0,0,,which says yeah, what you wanted to do was accumulate them.
Dialogue: 0,1:00:19.62,1:00:21.88,EN,,0,0,0,,So, you see, the substitution model is not such a lie.
Dialogue: 0,1:00:22.56,1:00:23.63,EN,,0,0,0,,That really is, in some sense,
Dialogue: 0,1:00:23.64,1:00:25.31,EN,,0,0,0,,what's sitting right on the stack.
Dialogue: 0,1:00:29.37,1:00:30.40,EN,,0,0,0,,All right, so that,
Dialogue: 0,1:00:30.81,1:00:32.48,EN,,0,0,0,,in some sense, should explain for you,
Dialogue: 0,1:00:33.26,1:00:34.52,EN,,0,0,0,,or at least convince you,
Dialogue: 0,1:00:35.93,1:00:38.72,EN,,0,0,0,,that somehow, this evaluator is managing
Dialogue: 0,1:00:40.06,1:00:42.86,EN,,0,0,0,,to take these procedures and execute some of them iteratively
Dialogue: 0,1:00:42.95,1:00:44.25,EN,,0,0,0,,and some of them recursively,
Dialogue: 0,1:00:45.26,1:00:47.45,EN,,0,0,0,,even though, as syntactically,
Dialogue: 0,1:00:47.45,1:00:49.05,EN,,0,0,0,,they look like recursive procedures.
Dialogue: 0,1:00:49.40,1:00:50.64,EN,,0,0,0,,How's it managing to do that?
Dialogue: 0,1:00:50.66,1:00:53.72,EN,,0,0,0,,Well, the basic reason it's managing to do that
Dialogue: 0,1:00:53.80,1:00:55.68,EN,,0,0,0,,is the evaluator is set up
Dialogue: 0,1:00:56.04,1:00:59.26,EN,,0,0,0,,to save only what it needs later.
Dialogue: 0,1:01:01.09,1:01:04.25,EN,,0,0,0,,So, for example, at the point where you've reduced
Dialogue: 0,1:01:04.67,1:01:07.39,EN,,0,0,0,,evaluating an expression and an environment
Dialogue: 0,1:01:07.87,1:01:09.87,EN,,0,0,0,,to applying a procedure to some arguments,
Dialogue: 0,1:01:10.52,1:01:12.49,EN,,0,0,0,,it doesn't need that original environment anymore
Dialogue: 0,1:01:13.37,1:01:16.65,EN,,0,0,0,,because any environment stuff will be packaged inside the procedures
Dialogue: 0,1:01:17.88,1:01:19.36,EN,,0,0,0,,where the application's going to happen.
Dialogue: 0,1:01:20.75,1:01:21.61,EN,,0,0,0,,All right, similarly,
Dialogue: 0,1:01:21.63,1:01:23.65,EN,,0,0,0,,when you're going along evaluating an argument list,
Dialogue: 0,1:01:23.65,1:01:25.20,EN,,0,0,0,,when you've finished evaluating the list,
Dialogue: 0,1:01:25.91,1:01:28.03,EN,,0,0,0,,when you're finished evaluating the last argument,
Dialogue: 0,1:01:28.20,1:01:31.61,EN,,0,0,0,,you don't need that argument list any more, right?
Dialogue: 0,1:01:31.63,1:01:32.94,EN,,0,0,0,,And you don't need the environment where
Dialogue: 0,1:01:33.04,1:01:34.64,EN,,0,0,0,,those arguments would be evaluated.
Dialogue: 0,1:01:36.69,1:01:40.89,EN,,0,0,0,,So the basic reason that this interpreter is being so smart
Dialogue: 0,1:01:40.89,1:01:42.88,EN,,0,0,0,,is that it's not being smart at all, it's being stupid.
Dialogue: 0,1:01:43.05,1:01:45.74,EN,,0,0,0,,It's just saying I'm only going to save what I really need.
Dialogue: 0,1:01:48.70,1:01:51.00,EN,,0,0,0,,Well, let me show you here.
Dialogue: 0,1:01:53.07,1:01:57.20,EN,,0,0,0,,Here's the actual thing that's making a tail recursive.
Dialogue: 0,1:01:58.31,1:02:00.20,EN,,0,0,0,,Remember, it's the restore of continue.
Dialogue: 0,1:02:00.22,1:02:06.94,EN,,0,0,0,,It's saying when I go off to evaluate the procedure body,
Dialogue: 0,1:02:08.96,1:02:11.00,EN,,0,0,0,,I should tell eval to come back to
Dialogue: 0,1:02:11.25,1:02:12.54,EN,,0,0,0,,the place where that original
Dialogue: 0,1:02:12.54,1:02:14.25,EN,,0,0,0,,evaluation was supposed to come back to.
Dialogue: 0,1:02:15.17,1:02:15.95,EN,,0,0,0,,So, in some sense,
Dialogue: 0,1:02:16.17,1:02:18.84,EN,,0,0,0,,you want to say what's the actual line that makes tail recursive
Dialogue: 0,1:02:18.89,1:02:19.44,EN,,0,0,0,,It's that one.
Dialogue: 0,1:02:19.92,1:02:21.53,EN,,0,0,0,,If I wanted to build a non-
Dialogue: 0,1:02:21.77,1:02:24.80,EN,,0,0,0,,tail recursive evaluator, for some strange reason,
Dialogue: 0,1:02:25.69,1:02:26.86,EN,,0,0,0,,all I would need to do
Dialogue: 0,1:02:27.12,1:02:29.29,EN,,0,0,0,,is, instead of restoring continue at this point,
Dialogue: 0,1:02:30.06,1:02:31.66,EN,,0,0,0,,I'd set up a label down here
Dialogue: 0,1:02:32.75,1:02:36.25,EN,,0,0,0,,called, "Where to come back after you've finished applying the procedure."
Dialogue: 0,1:02:37.64,1:02:39.71,EN,,0,0,0,,Instead, I'd set continue to that.
Dialogue: 0,1:02:39.92,1:02:41.21,EN,,0,0,0,,I'd go to eval-dispatch,
Dialogue: 0,1:02:41.40,1:02:43.21,EN,,0,0,0,,and then eval-dispatch would come back here.
Dialogue: 0,1:02:43.79,1:02:44.30,EN,,0,0,0,,At that point,
Dialogue: 0,1:02:44.32,1:02:45.28,EN,,0,0,0,,I would restore continue
Dialogue: 0,1:02:45.29,1:02:46.52,EN,,0,0,0,,and go to the original one.
Dialogue: 0,1:02:47.92,1:02:51.00,EN,,0,0,0,,So here, the only consequence of that
Dialogue: 0,1:02:51.15,1:02:52.68,EN,,0,0,0,,would be to make it non-tail recursive.
Dialogue: 0,1:02:52.84,1:02:54.62,EN,,0,0,0,,It would give you exactly the same answers,
Dialogue: 0,1:02:54.72,1:02:57.02,EN,,0,0,0,,except if you did that iterative factorial
Dialogue: 0,1:02:57.05,1:02:58.36,EN,,0,0,0,,and all those iterative procedures,
Dialogue: 0,1:02:58.60,1:02:59.80,EN,,0,0,0,,it would execute recursively.
Dialogue: 0,1:03:03.04,1:03:05.40,EN,,0,0,0,,Well, I lied to you a little bit, but just a little bit,
Dialogue: 0,1:03:05.76,1:03:06.99,EN,,0,0,0,,because I showed you a slightly
Dialogue: 0,1:03:07.02,1:03:08.33,EN,,0,0,0,,over-simplified evaluator
Dialogue: 0,1:03:08.72,1:03:10.38,EN,,0,0,0,,where it assumes that each procedure --
Dialogue: 0,1:03:11.36,1:03:13.66,EN,,0,0,0,,each procedure body has only one expression.
Dialogue: 0,1:03:13.89,1:03:14.54,EN,,0,0,0,,Remember, in general,
Dialogue: 0,1:03:14.56,1:03:16.57,EN,,0,0,0,,a procedure has a sequence of expressions in it.
Dialogue: 0,1:03:17.87,1:03:20.49,EN,,0,0,0,,So there's nothing really conceptually new.
Dialogue: 0,1:03:20.49,1:03:22.28,EN,,0,0,0,,Let me just show you the actual evaluator
Dialogue: 0,1:03:22.89,1:03:24.73,EN,,0,0,0,,that handles sequences of expressions.
Dialogue: 0,1:03:28.47,1:03:29.74,EN,,0,0,0,,This is compound-apply now,
Dialogue: 0,1:03:29.74,1:03:31.31,EN,,0,0,0,,and the only difference from the old one
Dialogue: 0,1:03:32.07,1:03:34.33,EN,,0,0,0,,is that, instead of going off to eval directly,
Dialogue: 0,1:03:35.98,1:03:38.03,EN,,0,0,0,,it takes the whole body of the procedure,
Dialogue: 0,1:03:38.03,1:03:40.15,EN,,0,0,0,,which, in this case, is a sequence of expressions,
Dialogue: 0,1:03:40.28,1:03:41.71,EN,,0,0,0,,and goes off to eval-sequence.
Dialogue: 0,1:03:42.60,1:03:45.32,EN,,0,0,0,,And eval-sequence is a little loop
Dialogue: 0,1:03:46.83,1:03:49.98,EN,,0,0,0,,that, basically, does these evaluations one at a time.
Dialogue: 0,1:03:52.63,1:03:53.85,EN,,0,0,0,,So it does an evaluation.
Dialogue: 0,1:03:53.90,1:03:54.94,EN,,0,0,0,,Says oh, when I come back,
Dialogue: 0,1:03:54.97,1:03:56.86,EN,,0,0,0,,I'd better come back here to do the next one.
Dialogue: 0,1:03:58.44,1:03:59.29,EN,,0,0,0,,And, when I'm all done,
Dialogue: 0,1:03:59.29,1:04:01.02,EN,,0,0,0,,when I want to get the last expression,
Dialogue: 0,1:04:01.31,1:04:03.28,EN,,0,0,0,,I just restore my continue
Dialogue: 0,1:04:03.92,1:04:05.28,EN,,0,0,0,,and go off to eval-dispatch.
Dialogue: 0,1:04:06.41,1:04:08.20,EN,,0,0,0,,And, again, if you wanted for some reason
Dialogue: 0,1:04:08.20,1:04:10.35,EN,,0,0,0,,to break tail recursion in this evaluator,
Dialogue: 0,1:04:10.64,1:04:13.71,EN,,0,0,0,,all you need to do is not handle the last expression, especially.
Dialogue: 0,1:04:14.90,1:04:17.34,EN,,0,0,0,,Just say, after you've done the last expression,
Dialogue: 0,1:04:17.36,1:04:18.65,EN,,0,0,0,,come back to some other place
Dialogue: 0,1:04:19.15,1:04:20.68,EN,,0,0,0,,after which you restore continue.
Dialogue: 0,1:04:21.90,1:04:23.26,EN,,0,0,0,,And, for some reason,
Dialogue: 0,1:04:23.26,1:04:25.74,EN,,0,0,0,,a lot of LISP evaluators tended to work that way.
Dialogue: 0,1:04:26.55,1:04:28.44,EN,,0,0,0,,And the only consequence of that is that
Dialogue: 0,1:04:28.86,1:04:30.72,EN,,0,0,0,,iterative procedures built up stack.
Dialogue: 0,1:04:31.88,1:04:33.61,EN,,0,0,0,,And it's not clear why that happened.
Dialogue: 0,1:04:35.92,1:04:37.98,EN,,0,0,0,,All right. Well, let me just sort of summarize,
Dialogue: 0,1:04:38.09,1:04:39.60,EN,,0,0,0,,since this is a lot of details
Dialogue: 0,1:04:39.98,1:04:41.04,EN,,0,0,0,,in a big program.
Dialogue: 0,1:04:41.12,1:04:42.25,EN,,0,0,0,,But the main point is that
Dialogue: 0,1:04:43.04,1:04:43.87,EN,,0,0,0,,it's no different,
Dialogue: 0,1:04:44.04,1:04:46.08,EN,,0,0,0,,conceptually, from translating any other program.
Dialogue: 0,1:04:47.06,1:04:48.06,EN,,0,0,0,,And the main idea is that
Dialogue: 0,1:04:48.06,1:04:50.28,EN,,0,0,0,,we have this universal evaluator program,
Dialogue: 0,1:04:50.33,1:04:51.71,EN,,0,0,0,,the meta-circular evaluator.
Dialogue: 0,1:04:51.87,1:04:53.07,EN,,0,0,0,,If we translate that into LISP,
Dialogue: 0,1:04:53.10,1:04:53.95,EN,,0,0,0,,then we have all of LISP.
Dialogue: 0,1:04:54.33,1:04:55.15,EN,,0,0,0,,And that's all we did.
Dialogue: 0,1:04:57.98,1:04:59.68,EN,,0,0,0,,The second point is that the magic's gone away.
Dialogue: 0,1:04:59.68,1:05:01.97,EN,,0,0,0,,There should be no more magic in this whole system, right?
Dialogue: 0,1:05:01.97,1:05:07.79,EN,,0,0,0,,In principle, it should all be very clear
Dialogue: 0,1:05:07.82,1:05:10.08,EN,,0,0,0,,except, maybe, for how list structured memory works,
Dialogue: 0,1:05:10.80,1:05:11.80,EN,,0,0,0,,and we'll see that later.
Dialogue: 0,1:05:12.64,1:05:14.20,EN,,0,0,0,,But that's not very hard.
Dialogue: 0,1:05:15.45,1:05:16.35,EN,,0,0,0,,The third point is that
Dialogue: 0,1:05:16.35,1:05:17.52,EN,,0,0,0,,all this tail recursion
Dialogue: 0,1:05:18.24,1:05:21.96,EN,,0,0,0,,came from the discipline of eval being very careful
Dialogue: 0,1:05:22.55,1:05:24.51,EN,,0,0,0,,to save only what it needs next time.
Dialogue: 0,1:05:25.87,1:05:27.72,EN,,0,0,0,,It's not some arbitrary thing
Dialogue: 0,1:05:27.76,1:05:29.86,EN,,0,0,0,,where we're saying well, whenever we call a sub-routine,
Dialogue: 0,1:05:29.86,1:05:32.16,EN,,0,0,0,,we'll save all the registers in the world and come back?
Dialogue: 0,1:05:33.94,1:05:36.49,EN,,0,0,0,,See, sometimes it pays to really worry about efficiency.
Dialogue: 0,1:05:37.15,1:05:39.96,EN,,0,0,0,,And, when you're down in the guts of your evaluator machine,
Dialogue: 0,1:05:40.45,1:05:42.56,EN,,0,0,0,,it really pays to think about things like that
Dialogue: 0,1:05:42.56,1:05:43.96,EN,,0,0,0,,because it makes big consequences.
Dialogue: 0,1:05:45.23,1:05:47.69,EN,,0,0,0,,Well, I hope what this has done
Dialogue: 0,1:05:47.90,1:05:52.30,EN,,0,0,0,,is really made the evaluator seem concrete.
Dialogue: 0,1:05:52.56,1:05:53.90,EN,,0,0,0,,I hope you really believe
Dialogue: 0,1:05:54.32,1:05:56.27,EN,,0,0,0,,that somebody could hold a LISP
Dialogue: 0,1:05:56.84,1:05:58.56,EN,,0,0,0,,LISP evaluator in the palm of their hand.
Dialogue: 0,1:05:59.07,1:06:00.49,EN,,0,0,0,,Maybe to help you believe that, here's a
Dialogue: 0,1:06:00.80,1:06:01.96,EN,,0,0,0,,here's a LISP evaluator
Dialogue: 0,1:06:02.54,1:06:04.06,EN,,0,0,0,,that I'm holding the palm of my hand.
Dialogue: 0,1:06:06.16,1:06:10.56,EN,,0,0,0,,And this is a chip which is actually
Dialogue: 0,1:06:10.89,1:06:13.70,EN,,0,0,0,,quite a bit more complicated than the evaluator I showed you.
Dialogue: 0,1:06:16.86,1:06:19.20,EN,,0,0,0,,Uh.. maybe, here's a better picture of it.
Dialogue: 0,1:06:22.07,1:06:22.57,EN,,0,0,0,,What there is,
Dialogue: 0,1:06:22.60,1:06:24.38,EN,,0,0,0,,is you can see the same overall structure.
Dialogue: 0,1:06:24.73,1:06:25.93,EN,,0,0,0,,This is a register array.
Dialogue: 0,1:06:26.80,1:06:27.71,EN,,0,0,0,,These are the data paths.
Dialogue: 0,1:06:27.72,1:06:29.07,EN,,0,0,0,,Here's a finite state controller.
Dialogue: 0,1:06:29.80,1:06:31.04,EN,,0,0,0,,And again, finite state,
Dialogue: 0,1:06:31.96,1:06:32.80,EN,,0,0,0,,that's all there is.
Dialogue: 0,1:06:32.81,1:06:34.16,EN,,0,0,0,,And somewhere there's external memory
Dialogue: 0,1:06:34.16,1:06:35.23,EN,,0,0,0,,that'll worry about things.
Dialogue: 0,1:06:35.75,1:06:37.63,EN,,0,0,0,,And this particular one is very complicated
Dialogue: 0,1:06:37.64,1:06:39.16,EN,,0,0,0,,because it's trying to run LISP fast.
Dialogue: 0,1:06:39.66,1:06:42.97,EN,,0,0,0,,And it has some very, very fast parallel operations in there
Dialogue: 0,1:06:43.07,1:06:46.32,EN,,0,0,0,,like, if you want to index into an array,
Dialogue: 0,1:06:46.70,1:06:50.40,EN,,0,0,0,,simultaneously check that the index is an integer,
Dialogue: 0,1:06:50.43,1:06:52.86,EN,,0,0,0,,check that it doesn't exceed the array bands,
Dialogue: 0,1:06:53.04,1:06:55.02,EN,,0,0,0,,and go off and do the memory access,
Dialogue: 0,1:06:55.05,1:06:56.70,EN,,0,0,0,,and do all those things simultaneously.
Dialogue: 0,1:06:57.12,1:06:58.40,EN,,0,0,0,,And then, later, if they're all OK,
Dialogue: 0,1:06:58.44,1:06:59.96,EN,,0,0,0,,actually get the value there.
Dialogue: 0,1:07:00.42,1:07:02.46,EN,,0,0,0,,So there are a lot of complicated operations
Dialogue: 0,1:07:02.48,1:07:04.65,EN,,0,0,0,,in these data paths for making LISP run in parallel.
Dialogue: 0,1:07:05.26,1:07:08.41,EN,,0,0,0,,It's a completely non-risk
Dialogue: 0,1:07:08.76,1:07:10.36,EN,,0,0,0,,philosophy of evaluating LISP.
Dialogue: 0,1:07:10.64,1:07:13.20,EN,,0,0,0,,And then, this microcode is pretty complicated.
Dialogue: 0,1:07:13.45,1:07:17.56,EN,,0,0,0,,Let's see, there's what?
Dialogue: 0,1:07:17.60,1:07:21.10,EN,,0,0,0,,There's about 389 instructions of
Dialogue: 0,1:07:21.68,1:07:23.85,EN,,0,0,0,,of 220-bit microcode sitting here
Dialogue: 0,1:07:24.07,1:07:27.94,EN,,0,0,0,,because these are very complicated data paths.
Dialogue: 0,1:07:27.94,1:07:32.25,EN,,0,0,0,,And the whole thing has about 89,000 transistors, OK?
Dialogue: 0,1:07:33.56,1:07:36.86,EN,,0,0,0,,OK. Well, I hope that that takes away a lot of the mystery.
Dialogue: 0,1:07:37.97,1:07:39.24,EN,,0,0,0,,Maybe somebody wants to look at this.
Dialogue: 0,1:07:46.14,1:07:46.89,EN,,0,0,0,,OK. Let's stop.
Dialogue: 0,1:07:56.46,1:07:56.75,EN,,0,0,0,,Questions?
Dialogue: 0,1:07:59.00,1:08:00.42,EN,,0,0,0,,AUDIENCE: OK, now, it sounds like what you're saying is that,
Dialogue: 0,1:08:00.42,1:08:03.48,EN,,0,0,0,,with the restore continue put in the proper place,
Dialogue: 0,1:08:03.58,1:08:09.42,EN,,0,0,0,,that procedures that would invoke a recursive process
Dialogue: 0,1:08:09.42,1:08:11.95,EN,,0,0,0,,now invoke an iterative process
Dialogue: 0,1:08:12.67,1:08:15.36,EN,,0,0,0,,just by the way that the eval-sequence source?
Dialogue: 0,1:08:15.60,1:08:17.54,EN,,0,0,0,,PROFESSOR: I think the way I'd prefer to put it is that,
Dialogue: 0,1:08:17.54,1:08:19.82,EN,,0,0,0,,with restore continue put in the wrong place,
Dialogue: 0,1:08:20.55,1:08:25.48,EN,,0,0,0,,you can cause any syntactically-looking recursive procedure,
Dialogue: 0,1:08:25.52,1:08:27.28,EN,,0,0,0,,in fact, to build up stack as it runs.
Dialogue: 0,1:08:28.64,1:08:30.52,EN,,0,0,0,,But there's no reason for that,
Dialogue: 0,1:08:33.15,1:08:35.12,EN,,0,0,0,,so you might want to play around with it.
Dialogue: 0,1:08:35.15,1:08:38.09,EN,,0,0,0,,You can just switch around two or three instructions
Dialogue: 0,1:08:38.18,1:08:40.78,EN,,0,0,0,,in the way compound-apply comes back,
Dialogue: 0,1:08:41.31,1:08:43.26,EN,,0,0,0,,and you'll get something which isn't tail recursive.
Dialogue: 0,1:08:45.06,1:08:46.14,EN,,0,0,0,,But the thing I wanted to emphasize
Dialogue: 0,1:08:46.16,1:08:47.40,EN,,0,0,0,,is there's no magic. there's no
Dialogue: 0,1:08:47.67,1:08:48.57,EN,,0,0,0,,It's not as if
Dialogue: 0,1:08:49.31,1:08:52.17,EN,,0,0,0,,there's some very clever pre-processing program
Dialogue: 0,1:08:52.65,1:08:55.45,EN,,0,0,0,,that's looking at this procedure, factorial iter,
Dialogue: 0,1:08:55.47,1:08:56.73,EN,,0,0,0,,and say oh, gee, um
Dialogue: 0,1:08:57.42,1:08:58.86,EN,,0,0,0,,I really notice that
Dialogue: 0,1:08:58.88,1:09:01.13,EN,,0,0,0,,I don't have to push stack in order to do this.
Dialogue: 0,1:09:01.13,1:09:02.88,EN,,0,0,0,,Some people think that that's what's going on.
Dialogue: 0,1:09:03.76,1:09:05.38,EN,,0,0,0,,It's something much, much more dumb than that,
Dialogue: 0,1:09:05.38,1:09:07.50,EN,,0,0,0,,it's this one place you're putting the restore instruction.
Dialogue: 0,1:09:08.56,1:09:09.79,EN,,0,0,0,,It's just automatic.
Dialogue: 0,1:09:14.72,1:09:17.55,EN,,0,0,0,,AUDIENCE: But that's not affecting the time complexity is it?
Dialogue: 0,1:09:17.58,1:09:17.87,EN,,0,0,0,,PROFESSOR: No.
Dialogue: 0,1:09:18.60,1:09:21.77,EN,,0,0,0,,AUDIENCE: It's just that it's handling it recursively
Dialogue: 0,1:09:21.80,1:09:23.02,EN,,0,0,0,,instead of iteratively.
Dialogue: 0,1:09:23.02,1:09:27.34,EN,,0,0,0,,But, in terms of the order of time it takes to finish the operation,
Dialogue: 0,1:09:27.37,1:09:29.22,EN,,0,0,0,,it's the same one way or the other, right?
Dialogue: 0,1:09:29.47,1:09:29.76,EN,,0,0,0,,PROFESSOR: Yes.
Dialogue: 0,1:09:29.79,1:09:32.68,EN,,0,0,0,,Tail recursion is not going to change the time complexity of anything
Dialogue: 0,1:09:32.72,1:09:33.29,EN,,0,0,0,,because, in some sense,
Dialogue: 0,1:09:33.34,1:09:35.15,EN,,0,0,0,,it's the same algorithm that's going on.
Dialogue: 0,1:09:36.02,1:09:39.37,EN,,0,0,0,,What it's doing is really making this thing run as an iteration.
Dialogue: 0,1:09:41.00,1:09:42.64,EN,,0,0,0,,Right? Not going to run out of memory
Dialogue: 0,1:09:42.68,1:09:44.22,EN,,0,0,0,,you know counting up to a giant number
Dialogue: 0,1:09:44.75,1:09:46.40,EN,,0,0,0,,simply because the stack would get pushed.
Dialogue: 0,1:09:48.35,1:09:50.24,EN,,0,0,0,,See, the thing you really have to believe is that,
Dialogue: 0,1:09:50.56,1:09:51.13,EN,,0,0,0,,when we write--
Dialogue: 0,1:09:51.64,1:09:53.78,EN,,0,0,0,,see, we've been writing all these things called iterations,
Dialogue: 0,1:09:53.93,1:09:57.99,EN,,0,0,0,,infinite loops, define loop to be called loop.
Dialogue: 0,1:10:00.32,1:10:03.36,EN,,0,0,0,,That's is as much an iteration
Dialogue: 0,1:10:03.65,1:10:05.66,EN,,0,0,0,,you know as if we wrote do forever loop.
Dialogue: 0,1:10:07.63,1:10:09.28,EN,,0,0,0,,It's just syntactic sugar as the difference.
Dialogue: 0,1:10:09.28,1:10:11.32,EN,,0,0,0,,These things are real, honest to god, iterations?
Dialogue: 0,1:10:14.73,1:10:16.08,EN,,0,0,0,,They don't change the time complexity,
Dialogue: 0,1:10:16.11,1:10:18.53,EN,,0,0,0,,but they turn them into real iterations.
Dialogue: 0,1:10:21.68,1:10:23.80,EN,,0,0,0,,All right, thank you.
